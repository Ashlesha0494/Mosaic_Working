var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all2) => {
  for (var name2 in all2)
    __defProp(target, name2, { get: all2[name2], enumerable: true });
};
var __copyProps = (to, from2, except, desc2) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from2[key], enumerable: !(desc2 = __getOwnPropDesc(from2, key)) || desc2.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../../node_modules/binary-search-bounds/search-bounds.js
var require_search_bounds = __commonJS({
  "../../node_modules/binary-search-bounds/search-bounds.js"(exports, module) {
    "use strict";
    function ge(a3, y4, c4, l, h2) {
      var i = h2 + 1;
      while (l <= h2) {
        var m2 = l + h2 >>> 1, x4 = a3[m2];
        var p2 = c4 !== void 0 ? c4(x4, y4) : x4 - y4;
        if (p2 >= 0) {
          i = m2;
          h2 = m2 - 1;
        } else {
          l = m2 + 1;
        }
      }
      return i;
    }
    function gt2(a3, y4, c4, l, h2) {
      var i = h2 + 1;
      while (l <= h2) {
        var m2 = l + h2 >>> 1, x4 = a3[m2];
        var p2 = c4 !== void 0 ? c4(x4, y4) : x4 - y4;
        if (p2 > 0) {
          i = m2;
          h2 = m2 - 1;
        } else {
          l = m2 + 1;
        }
      }
      return i;
    }
    function lt2(a3, y4, c4, l, h2) {
      var i = l - 1;
      while (l <= h2) {
        var m2 = l + h2 >>> 1, x4 = a3[m2];
        var p2 = c4 !== void 0 ? c4(x4, y4) : x4 - y4;
        if (p2 < 0) {
          i = m2;
          l = m2 + 1;
        } else {
          h2 = m2 - 1;
        }
      }
      return i;
    }
    function le(a3, y4, c4, l, h2) {
      var i = l - 1;
      while (l <= h2) {
        var m2 = l + h2 >>> 1, x4 = a3[m2];
        var p2 = c4 !== void 0 ? c4(x4, y4) : x4 - y4;
        if (p2 <= 0) {
          i = m2;
          l = m2 + 1;
        } else {
          h2 = m2 - 1;
        }
      }
      return i;
    }
    function eq2(a3, y4, c4, l, h2) {
      while (l <= h2) {
        var m2 = l + h2 >>> 1, x4 = a3[m2];
        var p2 = c4 !== void 0 ? c4(x4, y4) : x4 - y4;
        if (p2 === 0) {
          return m2;
        }
        if (p2 <= 0) {
          l = m2 + 1;
        } else {
          h2 = m2 - 1;
        }
      }
      return -1;
    }
    function norm(a3, y4, c4, l, h2, f2) {
      if (typeof c4 === "function") {
        return f2(a3, y4, c4, l === void 0 ? 0 : l | 0, h2 === void 0 ? a3.length - 1 : h2 | 0);
      }
      return f2(a3, y4, void 0, c4 === void 0 ? 0 : c4 | 0, l === void 0 ? a3.length - 1 : l | 0);
    }
    module.exports = {
      ge: function(a3, y4, c4, l, h2) {
        return norm(a3, y4, c4, l, h2, ge);
      },
      gt: function(a3, y4, c4, l, h2) {
        return norm(a3, y4, c4, l, h2, gt2);
      },
      lt: function(a3, y4, c4, l, h2) {
        return norm(a3, y4, c4, l, h2, lt2);
      },
      le: function(a3, y4, c4, l, h2) {
        return norm(a3, y4, c4, l, h2, le);
      },
      eq: function(a3, y4, c4, l, h2) {
        return norm(a3, y4, c4, l, h2, eq2);
      }
    };
  }
});

// ../../node_modules/interval-tree-1d/interval-tree.js
var require_interval_tree = __commonJS({
  "../../node_modules/interval-tree-1d/interval-tree.js"(exports, module) {
    "use strict";
    var bounds = require_search_bounds();
    var NOT_FOUND = 0;
    var SUCCESS = 1;
    var EMPTY = 2;
    module.exports = createWrapper;
    function IntervalTreeNode(mid2, left2, right2, leftPoints, rightPoints) {
      this.mid = mid2;
      this.left = left2;
      this.right = right2;
      this.leftPoints = leftPoints;
      this.rightPoints = rightPoints;
      this.count = (left2 ? left2.count : 0) + (right2 ? right2.count : 0) + leftPoints.length;
    }
    var proto = IntervalTreeNode.prototype;
    function copy4(a3, b2) {
      a3.mid = b2.mid;
      a3.left = b2.left;
      a3.right = b2.right;
      a3.leftPoints = b2.leftPoints;
      a3.rightPoints = b2.rightPoints;
      a3.count = b2.count;
    }
    function rebuild(node, intervals) {
      var ntree = createIntervalTree(intervals);
      node.mid = ntree.mid;
      node.left = ntree.left;
      node.right = ntree.right;
      node.leftPoints = ntree.leftPoints;
      node.rightPoints = ntree.rightPoints;
      node.count = ntree.count;
    }
    function rebuildWithInterval(node, interval2) {
      var intervals = node.intervals([]);
      intervals.push(interval2);
      rebuild(node, intervals);
    }
    function rebuildWithoutInterval(node, interval2) {
      var intervals = node.intervals([]);
      var idx = intervals.indexOf(interval2);
      if (idx < 0) {
        return NOT_FOUND;
      }
      intervals.splice(idx, 1);
      rebuild(node, intervals);
      return SUCCESS;
    }
    proto.intervals = function(result) {
      result.push.apply(result, this.leftPoints);
      if (this.left) {
        this.left.intervals(result);
      }
      if (this.right) {
        this.right.intervals(result);
      }
      return result;
    };
    proto.insert = function(interval2) {
      var weight = this.count - this.leftPoints.length;
      this.count += 1;
      if (interval2[1] < this.mid) {
        if (this.left) {
          if (4 * (this.left.count + 1) > 3 * (weight + 1)) {
            rebuildWithInterval(this, interval2);
          } else {
            this.left.insert(interval2);
          }
        } else {
          this.left = createIntervalTree([interval2]);
        }
      } else if (interval2[0] > this.mid) {
        if (this.right) {
          if (4 * (this.right.count + 1) > 3 * (weight + 1)) {
            rebuildWithInterval(this, interval2);
          } else {
            this.right.insert(interval2);
          }
        } else {
          this.right = createIntervalTree([interval2]);
        }
      } else {
        var l = bounds.ge(this.leftPoints, interval2, compareBegin);
        var r = bounds.ge(this.rightPoints, interval2, compareEnd);
        this.leftPoints.splice(l, 0, interval2);
        this.rightPoints.splice(r, 0, interval2);
      }
    };
    proto.remove = function(interval2) {
      var weight = this.count - this.leftPoints;
      if (interval2[1] < this.mid) {
        if (!this.left) {
          return NOT_FOUND;
        }
        var rw = this.right ? this.right.count : 0;
        if (4 * rw > 3 * (weight - 1)) {
          return rebuildWithoutInterval(this, interval2);
        }
        var r = this.left.remove(interval2);
        if (r === EMPTY) {
          this.left = null;
          this.count -= 1;
          return SUCCESS;
        } else if (r === SUCCESS) {
          this.count -= 1;
        }
        return r;
      } else if (interval2[0] > this.mid) {
        if (!this.right) {
          return NOT_FOUND;
        }
        var lw = this.left ? this.left.count : 0;
        if (4 * lw > 3 * (weight - 1)) {
          return rebuildWithoutInterval(this, interval2);
        }
        var r = this.right.remove(interval2);
        if (r === EMPTY) {
          this.right = null;
          this.count -= 1;
          return SUCCESS;
        } else if (r === SUCCESS) {
          this.count -= 1;
        }
        return r;
      } else {
        if (this.count === 1) {
          if (this.leftPoints[0] === interval2) {
            return EMPTY;
          } else {
            return NOT_FOUND;
          }
        }
        if (this.leftPoints.length === 1 && this.leftPoints[0] === interval2) {
          if (this.left && this.right) {
            var p2 = this;
            var n = this.left;
            while (n.right) {
              p2 = n;
              n = n.right;
            }
            if (p2 === this) {
              n.right = this.right;
            } else {
              var l = this.left;
              var r = this.right;
              p2.count -= n.count;
              p2.right = n.left;
              n.left = l;
              n.right = r;
            }
            copy4(this, n);
            this.count = (this.left ? this.left.count : 0) + (this.right ? this.right.count : 0) + this.leftPoints.length;
          } else if (this.left) {
            copy4(this, this.left);
          } else {
            copy4(this, this.right);
          }
          return SUCCESS;
        }
        for (var l = bounds.ge(this.leftPoints, interval2, compareBegin); l < this.leftPoints.length; ++l) {
          if (this.leftPoints[l][0] !== interval2[0]) {
            break;
          }
          if (this.leftPoints[l] === interval2) {
            this.count -= 1;
            this.leftPoints.splice(l, 1);
            for (var r = bounds.ge(this.rightPoints, interval2, compareEnd); r < this.rightPoints.length; ++r) {
              if (this.rightPoints[r][1] !== interval2[1]) {
                break;
              } else if (this.rightPoints[r] === interval2) {
                this.rightPoints.splice(r, 1);
                return SUCCESS;
              }
            }
          }
        }
        return NOT_FOUND;
      }
    };
    function reportLeftRange(arr, hi, cb) {
      for (var i = 0; i < arr.length && arr[i][0] <= hi; ++i) {
        var r = cb(arr[i]);
        if (r) {
          return r;
        }
      }
    }
    function reportRightRange(arr, lo, cb) {
      for (var i = arr.length - 1; i >= 0 && arr[i][1] >= lo; --i) {
        var r = cb(arr[i]);
        if (r) {
          return r;
        }
      }
    }
    function reportRange(arr, cb) {
      for (var i = 0; i < arr.length; ++i) {
        var r = cb(arr[i]);
        if (r) {
          return r;
        }
      }
    }
    proto.queryPoint = function(x4, cb) {
      if (x4 < this.mid) {
        if (this.left) {
          var r = this.left.queryPoint(x4, cb);
          if (r) {
            return r;
          }
        }
        return reportLeftRange(this.leftPoints, x4, cb);
      } else if (x4 > this.mid) {
        if (this.right) {
          var r = this.right.queryPoint(x4, cb);
          if (r) {
            return r;
          }
        }
        return reportRightRange(this.rightPoints, x4, cb);
      } else {
        return reportRange(this.leftPoints, cb);
      }
    };
    proto.queryInterval = function(lo, hi, cb) {
      if (lo < this.mid && this.left) {
        var r = this.left.queryInterval(lo, hi, cb);
        if (r) {
          return r;
        }
      }
      if (hi > this.mid && this.right) {
        var r = this.right.queryInterval(lo, hi, cb);
        if (r) {
          return r;
        }
      }
      if (hi < this.mid) {
        return reportLeftRange(this.leftPoints, hi, cb);
      } else if (lo > this.mid) {
        return reportRightRange(this.rightPoints, lo, cb);
      } else {
        return reportRange(this.leftPoints, cb);
      }
    };
    function compareNumbers(a3, b2) {
      return a3 - b2;
    }
    function compareBegin(a3, b2) {
      var d = a3[0] - b2[0];
      if (d) {
        return d;
      }
      return a3[1] - b2[1];
    }
    function compareEnd(a3, b2) {
      var d = a3[1] - b2[1];
      if (d) {
        return d;
      }
      return a3[0] - b2[0];
    }
    function createIntervalTree(intervals) {
      if (intervals.length === 0) {
        return null;
      }
      var pts = [];
      for (var i = 0; i < intervals.length; ++i) {
        pts.push(intervals[i][0], intervals[i][1]);
      }
      pts.sort(compareNumbers);
      var mid2 = pts[pts.length >> 1];
      var leftIntervals = [];
      var rightIntervals = [];
      var centerIntervals = [];
      for (var i = 0; i < intervals.length; ++i) {
        var s2 = intervals[i];
        if (s2[1] < mid2) {
          leftIntervals.push(s2);
        } else if (mid2 < s2[0]) {
          rightIntervals.push(s2);
        } else {
          centerIntervals.push(s2);
        }
      }
      var leftPoints = centerIntervals;
      var rightPoints = centerIntervals.slice();
      leftPoints.sort(compareBegin);
      rightPoints.sort(compareEnd);
      return new IntervalTreeNode(
        mid2,
        createIntervalTree(leftIntervals),
        createIntervalTree(rightIntervals),
        leftPoints,
        rightPoints
      );
    }
    function IntervalTree2(root2) {
      this.root = root2;
    }
    var tproto = IntervalTree2.prototype;
    tproto.insert = function(interval2) {
      if (this.root) {
        this.root.insert(interval2);
      } else {
        this.root = new IntervalTreeNode(interval2[0], null, null, [interval2], [interval2]);
      }
    };
    tproto.remove = function(interval2) {
      if (this.root) {
        var r = this.root.remove(interval2);
        if (r === EMPTY) {
          this.root = null;
        }
        return r !== NOT_FOUND;
      }
      return false;
    };
    tproto.queryPoint = function(p2, cb) {
      if (this.root) {
        return this.root.queryPoint(p2, cb);
      }
    };
    tproto.queryInterval = function(lo, hi, cb) {
      if (lo <= hi && this.root) {
        return this.root.queryInterval(lo, hi, cb);
      }
    };
    Object.defineProperty(tproto, "count", {
      get: function() {
        if (this.root) {
          return this.root.count;
        }
        return 0;
      }
    });
    Object.defineProperty(tproto, "intervals", {
      get: function() {
        if (this.root) {
          return this.root.intervals([]);
        }
        return [];
      }
    });
    function createWrapper(intervals) {
      if (!intervals || intervals.length === 0) {
        return new IntervalTree2(null);
      }
      return new IntervalTree2(createIntervalTree(intervals));
    }
  }
});

// ../core/src/util/throttle.js
var NIL = {};
function throttle(callback, debounce = false) {
  let curr;
  let next;
  let pending = NIL;
  function invoke(event) {
    curr = callback(event).then(() => {
      if (next) {
        const { value } = next;
        next = null;
        invoke(value);
      } else {
        curr = null;
      }
    });
  }
  function enqueue(event) {
    next = { event };
  }
  function process(event) {
    curr ? enqueue(event) : invoke(event);
  }
  function delay(event) {
    if (pending !== event) {
      requestAnimationFrame(() => {
        const e = pending;
        pending = NIL;
        process(e);
      });
    }
    pending = event;
  }
  return debounce ? delay : process;
}

// ../core/src/MosaicClient.js
var MosaicClient = class {
  /**
   * Constructor.
   * @param {*} filterSelection An optional selection to interactively filter
   *  this client's data. If provided, a coordinator will re-query and update
   *  the client when the selection updates.
   */
  constructor(filterSelection) {
    this._filterBy = filterSelection;
    this._requestUpdate = throttle(() => this.requestQuery(), true);
    this._coordinator = null;
  }
  /**
   * Return this client's connected coordinator.
   */
  get coordinator() {
    return this._coordinator;
  }
  /**
   * Set this client's connected coordinator.
   */
  set coordinator(coordinator2) {
    this._coordinator = coordinator2;
  }
  /**
   * Return this client's filter selection.
   */
  get filterBy() {
    return this._filterBy;
  }
  /**
   * Return a boolean indicating if the client query can be indexed. Should
   * return true if changes to the filterBy selection does not change the
   * groupby domain of the client query.
   */
  get filterIndexable() {
    return true;
  }
  /**
   * Return an array of fields queried by this client.
   * @returns {object[]|null} The fields to retrieve info for.
   */
  fields() {
    return null;
  }
  /**
   * Called by the coordinator to set the field info for this client.
   * @param {*} info The field info result.
   * @returns {this}
   */
  fieldInfo(info) {
    return this;
  }
  /**
   * Return a query specifying the data needed by this client.
   * @param {*} [filter] The filtering criteria to apply in the query.
   * @returns {*} The client query
   */
  query(filter3) {
    return null;
  }
  /**
   * Called by the coordinator to inform the client that a query is pending.
   * @returns {this}
   */
  queryPending() {
    return this;
  }
  /**
   * Called by the coordinator to return a query result.
   * @param {*} data The query result.
   * @returns {this}
   */
  queryResult(data) {
    return this;
  }
  /**
   * Called by the coordinator to report a query execution error.
   * @param {*} error
   * @returns {this}
   */
  queryError(error) {
    console.error(error);
    return this;
  }
  /**
   * Request the coordinator to execute a query for this client.
   * If an explicit query is not provided, the client query method will
   * be called, filtered by the current filterBy selection.
   */
  requestQuery(query) {
    const q2 = query || this.query(this.filterBy?.predicate(this));
    return this._coordinator.requestQuery(this, q2);
  }
  /**
   * Request that the coordinator perform a throttled update of this client
   * using the default query. Unlike requestQuery, for which every call will
   * result in an executed query, multiple calls to requestUpdate may be
   * consolidated into a single update.
   */
  requestUpdate() {
    this._requestUpdate();
  }
  /**
   * Requests a client update.
   * For example to (re-)render an interface component.
   * 
   * @returns {this | Promise<any>}
   */
  update() {
    return this;
  }
};

// ../../node_modules/tslib/tslib.es6.mjs
function __rest(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
}
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __values(o) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o[s2], i = 0;
  if (m2)
    return m2.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __await(v3) {
  return this instanceof __await ? (this.v = v3, this) : new __await(v3);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i, q2 = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g2[n])
      i[n] = function(v3) {
        return new Promise(function(a3, b2) {
          q2.push([n, v3, a3, b2]) > 1 || resume(n, v3);
        });
      };
  }
  function resume(n, v3) {
    try {
      step(g2[n](v3));
    } catch (e) {
      settle(q2[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q2[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f2, v3) {
    if (f2(v3), q2.shift(), q2.length)
      resume(q2[0][0], q2[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p2;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f2) {
    i[n] = o[n] ? function(v3) {
      return (p2 = !p2) ? { value: __await(o[n](v3)), done: false } : f2 ? f2(v3) : v3;
    } : f2;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o[Symbol.asyncIterator], i;
  return m2 ? m2.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v3) {
      return new Promise(function(resolve, reject) {
        v3 = o[n](v3), settle(resolve, reject, v3.done, v3.value);
      });
    };
  }
  function settle(resolve, reject, d, v3) {
    Promise.resolve(v3).then(function(v4) {
      resolve({ value: v4, done: d });
    }, reject);
  }
}

// ../core/node_modules/apache-arrow/util/buffer.mjs
var buffer_exports = {};
__export(buffer_exports, {
  compareArrayLike: () => compareArrayLike,
  joinUint8Arrays: () => joinUint8Arrays,
  memcpy: () => memcpy,
  rebaseValueOffsets: () => rebaseValueOffsets,
  toArrayBufferView: () => toArrayBufferView,
  toArrayBufferViewAsyncIterator: () => toArrayBufferViewAsyncIterator,
  toArrayBufferViewIterator: () => toArrayBufferViewIterator,
  toBigInt64Array: () => toBigInt64Array,
  toBigUint64Array: () => toBigUint64Array,
  toFloat32Array: () => toFloat32Array,
  toFloat32ArrayAsyncIterator: () => toFloat32ArrayAsyncIterator,
  toFloat32ArrayIterator: () => toFloat32ArrayIterator,
  toFloat64Array: () => toFloat64Array,
  toFloat64ArrayAsyncIterator: () => toFloat64ArrayAsyncIterator,
  toFloat64ArrayIterator: () => toFloat64ArrayIterator,
  toInt16Array: () => toInt16Array,
  toInt16ArrayAsyncIterator: () => toInt16ArrayAsyncIterator,
  toInt16ArrayIterator: () => toInt16ArrayIterator,
  toInt32Array: () => toInt32Array,
  toInt32ArrayAsyncIterator: () => toInt32ArrayAsyncIterator,
  toInt32ArrayIterator: () => toInt32ArrayIterator,
  toInt8Array: () => toInt8Array,
  toInt8ArrayAsyncIterator: () => toInt8ArrayAsyncIterator,
  toInt8ArrayIterator: () => toInt8ArrayIterator,
  toUint16Array: () => toUint16Array,
  toUint16ArrayAsyncIterator: () => toUint16ArrayAsyncIterator,
  toUint16ArrayIterator: () => toUint16ArrayIterator,
  toUint32Array: () => toUint32Array,
  toUint32ArrayAsyncIterator: () => toUint32ArrayAsyncIterator,
  toUint32ArrayIterator: () => toUint32ArrayIterator,
  toUint8Array: () => toUint8Array,
  toUint8ArrayAsyncIterator: () => toUint8ArrayAsyncIterator,
  toUint8ArrayIterator: () => toUint8ArrayIterator,
  toUint8ClampedArray: () => toUint8ClampedArray,
  toUint8ClampedArrayAsyncIterator: () => toUint8ClampedArrayAsyncIterator,
  toUint8ClampedArrayIterator: () => toUint8ClampedArrayIterator
});

// ../core/node_modules/apache-arrow/util/utf8.mjs
var decoder = new TextDecoder("utf-8");
var decodeUtf8 = (buffer) => decoder.decode(buffer);
var encoder = new TextEncoder();
var encodeUtf8 = (value) => encoder.encode(value);

// ../core/node_modules/apache-arrow/util/compat.mjs
var isNumber = (x4) => typeof x4 === "number";
var isBoolean = (x4) => typeof x4 === "boolean";
var isFunction = (x4) => typeof x4 === "function";
var isObject = (x4) => x4 != null && Object(x4) === x4;
var isPromise = (x4) => {
  return isObject(x4) && isFunction(x4.then);
};
var isIterable = (x4) => {
  return isObject(x4) && isFunction(x4[Symbol.iterator]);
};
var isAsyncIterable = (x4) => {
  return isObject(x4) && isFunction(x4[Symbol.asyncIterator]);
};
var isArrowJSON = (x4) => {
  return isObject(x4) && isObject(x4["schema"]);
};
var isIteratorResult = (x4) => {
  return isObject(x4) && "done" in x4 && "value" in x4;
};
var isFileHandle = (x4) => {
  return isObject(x4) && isFunction(x4["stat"]) && isNumber(x4["fd"]);
};
var isFetchResponse = (x4) => {
  return isObject(x4) && isReadableDOMStream(x4["body"]);
};
var isReadableInterop = (x4) => "_getDOMStream" in x4 && "_getNodeStream" in x4;
var isWritableDOMStream = (x4) => {
  return isObject(x4) && isFunction(x4["abort"]) && isFunction(x4["getWriter"]) && !isReadableInterop(x4);
};
var isReadableDOMStream = (x4) => {
  return isObject(x4) && isFunction(x4["cancel"]) && isFunction(x4["getReader"]) && !isReadableInterop(x4);
};
var isWritableNodeStream = (x4) => {
  return isObject(x4) && isFunction(x4["end"]) && isFunction(x4["write"]) && isBoolean(x4["writable"]) && !isReadableInterop(x4);
};
var isReadableNodeStream = (x4) => {
  return isObject(x4) && isFunction(x4["read"]) && isFunction(x4["pipe"]) && isBoolean(x4["readable"]) && !isReadableInterop(x4);
};
var isFlatbuffersByteBuffer = (x4) => {
  return isObject(x4) && isFunction(x4["clear"]) && isFunction(x4["bytes"]) && isFunction(x4["position"]) && isFunction(x4["setPosition"]) && isFunction(x4["capacity"]) && isFunction(x4["getBufferIdentifier"]) && isFunction(x4["createLong"]);
};

// ../core/node_modules/apache-arrow/util/buffer.mjs
var SharedArrayBuf = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : ArrayBuffer;
function collapseContiguousByteRanges(chunks) {
  const result = chunks[0] ? [chunks[0]] : [];
  let xOffset, yOffset, xLen, yLen;
  for (let x4, y4, i = 0, j2 = 0, n = chunks.length; ++i < n; ) {
    x4 = result[j2];
    y4 = chunks[i];
    if (!x4 || !y4 || x4.buffer !== y4.buffer || y4.byteOffset < x4.byteOffset) {
      y4 && (result[++j2] = y4);
      continue;
    }
    ({ byteOffset: xOffset, byteLength: xLen } = x4);
    ({ byteOffset: yOffset, byteLength: yLen } = y4);
    if (xOffset + xLen < yOffset || yOffset + yLen < xOffset) {
      y4 && (result[++j2] = y4);
      continue;
    }
    result[j2] = new Uint8Array(x4.buffer, xOffset, yOffset - xOffset + yLen);
  }
  return result;
}
function memcpy(target, source, targetByteOffset = 0, sourceByteLength = source.byteLength) {
  const targetByteLength = target.byteLength;
  const dst = new Uint8Array(target.buffer, target.byteOffset, targetByteLength);
  const src = new Uint8Array(source.buffer, source.byteOffset, Math.min(sourceByteLength, targetByteLength));
  dst.set(src, targetByteOffset);
  return target;
}
function joinUint8Arrays(chunks, size) {
  const result = collapseContiguousByteRanges(chunks);
  const byteLength = result.reduce((x4, b2) => x4 + b2.byteLength, 0);
  let source, sliced, buffer;
  let offset2 = 0, index2 = -1;
  const length4 = Math.min(size || Number.POSITIVE_INFINITY, byteLength);
  for (const n = result.length; ++index2 < n; ) {
    source = result[index2];
    sliced = source.subarray(0, Math.min(source.length, length4 - offset2));
    if (length4 <= offset2 + sliced.length) {
      if (sliced.length < source.length) {
        result[index2] = source.subarray(sliced.length);
      } else if (sliced.length === source.length) {
        index2++;
      }
      buffer ? memcpy(buffer, sliced, offset2) : buffer = sliced;
      break;
    }
    memcpy(buffer || (buffer = new Uint8Array(length4)), sliced, offset2);
    offset2 += sliced.length;
  }
  return [buffer || new Uint8Array(0), result.slice(index2), byteLength - (buffer ? buffer.byteLength : 0)];
}
function toArrayBufferView(ArrayBufferViewCtor, input3) {
  let value = isIteratorResult(input3) ? input3.value : input3;
  if (value instanceof ArrayBufferViewCtor) {
    if (ArrayBufferViewCtor === Uint8Array) {
      return new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength);
    }
    return value;
  }
  if (!value) {
    return new ArrayBufferViewCtor(0);
  }
  if (typeof value === "string") {
    value = encodeUtf8(value);
  }
  if (value instanceof ArrayBuffer) {
    return new ArrayBufferViewCtor(value);
  }
  if (value instanceof SharedArrayBuf) {
    return new ArrayBufferViewCtor(value);
  }
  if (isFlatbuffersByteBuffer(value)) {
    return toArrayBufferView(ArrayBufferViewCtor, value.bytes());
  }
  return !ArrayBuffer.isView(value) ? ArrayBufferViewCtor.from(value) : value.byteLength <= 0 ? new ArrayBufferViewCtor(0) : new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength / ArrayBufferViewCtor.BYTES_PER_ELEMENT);
}
var toInt8Array = (input3) => toArrayBufferView(Int8Array, input3);
var toInt16Array = (input3) => toArrayBufferView(Int16Array, input3);
var toInt32Array = (input3) => toArrayBufferView(Int32Array, input3);
var toBigInt64Array = (input3) => toArrayBufferView(BigInt64Array, input3);
var toUint8Array = (input3) => toArrayBufferView(Uint8Array, input3);
var toUint16Array = (input3) => toArrayBufferView(Uint16Array, input3);
var toUint32Array = (input3) => toArrayBufferView(Uint32Array, input3);
var toBigUint64Array = (input3) => toArrayBufferView(BigUint64Array, input3);
var toFloat32Array = (input3) => toArrayBufferView(Float32Array, input3);
var toFloat64Array = (input3) => toArrayBufferView(Float64Array, input3);
var toUint8ClampedArray = (input3) => toArrayBufferView(Uint8ClampedArray, input3);
var pump = (iterator) => {
  iterator.next();
  return iterator;
};
function* toArrayBufferViewIterator(ArrayCtor, source) {
  const wrap2 = function* (x4) {
    yield x4;
  };
  const buffers = typeof source === "string" ? wrap2(source) : ArrayBuffer.isView(source) ? wrap2(source) : source instanceof ArrayBuffer ? wrap2(source) : source instanceof SharedArrayBuf ? wrap2(source) : !isIterable(source) ? wrap2(source) : source;
  yield* pump(function* (it2) {
    let r = null;
    do {
      r = it2.next(yield toArrayBufferView(ArrayCtor, r));
    } while (!r.done);
  }(buffers[Symbol.iterator]()));
  return new ArrayCtor();
}
var toInt8ArrayIterator = (input3) => toArrayBufferViewIterator(Int8Array, input3);
var toInt16ArrayIterator = (input3) => toArrayBufferViewIterator(Int16Array, input3);
var toInt32ArrayIterator = (input3) => toArrayBufferViewIterator(Int32Array, input3);
var toUint8ArrayIterator = (input3) => toArrayBufferViewIterator(Uint8Array, input3);
var toUint16ArrayIterator = (input3) => toArrayBufferViewIterator(Uint16Array, input3);
var toUint32ArrayIterator = (input3) => toArrayBufferViewIterator(Uint32Array, input3);
var toFloat32ArrayIterator = (input3) => toArrayBufferViewIterator(Float32Array, input3);
var toFloat64ArrayIterator = (input3) => toArrayBufferViewIterator(Float64Array, input3);
var toUint8ClampedArrayIterator = (input3) => toArrayBufferViewIterator(Uint8ClampedArray, input3);
function toArrayBufferViewAsyncIterator(ArrayCtor, source) {
  return __asyncGenerator(this, arguments, function* toArrayBufferViewAsyncIterator_1() {
    if (isPromise(source)) {
      return yield __await(yield __await(yield* __asyncDelegator(__asyncValues(toArrayBufferViewAsyncIterator(ArrayCtor, yield __await(source))))));
    }
    const wrap2 = function(x4) {
      return __asyncGenerator(this, arguments, function* () {
        yield yield __await(yield __await(x4));
      });
    };
    const emit = function(source2) {
      return __asyncGenerator(this, arguments, function* () {
        yield __await(yield* __asyncDelegator(__asyncValues(pump(function* (it2) {
          let r = null;
          do {
            r = it2.next(yield r === null || r === void 0 ? void 0 : r.value);
          } while (!r.done);
        }(source2[Symbol.iterator]())))));
      });
    };
    const buffers = typeof source === "string" ? wrap2(source) : ArrayBuffer.isView(source) ? wrap2(source) : source instanceof ArrayBuffer ? wrap2(source) : source instanceof SharedArrayBuf ? wrap2(source) : isIterable(source) ? emit(source) : !isAsyncIterable(source) ? wrap2(source) : source;
    yield __await(
      // otherwise if AsyncIterable, use it
      yield* __asyncDelegator(__asyncValues(pump(function(it2) {
        return __asyncGenerator(this, arguments, function* () {
          let r = null;
          do {
            r = yield __await(it2.next(yield yield __await(toArrayBufferView(ArrayCtor, r))));
          } while (!r.done);
        });
      }(buffers[Symbol.asyncIterator]()))))
    );
    return yield __await(new ArrayCtor());
  });
}
var toInt8ArrayAsyncIterator = (input3) => toArrayBufferViewAsyncIterator(Int8Array, input3);
var toInt16ArrayAsyncIterator = (input3) => toArrayBufferViewAsyncIterator(Int16Array, input3);
var toInt32ArrayAsyncIterator = (input3) => toArrayBufferViewAsyncIterator(Int32Array, input3);
var toUint8ArrayAsyncIterator = (input3) => toArrayBufferViewAsyncIterator(Uint8Array, input3);
var toUint16ArrayAsyncIterator = (input3) => toArrayBufferViewAsyncIterator(Uint16Array, input3);
var toUint32ArrayAsyncIterator = (input3) => toArrayBufferViewAsyncIterator(Uint32Array, input3);
var toFloat32ArrayAsyncIterator = (input3) => toArrayBufferViewAsyncIterator(Float32Array, input3);
var toFloat64ArrayAsyncIterator = (input3) => toArrayBufferViewAsyncIterator(Float64Array, input3);
var toUint8ClampedArrayAsyncIterator = (input3) => toArrayBufferViewAsyncIterator(Uint8ClampedArray, input3);
function rebaseValueOffsets(offset2, length4, valueOffsets) {
  if (offset2 !== 0) {
    valueOffsets = valueOffsets.slice(0, length4);
    for (let i = -1, n = valueOffsets.length; ++i < n; ) {
      valueOffsets[i] += offset2;
    }
  }
  return valueOffsets.subarray(0, length4);
}
function compareArrayLike(a3, b2) {
  let i = 0;
  const n = a3.length;
  if (n !== b2.length) {
    return false;
  }
  if (n > 0) {
    do {
      if (a3[i] !== b2[i]) {
        return false;
      }
    } while (++i < n);
  }
  return true;
}

// ../core/node_modules/apache-arrow/io/adapters.mjs
var adapters_default = {
  fromIterable(source) {
    return pump2(fromIterable(source));
  },
  fromAsyncIterable(source) {
    return pump2(fromAsyncIterable(source));
  },
  fromDOMStream(source) {
    return pump2(fromDOMStream(source));
  },
  fromNodeStream(stream) {
    return pump2(fromNodeStream(stream));
  },
  // @ts-ignore
  toDOMStream(source, options) {
    throw new Error(`"toDOMStream" not available in this environment`);
  },
  // @ts-ignore
  toNodeStream(source, options) {
    throw new Error(`"toNodeStream" not available in this environment`);
  }
};
var pump2 = (iterator) => {
  iterator.next();
  return iterator;
};
function* fromIterable(source) {
  let done, threw = false;
  let buffers = [], buffer;
  let cmd, size, bufferLength = 0;
  function byteRange() {
    if (cmd === "peek") {
      return joinUint8Arrays(buffers, size)[0];
    }
    [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);
    return buffer;
  }
  ({ cmd, size } = (yield /* @__PURE__ */ (() => null)()) || { cmd: "read", size: 0 });
  const it2 = toUint8ArrayIterator(source)[Symbol.iterator]();
  try {
    do {
      ({ done, value: buffer } = Number.isNaN(size - bufferLength) ? it2.next() : it2.next(size - bufferLength));
      if (!done && buffer.byteLength > 0) {
        buffers.push(buffer);
        bufferLength += buffer.byteLength;
      }
      if (done || size <= bufferLength) {
        do {
          ({ cmd, size } = yield byteRange());
        } while (size < bufferLength);
      }
    } while (!done);
  } catch (e) {
    (threw = true) && typeof it2.throw === "function" && it2.throw(e);
  } finally {
    threw === false && typeof it2.return === "function" && it2.return(null);
  }
  return null;
}
function fromAsyncIterable(source) {
  return __asyncGenerator(this, arguments, function* fromAsyncIterable_1() {
    let done, threw = false;
    let buffers = [], buffer;
    let cmd, size, bufferLength = 0;
    function byteRange() {
      if (cmd === "peek") {
        return joinUint8Arrays(buffers, size)[0];
      }
      [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);
      return buffer;
    }
    ({ cmd, size } = (yield yield __await(/* @__PURE__ */ (() => null)())) || { cmd: "read", size: 0 });
    const it2 = toUint8ArrayAsyncIterator(source)[Symbol.asyncIterator]();
    try {
      do {
        ({ done, value: buffer } = Number.isNaN(size - bufferLength) ? yield __await(it2.next()) : yield __await(it2.next(size - bufferLength)));
        if (!done && buffer.byteLength > 0) {
          buffers.push(buffer);
          bufferLength += buffer.byteLength;
        }
        if (done || size <= bufferLength) {
          do {
            ({ cmd, size } = yield yield __await(byteRange()));
          } while (size < bufferLength);
        }
      } while (!done);
    } catch (e) {
      (threw = true) && typeof it2.throw === "function" && (yield __await(it2.throw(e)));
    } finally {
      threw === false && typeof it2.return === "function" && (yield __await(it2.return(new Uint8Array(0))));
    }
    return yield __await(null);
  });
}
function fromDOMStream(source) {
  return __asyncGenerator(this, arguments, function* fromDOMStream_1() {
    let done = false, threw = false;
    let buffers = [], buffer;
    let cmd, size, bufferLength = 0;
    function byteRange() {
      if (cmd === "peek") {
        return joinUint8Arrays(buffers, size)[0];
      }
      [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);
      return buffer;
    }
    ({ cmd, size } = (yield yield __await(/* @__PURE__ */ (() => null)())) || { cmd: "read", size: 0 });
    const it2 = new AdaptiveByteReader(source);
    try {
      do {
        ({ done, value: buffer } = Number.isNaN(size - bufferLength) ? yield __await(it2["read"]()) : yield __await(it2["read"](size - bufferLength)));
        if (!done && buffer.byteLength > 0) {
          buffers.push(toUint8Array(buffer));
          bufferLength += buffer.byteLength;
        }
        if (done || size <= bufferLength) {
          do {
            ({ cmd, size } = yield yield __await(byteRange()));
          } while (size < bufferLength);
        }
      } while (!done);
    } catch (e) {
      (threw = true) && (yield __await(it2["cancel"](e)));
    } finally {
      threw === false ? yield __await(it2["cancel"]()) : source["locked"] && it2.releaseLock();
    }
    return yield __await(null);
  });
}
var AdaptiveByteReader = class {
  constructor(source) {
    this.source = source;
    this.reader = null;
    this.reader = this.source["getReader"]();
    this.reader["closed"].catch(() => {
    });
  }
  get closed() {
    return this.reader ? this.reader["closed"].catch(() => {
    }) : Promise.resolve();
  }
  releaseLock() {
    if (this.reader) {
      this.reader.releaseLock();
    }
    this.reader = null;
  }
  cancel(reason) {
    return __awaiter(this, void 0, void 0, function* () {
      const { reader, source } = this;
      reader && (yield reader["cancel"](reason).catch(() => {
      }));
      source && (source["locked"] && this.releaseLock());
    });
  }
  read(size) {
    return __awaiter(this, void 0, void 0, function* () {
      if (size === 0) {
        return { done: this.reader == null, value: new Uint8Array(0) };
      }
      const result = yield this.reader.read();
      !result.done && (result.value = toUint8Array(result));
      return result;
    });
  }
};
var onEvent = (stream, event) => {
  const handler = (_2) => resolve([event, _2]);
  let resolve;
  return [event, handler, new Promise((r) => (resolve = r) && stream["once"](event, handler))];
};
function fromNodeStream(stream) {
  return __asyncGenerator(this, arguments, function* fromNodeStream_1() {
    const events = [];
    let event = "error";
    let done = false, err = null;
    let cmd, size, bufferLength = 0;
    let buffers = [], buffer;
    function byteRange() {
      if (cmd === "peek") {
        return joinUint8Arrays(buffers, size)[0];
      }
      [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);
      return buffer;
    }
    ({ cmd, size } = (yield yield __await(/* @__PURE__ */ (() => null)())) || { cmd: "read", size: 0 });
    if (stream["isTTY"]) {
      yield yield __await(new Uint8Array(0));
      return yield __await(null);
    }
    try {
      events[0] = onEvent(stream, "end");
      events[1] = onEvent(stream, "error");
      do {
        events[2] = onEvent(stream, "readable");
        [event, err] = yield __await(Promise.race(events.map((x4) => x4[2])));
        if (event === "error") {
          break;
        }
        if (!(done = event === "end")) {
          if (!Number.isFinite(size - bufferLength)) {
            buffer = toUint8Array(stream["read"]());
          } else {
            buffer = toUint8Array(stream["read"](size - bufferLength));
            if (buffer.byteLength < size - bufferLength) {
              buffer = toUint8Array(stream["read"]());
            }
          }
          if (buffer.byteLength > 0) {
            buffers.push(buffer);
            bufferLength += buffer.byteLength;
          }
        }
        if (done || size <= bufferLength) {
          do {
            ({ cmd, size } = yield yield __await(byteRange()));
          } while (size < bufferLength);
        }
      } while (!done);
    } finally {
      yield __await(cleanup(events, event === "error" ? err : null));
    }
    return yield __await(null);
    function cleanup(events2, err2) {
      buffer = buffers = null;
      return new Promise((resolve, reject) => {
        for (const [evt, fn] of events2) {
          stream["off"](evt, fn);
        }
        try {
          const destroy = stream["destroy"];
          destroy && destroy.call(stream, err2);
          err2 = void 0;
        } catch (e) {
          err2 = e || err2;
        } finally {
          err2 != null ? reject(err2) : resolve();
        }
      });
    }
  });
}

// ../core/node_modules/apache-arrow/fb/metadata-version.mjs
var MetadataVersion;
(function(MetadataVersion4) {
  MetadataVersion4[MetadataVersion4["V1"] = 0] = "V1";
  MetadataVersion4[MetadataVersion4["V2"] = 1] = "V2";
  MetadataVersion4[MetadataVersion4["V3"] = 2] = "V3";
  MetadataVersion4[MetadataVersion4["V4"] = 3] = "V4";
  MetadataVersion4[MetadataVersion4["V5"] = 4] = "V5";
})(MetadataVersion || (MetadataVersion = {}));

// ../core/node_modules/apache-arrow/fb/union-mode.mjs
var UnionMode;
(function(UnionMode4) {
  UnionMode4[UnionMode4["Sparse"] = 0] = "Sparse";
  UnionMode4[UnionMode4["Dense"] = 1] = "Dense";
})(UnionMode || (UnionMode = {}));

// ../core/node_modules/apache-arrow/fb/precision.mjs
var Precision;
(function(Precision4) {
  Precision4[Precision4["HALF"] = 0] = "HALF";
  Precision4[Precision4["SINGLE"] = 1] = "SINGLE";
  Precision4[Precision4["DOUBLE"] = 2] = "DOUBLE";
})(Precision || (Precision = {}));

// ../core/node_modules/apache-arrow/fb/date-unit.mjs
var DateUnit;
(function(DateUnit4) {
  DateUnit4[DateUnit4["DAY"] = 0] = "DAY";
  DateUnit4[DateUnit4["MILLISECOND"] = 1] = "MILLISECOND";
})(DateUnit || (DateUnit = {}));

// ../core/node_modules/apache-arrow/fb/time-unit.mjs
var TimeUnit;
(function(TimeUnit4) {
  TimeUnit4[TimeUnit4["SECOND"] = 0] = "SECOND";
  TimeUnit4[TimeUnit4["MILLISECOND"] = 1] = "MILLISECOND";
  TimeUnit4[TimeUnit4["MICROSECOND"] = 2] = "MICROSECOND";
  TimeUnit4[TimeUnit4["NANOSECOND"] = 3] = "NANOSECOND";
})(TimeUnit || (TimeUnit = {}));

// ../core/node_modules/apache-arrow/fb/interval-unit.mjs
var IntervalUnit;
(function(IntervalUnit4) {
  IntervalUnit4[IntervalUnit4["YEAR_MONTH"] = 0] = "YEAR_MONTH";
  IntervalUnit4[IntervalUnit4["DAY_TIME"] = 1] = "DAY_TIME";
  IntervalUnit4[IntervalUnit4["MONTH_DAY_NANO"] = 2] = "MONTH_DAY_NANO";
})(IntervalUnit || (IntervalUnit = {}));

// ../../node_modules/flatbuffers/mjs/constants.js
var SIZEOF_SHORT = 2;
var SIZEOF_INT = 4;
var FILE_IDENTIFIER_LENGTH = 4;
var SIZE_PREFIX_LENGTH = 4;

// ../../node_modules/flatbuffers/mjs/utils.js
var int32 = new Int32Array(2);
var float32 = new Float32Array(int32.buffer);
var float64 = new Float64Array(int32.buffer);
var isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;

// ../../node_modules/flatbuffers/mjs/encoding.js
var Encoding;
(function(Encoding2) {
  Encoding2[Encoding2["UTF8_BYTES"] = 1] = "UTF8_BYTES";
  Encoding2[Encoding2["UTF16_STRING"] = 2] = "UTF16_STRING";
})(Encoding || (Encoding = {}));

// ../../node_modules/flatbuffers/mjs/byte-buffer.js
var ByteBuffer = class _ByteBuffer {
  /**
   * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)
   */
  constructor(bytes_) {
    this.bytes_ = bytes_;
    this.position_ = 0;
    this.text_decoder_ = new TextDecoder();
  }
  /**
   * Create and allocate a new ByteBuffer with a given size.
   */
  static allocate(byte_size) {
    return new _ByteBuffer(new Uint8Array(byte_size));
  }
  clear() {
    this.position_ = 0;
  }
  /**
   * Get the underlying `Uint8Array`.
   */
  bytes() {
    return this.bytes_;
  }
  /**
   * Get the buffer's position.
   */
  position() {
    return this.position_;
  }
  /**
   * Set the buffer's position.
   */
  setPosition(position3) {
    this.position_ = position3;
  }
  /**
   * Get the buffer's capacity.
   */
  capacity() {
    return this.bytes_.length;
  }
  readInt8(offset2) {
    return this.readUint8(offset2) << 24 >> 24;
  }
  readUint8(offset2) {
    return this.bytes_[offset2];
  }
  readInt16(offset2) {
    return this.readUint16(offset2) << 16 >> 16;
  }
  readUint16(offset2) {
    return this.bytes_[offset2] | this.bytes_[offset2 + 1] << 8;
  }
  readInt32(offset2) {
    return this.bytes_[offset2] | this.bytes_[offset2 + 1] << 8 | this.bytes_[offset2 + 2] << 16 | this.bytes_[offset2 + 3] << 24;
  }
  readUint32(offset2) {
    return this.readInt32(offset2) >>> 0;
  }
  readInt64(offset2) {
    return BigInt.asIntN(64, BigInt(this.readUint32(offset2)) + (BigInt(this.readUint32(offset2 + 4)) << BigInt(32)));
  }
  readUint64(offset2) {
    return BigInt.asUintN(64, BigInt(this.readUint32(offset2)) + (BigInt(this.readUint32(offset2 + 4)) << BigInt(32)));
  }
  readFloat32(offset2) {
    int32[0] = this.readInt32(offset2);
    return float32[0];
  }
  readFloat64(offset2) {
    int32[isLittleEndian ? 0 : 1] = this.readInt32(offset2);
    int32[isLittleEndian ? 1 : 0] = this.readInt32(offset2 + 4);
    return float64[0];
  }
  writeInt8(offset2, value) {
    this.bytes_[offset2] = value;
  }
  writeUint8(offset2, value) {
    this.bytes_[offset2] = value;
  }
  writeInt16(offset2, value) {
    this.bytes_[offset2] = value;
    this.bytes_[offset2 + 1] = value >> 8;
  }
  writeUint16(offset2, value) {
    this.bytes_[offset2] = value;
    this.bytes_[offset2 + 1] = value >> 8;
  }
  writeInt32(offset2, value) {
    this.bytes_[offset2] = value;
    this.bytes_[offset2 + 1] = value >> 8;
    this.bytes_[offset2 + 2] = value >> 16;
    this.bytes_[offset2 + 3] = value >> 24;
  }
  writeUint32(offset2, value) {
    this.bytes_[offset2] = value;
    this.bytes_[offset2 + 1] = value >> 8;
    this.bytes_[offset2 + 2] = value >> 16;
    this.bytes_[offset2 + 3] = value >> 24;
  }
  writeInt64(offset2, value) {
    this.writeInt32(offset2, Number(BigInt.asIntN(32, value)));
    this.writeInt32(offset2 + 4, Number(BigInt.asIntN(32, value >> BigInt(32))));
  }
  writeUint64(offset2, value) {
    this.writeUint32(offset2, Number(BigInt.asUintN(32, value)));
    this.writeUint32(offset2 + 4, Number(BigInt.asUintN(32, value >> BigInt(32))));
  }
  writeFloat32(offset2, value) {
    float32[0] = value;
    this.writeInt32(offset2, int32[0]);
  }
  writeFloat64(offset2, value) {
    float64[0] = value;
    this.writeInt32(offset2, int32[isLittleEndian ? 0 : 1]);
    this.writeInt32(offset2 + 4, int32[isLittleEndian ? 1 : 0]);
  }
  /**
   * Return the file identifier.   Behavior is undefined for FlatBuffers whose
   * schema does not include a file_identifier (likely points at padding or the
   * start of a the root vtable).
   */
  getBufferIdentifier() {
    if (this.bytes_.length < this.position_ + SIZEOF_INT + FILE_IDENTIFIER_LENGTH) {
      throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
    }
    let result = "";
    for (let i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {
      result += String.fromCharCode(this.readInt8(this.position_ + SIZEOF_INT + i));
    }
    return result;
  }
  /**
   * Look up a field in the vtable, return an offset into the object, or 0 if the
   * field is not present.
   */
  __offset(bb_pos, vtable_offset) {
    const vtable = bb_pos - this.readInt32(bb_pos);
    return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;
  }
  /**
   * Initialize any Table-derived type to point to the union at the given offset.
   */
  __union(t, offset2) {
    t.bb_pos = offset2 + this.readInt32(offset2);
    t.bb = this;
    return t;
  }
  /**
   * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.
   * This allocates a new string and converts to wide chars upon each access.
   *
   * To avoid the conversion to string, pass Encoding.UTF8_BYTES as the
   * "optionalEncoding" argument. This is useful for avoiding conversion when
   * the data will just be packaged back up in another FlatBuffer later on.
   *
   * @param offset
   * @param opt_encoding Defaults to UTF16_STRING
   */
  __string(offset2, opt_encoding) {
    offset2 += this.readInt32(offset2);
    const length4 = this.readInt32(offset2);
    offset2 += SIZEOF_INT;
    const utf8bytes = this.bytes_.subarray(offset2, offset2 + length4);
    if (opt_encoding === Encoding.UTF8_BYTES)
      return utf8bytes;
    else
      return this.text_decoder_.decode(utf8bytes);
  }
  /**
   * Handle unions that can contain string as its member, if a Table-derived type then initialize it,
   * if a string then return a new one
   *
   * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this
   * makes the behaviour of __union_with_string different compared to __union
   */
  __union_with_string(o, offset2) {
    if (typeof o === "string") {
      return this.__string(offset2);
    }
    return this.__union(o, offset2);
  }
  /**
   * Retrieve the relative offset stored at "offset"
   */
  __indirect(offset2) {
    return offset2 + this.readInt32(offset2);
  }
  /**
   * Get the start of data of a vector whose offset is stored at "offset" in this object.
   */
  __vector(offset2) {
    return offset2 + this.readInt32(offset2) + SIZEOF_INT;
  }
  /**
   * Get the length of a vector whose offset is stored at "offset" in this object.
   */
  __vector_len(offset2) {
    return this.readInt32(offset2 + this.readInt32(offset2));
  }
  __has_identifier(ident) {
    if (ident.length != FILE_IDENTIFIER_LENGTH) {
      throw new Error("FlatBuffers: file identifier must be length " + FILE_IDENTIFIER_LENGTH);
    }
    for (let i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {
      if (ident.charCodeAt(i) != this.readInt8(this.position() + SIZEOF_INT + i)) {
        return false;
      }
    }
    return true;
  }
  /**
   * A helper function for generating list for obj api
   */
  createScalarList(listAccessor, listLength) {
    const ret = [];
    for (let i = 0; i < listLength; ++i) {
      const val = listAccessor(i);
      if (val !== null) {
        ret.push(val);
      }
    }
    return ret;
  }
  /**
   * A helper function for generating list for obj api
   * @param listAccessor function that accepts an index and return data at that index
   * @param listLength listLength
   * @param res result list
   */
  createObjList(listAccessor, listLength) {
    const ret = [];
    for (let i = 0; i < listLength; ++i) {
      const val = listAccessor(i);
      if (val !== null) {
        ret.push(val.unpack());
      }
    }
    return ret;
  }
};

// ../../node_modules/flatbuffers/mjs/builder.js
var Builder = class _Builder {
  /**
   * Create a FlatBufferBuilder.
   */
  constructor(opt_initial_size) {
    this.minalign = 1;
    this.vtable = null;
    this.vtable_in_use = 0;
    this.isNested = false;
    this.object_start = 0;
    this.vtables = [];
    this.vector_num_elems = 0;
    this.force_defaults = false;
    this.string_maps = null;
    this.text_encoder = new TextEncoder();
    let initial_size;
    if (!opt_initial_size) {
      initial_size = 1024;
    } else {
      initial_size = opt_initial_size;
    }
    this.bb = ByteBuffer.allocate(initial_size);
    this.space = initial_size;
  }
  clear() {
    this.bb.clear();
    this.space = this.bb.capacity();
    this.minalign = 1;
    this.vtable = null;
    this.vtable_in_use = 0;
    this.isNested = false;
    this.object_start = 0;
    this.vtables = [];
    this.vector_num_elems = 0;
    this.force_defaults = false;
    this.string_maps = null;
  }
  /**
   * In order to save space, fields that are set to their default value
   * don't get serialized into the buffer. Forcing defaults provides a
   * way to manually disable this optimization.
   *
   * @param forceDefaults true always serializes default values
   */
  forceDefaults(forceDefaults) {
    this.force_defaults = forceDefaults;
  }
  /**
   * Get the ByteBuffer representing the FlatBuffer. Only call this after you've
   * called finish(). The actual data starts at the ByteBuffer's current position,
   * not necessarily at 0.
   */
  dataBuffer() {
    return this.bb;
  }
  /**
   * Get the bytes representing the FlatBuffer. Only call this after you've
   * called finish().
   */
  asUint8Array() {
    return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
  }
  /**
   * Prepare to write an element of `size` after `additional_bytes` have been
   * written, e.g. if you write a string, you need to align such the int length
   * field is aligned to 4 bytes, and the string data follows it directly. If all
   * you need to do is alignment, `additional_bytes` will be 0.
   *
   * @param size This is the of the new element to write
   * @param additional_bytes The padding size
   */
  prep(size, additional_bytes) {
    if (size > this.minalign) {
      this.minalign = size;
    }
    const align_size = ~(this.bb.capacity() - this.space + additional_bytes) + 1 & size - 1;
    while (this.space < align_size + size + additional_bytes) {
      const old_buf_size = this.bb.capacity();
      this.bb = _Builder.growByteBuffer(this.bb);
      this.space += this.bb.capacity() - old_buf_size;
    }
    this.pad(align_size);
  }
  pad(byte_size) {
    for (let i = 0; i < byte_size; i++) {
      this.bb.writeInt8(--this.space, 0);
    }
  }
  writeInt8(value) {
    this.bb.writeInt8(this.space -= 1, value);
  }
  writeInt16(value) {
    this.bb.writeInt16(this.space -= 2, value);
  }
  writeInt32(value) {
    this.bb.writeInt32(this.space -= 4, value);
  }
  writeInt64(value) {
    this.bb.writeInt64(this.space -= 8, value);
  }
  writeFloat32(value) {
    this.bb.writeFloat32(this.space -= 4, value);
  }
  writeFloat64(value) {
    this.bb.writeFloat64(this.space -= 8, value);
  }
  /**
   * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int8` to add the buffer.
   */
  addInt8(value) {
    this.prep(1, 0);
    this.writeInt8(value);
  }
  /**
   * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int16` to add the buffer.
   */
  addInt16(value) {
    this.prep(2, 0);
    this.writeInt16(value);
  }
  /**
   * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int32` to add the buffer.
   */
  addInt32(value) {
    this.prep(4, 0);
    this.writeInt32(value);
  }
  /**
   * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int64` to add the buffer.
   */
  addInt64(value) {
    this.prep(8, 0);
    this.writeInt64(value);
  }
  /**
   * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `float32` to add the buffer.
   */
  addFloat32(value) {
    this.prep(4, 0);
    this.writeFloat32(value);
  }
  /**
   * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `float64` to add the buffer.
   */
  addFloat64(value) {
    this.prep(8, 0);
    this.writeFloat64(value);
  }
  addFieldInt8(voffset, value, defaultValue) {
    if (this.force_defaults || value != defaultValue) {
      this.addInt8(value);
      this.slot(voffset);
    }
  }
  addFieldInt16(voffset, value, defaultValue) {
    if (this.force_defaults || value != defaultValue) {
      this.addInt16(value);
      this.slot(voffset);
    }
  }
  addFieldInt32(voffset, value, defaultValue) {
    if (this.force_defaults || value != defaultValue) {
      this.addInt32(value);
      this.slot(voffset);
    }
  }
  addFieldInt64(voffset, value, defaultValue) {
    if (this.force_defaults || value !== defaultValue) {
      this.addInt64(value);
      this.slot(voffset);
    }
  }
  addFieldFloat32(voffset, value, defaultValue) {
    if (this.force_defaults || value != defaultValue) {
      this.addFloat32(value);
      this.slot(voffset);
    }
  }
  addFieldFloat64(voffset, value, defaultValue) {
    if (this.force_defaults || value != defaultValue) {
      this.addFloat64(value);
      this.slot(voffset);
    }
  }
  addFieldOffset(voffset, value, defaultValue) {
    if (this.force_defaults || value != defaultValue) {
      this.addOffset(value);
      this.slot(voffset);
    }
  }
  /**
   * Structs are stored inline, so nothing additional is being added. `d` is always 0.
   */
  addFieldStruct(voffset, value, defaultValue) {
    if (value != defaultValue) {
      this.nested(value);
      this.slot(voffset);
    }
  }
  /**
   * Structures are always stored inline, they need to be created right
   * where they're used.  You'll get this assertion failure if you
   * created it elsewhere.
   */
  nested(obj) {
    if (obj != this.offset()) {
      throw new TypeError("FlatBuffers: struct must be serialized inline.");
    }
  }
  /**
   * Should not be creating any other object, string or vector
   * while an object is being constructed
   */
  notNested() {
    if (this.isNested) {
      throw new TypeError("FlatBuffers: object serialization must not be nested.");
    }
  }
  /**
   * Set the current vtable at `voffset` to the current location in the buffer.
   */
  slot(voffset) {
    if (this.vtable !== null)
      this.vtable[voffset] = this.offset();
  }
  /**
   * @returns Offset relative to the end of the buffer.
   */
  offset() {
    return this.bb.capacity() - this.space;
  }
  /**
   * Doubles the size of the backing ByteBuffer and copies the old data towards
   * the end of the new buffer (since we build the buffer backwards).
   *
   * @param bb The current buffer with the existing data
   * @returns A new byte buffer with the old data copied
   * to it. The data is located at the end of the buffer.
   *
   * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass
   * it a uint8Array we need to suppress the type check:
   * @suppress {checkTypes}
   */
  static growByteBuffer(bb2) {
    const old_buf_size = bb2.capacity();
    if (old_buf_size & 3221225472) {
      throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");
    }
    const new_buf_size = old_buf_size << 1;
    const nbb = ByteBuffer.allocate(new_buf_size);
    nbb.setPosition(new_buf_size - old_buf_size);
    nbb.bytes().set(bb2.bytes(), new_buf_size - old_buf_size);
    return nbb;
  }
  /**
   * Adds on offset, relative to where it will be written.
   *
   * @param offset The offset to add.
   */
  addOffset(offset2) {
    this.prep(SIZEOF_INT, 0);
    this.writeInt32(this.offset() - offset2 + SIZEOF_INT);
  }
  /**
   * Start encoding a new object in the buffer.  Users will not usually need to
   * call this directly. The FlatBuffers compiler will generate helper methods
   * that call this method internally.
   */
  startObject(numfields) {
    this.notNested();
    if (this.vtable == null) {
      this.vtable = [];
    }
    this.vtable_in_use = numfields;
    for (let i = 0; i < numfields; i++) {
      this.vtable[i] = 0;
    }
    this.isNested = true;
    this.object_start = this.offset();
  }
  /**
   * Finish off writing the object that is under construction.
   *
   * @returns The offset to the object inside `dataBuffer`
   */
  endObject() {
    if (this.vtable == null || !this.isNested) {
      throw new Error("FlatBuffers: endObject called without startObject");
    }
    this.addInt32(0);
    const vtableloc = this.offset();
    let i = this.vtable_in_use - 1;
    for (; i >= 0 && this.vtable[i] == 0; i--) {
    }
    const trimmed_size = i + 1;
    for (; i >= 0; i--) {
      this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);
    }
    const standard_fields = 2;
    this.addInt16(vtableloc - this.object_start);
    const len = (trimmed_size + standard_fields) * SIZEOF_SHORT;
    this.addInt16(len);
    let existing_vtable = 0;
    const vt1 = this.space;
    outer_loop:
      for (i = 0; i < this.vtables.length; i++) {
        const vt2 = this.bb.capacity() - this.vtables[i];
        if (len == this.bb.readInt16(vt2)) {
          for (let j2 = SIZEOF_SHORT; j2 < len; j2 += SIZEOF_SHORT) {
            if (this.bb.readInt16(vt1 + j2) != this.bb.readInt16(vt2 + j2)) {
              continue outer_loop;
            }
          }
          existing_vtable = this.vtables[i];
          break;
        }
      }
    if (existing_vtable) {
      this.space = this.bb.capacity() - vtableloc;
      this.bb.writeInt32(this.space, existing_vtable - vtableloc);
    } else {
      this.vtables.push(this.offset());
      this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);
    }
    this.isNested = false;
    return vtableloc;
  }
  /**
   * Finalize a buffer, poiting to the given `root_table`.
   */
  finish(root_table, opt_file_identifier, opt_size_prefix) {
    const size_prefix = opt_size_prefix ? SIZE_PREFIX_LENGTH : 0;
    if (opt_file_identifier) {
      const file_identifier = opt_file_identifier;
      this.prep(this.minalign, SIZEOF_INT + FILE_IDENTIFIER_LENGTH + size_prefix);
      if (file_identifier.length != FILE_IDENTIFIER_LENGTH) {
        throw new TypeError("FlatBuffers: file identifier must be length " + FILE_IDENTIFIER_LENGTH);
      }
      for (let i = FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {
        this.writeInt8(file_identifier.charCodeAt(i));
      }
    }
    this.prep(this.minalign, SIZEOF_INT + size_prefix);
    this.addOffset(root_table);
    if (size_prefix) {
      this.addInt32(this.bb.capacity() - this.space);
    }
    this.bb.setPosition(this.space);
  }
  /**
   * Finalize a size prefixed buffer, pointing to the given `root_table`.
   */
  finishSizePrefixed(root_table, opt_file_identifier) {
    this.finish(root_table, opt_file_identifier, true);
  }
  /**
   * This checks a required field has been set in a given table that has
   * just been constructed.
   */
  requiredField(table3, field2) {
    const table_start = this.bb.capacity() - table3;
    const vtable_start = table_start - this.bb.readInt32(table_start);
    const ok = field2 < this.bb.readInt16(vtable_start) && this.bb.readInt16(vtable_start + field2) != 0;
    if (!ok) {
      throw new TypeError("FlatBuffers: field " + field2 + " must be set");
    }
  }
  /**
   * Start a new array/vector of objects.  Users usually will not call
   * this directly. The FlatBuffers compiler will create a start/end
   * method for vector types in generated code.
   *
   * @param elem_size The size of each element in the array
   * @param num_elems The number of elements in the array
   * @param alignment The alignment of the array
   */
  startVector(elem_size, num_elems, alignment) {
    this.notNested();
    this.vector_num_elems = num_elems;
    this.prep(SIZEOF_INT, elem_size * num_elems);
    this.prep(alignment, elem_size * num_elems);
  }
  /**
   * Finish off the creation of an array and all its elements. The array must be
   * created with `startVector`.
   *
   * @returns The offset at which the newly created array
   * starts.
   */
  endVector() {
    this.writeInt32(this.vector_num_elems);
    return this.offset();
  }
  /**
   * Encode the string `s` in the buffer using UTF-8. If the string passed has
   * already been seen, we return the offset of the already written string
   *
   * @param s The string to encode
   * @return The offset in the buffer where the encoded string starts
   */
  createSharedString(s2) {
    if (!s2) {
      return 0;
    }
    if (!this.string_maps) {
      this.string_maps = /* @__PURE__ */ new Map();
    }
    if (this.string_maps.has(s2)) {
      return this.string_maps.get(s2);
    }
    const offset2 = this.createString(s2);
    this.string_maps.set(s2, offset2);
    return offset2;
  }
  /**
   * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed
   * instead of a string, it is assumed to contain valid UTF-8 encoded data.
   *
   * @param s The string to encode
   * @return The offset in the buffer where the encoded string starts
   */
  createString(s2) {
    if (s2 === null || s2 === void 0) {
      return 0;
    }
    let utf8;
    if (s2 instanceof Uint8Array) {
      utf8 = s2;
    } else {
      utf8 = this.text_encoder.encode(s2);
    }
    this.addInt8(0);
    this.startVector(1, utf8.length, 1);
    this.bb.setPosition(this.space -= utf8.length);
    for (let i = 0, offset2 = this.space, bytes = this.bb.bytes(); i < utf8.length; i++) {
      bytes[offset2++] = utf8[i];
    }
    return this.endVector();
  }
  /**
   * A helper function to pack an object
   *
   * @returns offset of obj
   */
  createObjectOffset(obj) {
    if (obj === null) {
      return 0;
    }
    if (typeof obj === "string") {
      return this.createString(obj);
    } else {
      return obj.pack(this);
    }
  }
  /**
   * A helper function to pack a list of object
   *
   * @returns list of offsets of each non null object
   */
  createObjectOffsetList(list) {
    const ret = [];
    for (let i = 0; i < list.length; ++i) {
      const val = list[i];
      if (val !== null) {
        ret.push(this.createObjectOffset(val));
      } else {
        throw new TypeError("FlatBuffers: Argument for createObjectOffsetList cannot contain null.");
      }
    }
    return ret;
  }
  createStructOffsetList(list, startFunc) {
    startFunc(this, list.length);
    this.createObjectOffsetList(list.slice().reverse());
    return this.endVector();
  }
};

// ../core/node_modules/apache-arrow/fb/body-compression-method.mjs
var BodyCompressionMethod;
(function(BodyCompressionMethod3) {
  BodyCompressionMethod3[BodyCompressionMethod3["BUFFER"] = 0] = "BUFFER";
})(BodyCompressionMethod || (BodyCompressionMethod = {}));

// ../core/node_modules/apache-arrow/fb/compression-type.mjs
var CompressionType;
(function(CompressionType3) {
  CompressionType3[CompressionType3["LZ4_FRAME"] = 0] = "LZ4_FRAME";
  CompressionType3[CompressionType3["ZSTD"] = 1] = "ZSTD";
})(CompressionType || (CompressionType = {}));

// ../core/node_modules/apache-arrow/fb/body-compression.mjs
var BodyCompression = class _BodyCompression {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsBodyCompression(bb2, obj) {
    return (obj || new _BodyCompression()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsBodyCompression(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _BodyCompression()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  /**
   * Compressor library.
   * For LZ4_FRAME, each compressed buffer must consist of a single frame.
   */
  codec() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt8(this.bb_pos + offset2) : CompressionType.LZ4_FRAME;
  }
  /**
   * Indicates the way the record batch body was compressed
   */
  method() {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? this.bb.readInt8(this.bb_pos + offset2) : BodyCompressionMethod.BUFFER;
  }
  static startBodyCompression(builder) {
    builder.startObject(2);
  }
  static addCodec(builder, codec) {
    builder.addFieldInt8(0, codec, CompressionType.LZ4_FRAME);
  }
  static addMethod(builder, method) {
    builder.addFieldInt8(1, method, BodyCompressionMethod.BUFFER);
  }
  static endBodyCompression(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createBodyCompression(builder, codec, method) {
    _BodyCompression.startBodyCompression(builder);
    _BodyCompression.addCodec(builder, codec);
    _BodyCompression.addMethod(builder, method);
    return _BodyCompression.endBodyCompression(builder);
  }
};

// ../core/node_modules/apache-arrow/fb/buffer.mjs
var Buffer2 = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  /**
   * The relative offset into the shared memory page where the bytes for this
   * buffer starts
   */
  offset() {
    return this.bb.readInt64(this.bb_pos);
  }
  /**
   * The absolute length (in bytes) of the memory buffer. The memory is found
   * from offset (inclusive) to offset + length (non-inclusive). When building
   * messages using the encapsulated IPC message, padding bytes may be written
   * after a buffer, but such padding bytes do not need to be accounted for in
   * the size here.
   */
  length() {
    return this.bb.readInt64(this.bb_pos + 8);
  }
  static sizeOf() {
    return 16;
  }
  static createBuffer(builder, offset2, length4) {
    builder.prep(8, 16);
    builder.writeInt64(BigInt(length4 !== null && length4 !== void 0 ? length4 : 0));
    builder.writeInt64(BigInt(offset2 !== null && offset2 !== void 0 ? offset2 : 0));
    return builder.offset();
  }
};

// ../core/node_modules/apache-arrow/fb/field-node.mjs
var FieldNode = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  /**
   * The number of value slots in the Arrow array at this level of a nested
   * tree
   */
  length() {
    return this.bb.readInt64(this.bb_pos);
  }
  /**
   * The number of observed nulls. Fields with null_count == 0 may choose not
   * to write their physical validity bitmap out as a materialized buffer,
   * instead setting the length of the bitmap buffer to 0.
   */
  nullCount() {
    return this.bb.readInt64(this.bb_pos + 8);
  }
  static sizeOf() {
    return 16;
  }
  static createFieldNode(builder, length4, null_count) {
    builder.prep(8, 16);
    builder.writeInt64(BigInt(null_count !== null && null_count !== void 0 ? null_count : 0));
    builder.writeInt64(BigInt(length4 !== null && length4 !== void 0 ? length4 : 0));
    return builder.offset();
  }
};

// ../core/node_modules/apache-arrow/fb/record-batch.mjs
var RecordBatch = class _RecordBatch {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsRecordBatch(bb2, obj) {
    return (obj || new _RecordBatch()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsRecordBatch(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _RecordBatch()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  /**
   * number of records / rows. The arrays in the batch should all have this
   * length
   */
  length() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt64(this.bb_pos + offset2) : BigInt("0");
  }
  /**
   * Nodes correspond to the pre-ordered flattened logical schema
   */
  nodes(index2, obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? (obj || new FieldNode()).__init(this.bb.__vector(this.bb_pos + offset2) + index2 * 16, this.bb) : null;
  }
  nodesLength() {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
  }
  /**
   * Buffers correspond to the pre-ordered flattened buffer tree
   *
   * The number of buffers appended to this list depends on the schema. For
   * example, most primitive arrays will have 2 buffers, 1 for the validity
   * bitmap and 1 for the values. For struct arrays, there will only be a
   * single buffer for the validity (nulls) bitmap
   */
  buffers(index2, obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 8);
    return offset2 ? (obj || new Buffer2()).__init(this.bb.__vector(this.bb_pos + offset2) + index2 * 16, this.bb) : null;
  }
  buffersLength() {
    const offset2 = this.bb.__offset(this.bb_pos, 8);
    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
  }
  /**
   * Optional compression of the message body
   */
  compression(obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 10);
    return offset2 ? (obj || new BodyCompression()).__init(this.bb.__indirect(this.bb_pos + offset2), this.bb) : null;
  }
  static startRecordBatch(builder) {
    builder.startObject(4);
  }
  static addLength(builder, length4) {
    builder.addFieldInt64(0, length4, BigInt("0"));
  }
  static addNodes(builder, nodesOffset) {
    builder.addFieldOffset(1, nodesOffset, 0);
  }
  static startNodesVector(builder, numElems) {
    builder.startVector(16, numElems, 8);
  }
  static addBuffers(builder, buffersOffset) {
    builder.addFieldOffset(2, buffersOffset, 0);
  }
  static startBuffersVector(builder, numElems) {
    builder.startVector(16, numElems, 8);
  }
  static addCompression(builder, compressionOffset) {
    builder.addFieldOffset(3, compressionOffset, 0);
  }
  static endRecordBatch(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
};

// ../core/node_modules/apache-arrow/fb/dictionary-batch.mjs
var DictionaryBatch = class _DictionaryBatch {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsDictionaryBatch(bb2, obj) {
    return (obj || new _DictionaryBatch()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsDictionaryBatch(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _DictionaryBatch()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  id() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt64(this.bb_pos + offset2) : BigInt("0");
  }
  data(obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? (obj || new RecordBatch()).__init(this.bb.__indirect(this.bb_pos + offset2), this.bb) : null;
  }
  /**
   * If isDelta is true the values in the dictionary are to be appended to a
   * dictionary with the indicated id. If isDelta is false this dictionary
   * should replace the existing dictionary.
   */
  isDelta() {
    const offset2 = this.bb.__offset(this.bb_pos, 8);
    return offset2 ? !!this.bb.readInt8(this.bb_pos + offset2) : false;
  }
  static startDictionaryBatch(builder) {
    builder.startObject(3);
  }
  static addId(builder, id2) {
    builder.addFieldInt64(0, id2, BigInt("0"));
  }
  static addData(builder, dataOffset) {
    builder.addFieldOffset(1, dataOffset, 0);
  }
  static addIsDelta(builder, isDelta) {
    builder.addFieldInt8(2, +isDelta, 0);
  }
  static endDictionaryBatch(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
};

// ../core/node_modules/apache-arrow/fb/endianness.mjs
var Endianness;
(function(Endianness3) {
  Endianness3[Endianness3["Little"] = 0] = "Little";
  Endianness3[Endianness3["Big"] = 1] = "Big";
})(Endianness || (Endianness = {}));

// ../core/node_modules/apache-arrow/fb/dictionary-kind.mjs
var DictionaryKind;
(function(DictionaryKind3) {
  DictionaryKind3[DictionaryKind3["DenseArray"] = 0] = "DenseArray";
})(DictionaryKind || (DictionaryKind = {}));

// ../core/node_modules/apache-arrow/fb/int.mjs
var Int = class _Int {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsInt(bb2, obj) {
    return (obj || new _Int()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsInt(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Int()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  bitWidth() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 0;
  }
  isSigned() {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? !!this.bb.readInt8(this.bb_pos + offset2) : false;
  }
  static startInt(builder) {
    builder.startObject(2);
  }
  static addBitWidth(builder, bitWidth) {
    builder.addFieldInt32(0, bitWidth, 0);
  }
  static addIsSigned(builder, isSigned) {
    builder.addFieldInt8(1, +isSigned, 0);
  }
  static endInt(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createInt(builder, bitWidth, isSigned) {
    _Int.startInt(builder);
    _Int.addBitWidth(builder, bitWidth);
    _Int.addIsSigned(builder, isSigned);
    return _Int.endInt(builder);
  }
};

// ../core/node_modules/apache-arrow/fb/dictionary-encoding.mjs
var DictionaryEncoding = class _DictionaryEncoding {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsDictionaryEncoding(bb2, obj) {
    return (obj || new _DictionaryEncoding()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsDictionaryEncoding(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _DictionaryEncoding()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  /**
   * The known dictionary id in the application where this data is used. In
   * the file or streaming formats, the dictionary ids are found in the
   * DictionaryBatch messages
   */
  id() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt64(this.bb_pos + offset2) : BigInt("0");
  }
  /**
   * The dictionary indices are constrained to be non-negative integers. If
   * this field is null, the indices must be signed int32. To maximize
   * cross-language compatibility and performance, implementations are
   * recommended to prefer signed integer types over unsigned integer types
   * and to avoid uint64 indices unless they are required by an application.
   */
  indexType(obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? (obj || new Int()).__init(this.bb.__indirect(this.bb_pos + offset2), this.bb) : null;
  }
  /**
   * By default, dictionaries are not ordered, or the order does not have
   * semantic meaning. In some statistical, applications, dictionary-encoding
   * is used to represent ordered categorical data, and we provide a way to
   * preserve that metadata here
   */
  isOrdered() {
    const offset2 = this.bb.__offset(this.bb_pos, 8);
    return offset2 ? !!this.bb.readInt8(this.bb_pos + offset2) : false;
  }
  dictionaryKind() {
    const offset2 = this.bb.__offset(this.bb_pos, 10);
    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : DictionaryKind.DenseArray;
  }
  static startDictionaryEncoding(builder) {
    builder.startObject(4);
  }
  static addId(builder, id2) {
    builder.addFieldInt64(0, id2, BigInt("0"));
  }
  static addIndexType(builder, indexTypeOffset) {
    builder.addFieldOffset(1, indexTypeOffset, 0);
  }
  static addIsOrdered(builder, isOrdered2) {
    builder.addFieldInt8(2, +isOrdered2, 0);
  }
  static addDictionaryKind(builder, dictionaryKind) {
    builder.addFieldInt16(3, dictionaryKind, DictionaryKind.DenseArray);
  }
  static endDictionaryEncoding(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
};

// ../core/node_modules/apache-arrow/fb/key-value.mjs
var KeyValue = class _KeyValue {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsKeyValue(bb2, obj) {
    return (obj || new _KeyValue()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsKeyValue(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _KeyValue()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  key(optionalEncoding) {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.__string(this.bb_pos + offset2, optionalEncoding) : null;
  }
  value(optionalEncoding) {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? this.bb.__string(this.bb_pos + offset2, optionalEncoding) : null;
  }
  static startKeyValue(builder) {
    builder.startObject(2);
  }
  static addKey(builder, keyOffset) {
    builder.addFieldOffset(0, keyOffset, 0);
  }
  static addValue(builder, valueOffset) {
    builder.addFieldOffset(1, valueOffset, 0);
  }
  static endKeyValue(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createKeyValue(builder, keyOffset, valueOffset) {
    _KeyValue.startKeyValue(builder);
    _KeyValue.addKey(builder, keyOffset);
    _KeyValue.addValue(builder, valueOffset);
    return _KeyValue.endKeyValue(builder);
  }
};

// ../core/node_modules/apache-arrow/fb/binary.mjs
var Binary = class _Binary {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsBinary(bb2, obj) {
    return (obj || new _Binary()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsBinary(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Binary()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static startBinary(builder) {
    builder.startObject(0);
  }
  static endBinary(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createBinary(builder) {
    _Binary.startBinary(builder);
    return _Binary.endBinary(builder);
  }
};

// ../core/node_modules/apache-arrow/fb/bool.mjs
var Bool = class _Bool {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsBool(bb2, obj) {
    return (obj || new _Bool()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsBool(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Bool()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static startBool(builder) {
    builder.startObject(0);
  }
  static endBool(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createBool(builder) {
    _Bool.startBool(builder);
    return _Bool.endBool(builder);
  }
};

// ../core/node_modules/apache-arrow/fb/date.mjs
var Date2 = class _Date {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsDate(bb2, obj) {
    return (obj || new _Date()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsDate(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Date()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  unit() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : DateUnit.MILLISECOND;
  }
  static startDate(builder) {
    builder.startObject(1);
  }
  static addUnit(builder, unit3) {
    builder.addFieldInt16(0, unit3, DateUnit.MILLISECOND);
  }
  static endDate(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createDate(builder, unit3) {
    _Date.startDate(builder);
    _Date.addUnit(builder, unit3);
    return _Date.endDate(builder);
  }
};

// ../core/node_modules/apache-arrow/fb/decimal.mjs
var Decimal = class _Decimal {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsDecimal(bb2, obj) {
    return (obj || new _Decimal()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsDecimal(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Decimal()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  /**
   * Total number of decimal digits
   */
  precision() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 0;
  }
  /**
   * Number of digits after the decimal point "."
   */
  scale() {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 0;
  }
  /**
   * Number of bits per value. The only accepted widths are 128 and 256.
   * We use bitWidth for consistency with Int::bitWidth.
   */
  bitWidth() {
    const offset2 = this.bb.__offset(this.bb_pos, 8);
    return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 128;
  }
  static startDecimal(builder) {
    builder.startObject(3);
  }
  static addPrecision(builder, precision) {
    builder.addFieldInt32(0, precision, 0);
  }
  static addScale(builder, scale3) {
    builder.addFieldInt32(1, scale3, 0);
  }
  static addBitWidth(builder, bitWidth) {
    builder.addFieldInt32(2, bitWidth, 128);
  }
  static endDecimal(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createDecimal(builder, precision, scale3, bitWidth) {
    _Decimal.startDecimal(builder);
    _Decimal.addPrecision(builder, precision);
    _Decimal.addScale(builder, scale3);
    _Decimal.addBitWidth(builder, bitWidth);
    return _Decimal.endDecimal(builder);
  }
};

// ../core/node_modules/apache-arrow/fb/duration.mjs
var Duration = class _Duration {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsDuration(bb2, obj) {
    return (obj || new _Duration()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsDuration(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Duration()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  unit() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : TimeUnit.MILLISECOND;
  }
  static startDuration(builder) {
    builder.startObject(1);
  }
  static addUnit(builder, unit3) {
    builder.addFieldInt16(0, unit3, TimeUnit.MILLISECOND);
  }
  static endDuration(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createDuration(builder, unit3) {
    _Duration.startDuration(builder);
    _Duration.addUnit(builder, unit3);
    return _Duration.endDuration(builder);
  }
};

// ../core/node_modules/apache-arrow/fb/fixed-size-binary.mjs
var FixedSizeBinary = class _FixedSizeBinary {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsFixedSizeBinary(bb2, obj) {
    return (obj || new _FixedSizeBinary()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsFixedSizeBinary(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _FixedSizeBinary()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  /**
   * Number of bytes per value
   */
  byteWidth() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 0;
  }
  static startFixedSizeBinary(builder) {
    builder.startObject(1);
  }
  static addByteWidth(builder, byteWidth) {
    builder.addFieldInt32(0, byteWidth, 0);
  }
  static endFixedSizeBinary(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createFixedSizeBinary(builder, byteWidth) {
    _FixedSizeBinary.startFixedSizeBinary(builder);
    _FixedSizeBinary.addByteWidth(builder, byteWidth);
    return _FixedSizeBinary.endFixedSizeBinary(builder);
  }
};

// ../core/node_modules/apache-arrow/fb/fixed-size-list.mjs
var FixedSizeList = class _FixedSizeList {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsFixedSizeList(bb2, obj) {
    return (obj || new _FixedSizeList()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsFixedSizeList(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _FixedSizeList()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  /**
   * Number of list items per value
   */
  listSize() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 0;
  }
  static startFixedSizeList(builder) {
    builder.startObject(1);
  }
  static addListSize(builder, listSize) {
    builder.addFieldInt32(0, listSize, 0);
  }
  static endFixedSizeList(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createFixedSizeList(builder, listSize) {
    _FixedSizeList.startFixedSizeList(builder);
    _FixedSizeList.addListSize(builder, listSize);
    return _FixedSizeList.endFixedSizeList(builder);
  }
};

// ../core/node_modules/apache-arrow/fb/floating-point.mjs
var FloatingPoint = class _FloatingPoint {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsFloatingPoint(bb2, obj) {
    return (obj || new _FloatingPoint()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsFloatingPoint(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _FloatingPoint()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  precision() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : Precision.HALF;
  }
  static startFloatingPoint(builder) {
    builder.startObject(1);
  }
  static addPrecision(builder, precision) {
    builder.addFieldInt16(0, precision, Precision.HALF);
  }
  static endFloatingPoint(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createFloatingPoint(builder, precision) {
    _FloatingPoint.startFloatingPoint(builder);
    _FloatingPoint.addPrecision(builder, precision);
    return _FloatingPoint.endFloatingPoint(builder);
  }
};

// ../core/node_modules/apache-arrow/fb/interval.mjs
var Interval = class _Interval {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsInterval(bb2, obj) {
    return (obj || new _Interval()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsInterval(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Interval()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  unit() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : IntervalUnit.YEAR_MONTH;
  }
  static startInterval(builder) {
    builder.startObject(1);
  }
  static addUnit(builder, unit3) {
    builder.addFieldInt16(0, unit3, IntervalUnit.YEAR_MONTH);
  }
  static endInterval(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createInterval(builder, unit3) {
    _Interval.startInterval(builder);
    _Interval.addUnit(builder, unit3);
    return _Interval.endInterval(builder);
  }
};

// ../core/node_modules/apache-arrow/fb/large-binary.mjs
var LargeBinary = class _LargeBinary {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsLargeBinary(bb2, obj) {
    return (obj || new _LargeBinary()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsLargeBinary(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _LargeBinary()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static startLargeBinary(builder) {
    builder.startObject(0);
  }
  static endLargeBinary(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createLargeBinary(builder) {
    _LargeBinary.startLargeBinary(builder);
    return _LargeBinary.endLargeBinary(builder);
  }
};

// ../core/node_modules/apache-arrow/fb/large-utf8.mjs
var LargeUtf8 = class _LargeUtf8 {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsLargeUtf8(bb2, obj) {
    return (obj || new _LargeUtf8()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsLargeUtf8(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _LargeUtf8()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static startLargeUtf8(builder) {
    builder.startObject(0);
  }
  static endLargeUtf8(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createLargeUtf8(builder) {
    _LargeUtf8.startLargeUtf8(builder);
    return _LargeUtf8.endLargeUtf8(builder);
  }
};

// ../core/node_modules/apache-arrow/fb/list.mjs
var List = class _List {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsList(bb2, obj) {
    return (obj || new _List()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsList(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _List()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static startList(builder) {
    builder.startObject(0);
  }
  static endList(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createList(builder) {
    _List.startList(builder);
    return _List.endList(builder);
  }
};

// ../core/node_modules/apache-arrow/fb/map.mjs
var Map2 = class _Map {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsMap(bb2, obj) {
    return (obj || new _Map()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsMap(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Map()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  /**
   * Set to true if the keys within each value are sorted
   */
  keysSorted() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? !!this.bb.readInt8(this.bb_pos + offset2) : false;
  }
  static startMap(builder) {
    builder.startObject(1);
  }
  static addKeysSorted(builder, keysSorted) {
    builder.addFieldInt8(0, +keysSorted, 0);
  }
  static endMap(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createMap(builder, keysSorted) {
    _Map.startMap(builder);
    _Map.addKeysSorted(builder, keysSorted);
    return _Map.endMap(builder);
  }
};

// ../core/node_modules/apache-arrow/fb/null.mjs
var Null = class _Null {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsNull(bb2, obj) {
    return (obj || new _Null()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsNull(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Null()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static startNull(builder) {
    builder.startObject(0);
  }
  static endNull(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createNull(builder) {
    _Null.startNull(builder);
    return _Null.endNull(builder);
  }
};

// ../core/node_modules/apache-arrow/fb/struct-.mjs
var Struct_ = class _Struct_ {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsStruct_(bb2, obj) {
    return (obj || new _Struct_()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsStruct_(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Struct_()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static startStruct_(builder) {
    builder.startObject(0);
  }
  static endStruct_(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createStruct_(builder) {
    _Struct_.startStruct_(builder);
    return _Struct_.endStruct_(builder);
  }
};

// ../core/node_modules/apache-arrow/fb/time.mjs
var Time = class _Time {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsTime(bb2, obj) {
    return (obj || new _Time()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsTime(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Time()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  unit() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : TimeUnit.MILLISECOND;
  }
  bitWidth() {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 32;
  }
  static startTime(builder) {
    builder.startObject(2);
  }
  static addUnit(builder, unit3) {
    builder.addFieldInt16(0, unit3, TimeUnit.MILLISECOND);
  }
  static addBitWidth(builder, bitWidth) {
    builder.addFieldInt32(1, bitWidth, 32);
  }
  static endTime(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createTime(builder, unit3, bitWidth) {
    _Time.startTime(builder);
    _Time.addUnit(builder, unit3);
    _Time.addBitWidth(builder, bitWidth);
    return _Time.endTime(builder);
  }
};

// ../core/node_modules/apache-arrow/fb/timestamp.mjs
var Timestamp = class _Timestamp {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsTimestamp(bb2, obj) {
    return (obj || new _Timestamp()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsTimestamp(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Timestamp()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  unit() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : TimeUnit.SECOND;
  }
  timezone(optionalEncoding) {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? this.bb.__string(this.bb_pos + offset2, optionalEncoding) : null;
  }
  static startTimestamp(builder) {
    builder.startObject(2);
  }
  static addUnit(builder, unit3) {
    builder.addFieldInt16(0, unit3, TimeUnit.SECOND);
  }
  static addTimezone(builder, timezoneOffset) {
    builder.addFieldOffset(1, timezoneOffset, 0);
  }
  static endTimestamp(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createTimestamp(builder, unit3, timezoneOffset) {
    _Timestamp.startTimestamp(builder);
    _Timestamp.addUnit(builder, unit3);
    _Timestamp.addTimezone(builder, timezoneOffset);
    return _Timestamp.endTimestamp(builder);
  }
};

// ../core/node_modules/apache-arrow/fb/union.mjs
var Union = class _Union {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsUnion(bb2, obj) {
    return (obj || new _Union()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsUnion(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Union()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  mode() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : UnionMode.Sparse;
  }
  typeIds(index2) {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset2) + index2 * 4) : 0;
  }
  typeIdsLength() {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
  }
  typeIdsArray() {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset2), this.bb.__vector_len(this.bb_pos + offset2)) : null;
  }
  static startUnion(builder) {
    builder.startObject(2);
  }
  static addMode(builder, mode3) {
    builder.addFieldInt16(0, mode3, UnionMode.Sparse);
  }
  static addTypeIds(builder, typeIdsOffset) {
    builder.addFieldOffset(1, typeIdsOffset, 0);
  }
  static createTypeIdsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt32(data[i]);
    }
    return builder.endVector();
  }
  static startTypeIdsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static endUnion(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createUnion(builder, mode3, typeIdsOffset) {
    _Union.startUnion(builder);
    _Union.addMode(builder, mode3);
    _Union.addTypeIds(builder, typeIdsOffset);
    return _Union.endUnion(builder);
  }
};

// ../core/node_modules/apache-arrow/fb/utf8.mjs
var Utf8 = class _Utf8 {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsUtf8(bb2, obj) {
    return (obj || new _Utf8()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsUtf8(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Utf8()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static startUtf8(builder) {
    builder.startObject(0);
  }
  static endUtf8(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createUtf8(builder) {
    _Utf8.startUtf8(builder);
    return _Utf8.endUtf8(builder);
  }
};

// ../core/node_modules/apache-arrow/fb/type.mjs
var Type;
(function(Type5) {
  Type5[Type5["NONE"] = 0] = "NONE";
  Type5[Type5["Null"] = 1] = "Null";
  Type5[Type5["Int"] = 2] = "Int";
  Type5[Type5["FloatingPoint"] = 3] = "FloatingPoint";
  Type5[Type5["Binary"] = 4] = "Binary";
  Type5[Type5["Utf8"] = 5] = "Utf8";
  Type5[Type5["Bool"] = 6] = "Bool";
  Type5[Type5["Decimal"] = 7] = "Decimal";
  Type5[Type5["Date"] = 8] = "Date";
  Type5[Type5["Time"] = 9] = "Time";
  Type5[Type5["Timestamp"] = 10] = "Timestamp";
  Type5[Type5["Interval"] = 11] = "Interval";
  Type5[Type5["List"] = 12] = "List";
  Type5[Type5["Struct_"] = 13] = "Struct_";
  Type5[Type5["Union"] = 14] = "Union";
  Type5[Type5["FixedSizeBinary"] = 15] = "FixedSizeBinary";
  Type5[Type5["FixedSizeList"] = 16] = "FixedSizeList";
  Type5[Type5["Map"] = 17] = "Map";
  Type5[Type5["Duration"] = 18] = "Duration";
  Type5[Type5["LargeBinary"] = 19] = "LargeBinary";
  Type5[Type5["LargeUtf8"] = 20] = "LargeUtf8";
  Type5[Type5["LargeList"] = 21] = "LargeList";
  Type5[Type5["RunEndEncoded"] = 22] = "RunEndEncoded";
})(Type || (Type = {}));

// ../core/node_modules/apache-arrow/fb/field.mjs
var Field = class _Field {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsField(bb2, obj) {
    return (obj || new _Field()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsField(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Field()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  name(optionalEncoding) {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.__string(this.bb_pos + offset2, optionalEncoding) : null;
  }
  /**
   * Whether or not this field can contain nulls. Should be true in general.
   */
  nullable() {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? !!this.bb.readInt8(this.bb_pos + offset2) : false;
  }
  typeType() {
    const offset2 = this.bb.__offset(this.bb_pos, 8);
    return offset2 ? this.bb.readUint8(this.bb_pos + offset2) : Type.NONE;
  }
  /**
   * This is the type of the decoded value if the field is dictionary encoded.
   */
  type(obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 10);
    return offset2 ? this.bb.__union(obj, this.bb_pos + offset2) : null;
  }
  /**
   * Present only if the field is dictionary encoded.
   */
  dictionary(obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 12);
    return offset2 ? (obj || new DictionaryEncoding()).__init(this.bb.__indirect(this.bb_pos + offset2), this.bb) : null;
  }
  /**
   * children apply only to nested data types like Struct, List and Union. For
   * primitive types children will have length 0.
   */
  children(index2, obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 14);
    return offset2 ? (obj || new _Field()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset2) + index2 * 4), this.bb) : null;
  }
  childrenLength() {
    const offset2 = this.bb.__offset(this.bb_pos, 14);
    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
  }
  /**
   * User-defined metadata
   */
  customMetadata(index2, obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 16);
    return offset2 ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset2) + index2 * 4), this.bb) : null;
  }
  customMetadataLength() {
    const offset2 = this.bb.__offset(this.bb_pos, 16);
    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
  }
  static startField(builder) {
    builder.startObject(7);
  }
  static addName(builder, nameOffset) {
    builder.addFieldOffset(0, nameOffset, 0);
  }
  static addNullable(builder, nullable) {
    builder.addFieldInt8(1, +nullable, 0);
  }
  static addTypeType(builder, typeType) {
    builder.addFieldInt8(2, typeType, Type.NONE);
  }
  static addType(builder, typeOffset) {
    builder.addFieldOffset(3, typeOffset, 0);
  }
  static addDictionary(builder, dictionaryOffset) {
    builder.addFieldOffset(4, dictionaryOffset, 0);
  }
  static addChildren(builder, childrenOffset) {
    builder.addFieldOffset(5, childrenOffset, 0);
  }
  static createChildrenVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startChildrenVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addCustomMetadata(builder, customMetadataOffset) {
    builder.addFieldOffset(6, customMetadataOffset, 0);
  }
  static createCustomMetadataVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startCustomMetadataVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static endField(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
};

// ../core/node_modules/apache-arrow/fb/schema.mjs
var Schema = class _Schema {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsSchema(bb2, obj) {
    return (obj || new _Schema()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsSchema(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Schema()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  /**
   * endianness of the buffer
   * it is Little Endian by default
   * if endianness doesn't match the underlying system then the vectors need to be converted
   */
  endianness() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : Endianness.Little;
  }
  fields(index2, obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? (obj || new Field()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset2) + index2 * 4), this.bb) : null;
  }
  fieldsLength() {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
  }
  customMetadata(index2, obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 8);
    return offset2 ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset2) + index2 * 4), this.bb) : null;
  }
  customMetadataLength() {
    const offset2 = this.bb.__offset(this.bb_pos, 8);
    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
  }
  /**
   * Features used in the stream/file.
   */
  features(index2) {
    const offset2 = this.bb.__offset(this.bb_pos, 10);
    return offset2 ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset2) + index2 * 8) : BigInt(0);
  }
  featuresLength() {
    const offset2 = this.bb.__offset(this.bb_pos, 10);
    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
  }
  static startSchema(builder) {
    builder.startObject(4);
  }
  static addEndianness(builder, endianness) {
    builder.addFieldInt16(0, endianness, Endianness.Little);
  }
  static addFields(builder, fieldsOffset) {
    builder.addFieldOffset(1, fieldsOffset, 0);
  }
  static createFieldsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startFieldsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addCustomMetadata(builder, customMetadataOffset) {
    builder.addFieldOffset(2, customMetadataOffset, 0);
  }
  static createCustomMetadataVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startCustomMetadataVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addFeatures(builder, featuresOffset) {
    builder.addFieldOffset(3, featuresOffset, 0);
  }
  static createFeaturesVector(builder, data) {
    builder.startVector(8, data.length, 8);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt64(data[i]);
    }
    return builder.endVector();
  }
  static startFeaturesVector(builder, numElems) {
    builder.startVector(8, numElems, 8);
  }
  static endSchema(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static finishSchemaBuffer(builder, offset2) {
    builder.finish(offset2);
  }
  static finishSizePrefixedSchemaBuffer(builder, offset2) {
    builder.finish(offset2, void 0, true);
  }
  static createSchema(builder, endianness, fieldsOffset, customMetadataOffset, featuresOffset) {
    _Schema.startSchema(builder);
    _Schema.addEndianness(builder, endianness);
    _Schema.addFields(builder, fieldsOffset);
    _Schema.addCustomMetadata(builder, customMetadataOffset);
    _Schema.addFeatures(builder, featuresOffset);
    return _Schema.endSchema(builder);
  }
};

// ../core/node_modules/apache-arrow/fb/message-header.mjs
var MessageHeader;
(function(MessageHeader4) {
  MessageHeader4[MessageHeader4["NONE"] = 0] = "NONE";
  MessageHeader4[MessageHeader4["Schema"] = 1] = "Schema";
  MessageHeader4[MessageHeader4["DictionaryBatch"] = 2] = "DictionaryBatch";
  MessageHeader4[MessageHeader4["RecordBatch"] = 3] = "RecordBatch";
  MessageHeader4[MessageHeader4["Tensor"] = 4] = "Tensor";
  MessageHeader4[MessageHeader4["SparseTensor"] = 5] = "SparseTensor";
})(MessageHeader || (MessageHeader = {}));

// ../core/node_modules/apache-arrow/enum.mjs
var Type2;
(function(Type5) {
  Type5[Type5["NONE"] = 0] = "NONE";
  Type5[Type5["Null"] = 1] = "Null";
  Type5[Type5["Int"] = 2] = "Int";
  Type5[Type5["Float"] = 3] = "Float";
  Type5[Type5["Binary"] = 4] = "Binary";
  Type5[Type5["Utf8"] = 5] = "Utf8";
  Type5[Type5["Bool"] = 6] = "Bool";
  Type5[Type5["Decimal"] = 7] = "Decimal";
  Type5[Type5["Date"] = 8] = "Date";
  Type5[Type5["Time"] = 9] = "Time";
  Type5[Type5["Timestamp"] = 10] = "Timestamp";
  Type5[Type5["Interval"] = 11] = "Interval";
  Type5[Type5["List"] = 12] = "List";
  Type5[Type5["Struct"] = 13] = "Struct";
  Type5[Type5["Union"] = 14] = "Union";
  Type5[Type5["FixedSizeBinary"] = 15] = "FixedSizeBinary";
  Type5[Type5["FixedSizeList"] = 16] = "FixedSizeList";
  Type5[Type5["Map"] = 17] = "Map";
  Type5[Type5["Duration"] = 18] = "Duration";
  Type5[Type5["LargeBinary"] = 19] = "LargeBinary";
  Type5[Type5["LargeUtf8"] = 20] = "LargeUtf8";
  Type5[Type5["Dictionary"] = -1] = "Dictionary";
  Type5[Type5["Int8"] = -2] = "Int8";
  Type5[Type5["Int16"] = -3] = "Int16";
  Type5[Type5["Int32"] = -4] = "Int32";
  Type5[Type5["Int64"] = -5] = "Int64";
  Type5[Type5["Uint8"] = -6] = "Uint8";
  Type5[Type5["Uint16"] = -7] = "Uint16";
  Type5[Type5["Uint32"] = -8] = "Uint32";
  Type5[Type5["Uint64"] = -9] = "Uint64";
  Type5[Type5["Float16"] = -10] = "Float16";
  Type5[Type5["Float32"] = -11] = "Float32";
  Type5[Type5["Float64"] = -12] = "Float64";
  Type5[Type5["DateDay"] = -13] = "DateDay";
  Type5[Type5["DateMillisecond"] = -14] = "DateMillisecond";
  Type5[Type5["TimestampSecond"] = -15] = "TimestampSecond";
  Type5[Type5["TimestampMillisecond"] = -16] = "TimestampMillisecond";
  Type5[Type5["TimestampMicrosecond"] = -17] = "TimestampMicrosecond";
  Type5[Type5["TimestampNanosecond"] = -18] = "TimestampNanosecond";
  Type5[Type5["TimeSecond"] = -19] = "TimeSecond";
  Type5[Type5["TimeMillisecond"] = -20] = "TimeMillisecond";
  Type5[Type5["TimeMicrosecond"] = -21] = "TimeMicrosecond";
  Type5[Type5["TimeNanosecond"] = -22] = "TimeNanosecond";
  Type5[Type5["DenseUnion"] = -23] = "DenseUnion";
  Type5[Type5["SparseUnion"] = -24] = "SparseUnion";
  Type5[Type5["IntervalDayTime"] = -25] = "IntervalDayTime";
  Type5[Type5["IntervalYearMonth"] = -26] = "IntervalYearMonth";
  Type5[Type5["DurationSecond"] = -27] = "DurationSecond";
  Type5[Type5["DurationMillisecond"] = -28] = "DurationMillisecond";
  Type5[Type5["DurationMicrosecond"] = -29] = "DurationMicrosecond";
  Type5[Type5["DurationNanosecond"] = -30] = "DurationNanosecond";
})(Type2 || (Type2 = {}));
var BufferType;
(function(BufferType3) {
  BufferType3[BufferType3["OFFSET"] = 0] = "OFFSET";
  BufferType3[BufferType3["DATA"] = 1] = "DATA";
  BufferType3[BufferType3["VALIDITY"] = 2] = "VALIDITY";
  BufferType3[BufferType3["TYPE"] = 3] = "TYPE";
})(BufferType || (BufferType = {}));

// ../core/node_modules/apache-arrow/util/vector.mjs
var vector_exports = {};
__export(vector_exports, {
  clampIndex: () => clampIndex,
  clampRange: () => clampRange,
  createElementComparator: () => createElementComparator
});

// ../core/node_modules/apache-arrow/util/pretty.mjs
var pretty_exports = {};
__export(pretty_exports, {
  valueToString: () => valueToString
});
var undf = void 0;
function valueToString(x4) {
  if (x4 === null) {
    return "null";
  }
  if (x4 === undf) {
    return "undefined";
  }
  switch (typeof x4) {
    case "number":
      return `${x4}`;
    case "bigint":
      return `${x4}`;
    case "string":
      return `"${x4}"`;
  }
  if (typeof x4[Symbol.toPrimitive] === "function") {
    return x4[Symbol.toPrimitive]("string");
  }
  if (ArrayBuffer.isView(x4)) {
    if (x4 instanceof BigInt64Array || x4 instanceof BigUint64Array) {
      return `[${[...x4].map((x5) => valueToString(x5))}]`;
    }
    return `[${x4}]`;
  }
  return ArrayBuffer.isView(x4) ? `[${x4}]` : JSON.stringify(x4, (_2, y4) => typeof y4 === "bigint" ? `${y4}` : y4);
}

// ../core/node_modules/apache-arrow/util/bn.mjs
var bn_exports = {};
__export(bn_exports, {
  BN: () => BN,
  bigNumToBigInt: () => bigNumToBigInt,
  bigNumToString: () => bigNumToString,
  isArrowBigNumSymbol: () => isArrowBigNumSymbol
});
var isArrowBigNumSymbol = Symbol.for("isArrowBigNum");
function BigNum(x4, ...xs) {
  if (xs.length === 0) {
    return Object.setPrototypeOf(toArrayBufferView(this["TypedArray"], x4), this.constructor.prototype);
  }
  return Object.setPrototypeOf(new this["TypedArray"](x4, ...xs), this.constructor.prototype);
}
BigNum.prototype[isArrowBigNumSymbol] = true;
BigNum.prototype.toJSON = function() {
  return `"${bigNumToString(this)}"`;
};
BigNum.prototype.valueOf = function() {
  return bigNumToNumber(this);
};
BigNum.prototype.toString = function() {
  return bigNumToString(this);
};
BigNum.prototype[Symbol.toPrimitive] = function(hint = "default") {
  switch (hint) {
    case "number":
      return bigNumToNumber(this);
    case "string":
      return bigNumToString(this);
    case "default":
      return bigNumToBigInt(this);
  }
  return bigNumToString(this);
};
function SignedBigNum(...args) {
  return BigNum.apply(this, args);
}
function UnsignedBigNum(...args) {
  return BigNum.apply(this, args);
}
function DecimalBigNum(...args) {
  return BigNum.apply(this, args);
}
Object.setPrototypeOf(SignedBigNum.prototype, Object.create(Int32Array.prototype));
Object.setPrototypeOf(UnsignedBigNum.prototype, Object.create(Uint32Array.prototype));
Object.setPrototypeOf(DecimalBigNum.prototype, Object.create(Uint32Array.prototype));
Object.assign(SignedBigNum.prototype, BigNum.prototype, { "constructor": SignedBigNum, "signed": true, "TypedArray": Int32Array, "BigIntArray": BigInt64Array });
Object.assign(UnsignedBigNum.prototype, BigNum.prototype, { "constructor": UnsignedBigNum, "signed": false, "TypedArray": Uint32Array, "BigIntArray": BigUint64Array });
Object.assign(DecimalBigNum.prototype, BigNum.prototype, { "constructor": DecimalBigNum, "signed": true, "TypedArray": Uint32Array, "BigIntArray": BigUint64Array });
function bigNumToNumber(bn) {
  const { buffer, byteOffset, length: length4, "signed": signed } = bn;
  const words = new BigUint64Array(buffer, byteOffset, length4);
  const negative2 = signed && words.at(-1) & BigInt(1) << BigInt(63);
  let number7 = negative2 ? BigInt(1) : BigInt(0);
  let i = BigInt(0);
  if (!negative2) {
    for (const word of words) {
      number7 += word * (BigInt(1) << BigInt(32) * i++);
    }
  } else {
    for (const word of words) {
      number7 += ~word * (BigInt(1) << BigInt(32) * i++);
    }
    number7 *= BigInt(-1);
  }
  return number7;
}
var bigNumToString = (a3) => {
  if (a3.byteLength === 8) {
    const bigIntArray = new a3["BigIntArray"](a3.buffer, a3.byteOffset, 1);
    return `${bigIntArray[0]}`;
  }
  if (!a3["signed"]) {
    return unsignedBigNumToString(a3);
  }
  let array4 = new Uint16Array(a3.buffer, a3.byteOffset, a3.byteLength / 2);
  const highOrderWord = new Int16Array([array4.at(-1)])[0];
  if (highOrderWord >= 0) {
    return unsignedBigNumToString(a3);
  }
  array4 = array4.slice();
  let carry = 1;
  for (let i = 0; i < array4.length; i++) {
    const elem = array4[i];
    const updated = ~elem + carry;
    array4[i] = updated;
    carry &= elem === 0 ? 1 : 0;
  }
  const negated = unsignedBigNumToString(array4);
  return `-${negated}`;
};
var bigNumToBigInt = (a3) => {
  if (a3.byteLength === 8) {
    const bigIntArray = new a3["BigIntArray"](a3.buffer, a3.byteOffset, 1);
    return bigIntArray[0];
  } else {
    return bigNumToString(a3);
  }
};
function unsignedBigNumToString(a3) {
  let digits = "";
  const base64 = new Uint32Array(2);
  let base32 = new Uint16Array(a3.buffer, a3.byteOffset, a3.byteLength / 2);
  const checks = new Uint32Array((base32 = new Uint16Array(base32).reverse()).buffer);
  let i = -1;
  const n = base32.length - 1;
  do {
    for (base64[0] = base32[i = 0]; i < n; ) {
      base32[i++] = base64[1] = base64[0] / 10;
      base64[0] = (base64[0] - base64[1] * 10 << 16) + base32[i];
    }
    base32[i] = base64[1] = base64[0] / 10;
    base64[0] = base64[0] - base64[1] * 10;
    digits = `${base64[0]}${digits}`;
  } while (checks[0] || checks[1] || checks[2] || checks[3]);
  return digits !== null && digits !== void 0 ? digits : `0`;
}
var BN = class _BN {
  /** @nocollapse */
  static new(num, isSigned) {
    switch (isSigned) {
      case true:
        return new SignedBigNum(num);
      case false:
        return new UnsignedBigNum(num);
    }
    switch (num.constructor) {
      case Int8Array:
      case Int16Array:
      case Int32Array:
      case BigInt64Array:
        return new SignedBigNum(num);
    }
    if (num.byteLength === 16) {
      return new DecimalBigNum(num);
    }
    return new UnsignedBigNum(num);
  }
  /** @nocollapse */
  static signed(num) {
    return new SignedBigNum(num);
  }
  /** @nocollapse */
  static unsigned(num) {
    return new UnsignedBigNum(num);
  }
  /** @nocollapse */
  static decimal(num) {
    return new DecimalBigNum(num);
  }
  constructor(num, isSigned) {
    return _BN.new(num, isSigned);
  }
};

// ../core/node_modules/apache-arrow/util/bigint.mjs
function bigIntToNumber(number7) {
  if (typeof number7 === "bigint" && (number7 < Number.MIN_SAFE_INTEGER || number7 > Number.MAX_SAFE_INTEGER)) {
    throw new TypeError(`${number7} is not safe to convert to a number.`);
  }
  return Number(number7);
}

// ../core/node_modules/apache-arrow/type.mjs
var _a;
var _b;
var _c;
var _d;
var _e;
var _f;
var _g;
var _h;
var _j;
var _k;
var _l;
var _m;
var _o;
var _p;
var _q;
var _r;
var _s;
var _t;
var _u;
var _v;
var _w;
var _x;
var DataType = class _DataType {
  /** @nocollapse */
  static isNull(x4) {
    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type2.Null;
  }
  /** @nocollapse */
  static isInt(x4) {
    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type2.Int;
  }
  /** @nocollapse */
  static isFloat(x4) {
    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type2.Float;
  }
  /** @nocollapse */
  static isBinary(x4) {
    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type2.Binary;
  }
  /** @nocollapse */
  static isLargeBinary(x4) {
    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type2.LargeBinary;
  }
  /** @nocollapse */
  static isUtf8(x4) {
    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type2.Utf8;
  }
  /** @nocollapse */
  static isLargeUtf8(x4) {
    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type2.LargeUtf8;
  }
  /** @nocollapse */
  static isBool(x4) {
    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type2.Bool;
  }
  /** @nocollapse */
  static isDecimal(x4) {
    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type2.Decimal;
  }
  /** @nocollapse */
  static isDate(x4) {
    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type2.Date;
  }
  /** @nocollapse */
  static isTime(x4) {
    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type2.Time;
  }
  /** @nocollapse */
  static isTimestamp(x4) {
    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type2.Timestamp;
  }
  /** @nocollapse */
  static isInterval(x4) {
    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type2.Interval;
  }
  /** @nocollapse */
  static isDuration(x4) {
    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type2.Duration;
  }
  /** @nocollapse */
  static isList(x4) {
    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type2.List;
  }
  /** @nocollapse */
  static isStruct(x4) {
    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type2.Struct;
  }
  /** @nocollapse */
  static isUnion(x4) {
    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type2.Union;
  }
  /** @nocollapse */
  static isFixedSizeBinary(x4) {
    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type2.FixedSizeBinary;
  }
  /** @nocollapse */
  static isFixedSizeList(x4) {
    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type2.FixedSizeList;
  }
  /** @nocollapse */
  static isMap(x4) {
    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type2.Map;
  }
  /** @nocollapse */
  static isDictionary(x4) {
    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type2.Dictionary;
  }
  /** @nocollapse */
  static isDenseUnion(x4) {
    return _DataType.isUnion(x4) && x4.mode === UnionMode.Dense;
  }
  /** @nocollapse */
  static isSparseUnion(x4) {
    return _DataType.isUnion(x4) && x4.mode === UnionMode.Sparse;
  }
  constructor(typeId) {
    this.typeId = typeId;
  }
};
_a = Symbol.toStringTag;
DataType[_a] = ((proto) => {
  proto.children = null;
  proto.ArrayType = Array;
  proto.OffsetArrayType = Int32Array;
  return proto[Symbol.toStringTag] = "DataType";
})(DataType.prototype);
var Null2 = class extends DataType {
  constructor() {
    super(Type2.Null);
  }
  toString() {
    return `Null`;
  }
};
_b = Symbol.toStringTag;
Null2[_b] = ((proto) => proto[Symbol.toStringTag] = "Null")(Null2.prototype);
var Int_ = class extends DataType {
  constructor(isSigned, bitWidth) {
    super(Type2.Int);
    this.isSigned = isSigned;
    this.bitWidth = bitWidth;
  }
  get ArrayType() {
    switch (this.bitWidth) {
      case 8:
        return this.isSigned ? Int8Array : Uint8Array;
      case 16:
        return this.isSigned ? Int16Array : Uint16Array;
      case 32:
        return this.isSigned ? Int32Array : Uint32Array;
      case 64:
        return this.isSigned ? BigInt64Array : BigUint64Array;
    }
    throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
  }
  toString() {
    return `${this.isSigned ? `I` : `Ui`}nt${this.bitWidth}`;
  }
};
_c = Symbol.toStringTag;
Int_[_c] = ((proto) => {
  proto.isSigned = null;
  proto.bitWidth = null;
  return proto[Symbol.toStringTag] = "Int";
})(Int_.prototype);
var Int8 = class extends Int_ {
  constructor() {
    super(true, 8);
  }
  get ArrayType() {
    return Int8Array;
  }
};
var Int16 = class extends Int_ {
  constructor() {
    super(true, 16);
  }
  get ArrayType() {
    return Int16Array;
  }
};
var Int32 = class extends Int_ {
  constructor() {
    super(true, 32);
  }
  get ArrayType() {
    return Int32Array;
  }
};
var Int64 = class extends Int_ {
  constructor() {
    super(true, 64);
  }
  get ArrayType() {
    return BigInt64Array;
  }
};
var Uint8 = class extends Int_ {
  constructor() {
    super(false, 8);
  }
  get ArrayType() {
    return Uint8Array;
  }
};
var Uint16 = class extends Int_ {
  constructor() {
    super(false, 16);
  }
  get ArrayType() {
    return Uint16Array;
  }
};
var Uint32 = class extends Int_ {
  constructor() {
    super(false, 32);
  }
  get ArrayType() {
    return Uint32Array;
  }
};
var Uint64 = class extends Int_ {
  constructor() {
    super(false, 64);
  }
  get ArrayType() {
    return BigUint64Array;
  }
};
Object.defineProperty(Int8.prototype, "ArrayType", { value: Int8Array });
Object.defineProperty(Int16.prototype, "ArrayType", { value: Int16Array });
Object.defineProperty(Int32.prototype, "ArrayType", { value: Int32Array });
Object.defineProperty(Int64.prototype, "ArrayType", { value: BigInt64Array });
Object.defineProperty(Uint8.prototype, "ArrayType", { value: Uint8Array });
Object.defineProperty(Uint16.prototype, "ArrayType", { value: Uint16Array });
Object.defineProperty(Uint32.prototype, "ArrayType", { value: Uint32Array });
Object.defineProperty(Uint64.prototype, "ArrayType", { value: BigUint64Array });
var Float = class extends DataType {
  constructor(precision) {
    super(Type2.Float);
    this.precision = precision;
  }
  get ArrayType() {
    switch (this.precision) {
      case Precision.HALF:
        return Uint16Array;
      case Precision.SINGLE:
        return Float32Array;
      case Precision.DOUBLE:
        return Float64Array;
    }
    throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
  }
  toString() {
    return `Float${this.precision << 5 || 16}`;
  }
};
_d = Symbol.toStringTag;
Float[_d] = ((proto) => {
  proto.precision = null;
  return proto[Symbol.toStringTag] = "Float";
})(Float.prototype);
var Float16 = class extends Float {
  constructor() {
    super(Precision.HALF);
  }
};
var Float32 = class extends Float {
  constructor() {
    super(Precision.SINGLE);
  }
};
var Float64 = class extends Float {
  constructor() {
    super(Precision.DOUBLE);
  }
};
Object.defineProperty(Float16.prototype, "ArrayType", { value: Uint16Array });
Object.defineProperty(Float32.prototype, "ArrayType", { value: Float32Array });
Object.defineProperty(Float64.prototype, "ArrayType", { value: Float64Array });
var Binary2 = class extends DataType {
  constructor() {
    super(Type2.Binary);
  }
  toString() {
    return `Binary`;
  }
};
_e = Symbol.toStringTag;
Binary2[_e] = ((proto) => {
  proto.ArrayType = Uint8Array;
  return proto[Symbol.toStringTag] = "Binary";
})(Binary2.prototype);
var LargeBinary2 = class extends DataType {
  constructor() {
    super(Type2.LargeBinary);
  }
  toString() {
    return `LargeBinary`;
  }
};
_f = Symbol.toStringTag;
LargeBinary2[_f] = ((proto) => {
  proto.ArrayType = Uint8Array;
  proto.OffsetArrayType = BigInt64Array;
  return proto[Symbol.toStringTag] = "LargeBinary";
})(LargeBinary2.prototype);
var Utf82 = class extends DataType {
  constructor() {
    super(Type2.Utf8);
  }
  toString() {
    return `Utf8`;
  }
};
_g = Symbol.toStringTag;
Utf82[_g] = ((proto) => {
  proto.ArrayType = Uint8Array;
  return proto[Symbol.toStringTag] = "Utf8";
})(Utf82.prototype);
var LargeUtf82 = class extends DataType {
  constructor() {
    super(Type2.LargeUtf8);
  }
  toString() {
    return `LargeUtf8`;
  }
};
_h = Symbol.toStringTag;
LargeUtf82[_h] = ((proto) => {
  proto.ArrayType = Uint8Array;
  proto.OffsetArrayType = BigInt64Array;
  return proto[Symbol.toStringTag] = "LargeUtf8";
})(LargeUtf82.prototype);
var Bool2 = class extends DataType {
  constructor() {
    super(Type2.Bool);
  }
  toString() {
    return `Bool`;
  }
};
_j = Symbol.toStringTag;
Bool2[_j] = ((proto) => {
  proto.ArrayType = Uint8Array;
  return proto[Symbol.toStringTag] = "Bool";
})(Bool2.prototype);
var Decimal2 = class extends DataType {
  constructor(scale3, precision, bitWidth = 128) {
    super(Type2.Decimal);
    this.scale = scale3;
    this.precision = precision;
    this.bitWidth = bitWidth;
  }
  toString() {
    return `Decimal[${this.precision}e${this.scale > 0 ? `+` : ``}${this.scale}]`;
  }
};
_k = Symbol.toStringTag;
Decimal2[_k] = ((proto) => {
  proto.scale = null;
  proto.precision = null;
  proto.ArrayType = Uint32Array;
  return proto[Symbol.toStringTag] = "Decimal";
})(Decimal2.prototype);
var Date_ = class extends DataType {
  constructor(unit3) {
    super(Type2.Date);
    this.unit = unit3;
  }
  toString() {
    return `Date${(this.unit + 1) * 32}<${DateUnit[this.unit]}>`;
  }
};
_l = Symbol.toStringTag;
Date_[_l] = ((proto) => {
  proto.unit = null;
  proto.ArrayType = Int32Array;
  return proto[Symbol.toStringTag] = "Date";
})(Date_.prototype);
var Time_ = class extends DataType {
  constructor(unit3, bitWidth) {
    super(Type2.Time);
    this.unit = unit3;
    this.bitWidth = bitWidth;
  }
  toString() {
    return `Time${this.bitWidth}<${TimeUnit[this.unit]}>`;
  }
  get ArrayType() {
    switch (this.bitWidth) {
      case 32:
        return Int32Array;
      case 64:
        return BigInt64Array;
    }
    throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
  }
};
_m = Symbol.toStringTag;
Time_[_m] = ((proto) => {
  proto.unit = null;
  proto.bitWidth = null;
  return proto[Symbol.toStringTag] = "Time";
})(Time_.prototype);
var Timestamp_ = class extends DataType {
  constructor(unit3, timezone) {
    super(Type2.Timestamp);
    this.unit = unit3;
    this.timezone = timezone;
  }
  toString() {
    return `Timestamp<${TimeUnit[this.unit]}${this.timezone ? `, ${this.timezone}` : ``}>`;
  }
};
_o = Symbol.toStringTag;
Timestamp_[_o] = ((proto) => {
  proto.unit = null;
  proto.timezone = null;
  proto.ArrayType = Int32Array;
  return proto[Symbol.toStringTag] = "Timestamp";
})(Timestamp_.prototype);
var Interval_ = class extends DataType {
  constructor(unit3) {
    super(Type2.Interval);
    this.unit = unit3;
  }
  toString() {
    return `Interval<${IntervalUnit[this.unit]}>`;
  }
};
_p = Symbol.toStringTag;
Interval_[_p] = ((proto) => {
  proto.unit = null;
  proto.ArrayType = Int32Array;
  return proto[Symbol.toStringTag] = "Interval";
})(Interval_.prototype);
var Duration2 = class extends DataType {
  constructor(unit3) {
    super(Type2.Duration);
    this.unit = unit3;
  }
  toString() {
    return `Duration<${TimeUnit[this.unit]}>`;
  }
};
_q = Symbol.toStringTag;
Duration2[_q] = ((proto) => {
  proto.unit = null;
  proto.ArrayType = BigInt64Array;
  return proto[Symbol.toStringTag] = "Duration";
})(Duration2.prototype);
var List2 = class extends DataType {
  constructor(child) {
    super(Type2.List);
    this.children = [child];
  }
  toString() {
    return `List<${this.valueType}>`;
  }
  get valueType() {
    return this.children[0].type;
  }
  get valueField() {
    return this.children[0];
  }
  get ArrayType() {
    return this.valueType.ArrayType;
  }
};
_r = Symbol.toStringTag;
List2[_r] = ((proto) => {
  proto.children = null;
  return proto[Symbol.toStringTag] = "List";
})(List2.prototype);
var Struct = class extends DataType {
  constructor(children2) {
    super(Type2.Struct);
    this.children = children2;
  }
  toString() {
    return `Struct<{${this.children.map((f2) => `${f2.name}:${f2.type}`).join(`, `)}}>`;
  }
};
_s = Symbol.toStringTag;
Struct[_s] = ((proto) => {
  proto.children = null;
  return proto[Symbol.toStringTag] = "Struct";
})(Struct.prototype);
var Union_ = class extends DataType {
  constructor(mode3, typeIds, children2) {
    super(Type2.Union);
    this.mode = mode3;
    this.children = children2;
    this.typeIds = typeIds = Int32Array.from(typeIds);
    this.typeIdToChildIndex = typeIds.reduce((typeIdToChildIndex, typeId, idx) => (typeIdToChildIndex[typeId] = idx) && typeIdToChildIndex || typeIdToChildIndex, /* @__PURE__ */ Object.create(null));
  }
  toString() {
    return `${this[Symbol.toStringTag]}<${this.children.map((x4) => `${x4.type}`).join(` | `)}>`;
  }
};
_t = Symbol.toStringTag;
Union_[_t] = ((proto) => {
  proto.mode = null;
  proto.typeIds = null;
  proto.children = null;
  proto.typeIdToChildIndex = null;
  proto.ArrayType = Int8Array;
  return proto[Symbol.toStringTag] = "Union";
})(Union_.prototype);
var FixedSizeBinary2 = class extends DataType {
  constructor(byteWidth) {
    super(Type2.FixedSizeBinary);
    this.byteWidth = byteWidth;
  }
  toString() {
    return `FixedSizeBinary[${this.byteWidth}]`;
  }
};
_u = Symbol.toStringTag;
FixedSizeBinary2[_u] = ((proto) => {
  proto.byteWidth = null;
  proto.ArrayType = Uint8Array;
  return proto[Symbol.toStringTag] = "FixedSizeBinary";
})(FixedSizeBinary2.prototype);
var FixedSizeList2 = class extends DataType {
  constructor(listSize, child) {
    super(Type2.FixedSizeList);
    this.listSize = listSize;
    this.children = [child];
  }
  get valueType() {
    return this.children[0].type;
  }
  get valueField() {
    return this.children[0];
  }
  get ArrayType() {
    return this.valueType.ArrayType;
  }
  toString() {
    return `FixedSizeList[${this.listSize}]<${this.valueType}>`;
  }
};
_v = Symbol.toStringTag;
FixedSizeList2[_v] = ((proto) => {
  proto.children = null;
  proto.listSize = null;
  return proto[Symbol.toStringTag] = "FixedSizeList";
})(FixedSizeList2.prototype);
var Map_ = class extends DataType {
  constructor(entries, keysSorted = false) {
    var _y, _z, _0;
    super(Type2.Map);
    this.children = [entries];
    this.keysSorted = keysSorted;
    if (entries) {
      entries["name"] = "entries";
      if ((_y = entries === null || entries === void 0 ? void 0 : entries.type) === null || _y === void 0 ? void 0 : _y.children) {
        const key = (_z = entries === null || entries === void 0 ? void 0 : entries.type) === null || _z === void 0 ? void 0 : _z.children[0];
        if (key) {
          key["name"] = "key";
        }
        const val = (_0 = entries === null || entries === void 0 ? void 0 : entries.type) === null || _0 === void 0 ? void 0 : _0.children[1];
        if (val) {
          val["name"] = "value";
        }
      }
    }
  }
  get keyType() {
    return this.children[0].type.children[0].type;
  }
  get valueType() {
    return this.children[0].type.children[1].type;
  }
  get childType() {
    return this.children[0].type;
  }
  toString() {
    return `Map<{${this.children[0].type.children.map((f2) => `${f2.name}:${f2.type}`).join(`, `)}}>`;
  }
};
_w = Symbol.toStringTag;
Map_[_w] = ((proto) => {
  proto.children = null;
  proto.keysSorted = null;
  return proto[Symbol.toStringTag] = "Map_";
})(Map_.prototype);
var getId = /* @__PURE__ */ ((atomicDictionaryId) => () => ++atomicDictionaryId)(-1);
var Dictionary = class extends DataType {
  constructor(dictionary, indices, id2, isOrdered2) {
    super(Type2.Dictionary);
    this.indices = indices;
    this.dictionary = dictionary;
    this.isOrdered = isOrdered2 || false;
    this.id = id2 == null ? getId() : bigIntToNumber(id2);
  }
  get children() {
    return this.dictionary.children;
  }
  get valueType() {
    return this.dictionary;
  }
  get ArrayType() {
    return this.dictionary.ArrayType;
  }
  toString() {
    return `Dictionary<${this.indices}, ${this.dictionary}>`;
  }
};
_x = Symbol.toStringTag;
Dictionary[_x] = ((proto) => {
  proto.id = null;
  proto.indices = null;
  proto.isOrdered = null;
  proto.dictionary = null;
  return proto[Symbol.toStringTag] = "Dictionary";
})(Dictionary.prototype);
function strideForType(type2) {
  const t = type2;
  switch (type2.typeId) {
    case Type2.Decimal:
      return type2.bitWidth / 32;
    case Type2.Timestamp:
      return 2;
    case Type2.Date:
      return 1 + t.unit;
    case Type2.Interval:
      return 1 + t.unit;
    case Type2.FixedSizeList:
      return t.listSize;
    case Type2.FixedSizeBinary:
      return t.byteWidth;
    default:
      return 1;
  }
}

// ../core/node_modules/apache-arrow/visitor.mjs
var Visitor = class {
  visitMany(nodes, ...args) {
    return nodes.map((node, i) => this.visit(node, ...args.map((x4) => x4[i])));
  }
  visit(...args) {
    return this.getVisitFn(args[0], false).apply(this, args);
  }
  getVisitFn(node, throwIfNotFound = true) {
    return getVisitFn(this, node, throwIfNotFound);
  }
  getVisitFnByTypeId(typeId, throwIfNotFound = true) {
    return getVisitFnByTypeId(this, typeId, throwIfNotFound);
  }
  visitNull(_node, ..._args) {
    return null;
  }
  visitBool(_node, ..._args) {
    return null;
  }
  visitInt(_node, ..._args) {
    return null;
  }
  visitFloat(_node, ..._args) {
    return null;
  }
  visitUtf8(_node, ..._args) {
    return null;
  }
  visitLargeUtf8(_node, ..._args) {
    return null;
  }
  visitBinary(_node, ..._args) {
    return null;
  }
  visitLargeBinary(_node, ..._args) {
    return null;
  }
  visitFixedSizeBinary(_node, ..._args) {
    return null;
  }
  visitDate(_node, ..._args) {
    return null;
  }
  visitTimestamp(_node, ..._args) {
    return null;
  }
  visitTime(_node, ..._args) {
    return null;
  }
  visitDecimal(_node, ..._args) {
    return null;
  }
  visitList(_node, ..._args) {
    return null;
  }
  visitStruct(_node, ..._args) {
    return null;
  }
  visitUnion(_node, ..._args) {
    return null;
  }
  visitDictionary(_node, ..._args) {
    return null;
  }
  visitInterval(_node, ..._args) {
    return null;
  }
  visitDuration(_node, ..._args) {
    return null;
  }
  visitFixedSizeList(_node, ..._args) {
    return null;
  }
  visitMap(_node, ..._args) {
    return null;
  }
};
function getVisitFn(visitor, node, throwIfNotFound = true) {
  if (typeof node === "number") {
    return getVisitFnByTypeId(visitor, node, throwIfNotFound);
  }
  if (typeof node === "string" && node in Type2) {
    return getVisitFnByTypeId(visitor, Type2[node], throwIfNotFound);
  }
  if (node && node instanceof DataType) {
    return getVisitFnByTypeId(visitor, inferDType(node), throwIfNotFound);
  }
  if ((node === null || node === void 0 ? void 0 : node.type) && node.type instanceof DataType) {
    return getVisitFnByTypeId(visitor, inferDType(node.type), throwIfNotFound);
  }
  return getVisitFnByTypeId(visitor, Type2.NONE, throwIfNotFound);
}
function getVisitFnByTypeId(visitor, dtype, throwIfNotFound = true) {
  let fn = null;
  switch (dtype) {
    case Type2.Null:
      fn = visitor.visitNull;
      break;
    case Type2.Bool:
      fn = visitor.visitBool;
      break;
    case Type2.Int:
      fn = visitor.visitInt;
      break;
    case Type2.Int8:
      fn = visitor.visitInt8 || visitor.visitInt;
      break;
    case Type2.Int16:
      fn = visitor.visitInt16 || visitor.visitInt;
      break;
    case Type2.Int32:
      fn = visitor.visitInt32 || visitor.visitInt;
      break;
    case Type2.Int64:
      fn = visitor.visitInt64 || visitor.visitInt;
      break;
    case Type2.Uint8:
      fn = visitor.visitUint8 || visitor.visitInt;
      break;
    case Type2.Uint16:
      fn = visitor.visitUint16 || visitor.visitInt;
      break;
    case Type2.Uint32:
      fn = visitor.visitUint32 || visitor.visitInt;
      break;
    case Type2.Uint64:
      fn = visitor.visitUint64 || visitor.visitInt;
      break;
    case Type2.Float:
      fn = visitor.visitFloat;
      break;
    case Type2.Float16:
      fn = visitor.visitFloat16 || visitor.visitFloat;
      break;
    case Type2.Float32:
      fn = visitor.visitFloat32 || visitor.visitFloat;
      break;
    case Type2.Float64:
      fn = visitor.visitFloat64 || visitor.visitFloat;
      break;
    case Type2.Utf8:
      fn = visitor.visitUtf8;
      break;
    case Type2.LargeUtf8:
      fn = visitor.visitLargeUtf8;
      break;
    case Type2.Binary:
      fn = visitor.visitBinary;
      break;
    case Type2.LargeBinary:
      fn = visitor.visitLargeBinary;
      break;
    case Type2.FixedSizeBinary:
      fn = visitor.visitFixedSizeBinary;
      break;
    case Type2.Date:
      fn = visitor.visitDate;
      break;
    case Type2.DateDay:
      fn = visitor.visitDateDay || visitor.visitDate;
      break;
    case Type2.DateMillisecond:
      fn = visitor.visitDateMillisecond || visitor.visitDate;
      break;
    case Type2.Timestamp:
      fn = visitor.visitTimestamp;
      break;
    case Type2.TimestampSecond:
      fn = visitor.visitTimestampSecond || visitor.visitTimestamp;
      break;
    case Type2.TimestampMillisecond:
      fn = visitor.visitTimestampMillisecond || visitor.visitTimestamp;
      break;
    case Type2.TimestampMicrosecond:
      fn = visitor.visitTimestampMicrosecond || visitor.visitTimestamp;
      break;
    case Type2.TimestampNanosecond:
      fn = visitor.visitTimestampNanosecond || visitor.visitTimestamp;
      break;
    case Type2.Time:
      fn = visitor.visitTime;
      break;
    case Type2.TimeSecond:
      fn = visitor.visitTimeSecond || visitor.visitTime;
      break;
    case Type2.TimeMillisecond:
      fn = visitor.visitTimeMillisecond || visitor.visitTime;
      break;
    case Type2.TimeMicrosecond:
      fn = visitor.visitTimeMicrosecond || visitor.visitTime;
      break;
    case Type2.TimeNanosecond:
      fn = visitor.visitTimeNanosecond || visitor.visitTime;
      break;
    case Type2.Decimal:
      fn = visitor.visitDecimal;
      break;
    case Type2.List:
      fn = visitor.visitList;
      break;
    case Type2.Struct:
      fn = visitor.visitStruct;
      break;
    case Type2.Union:
      fn = visitor.visitUnion;
      break;
    case Type2.DenseUnion:
      fn = visitor.visitDenseUnion || visitor.visitUnion;
      break;
    case Type2.SparseUnion:
      fn = visitor.visitSparseUnion || visitor.visitUnion;
      break;
    case Type2.Dictionary:
      fn = visitor.visitDictionary;
      break;
    case Type2.Interval:
      fn = visitor.visitInterval;
      break;
    case Type2.IntervalDayTime:
      fn = visitor.visitIntervalDayTime || visitor.visitInterval;
      break;
    case Type2.IntervalYearMonth:
      fn = visitor.visitIntervalYearMonth || visitor.visitInterval;
      break;
    case Type2.Duration:
      fn = visitor.visitDuration;
      break;
    case Type2.DurationSecond:
      fn = visitor.visitDurationSecond || visitor.visitDuration;
      break;
    case Type2.DurationMillisecond:
      fn = visitor.visitDurationMillisecond || visitor.visitDuration;
      break;
    case Type2.DurationMicrosecond:
      fn = visitor.visitDurationMicrosecond || visitor.visitDuration;
      break;
    case Type2.DurationNanosecond:
      fn = visitor.visitDurationNanosecond || visitor.visitDuration;
      break;
    case Type2.FixedSizeList:
      fn = visitor.visitFixedSizeList;
      break;
    case Type2.Map:
      fn = visitor.visitMap;
      break;
  }
  if (typeof fn === "function")
    return fn;
  if (!throwIfNotFound)
    return () => null;
  throw new Error(`Unrecognized type '${Type2[dtype]}'`);
}
function inferDType(type2) {
  switch (type2.typeId) {
    case Type2.Null:
      return Type2.Null;
    case Type2.Int: {
      const { bitWidth, isSigned } = type2;
      switch (bitWidth) {
        case 8:
          return isSigned ? Type2.Int8 : Type2.Uint8;
        case 16:
          return isSigned ? Type2.Int16 : Type2.Uint16;
        case 32:
          return isSigned ? Type2.Int32 : Type2.Uint32;
        case 64:
          return isSigned ? Type2.Int64 : Type2.Uint64;
      }
      return Type2.Int;
    }
    case Type2.Float:
      switch (type2.precision) {
        case Precision.HALF:
          return Type2.Float16;
        case Precision.SINGLE:
          return Type2.Float32;
        case Precision.DOUBLE:
          return Type2.Float64;
      }
      return Type2.Float;
    case Type2.Binary:
      return Type2.Binary;
    case Type2.LargeBinary:
      return Type2.LargeBinary;
    case Type2.Utf8:
      return Type2.Utf8;
    case Type2.LargeUtf8:
      return Type2.LargeUtf8;
    case Type2.Bool:
      return Type2.Bool;
    case Type2.Decimal:
      return Type2.Decimal;
    case Type2.Time:
      switch (type2.unit) {
        case TimeUnit.SECOND:
          return Type2.TimeSecond;
        case TimeUnit.MILLISECOND:
          return Type2.TimeMillisecond;
        case TimeUnit.MICROSECOND:
          return Type2.TimeMicrosecond;
        case TimeUnit.NANOSECOND:
          return Type2.TimeNanosecond;
      }
      return Type2.Time;
    case Type2.Timestamp:
      switch (type2.unit) {
        case TimeUnit.SECOND:
          return Type2.TimestampSecond;
        case TimeUnit.MILLISECOND:
          return Type2.TimestampMillisecond;
        case TimeUnit.MICROSECOND:
          return Type2.TimestampMicrosecond;
        case TimeUnit.NANOSECOND:
          return Type2.TimestampNanosecond;
      }
      return Type2.Timestamp;
    case Type2.Date:
      switch (type2.unit) {
        case DateUnit.DAY:
          return Type2.DateDay;
        case DateUnit.MILLISECOND:
          return Type2.DateMillisecond;
      }
      return Type2.Date;
    case Type2.Interval:
      switch (type2.unit) {
        case IntervalUnit.DAY_TIME:
          return Type2.IntervalDayTime;
        case IntervalUnit.YEAR_MONTH:
          return Type2.IntervalYearMonth;
      }
      return Type2.Interval;
    case Type2.Duration:
      switch (type2.unit) {
        case TimeUnit.SECOND:
          return Type2.DurationSecond;
        case TimeUnit.MILLISECOND:
          return Type2.DurationMillisecond;
        case TimeUnit.MICROSECOND:
          return Type2.DurationMicrosecond;
        case TimeUnit.NANOSECOND:
          return Type2.DurationNanosecond;
      }
      return Type2.Duration;
    case Type2.Map:
      return Type2.Map;
    case Type2.List:
      return Type2.List;
    case Type2.Struct:
      return Type2.Struct;
    case Type2.Union:
      switch (type2.mode) {
        case UnionMode.Dense:
          return Type2.DenseUnion;
        case UnionMode.Sparse:
          return Type2.SparseUnion;
      }
      return Type2.Union;
    case Type2.FixedSizeBinary:
      return Type2.FixedSizeBinary;
    case Type2.FixedSizeList:
      return Type2.FixedSizeList;
    case Type2.Dictionary:
      return Type2.Dictionary;
  }
  throw new Error(`Unrecognized type '${Type2[type2.typeId]}'`);
}
Visitor.prototype.visitInt8 = null;
Visitor.prototype.visitInt16 = null;
Visitor.prototype.visitInt32 = null;
Visitor.prototype.visitInt64 = null;
Visitor.prototype.visitUint8 = null;
Visitor.prototype.visitUint16 = null;
Visitor.prototype.visitUint32 = null;
Visitor.prototype.visitUint64 = null;
Visitor.prototype.visitFloat16 = null;
Visitor.prototype.visitFloat32 = null;
Visitor.prototype.visitFloat64 = null;
Visitor.prototype.visitDateDay = null;
Visitor.prototype.visitDateMillisecond = null;
Visitor.prototype.visitTimestampSecond = null;
Visitor.prototype.visitTimestampMillisecond = null;
Visitor.prototype.visitTimestampMicrosecond = null;
Visitor.prototype.visitTimestampNanosecond = null;
Visitor.prototype.visitTimeSecond = null;
Visitor.prototype.visitTimeMillisecond = null;
Visitor.prototype.visitTimeMicrosecond = null;
Visitor.prototype.visitTimeNanosecond = null;
Visitor.prototype.visitDenseUnion = null;
Visitor.prototype.visitSparseUnion = null;
Visitor.prototype.visitIntervalDayTime = null;
Visitor.prototype.visitIntervalYearMonth = null;
Visitor.prototype.visitDuration = null;
Visitor.prototype.visitDurationSecond = null;
Visitor.prototype.visitDurationMillisecond = null;
Visitor.prototype.visitDurationMicrosecond = null;
Visitor.prototype.visitDurationNanosecond = null;

// ../core/node_modules/apache-arrow/util/math.mjs
var math_exports = {};
__export(math_exports, {
  float64ToUint16: () => float64ToUint16,
  uint16ToFloat64: () => uint16ToFloat64
});
var f64 = new Float64Array(1);
var u32 = new Uint32Array(f64.buffer);
function uint16ToFloat64(h2) {
  const expo = (h2 & 31744) >> 10;
  const sigf = (h2 & 1023) / 1024;
  const sign3 = Math.pow(-1, (h2 & 32768) >> 15);
  switch (expo) {
    case 31:
      return sign3 * (sigf ? Number.NaN : 1 / 0);
    case 0:
      return sign3 * (sigf ? 6103515625e-14 * sigf : 0);
  }
  return sign3 * Math.pow(2, expo - 15) * (1 + sigf);
}
function float64ToUint16(d) {
  if (d !== d) {
    return 32256;
  }
  f64[0] = d;
  const sign3 = (u32[1] & 2147483648) >> 16 & 65535;
  let expo = u32[1] & 2146435072, sigf = 0;
  if (expo >= 1089470464) {
    if (u32[0] > 0) {
      expo = 31744;
    } else {
      expo = (expo & 2080374784) >> 16;
      sigf = (u32[1] & 1048575) >> 10;
    }
  } else if (expo <= 1056964608) {
    sigf = 1048576 + (u32[1] & 1048575);
    sigf = 1048576 + (sigf << (expo >> 20) - 998) >> 21;
    expo = 0;
  } else {
    expo = expo - 1056964608 >> 10;
    sigf = (u32[1] & 1048575) + 512 >> 10;
  }
  return sign3 | expo | sigf & 65535;
}

// ../core/node_modules/apache-arrow/visitor/set.mjs
var SetVisitor = class extends Visitor {
};
function wrapSet(fn) {
  return (data, _1, _2) => {
    if (data.setValid(_1, _2 != null)) {
      return fn(data, _1, _2);
    }
  };
}
var setEpochMsToDays = (data, index2, epochMs) => {
  data[index2] = Math.trunc(epochMs / 864e5);
};
var setEpochMsToMillisecondsLong = (data, index2, epochMs) => {
  data[index2] = Math.trunc(epochMs % 4294967296);
  data[index2 + 1] = Math.trunc(epochMs / 4294967296);
};
var setEpochMsToMicrosecondsLong = (data, index2, epochMs) => {
  data[index2] = Math.trunc(epochMs * 1e3 % 4294967296);
  data[index2 + 1] = Math.trunc(epochMs * 1e3 / 4294967296);
};
var setEpochMsToNanosecondsLong = (data, index2, epochMs) => {
  data[index2] = Math.trunc(epochMs * 1e6 % 4294967296);
  data[index2 + 1] = Math.trunc(epochMs * 1e6 / 4294967296);
};
var setVariableWidthBytes = (values2, valueOffsets, index2, value) => {
  if (index2 + 1 < valueOffsets.length) {
    const x4 = bigIntToNumber(valueOffsets[index2]);
    const y4 = bigIntToNumber(valueOffsets[index2 + 1]);
    values2.set(value.subarray(0, y4 - x4), x4);
  }
};
var setBool = ({ offset: offset2, values: values2 }, index2, val) => {
  const idx = offset2 + index2;
  val ? values2[idx >> 3] |= 1 << idx % 8 : values2[idx >> 3] &= ~(1 << idx % 8);
};
var setInt = ({ values: values2 }, index2, value) => {
  values2[index2] = value;
};
var setFloat = ({ values: values2 }, index2, value) => {
  values2[index2] = value;
};
var setFloat16 = ({ values: values2 }, index2, value) => {
  values2[index2] = float64ToUint16(value);
};
var setAnyFloat = (data, index2, value) => {
  switch (data.type.precision) {
    case Precision.HALF:
      return setFloat16(data, index2, value);
    case Precision.SINGLE:
    case Precision.DOUBLE:
      return setFloat(data, index2, value);
  }
};
var setDateDay = ({ values: values2 }, index2, value) => {
  setEpochMsToDays(values2, index2, value.valueOf());
};
var setDateMillisecond = ({ values: values2 }, index2, value) => {
  setEpochMsToMillisecondsLong(values2, index2 * 2, value.valueOf());
};
var setFixedSizeBinary = ({ stride, values: values2 }, index2, value) => {
  values2.set(value.subarray(0, stride), stride * index2);
};
var setBinary = ({ values: values2, valueOffsets }, index2, value) => setVariableWidthBytes(values2, valueOffsets, index2, value);
var setUtf8 = ({ values: values2, valueOffsets }, index2, value) => setVariableWidthBytes(values2, valueOffsets, index2, encodeUtf8(value));
var setDate = (data, index2, value) => {
  data.type.unit === DateUnit.DAY ? setDateDay(data, index2, value) : setDateMillisecond(data, index2, value);
};
var setTimestampSecond = ({ values: values2 }, index2, value) => setEpochMsToMillisecondsLong(values2, index2 * 2, value / 1e3);
var setTimestampMillisecond = ({ values: values2 }, index2, value) => setEpochMsToMillisecondsLong(values2, index2 * 2, value);
var setTimestampMicrosecond = ({ values: values2 }, index2, value) => setEpochMsToMicrosecondsLong(values2, index2 * 2, value);
var setTimestampNanosecond = ({ values: values2 }, index2, value) => setEpochMsToNanosecondsLong(values2, index2 * 2, value);
var setTimestamp = (data, index2, value) => {
  switch (data.type.unit) {
    case TimeUnit.SECOND:
      return setTimestampSecond(data, index2, value);
    case TimeUnit.MILLISECOND:
      return setTimestampMillisecond(data, index2, value);
    case TimeUnit.MICROSECOND:
      return setTimestampMicrosecond(data, index2, value);
    case TimeUnit.NANOSECOND:
      return setTimestampNanosecond(data, index2, value);
  }
};
var setTimeSecond = ({ values: values2 }, index2, value) => {
  values2[index2] = value;
};
var setTimeMillisecond = ({ values: values2 }, index2, value) => {
  values2[index2] = value;
};
var setTimeMicrosecond = ({ values: values2 }, index2, value) => {
  values2[index2] = value;
};
var setTimeNanosecond = ({ values: values2 }, index2, value) => {
  values2[index2] = value;
};
var setTime = (data, index2, value) => {
  switch (data.type.unit) {
    case TimeUnit.SECOND:
      return setTimeSecond(data, index2, value);
    case TimeUnit.MILLISECOND:
      return setTimeMillisecond(data, index2, value);
    case TimeUnit.MICROSECOND:
      return setTimeMicrosecond(data, index2, value);
    case TimeUnit.NANOSECOND:
      return setTimeNanosecond(data, index2, value);
  }
};
var setDecimal = ({ values: values2, stride }, index2, value) => {
  values2.set(value.subarray(0, stride), stride * index2);
};
var setList = (data, index2, value) => {
  const values2 = data.children[0];
  const valueOffsets = data.valueOffsets;
  const set3 = instance.getVisitFn(values2);
  if (Array.isArray(value)) {
    for (let idx = -1, itr = valueOffsets[index2], end = valueOffsets[index2 + 1]; itr < end; ) {
      set3(values2, itr++, value[++idx]);
    }
  } else {
    for (let idx = -1, itr = valueOffsets[index2], end = valueOffsets[index2 + 1]; itr < end; ) {
      set3(values2, itr++, value.get(++idx));
    }
  }
};
var setMap = (data, index2, value) => {
  const values2 = data.children[0];
  const { valueOffsets } = data;
  const set3 = instance.getVisitFn(values2);
  let { [index2]: idx, [index2 + 1]: end } = valueOffsets;
  const entries = value instanceof Map ? value.entries() : Object.entries(value);
  for (const val of entries) {
    set3(values2, idx, val);
    if (++idx >= end)
      break;
  }
};
var _setStructArrayValue = (o, v3) => (set3, c4, _2, i) => c4 && set3(c4, o, v3[i]);
var _setStructVectorValue = (o, v3) => (set3, c4, _2, i) => c4 && set3(c4, o, v3.get(i));
var _setStructMapValue = (o, v3) => (set3, c4, f2, _2) => c4 && set3(c4, o, v3.get(f2.name));
var _setStructObjectValue = (o, v3) => (set3, c4, f2, _2) => c4 && set3(c4, o, v3[f2.name]);
var setStruct = (data, index2, value) => {
  const childSetters = data.type.children.map((f2) => instance.getVisitFn(f2.type));
  const set3 = value instanceof Map ? _setStructMapValue(index2, value) : value instanceof Vector ? _setStructVectorValue(index2, value) : Array.isArray(value) ? _setStructArrayValue(index2, value) : _setStructObjectValue(index2, value);
  data.type.children.forEach((f2, i) => set3(childSetters[i], data.children[i], f2, i));
};
var setUnion = (data, index2, value) => {
  data.type.mode === UnionMode.Dense ? setDenseUnion(data, index2, value) : setSparseUnion(data, index2, value);
};
var setDenseUnion = (data, index2, value) => {
  const childIndex = data.type.typeIdToChildIndex[data.typeIds[index2]];
  const child = data.children[childIndex];
  instance.visit(child, data.valueOffsets[index2], value);
};
var setSparseUnion = (data, index2, value) => {
  const childIndex = data.type.typeIdToChildIndex[data.typeIds[index2]];
  const child = data.children[childIndex];
  instance.visit(child, index2, value);
};
var setDictionary = (data, index2, value) => {
  var _a9;
  (_a9 = data.dictionary) === null || _a9 === void 0 ? void 0 : _a9.set(data.values[index2], value);
};
var setIntervalValue = (data, index2, value) => {
  data.type.unit === IntervalUnit.DAY_TIME ? setIntervalDayTime(data, index2, value) : setIntervalYearMonth(data, index2, value);
};
var setIntervalDayTime = ({ values: values2 }, index2, value) => {
  values2.set(value.subarray(0, 2), 2 * index2);
};
var setIntervalYearMonth = ({ values: values2 }, index2, value) => {
  values2[index2] = value[0] * 12 + value[1] % 12;
};
var setDurationSecond = ({ values: values2 }, index2, value) => {
  values2[index2] = value;
};
var setDurationMillisecond = ({ values: values2 }, index2, value) => {
  values2[index2] = value;
};
var setDurationMicrosecond = ({ values: values2 }, index2, value) => {
  values2[index2] = value;
};
var setDurationNanosecond = ({ values: values2 }, index2, value) => {
  values2[index2] = value;
};
var setDuration = (data, index2, value) => {
  switch (data.type.unit) {
    case TimeUnit.SECOND:
      return setDurationSecond(data, index2, value);
    case TimeUnit.MILLISECOND:
      return setDurationMillisecond(data, index2, value);
    case TimeUnit.MICROSECOND:
      return setDurationMicrosecond(data, index2, value);
    case TimeUnit.NANOSECOND:
      return setDurationNanosecond(data, index2, value);
  }
};
var setFixedSizeList = (data, index2, value) => {
  const { stride } = data;
  const child = data.children[0];
  const set3 = instance.getVisitFn(child);
  if (Array.isArray(value)) {
    for (let idx = -1, offset2 = index2 * stride; ++idx < stride; ) {
      set3(child, offset2 + idx, value[idx]);
    }
  } else {
    for (let idx = -1, offset2 = index2 * stride; ++idx < stride; ) {
      set3(child, offset2 + idx, value.get(idx));
    }
  }
};
SetVisitor.prototype.visitBool = wrapSet(setBool);
SetVisitor.prototype.visitInt = wrapSet(setInt);
SetVisitor.prototype.visitInt8 = wrapSet(setInt);
SetVisitor.prototype.visitInt16 = wrapSet(setInt);
SetVisitor.prototype.visitInt32 = wrapSet(setInt);
SetVisitor.prototype.visitInt64 = wrapSet(setInt);
SetVisitor.prototype.visitUint8 = wrapSet(setInt);
SetVisitor.prototype.visitUint16 = wrapSet(setInt);
SetVisitor.prototype.visitUint32 = wrapSet(setInt);
SetVisitor.prototype.visitUint64 = wrapSet(setInt);
SetVisitor.prototype.visitFloat = wrapSet(setAnyFloat);
SetVisitor.prototype.visitFloat16 = wrapSet(setFloat16);
SetVisitor.prototype.visitFloat32 = wrapSet(setFloat);
SetVisitor.prototype.visitFloat64 = wrapSet(setFloat);
SetVisitor.prototype.visitUtf8 = wrapSet(setUtf8);
SetVisitor.prototype.visitLargeUtf8 = wrapSet(setUtf8);
SetVisitor.prototype.visitBinary = wrapSet(setBinary);
SetVisitor.prototype.visitLargeBinary = wrapSet(setBinary);
SetVisitor.prototype.visitFixedSizeBinary = wrapSet(setFixedSizeBinary);
SetVisitor.prototype.visitDate = wrapSet(setDate);
SetVisitor.prototype.visitDateDay = wrapSet(setDateDay);
SetVisitor.prototype.visitDateMillisecond = wrapSet(setDateMillisecond);
SetVisitor.prototype.visitTimestamp = wrapSet(setTimestamp);
SetVisitor.prototype.visitTimestampSecond = wrapSet(setTimestampSecond);
SetVisitor.prototype.visitTimestampMillisecond = wrapSet(setTimestampMillisecond);
SetVisitor.prototype.visitTimestampMicrosecond = wrapSet(setTimestampMicrosecond);
SetVisitor.prototype.visitTimestampNanosecond = wrapSet(setTimestampNanosecond);
SetVisitor.prototype.visitTime = wrapSet(setTime);
SetVisitor.prototype.visitTimeSecond = wrapSet(setTimeSecond);
SetVisitor.prototype.visitTimeMillisecond = wrapSet(setTimeMillisecond);
SetVisitor.prototype.visitTimeMicrosecond = wrapSet(setTimeMicrosecond);
SetVisitor.prototype.visitTimeNanosecond = wrapSet(setTimeNanosecond);
SetVisitor.prototype.visitDecimal = wrapSet(setDecimal);
SetVisitor.prototype.visitList = wrapSet(setList);
SetVisitor.prototype.visitStruct = wrapSet(setStruct);
SetVisitor.prototype.visitUnion = wrapSet(setUnion);
SetVisitor.prototype.visitDenseUnion = wrapSet(setDenseUnion);
SetVisitor.prototype.visitSparseUnion = wrapSet(setSparseUnion);
SetVisitor.prototype.visitDictionary = wrapSet(setDictionary);
SetVisitor.prototype.visitInterval = wrapSet(setIntervalValue);
SetVisitor.prototype.visitIntervalDayTime = wrapSet(setIntervalDayTime);
SetVisitor.prototype.visitIntervalYearMonth = wrapSet(setIntervalYearMonth);
SetVisitor.prototype.visitDuration = wrapSet(setDuration);
SetVisitor.prototype.visitDurationSecond = wrapSet(setDurationSecond);
SetVisitor.prototype.visitDurationMillisecond = wrapSet(setDurationMillisecond);
SetVisitor.prototype.visitDurationMicrosecond = wrapSet(setDurationMicrosecond);
SetVisitor.prototype.visitDurationNanosecond = wrapSet(setDurationNanosecond);
SetVisitor.prototype.visitFixedSizeList = wrapSet(setFixedSizeList);
SetVisitor.prototype.visitMap = wrapSet(setMap);
var instance = new SetVisitor();

// ../core/node_modules/apache-arrow/row/struct.mjs
var kParent = Symbol.for("parent");
var kRowIndex = Symbol.for("rowIndex");
var StructRow = class {
  constructor(parent, rowIndex) {
    this[kParent] = parent;
    this[kRowIndex] = rowIndex;
    return new Proxy(this, new StructRowProxyHandler());
  }
  toArray() {
    return Object.values(this.toJSON());
  }
  toJSON() {
    const i = this[kRowIndex];
    const parent = this[kParent];
    const keys = parent.type.children;
    const json = {};
    for (let j2 = -1, n = keys.length; ++j2 < n; ) {
      json[keys[j2].name] = instance2.visit(parent.children[j2], i);
    }
    return json;
  }
  toString() {
    return `{${[...this].map(([key, val]) => `${valueToString(key)}: ${valueToString(val)}`).join(", ")}}`;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.toString();
  }
  [Symbol.iterator]() {
    return new StructRowIterator(this[kParent], this[kRowIndex]);
  }
};
var StructRowIterator = class {
  constructor(data, rowIndex) {
    this.childIndex = 0;
    this.children = data.children;
    this.rowIndex = rowIndex;
    this.childFields = data.type.children;
    this.numChildren = this.childFields.length;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const i = this.childIndex;
    if (i < this.numChildren) {
      this.childIndex = i + 1;
      return {
        done: false,
        value: [
          this.childFields[i].name,
          instance2.visit(this.children[i], this.rowIndex)
        ]
      };
    }
    return { done: true, value: null };
  }
};
Object.defineProperties(StructRow.prototype, {
  [Symbol.toStringTag]: { enumerable: false, configurable: false, value: "Row" },
  [kParent]: { writable: true, enumerable: false, configurable: false, value: null },
  [kRowIndex]: { writable: true, enumerable: false, configurable: false, value: -1 }
});
var StructRowProxyHandler = class {
  isExtensible() {
    return false;
  }
  deleteProperty() {
    return false;
  }
  preventExtensions() {
    return true;
  }
  ownKeys(row) {
    return row[kParent].type.children.map((f2) => f2.name);
  }
  has(row, key) {
    return row[kParent].type.children.findIndex((f2) => f2.name === key) !== -1;
  }
  getOwnPropertyDescriptor(row, key) {
    if (row[kParent].type.children.findIndex((f2) => f2.name === key) !== -1) {
      return { writable: true, enumerable: true, configurable: true };
    }
    return;
  }
  get(row, key) {
    if (Reflect.has(row, key)) {
      return row[key];
    }
    const idx = row[kParent].type.children.findIndex((f2) => f2.name === key);
    if (idx !== -1) {
      const val = instance2.visit(row[kParent].children[idx], row[kRowIndex]);
      Reflect.set(row, key, val);
      return val;
    }
  }
  set(row, key, val) {
    const idx = row[kParent].type.children.findIndex((f2) => f2.name === key);
    if (idx !== -1) {
      instance.visit(row[kParent].children[idx], row[kRowIndex], val);
      return Reflect.set(row, key, val);
    } else if (Reflect.has(row, key) || typeof key === "symbol") {
      return Reflect.set(row, key, val);
    }
    return false;
  }
};

// ../core/node_modules/apache-arrow/visitor/get.mjs
var GetVisitor = class extends Visitor {
};
function wrapGet(fn) {
  return (data, _1) => data.getValid(_1) ? fn(data, _1) : null;
}
var epochDaysToMs = (data, index2) => 864e5 * data[index2];
var epochMillisecondsLongToMs = (data, index2) => 4294967296 * data[index2 + 1] + (data[index2] >>> 0);
var epochMicrosecondsLongToMs = (data, index2) => 4294967296 * (data[index2 + 1] / 1e3) + (data[index2] >>> 0) / 1e3;
var epochNanosecondsLongToMs = (data, index2) => 4294967296 * (data[index2 + 1] / 1e6) + (data[index2] >>> 0) / 1e6;
var epochMillisecondsToDate = (epochMs) => new Date(epochMs);
var epochDaysToDate = (data, index2) => epochMillisecondsToDate(epochDaysToMs(data, index2));
var epochMillisecondsLongToDate = (data, index2) => epochMillisecondsToDate(epochMillisecondsLongToMs(data, index2));
var getNull = (_data, _index) => null;
var getVariableWidthBytes = (values2, valueOffsets, index2) => {
  if (index2 + 1 >= valueOffsets.length) {
    return null;
  }
  const x4 = bigIntToNumber(valueOffsets[index2]);
  const y4 = bigIntToNumber(valueOffsets[index2 + 1]);
  return values2.subarray(x4, y4);
};
var getBool = ({ offset: offset2, values: values2 }, index2) => {
  const idx = offset2 + index2;
  const byte = values2[idx >> 3];
  return (byte & 1 << idx % 8) !== 0;
};
var getDateDay = ({ values: values2 }, index2) => epochDaysToDate(values2, index2);
var getDateMillisecond = ({ values: values2 }, index2) => epochMillisecondsLongToDate(values2, index2 * 2);
var getNumeric = ({ stride, values: values2 }, index2) => values2[stride * index2];
var getFloat16 = ({ stride, values: values2 }, index2) => uint16ToFloat64(values2[stride * index2]);
var getBigInts = ({ values: values2 }, index2) => values2[index2];
var getFixedSizeBinary = ({ stride, values: values2 }, index2) => values2.subarray(stride * index2, stride * (index2 + 1));
var getBinary = ({ values: values2, valueOffsets }, index2) => getVariableWidthBytes(values2, valueOffsets, index2);
var getUtf8 = ({ values: values2, valueOffsets }, index2) => {
  const bytes = getVariableWidthBytes(values2, valueOffsets, index2);
  return bytes !== null ? decodeUtf8(bytes) : null;
};
var getInt = ({ values: values2 }, index2) => values2[index2];
var getFloat = ({ type: type2, values: values2 }, index2) => type2.precision !== Precision.HALF ? values2[index2] : uint16ToFloat64(values2[index2]);
var getDate = (data, index2) => data.type.unit === DateUnit.DAY ? getDateDay(data, index2) : getDateMillisecond(data, index2);
var getTimestampSecond = ({ values: values2 }, index2) => 1e3 * epochMillisecondsLongToMs(values2, index2 * 2);
var getTimestampMillisecond = ({ values: values2 }, index2) => epochMillisecondsLongToMs(values2, index2 * 2);
var getTimestampMicrosecond = ({ values: values2 }, index2) => epochMicrosecondsLongToMs(values2, index2 * 2);
var getTimestampNanosecond = ({ values: values2 }, index2) => epochNanosecondsLongToMs(values2, index2 * 2);
var getTimestamp = (data, index2) => {
  switch (data.type.unit) {
    case TimeUnit.SECOND:
      return getTimestampSecond(data, index2);
    case TimeUnit.MILLISECOND:
      return getTimestampMillisecond(data, index2);
    case TimeUnit.MICROSECOND:
      return getTimestampMicrosecond(data, index2);
    case TimeUnit.NANOSECOND:
      return getTimestampNanosecond(data, index2);
  }
};
var getTimeSecond = ({ values: values2 }, index2) => values2[index2];
var getTimeMillisecond = ({ values: values2 }, index2) => values2[index2];
var getTimeMicrosecond = ({ values: values2 }, index2) => values2[index2];
var getTimeNanosecond = ({ values: values2 }, index2) => values2[index2];
var getTime = (data, index2) => {
  switch (data.type.unit) {
    case TimeUnit.SECOND:
      return getTimeSecond(data, index2);
    case TimeUnit.MILLISECOND:
      return getTimeMillisecond(data, index2);
    case TimeUnit.MICROSECOND:
      return getTimeMicrosecond(data, index2);
    case TimeUnit.NANOSECOND:
      return getTimeNanosecond(data, index2);
  }
};
var getDecimal = ({ values: values2, stride }, index2) => BN.decimal(values2.subarray(stride * index2, stride * (index2 + 1)));
var getList = (data, index2) => {
  const { valueOffsets, stride, children: children2 } = data;
  const { [index2 * stride]: begin, [index2 * stride + 1]: end } = valueOffsets;
  const child = children2[0];
  const slice4 = child.slice(begin, end - begin);
  return new Vector([slice4]);
};
var getMap = (data, index2) => {
  const { valueOffsets, children: children2 } = data;
  const { [index2]: begin, [index2 + 1]: end } = valueOffsets;
  const child = children2[0];
  return new MapRow(child.slice(begin, end - begin));
};
var getStruct = (data, index2) => {
  return new StructRow(data, index2);
};
var getUnion = (data, index2) => {
  return data.type.mode === UnionMode.Dense ? getDenseUnion(data, index2) : getSparseUnion(data, index2);
};
var getDenseUnion = (data, index2) => {
  const childIndex = data.type.typeIdToChildIndex[data.typeIds[index2]];
  const child = data.children[childIndex];
  return instance2.visit(child, data.valueOffsets[index2]);
};
var getSparseUnion = (data, index2) => {
  const childIndex = data.type.typeIdToChildIndex[data.typeIds[index2]];
  const child = data.children[childIndex];
  return instance2.visit(child, index2);
};
var getDictionary = (data, index2) => {
  var _a9;
  return (_a9 = data.dictionary) === null || _a9 === void 0 ? void 0 : _a9.get(data.values[index2]);
};
var getInterval = (data, index2) => data.type.unit === IntervalUnit.DAY_TIME ? getIntervalDayTime(data, index2) : getIntervalYearMonth(data, index2);
var getIntervalDayTime = ({ values: values2 }, index2) => values2.subarray(2 * index2, 2 * (index2 + 1));
var getIntervalYearMonth = ({ values: values2 }, index2) => {
  const interval2 = values2[index2];
  const int32s = new Int32Array(2);
  int32s[0] = Math.trunc(interval2 / 12);
  int32s[1] = Math.trunc(interval2 % 12);
  return int32s;
};
var getDurationSecond = ({ values: values2 }, index2) => values2[index2];
var getDurationMillisecond = ({ values: values2 }, index2) => values2[index2];
var getDurationMicrosecond = ({ values: values2 }, index2) => values2[index2];
var getDurationNanosecond = ({ values: values2 }, index2) => values2[index2];
var getDuration = (data, index2) => {
  switch (data.type.unit) {
    case TimeUnit.SECOND:
      return getDurationSecond(data, index2);
    case TimeUnit.MILLISECOND:
      return getDurationMillisecond(data, index2);
    case TimeUnit.MICROSECOND:
      return getDurationMicrosecond(data, index2);
    case TimeUnit.NANOSECOND:
      return getDurationNanosecond(data, index2);
  }
};
var getFixedSizeList = (data, index2) => {
  const { stride, children: children2 } = data;
  const child = children2[0];
  const slice4 = child.slice(index2 * stride, stride);
  return new Vector([slice4]);
};
GetVisitor.prototype.visitNull = wrapGet(getNull);
GetVisitor.prototype.visitBool = wrapGet(getBool);
GetVisitor.prototype.visitInt = wrapGet(getInt);
GetVisitor.prototype.visitInt8 = wrapGet(getNumeric);
GetVisitor.prototype.visitInt16 = wrapGet(getNumeric);
GetVisitor.prototype.visitInt32 = wrapGet(getNumeric);
GetVisitor.prototype.visitInt64 = wrapGet(getBigInts);
GetVisitor.prototype.visitUint8 = wrapGet(getNumeric);
GetVisitor.prototype.visitUint16 = wrapGet(getNumeric);
GetVisitor.prototype.visitUint32 = wrapGet(getNumeric);
GetVisitor.prototype.visitUint64 = wrapGet(getBigInts);
GetVisitor.prototype.visitFloat = wrapGet(getFloat);
GetVisitor.prototype.visitFloat16 = wrapGet(getFloat16);
GetVisitor.prototype.visitFloat32 = wrapGet(getNumeric);
GetVisitor.prototype.visitFloat64 = wrapGet(getNumeric);
GetVisitor.prototype.visitUtf8 = wrapGet(getUtf8);
GetVisitor.prototype.visitLargeUtf8 = wrapGet(getUtf8);
GetVisitor.prototype.visitBinary = wrapGet(getBinary);
GetVisitor.prototype.visitLargeBinary = wrapGet(getBinary);
GetVisitor.prototype.visitFixedSizeBinary = wrapGet(getFixedSizeBinary);
GetVisitor.prototype.visitDate = wrapGet(getDate);
GetVisitor.prototype.visitDateDay = wrapGet(getDateDay);
GetVisitor.prototype.visitDateMillisecond = wrapGet(getDateMillisecond);
GetVisitor.prototype.visitTimestamp = wrapGet(getTimestamp);
GetVisitor.prototype.visitTimestampSecond = wrapGet(getTimestampSecond);
GetVisitor.prototype.visitTimestampMillisecond = wrapGet(getTimestampMillisecond);
GetVisitor.prototype.visitTimestampMicrosecond = wrapGet(getTimestampMicrosecond);
GetVisitor.prototype.visitTimestampNanosecond = wrapGet(getTimestampNanosecond);
GetVisitor.prototype.visitTime = wrapGet(getTime);
GetVisitor.prototype.visitTimeSecond = wrapGet(getTimeSecond);
GetVisitor.prototype.visitTimeMillisecond = wrapGet(getTimeMillisecond);
GetVisitor.prototype.visitTimeMicrosecond = wrapGet(getTimeMicrosecond);
GetVisitor.prototype.visitTimeNanosecond = wrapGet(getTimeNanosecond);
GetVisitor.prototype.visitDecimal = wrapGet(getDecimal);
GetVisitor.prototype.visitList = wrapGet(getList);
GetVisitor.prototype.visitStruct = wrapGet(getStruct);
GetVisitor.prototype.visitUnion = wrapGet(getUnion);
GetVisitor.prototype.visitDenseUnion = wrapGet(getDenseUnion);
GetVisitor.prototype.visitSparseUnion = wrapGet(getSparseUnion);
GetVisitor.prototype.visitDictionary = wrapGet(getDictionary);
GetVisitor.prototype.visitInterval = wrapGet(getInterval);
GetVisitor.prototype.visitIntervalDayTime = wrapGet(getIntervalDayTime);
GetVisitor.prototype.visitIntervalYearMonth = wrapGet(getIntervalYearMonth);
GetVisitor.prototype.visitDuration = wrapGet(getDuration);
GetVisitor.prototype.visitDurationSecond = wrapGet(getDurationSecond);
GetVisitor.prototype.visitDurationMillisecond = wrapGet(getDurationMillisecond);
GetVisitor.prototype.visitDurationMicrosecond = wrapGet(getDurationMicrosecond);
GetVisitor.prototype.visitDurationNanosecond = wrapGet(getDurationNanosecond);
GetVisitor.prototype.visitFixedSizeList = wrapGet(getFixedSizeList);
GetVisitor.prototype.visitMap = wrapGet(getMap);
var instance2 = new GetVisitor();

// ../core/node_modules/apache-arrow/row/map.mjs
var kKeys = Symbol.for("keys");
var kVals = Symbol.for("vals");
var MapRow = class {
  constructor(slice4) {
    this[kKeys] = new Vector([slice4.children[0]]).memoize();
    this[kVals] = slice4.children[1];
    return new Proxy(this, new MapRowProxyHandler());
  }
  [Symbol.iterator]() {
    return new MapRowIterator(this[kKeys], this[kVals]);
  }
  get size() {
    return this[kKeys].length;
  }
  toArray() {
    return Object.values(this.toJSON());
  }
  toJSON() {
    const keys = this[kKeys];
    const vals = this[kVals];
    const json = {};
    for (let i = -1, n = keys.length; ++i < n; ) {
      json[keys.get(i)] = instance2.visit(vals, i);
    }
    return json;
  }
  toString() {
    return `{${[...this].map(([key, val]) => `${valueToString(key)}: ${valueToString(val)}`).join(", ")}}`;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.toString();
  }
};
var MapRowIterator = class {
  constructor(keys, vals) {
    this.keys = keys;
    this.vals = vals;
    this.keyIndex = 0;
    this.numKeys = keys.length;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const i = this.keyIndex;
    if (i === this.numKeys) {
      return { done: true, value: null };
    }
    this.keyIndex++;
    return {
      done: false,
      value: [
        this.keys.get(i),
        instance2.visit(this.vals, i)
      ]
    };
  }
};
var MapRowProxyHandler = class {
  isExtensible() {
    return false;
  }
  deleteProperty() {
    return false;
  }
  preventExtensions() {
    return true;
  }
  ownKeys(row) {
    return row[kKeys].toArray().map(String);
  }
  has(row, key) {
    return row[kKeys].includes(key);
  }
  getOwnPropertyDescriptor(row, key) {
    const idx = row[kKeys].indexOf(key);
    if (idx !== -1) {
      return { writable: true, enumerable: true, configurable: true };
    }
    return;
  }
  get(row, key) {
    if (Reflect.has(row, key)) {
      return row[key];
    }
    const idx = row[kKeys].indexOf(key);
    if (idx !== -1) {
      const val = instance2.visit(Reflect.get(row, kVals), idx);
      Reflect.set(row, key, val);
      return val;
    }
  }
  set(row, key, val) {
    const idx = row[kKeys].indexOf(key);
    if (idx !== -1) {
      instance.visit(Reflect.get(row, kVals), idx, val);
      return Reflect.set(row, key, val);
    } else if (Reflect.has(row, key)) {
      return Reflect.set(row, key, val);
    }
    return false;
  }
};
Object.defineProperties(MapRow.prototype, {
  [Symbol.toStringTag]: { enumerable: false, configurable: false, value: "Row" },
  [kKeys]: { writable: true, enumerable: false, configurable: false, value: null },
  [kVals]: { writable: true, enumerable: false, configurable: false, value: null }
});

// ../core/node_modules/apache-arrow/util/vector.mjs
function clampIndex(source, index2, then) {
  const length4 = source.length;
  const adjust = index2 > -1 ? index2 : length4 + index2 % length4;
  return then ? then(source, adjust) : adjust;
}
var tmp;
function clampRange(source, begin, end, then) {
  const { length: len = 0 } = source;
  let lhs = typeof begin !== "number" ? 0 : begin;
  let rhs = typeof end !== "number" ? len : end;
  lhs < 0 && (lhs = (lhs % len + len) % len);
  rhs < 0 && (rhs = (rhs % len + len) % len);
  rhs < lhs && (tmp = lhs, lhs = rhs, rhs = tmp);
  rhs > len && (rhs = len);
  return then ? then(source, lhs, rhs) : [lhs, rhs];
}
var isNaNFast = (value) => value !== value;
function createElementComparator(search3) {
  const typeofSearch = typeof search3;
  if (typeofSearch !== "object" || search3 === null) {
    if (isNaNFast(search3)) {
      return isNaNFast;
    }
    return (value) => value === search3;
  }
  if (search3 instanceof Date) {
    const valueOfSearch = search3.valueOf();
    return (value) => value instanceof Date ? value.valueOf() === valueOfSearch : false;
  }
  if (ArrayBuffer.isView(search3)) {
    return (value) => value ? compareArrayLike(search3, value) : false;
  }
  if (search3 instanceof Map) {
    return createMapComparator(search3);
  }
  if (Array.isArray(search3)) {
    return createArrayLikeComparator(search3);
  }
  if (search3 instanceof Vector) {
    return createVectorComparator(search3);
  }
  return createObjectComparator(search3, true);
}
function createArrayLikeComparator(lhs) {
  const comparators = [];
  for (let i = -1, n = lhs.length; ++i < n; ) {
    comparators[i] = createElementComparator(lhs[i]);
  }
  return createSubElementsComparator(comparators);
}
function createMapComparator(lhs) {
  let i = -1;
  const comparators = [];
  for (const v3 of lhs.values())
    comparators[++i] = createElementComparator(v3);
  return createSubElementsComparator(comparators);
}
function createVectorComparator(lhs) {
  const comparators = [];
  for (let i = -1, n = lhs.length; ++i < n; ) {
    comparators[i] = createElementComparator(lhs.get(i));
  }
  return createSubElementsComparator(comparators);
}
function createObjectComparator(lhs, allowEmpty = false) {
  const keys = Object.keys(lhs);
  if (!allowEmpty && keys.length === 0) {
    return () => false;
  }
  const comparators = [];
  for (let i = -1, n = keys.length; ++i < n; ) {
    comparators[i] = createElementComparator(lhs[keys[i]]);
  }
  return createSubElementsComparator(comparators, keys);
}
function createSubElementsComparator(comparators, keys) {
  return (rhs) => {
    if (!rhs || typeof rhs !== "object") {
      return false;
    }
    switch (rhs.constructor) {
      case Array:
        return compareArray(comparators, rhs);
      case Map:
        return compareObject(comparators, rhs, rhs.keys());
      case MapRow:
      case StructRow:
      case Object:
      case void 0:
        return compareObject(comparators, rhs, keys || Object.keys(rhs));
    }
    return rhs instanceof Vector ? compareVector(comparators, rhs) : false;
  };
}
function compareArray(comparators, arr) {
  const n = comparators.length;
  if (arr.length !== n) {
    return false;
  }
  for (let i = -1; ++i < n; ) {
    if (!comparators[i](arr[i])) {
      return false;
    }
  }
  return true;
}
function compareVector(comparators, vec2) {
  const n = comparators.length;
  if (vec2.length !== n) {
    return false;
  }
  for (let i = -1; ++i < n; ) {
    if (!comparators[i](vec2.get(i))) {
      return false;
    }
  }
  return true;
}
function compareObject(comparators, obj, keys) {
  const lKeyItr = keys[Symbol.iterator]();
  const rKeyItr = obj instanceof Map ? obj.keys() : Object.keys(obj)[Symbol.iterator]();
  const rValItr = obj instanceof Map ? obj.values() : Object.values(obj)[Symbol.iterator]();
  let i = 0;
  const n = comparators.length;
  let rVal = rValItr.next();
  let lKey = lKeyItr.next();
  let rKey = rKeyItr.next();
  for (; i < n && !lKey.done && !rKey.done && !rVal.done; ++i, lKey = lKeyItr.next(), rKey = rKeyItr.next(), rVal = rValItr.next()) {
    if (lKey.value !== rKey.value || !comparators[i](rVal.value)) {
      break;
    }
  }
  if (i === n && lKey.done && rKey.done && rVal.done) {
    return true;
  }
  lKeyItr.return && lKeyItr.return();
  rKeyItr.return && rKeyItr.return();
  rValItr.return && rValItr.return();
  return false;
}

// ../core/node_modules/apache-arrow/util/bit.mjs
var bit_exports = {};
__export(bit_exports, {
  BitIterator: () => BitIterator,
  getBit: () => getBit,
  getBool: () => getBool2,
  packBools: () => packBools,
  popcnt_array: () => popcnt_array,
  popcnt_bit_range: () => popcnt_bit_range,
  popcnt_uint32: () => popcnt_uint32,
  setBool: () => setBool2,
  truncateBitmap: () => truncateBitmap
});
function getBool2(_data, _index, byte, bit) {
  return (byte & 1 << bit) !== 0;
}
function getBit(_data, _index, byte, bit) {
  return (byte & 1 << bit) >> bit;
}
function setBool2(bytes, index2, value) {
  return value ? !!(bytes[index2 >> 3] |= 1 << index2 % 8) || true : !(bytes[index2 >> 3] &= ~(1 << index2 % 8)) && false;
}
function truncateBitmap(offset2, length4, bitmap) {
  const alignedSize = bitmap.byteLength + 7 & ~7;
  if (offset2 > 0 || bitmap.byteLength < alignedSize) {
    const bytes = new Uint8Array(alignedSize);
    bytes.set(offset2 % 8 === 0 ? bitmap.subarray(offset2 >> 3) : (
      // Otherwise iterate each bit from the offset and return a new one
      packBools(new BitIterator(bitmap, offset2, length4, null, getBool2)).subarray(0, alignedSize)
    ));
    return bytes;
  }
  return bitmap;
}
function packBools(values2) {
  const xs = [];
  let i = 0, bit = 0, byte = 0;
  for (const value of values2) {
    value && (byte |= 1 << bit);
    if (++bit === 8) {
      xs[i++] = byte;
      byte = bit = 0;
    }
  }
  if (i === 0 || bit > 0) {
    xs[i++] = byte;
  }
  const b2 = new Uint8Array(xs.length + 7 & ~7);
  b2.set(xs);
  return b2;
}
var BitIterator = class {
  constructor(bytes, begin, length4, context, get3) {
    this.bytes = bytes;
    this.length = length4;
    this.context = context;
    this.get = get3;
    this.bit = begin % 8;
    this.byteIndex = begin >> 3;
    this.byte = bytes[this.byteIndex++];
    this.index = 0;
  }
  next() {
    if (this.index < this.length) {
      if (this.bit === 8) {
        this.bit = 0;
        this.byte = this.bytes[this.byteIndex++];
      }
      return {
        value: this.get(this.context, this.index++, this.byte, this.bit++)
      };
    }
    return { done: true, value: null };
  }
  [Symbol.iterator]() {
    return this;
  }
};
function popcnt_bit_range(data, lhs, rhs) {
  if (rhs - lhs <= 0) {
    return 0;
  }
  if (rhs - lhs < 8) {
    let sum5 = 0;
    for (const bit of new BitIterator(data, lhs, rhs - lhs, data, getBit)) {
      sum5 += bit;
    }
    return sum5;
  }
  const rhsInside = rhs >> 3 << 3;
  const lhsInside = lhs + (lhs % 8 === 0 ? 0 : 8 - lhs % 8);
  return (
    // Get the popcnt of bits between the left hand side, and the next highest multiple of 8
    popcnt_bit_range(data, lhs, lhsInside) + // Get the popcnt of bits between the right hand side, and the next lowest multiple of 8
    popcnt_bit_range(data, rhsInside, rhs) + // Get the popcnt of all bits between the left and right hand sides' multiples of 8
    popcnt_array(data, lhsInside >> 3, rhsInside - lhsInside >> 3)
  );
}
function popcnt_array(arr, byteOffset, byteLength) {
  let cnt = 0, pos = Math.trunc(byteOffset);
  const view = new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  const len = byteLength === void 0 ? arr.byteLength : pos + byteLength;
  while (len - pos >= 4) {
    cnt += popcnt_uint32(view.getUint32(pos));
    pos += 4;
  }
  while (len - pos >= 2) {
    cnt += popcnt_uint32(view.getUint16(pos));
    pos += 2;
  }
  while (len - pos >= 1) {
    cnt += popcnt_uint32(view.getUint8(pos));
    pos += 1;
  }
  return cnt;
}
function popcnt_uint32(uint32) {
  let i = Math.trunc(uint32);
  i = i - (i >>> 1 & 1431655765);
  i = (i & 858993459) + (i >>> 2 & 858993459);
  return (i + (i >>> 4) & 252645135) * 16843009 >>> 24;
}

// ../core/node_modules/apache-arrow/data.mjs
var kUnknownNullCount = -1;
var Data = class _Data {
  get typeId() {
    return this.type.typeId;
  }
  get ArrayType() {
    return this.type.ArrayType;
  }
  get buffers() {
    return [this.valueOffsets, this.values, this.nullBitmap, this.typeIds];
  }
  get nullable() {
    if (this._nullCount !== 0) {
      const { type: type2 } = this;
      if (DataType.isSparseUnion(type2)) {
        return this.children.some((child) => child.nullable);
      } else if (DataType.isDenseUnion(type2)) {
        return this.children.some((child) => child.nullable);
      }
      return this.nullBitmap && this.nullBitmap.byteLength > 0;
    }
    return true;
  }
  get byteLength() {
    let byteLength = 0;
    const { valueOffsets, values: values2, nullBitmap, typeIds } = this;
    valueOffsets && (byteLength += valueOffsets.byteLength);
    values2 && (byteLength += values2.byteLength);
    nullBitmap && (byteLength += nullBitmap.byteLength);
    typeIds && (byteLength += typeIds.byteLength);
    return this.children.reduce((byteLength2, child) => byteLength2 + child.byteLength, byteLength);
  }
  get nullCount() {
    if (DataType.isUnion(this.type)) {
      return this.children.reduce((nullCount2, child) => nullCount2 + child.nullCount, 0);
    }
    let nullCount = this._nullCount;
    let nullBitmap;
    if (nullCount <= kUnknownNullCount && (nullBitmap = this.nullBitmap)) {
      this._nullCount = nullCount = this.length - popcnt_bit_range(nullBitmap, this.offset, this.offset + this.length);
    }
    return nullCount;
  }
  constructor(type2, offset2, length4, nullCount, buffers, children2 = [], dictionary) {
    this.type = type2;
    this.children = children2;
    this.dictionary = dictionary;
    this.offset = Math.floor(Math.max(offset2 || 0, 0));
    this.length = Math.floor(Math.max(length4 || 0, 0));
    this._nullCount = Math.floor(Math.max(nullCount || 0, -1));
    let buffer;
    if (buffers instanceof _Data) {
      this.stride = buffers.stride;
      this.values = buffers.values;
      this.typeIds = buffers.typeIds;
      this.nullBitmap = buffers.nullBitmap;
      this.valueOffsets = buffers.valueOffsets;
    } else {
      this.stride = strideForType(type2);
      if (buffers) {
        (buffer = buffers[0]) && (this.valueOffsets = buffer);
        (buffer = buffers[1]) && (this.values = buffer);
        (buffer = buffers[2]) && (this.nullBitmap = buffer);
        (buffer = buffers[3]) && (this.typeIds = buffer);
      }
    }
  }
  getValid(index2) {
    const { type: type2 } = this;
    if (DataType.isUnion(type2)) {
      const union = type2;
      const child = this.children[union.typeIdToChildIndex[this.typeIds[index2]]];
      const indexInChild = union.mode === UnionMode.Dense ? this.valueOffsets[index2] : index2;
      return child.getValid(indexInChild);
    }
    if (this.nullable && this.nullCount > 0) {
      const pos = this.offset + index2;
      const val = this.nullBitmap[pos >> 3];
      return (val & 1 << pos % 8) !== 0;
    }
    return true;
  }
  setValid(index2, value) {
    let prev;
    const { type: type2 } = this;
    if (DataType.isUnion(type2)) {
      const union = type2;
      const child = this.children[union.typeIdToChildIndex[this.typeIds[index2]]];
      const indexInChild = union.mode === UnionMode.Dense ? this.valueOffsets[index2] : index2;
      prev = child.getValid(indexInChild);
      child.setValid(indexInChild, value);
    } else {
      let { nullBitmap } = this;
      const { offset: offset2, length: length4 } = this;
      const idx = offset2 + index2;
      const mask = 1 << idx % 8;
      const byteOffset = idx >> 3;
      if (!nullBitmap || nullBitmap.byteLength <= byteOffset) {
        nullBitmap = new Uint8Array((offset2 + length4 + 63 & ~63) >> 3).fill(255);
        if (this.nullCount > 0) {
          nullBitmap.set(truncateBitmap(offset2, length4, this.nullBitmap), 0);
        }
        Object.assign(this, { nullBitmap, _nullCount: -1 });
      }
      const byte = nullBitmap[byteOffset];
      prev = (byte & mask) !== 0;
      value ? nullBitmap[byteOffset] = byte | mask : nullBitmap[byteOffset] = byte & ~mask;
    }
    if (prev !== !!value) {
      this._nullCount = this.nullCount + (value ? -1 : 1);
    }
    return value;
  }
  clone(type2 = this.type, offset2 = this.offset, length4 = this.length, nullCount = this._nullCount, buffers = this, children2 = this.children) {
    return new _Data(type2, offset2, length4, nullCount, buffers, children2, this.dictionary);
  }
  slice(offset2, length4) {
    const { stride, typeId, children: children2 } = this;
    const nullCount = +(this._nullCount === 0) - 1;
    const childStride = typeId === 16 ? stride : 1;
    const buffers = this._sliceBuffers(offset2, length4, stride, typeId);
    return this.clone(
      this.type,
      this.offset + offset2,
      length4,
      nullCount,
      buffers,
      // Don't slice children if we have value offsets (the variable-width types)
      children2.length === 0 || this.valueOffsets ? children2 : this._sliceChildren(children2, childStride * offset2, childStride * length4)
    );
  }
  _changeLengthAndBackfillNullBitmap(newLength) {
    if (this.typeId === Type2.Null) {
      return this.clone(this.type, 0, newLength, 0);
    }
    const { length: length4, nullCount } = this;
    const bitmap = new Uint8Array((newLength + 63 & ~63) >> 3).fill(255, 0, length4 >> 3);
    bitmap[length4 >> 3] = (1 << length4 - (length4 & ~7)) - 1;
    if (nullCount > 0) {
      bitmap.set(truncateBitmap(this.offset, length4, this.nullBitmap), 0);
    }
    const buffers = this.buffers;
    buffers[BufferType.VALIDITY] = bitmap;
    return this.clone(this.type, 0, newLength, nullCount + (newLength - length4), buffers);
  }
  _sliceBuffers(offset2, length4, stride, typeId) {
    let arr;
    const { buffers } = this;
    (arr = buffers[BufferType.TYPE]) && (buffers[BufferType.TYPE] = arr.subarray(offset2, offset2 + length4));
    (arr = buffers[BufferType.OFFSET]) && (buffers[BufferType.OFFSET] = arr.subarray(offset2, offset2 + length4 + 1)) || // Otherwise if no offsets, slice the data buffer. Don't slice the data vector for Booleans, since the offset goes by bits not bytes
    (arr = buffers[BufferType.DATA]) && (buffers[BufferType.DATA] = typeId === 6 ? arr : arr.subarray(stride * offset2, stride * (offset2 + length4)));
    return buffers;
  }
  _sliceChildren(children2, offset2, length4) {
    return children2.map((child) => child.slice(offset2, length4));
  }
};
Data.prototype.children = Object.freeze([]);
var MakeDataVisitor = class _MakeDataVisitor extends Visitor {
  visit(props) {
    return this.getVisitFn(props["type"]).call(this, props);
  }
  visitNull(props) {
    const { ["type"]: type2, ["offset"]: offset2 = 0, ["length"]: length4 = 0 } = props;
    return new Data(type2, offset2, length4, length4);
  }
  visitBool(props) {
    const { ["type"]: type2, ["offset"]: offset2 = 0 } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const data = toArrayBufferView(type2.ArrayType, props["data"]);
    const { ["length"]: length4 = data.length >> 3, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);
  }
  visitInt(props) {
    const { ["type"]: type2, ["offset"]: offset2 = 0 } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const data = toArrayBufferView(type2.ArrayType, props["data"]);
    const { ["length"]: length4 = data.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);
  }
  visitFloat(props) {
    const { ["type"]: type2, ["offset"]: offset2 = 0 } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const data = toArrayBufferView(type2.ArrayType, props["data"]);
    const { ["length"]: length4 = data.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);
  }
  visitUtf8(props) {
    const { ["type"]: type2, ["offset"]: offset2 = 0 } = props;
    const data = toUint8Array(props["data"]);
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const valueOffsets = toInt32Array(props["valueOffsets"]);
    const { ["length"]: length4 = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data(type2, offset2, length4, nullCount, [valueOffsets, data, nullBitmap]);
  }
  visitLargeUtf8(props) {
    const { ["type"]: type2, ["offset"]: offset2 = 0 } = props;
    const data = toUint8Array(props["data"]);
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const valueOffsets = toBigInt64Array(props["valueOffsets"]);
    const { ["length"]: length4 = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data(type2, offset2, length4, nullCount, [valueOffsets, data, nullBitmap]);
  }
  visitBinary(props) {
    const { ["type"]: type2, ["offset"]: offset2 = 0 } = props;
    const data = toUint8Array(props["data"]);
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const valueOffsets = toInt32Array(props["valueOffsets"]);
    const { ["length"]: length4 = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data(type2, offset2, length4, nullCount, [valueOffsets, data, nullBitmap]);
  }
  visitLargeBinary(props) {
    const { ["type"]: type2, ["offset"]: offset2 = 0 } = props;
    const data = toUint8Array(props["data"]);
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const valueOffsets = toBigInt64Array(props["valueOffsets"]);
    const { ["length"]: length4 = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data(type2, offset2, length4, nullCount, [valueOffsets, data, nullBitmap]);
  }
  visitFixedSizeBinary(props) {
    const { ["type"]: type2, ["offset"]: offset2 = 0 } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const data = toArrayBufferView(type2.ArrayType, props["data"]);
    const { ["length"]: length4 = data.length / strideForType(type2), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);
  }
  visitDate(props) {
    const { ["type"]: type2, ["offset"]: offset2 = 0 } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const data = toArrayBufferView(type2.ArrayType, props["data"]);
    const { ["length"]: length4 = data.length / strideForType(type2), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);
  }
  visitTimestamp(props) {
    const { ["type"]: type2, ["offset"]: offset2 = 0 } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const data = toArrayBufferView(type2.ArrayType, props["data"]);
    const { ["length"]: length4 = data.length / strideForType(type2), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);
  }
  visitTime(props) {
    const { ["type"]: type2, ["offset"]: offset2 = 0 } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const data = toArrayBufferView(type2.ArrayType, props["data"]);
    const { ["length"]: length4 = data.length / strideForType(type2), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);
  }
  visitDecimal(props) {
    const { ["type"]: type2, ["offset"]: offset2 = 0 } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const data = toArrayBufferView(type2.ArrayType, props["data"]);
    const { ["length"]: length4 = data.length / strideForType(type2), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);
  }
  visitList(props) {
    const { ["type"]: type2, ["offset"]: offset2 = 0, ["child"]: child } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const valueOffsets = toInt32Array(props["valueOffsets"]);
    const { ["length"]: length4 = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data(type2, offset2, length4, nullCount, [valueOffsets, void 0, nullBitmap], [child]);
  }
  visitStruct(props) {
    const { ["type"]: type2, ["offset"]: offset2 = 0, ["children"]: children2 = [] } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const { length: length4 = children2.reduce((len, { length: length5 }) => Math.max(len, length5), 0), nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data(type2, offset2, length4, nullCount, [void 0, void 0, nullBitmap], children2);
  }
  visitUnion(props) {
    const { ["type"]: type2, ["offset"]: offset2 = 0, ["children"]: children2 = [] } = props;
    const typeIds = toArrayBufferView(type2.ArrayType, props["typeIds"]);
    const { ["length"]: length4 = typeIds.length, ["nullCount"]: nullCount = -1 } = props;
    if (DataType.isSparseUnion(type2)) {
      return new Data(type2, offset2, length4, nullCount, [void 0, void 0, void 0, typeIds], children2);
    }
    const valueOffsets = toInt32Array(props["valueOffsets"]);
    return new Data(type2, offset2, length4, nullCount, [valueOffsets, void 0, void 0, typeIds], children2);
  }
  visitDictionary(props) {
    const { ["type"]: type2, ["offset"]: offset2 = 0 } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const data = toArrayBufferView(type2.indices.ArrayType, props["data"]);
    const { ["dictionary"]: dictionary = new Vector([new _MakeDataVisitor().visit({ type: type2.dictionary })]) } = props;
    const { ["length"]: length4 = data.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap], [], dictionary);
  }
  visitInterval(props) {
    const { ["type"]: type2, ["offset"]: offset2 = 0 } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const data = toArrayBufferView(type2.ArrayType, props["data"]);
    const { ["length"]: length4 = data.length / strideForType(type2), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);
  }
  visitDuration(props) {
    const { ["type"]: type2, ["offset"]: offset2 = 0 } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const data = toArrayBufferView(type2.ArrayType, props["data"]);
    const { ["length"]: length4 = data.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);
  }
  visitFixedSizeList(props) {
    const { ["type"]: type2, ["offset"]: offset2 = 0, ["child"]: child = new _MakeDataVisitor().visit({ type: type2.valueType }) } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const { ["length"]: length4 = child.length / strideForType(type2), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data(type2, offset2, length4, nullCount, [void 0, void 0, nullBitmap], [child]);
  }
  visitMap(props) {
    const { ["type"]: type2, ["offset"]: offset2 = 0, ["child"]: child = new _MakeDataVisitor().visit({ type: type2.childType }) } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const valueOffsets = toInt32Array(props["valueOffsets"]);
    const { ["length"]: length4 = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data(type2, offset2, length4, nullCount, [valueOffsets, void 0, nullBitmap], [child]);
  }
};
var makeDataVisitor = new MakeDataVisitor();
function makeData(props) {
  return makeDataVisitor.visit(props);
}

// ../core/node_modules/apache-arrow/util/chunk.mjs
var ChunkedIterator = class {
  constructor(numChunks = 0, getChunkIterator) {
    this.numChunks = numChunks;
    this.getChunkIterator = getChunkIterator;
    this.chunkIndex = 0;
    this.chunkIterator = this.getChunkIterator(0);
  }
  next() {
    while (this.chunkIndex < this.numChunks) {
      const next = this.chunkIterator.next();
      if (!next.done) {
        return next;
      }
      if (++this.chunkIndex < this.numChunks) {
        this.chunkIterator = this.getChunkIterator(this.chunkIndex);
      }
    }
    return { done: true, value: null };
  }
  [Symbol.iterator]() {
    return this;
  }
};
function computeChunkNullable(chunks) {
  return chunks.some((chunk) => chunk.nullable);
}
function computeChunkNullCounts(chunks) {
  return chunks.reduce((nullCount, chunk) => nullCount + chunk.nullCount, 0);
}
function computeChunkOffsets(chunks) {
  return chunks.reduce((offsets, chunk, index2) => {
    offsets[index2 + 1] = offsets[index2] + chunk.length;
    return offsets;
  }, new Uint32Array(chunks.length + 1));
}
function sliceChunks(chunks, offsets, begin, end) {
  const slices = [];
  for (let i = -1, n = chunks.length; ++i < n; ) {
    const chunk = chunks[i];
    const offset2 = offsets[i];
    const { length: length4 } = chunk;
    if (offset2 >= end) {
      break;
    }
    if (begin >= offset2 + length4) {
      continue;
    }
    if (offset2 >= begin && offset2 + length4 <= end) {
      slices.push(chunk);
      continue;
    }
    const from2 = Math.max(0, begin - offset2);
    const to = Math.min(end - offset2, length4);
    slices.push(chunk.slice(from2, to - from2));
  }
  if (slices.length === 0) {
    slices.push(chunks[0].slice(0, 0));
  }
  return slices;
}
function binarySearch(chunks, offsets, idx, fn) {
  let lhs = 0, mid2 = 0, rhs = offsets.length - 1;
  do {
    if (lhs >= rhs - 1) {
      return idx < offsets[rhs] ? fn(chunks, lhs, idx - offsets[lhs]) : null;
    }
    mid2 = lhs + Math.trunc((rhs - lhs) * 0.5);
    idx < offsets[mid2] ? rhs = mid2 : lhs = mid2;
  } while (lhs < rhs);
}
function isChunkedValid(data, index2) {
  return data.getValid(index2);
}
function wrapChunkedCall1(fn) {
  function chunkedFn(chunks, i, j2) {
    return fn(chunks[i], j2);
  }
  return function(index2) {
    const data = this.data;
    return binarySearch(data, this._offsets, index2, chunkedFn);
  };
}
function wrapChunkedCall2(fn) {
  let _2;
  function chunkedFn(chunks, i, j2) {
    return fn(chunks[i], j2, _2);
  }
  return function(index2, value) {
    const data = this.data;
    _2 = value;
    const result = binarySearch(data, this._offsets, index2, chunkedFn);
    _2 = void 0;
    return result;
  };
}
function wrapChunkedIndexOf(indexOf2) {
  let _1;
  function chunkedIndexOf(data, chunkIndex, fromIndex) {
    let begin = fromIndex, index2 = 0, total = 0;
    for (let i = chunkIndex - 1, n = data.length; ++i < n; ) {
      const chunk = data[i];
      if (~(index2 = indexOf2(chunk, _1, begin))) {
        return total + index2;
      }
      begin = 0;
      total += chunk.length;
    }
    return -1;
  }
  return function(element, offset2) {
    _1 = element;
    const data = this.data;
    const result = typeof offset2 !== "number" ? chunkedIndexOf(data, 0, 0) : binarySearch(data, this._offsets, offset2, chunkedIndexOf);
    _1 = void 0;
    return result;
  };
}

// ../core/node_modules/apache-arrow/visitor/indexof.mjs
var IndexOfVisitor = class extends Visitor {
};
function nullIndexOf(data, searchElement) {
  return searchElement === null && data.length > 0 ? 0 : -1;
}
function indexOfNull(data, fromIndex) {
  const { nullBitmap } = data;
  if (!nullBitmap || data.nullCount <= 0) {
    return -1;
  }
  let i = 0;
  for (const isValid of new BitIterator(nullBitmap, data.offset + (fromIndex || 0), data.length, nullBitmap, getBool2)) {
    if (!isValid) {
      return i;
    }
    ++i;
  }
  return -1;
}
function indexOfValue(data, searchElement, fromIndex) {
  if (searchElement === void 0) {
    return -1;
  }
  if (searchElement === null) {
    switch (data.typeId) {
      case Type2.Union:
        break;
      case Type2.Dictionary:
        break;
      default:
        return indexOfNull(data, fromIndex);
    }
  }
  const get3 = instance2.getVisitFn(data);
  const compare = createElementComparator(searchElement);
  for (let i = (fromIndex || 0) - 1, n = data.length; ++i < n; ) {
    if (compare(get3(data, i))) {
      return i;
    }
  }
  return -1;
}
function indexOfUnion(data, searchElement, fromIndex) {
  const get3 = instance2.getVisitFn(data);
  const compare = createElementComparator(searchElement);
  for (let i = (fromIndex || 0) - 1, n = data.length; ++i < n; ) {
    if (compare(get3(data, i))) {
      return i;
    }
  }
  return -1;
}
IndexOfVisitor.prototype.visitNull = nullIndexOf;
IndexOfVisitor.prototype.visitBool = indexOfValue;
IndexOfVisitor.prototype.visitInt = indexOfValue;
IndexOfVisitor.prototype.visitInt8 = indexOfValue;
IndexOfVisitor.prototype.visitInt16 = indexOfValue;
IndexOfVisitor.prototype.visitInt32 = indexOfValue;
IndexOfVisitor.prototype.visitInt64 = indexOfValue;
IndexOfVisitor.prototype.visitUint8 = indexOfValue;
IndexOfVisitor.prototype.visitUint16 = indexOfValue;
IndexOfVisitor.prototype.visitUint32 = indexOfValue;
IndexOfVisitor.prototype.visitUint64 = indexOfValue;
IndexOfVisitor.prototype.visitFloat = indexOfValue;
IndexOfVisitor.prototype.visitFloat16 = indexOfValue;
IndexOfVisitor.prototype.visitFloat32 = indexOfValue;
IndexOfVisitor.prototype.visitFloat64 = indexOfValue;
IndexOfVisitor.prototype.visitUtf8 = indexOfValue;
IndexOfVisitor.prototype.visitLargeUtf8 = indexOfValue;
IndexOfVisitor.prototype.visitBinary = indexOfValue;
IndexOfVisitor.prototype.visitLargeBinary = indexOfValue;
IndexOfVisitor.prototype.visitFixedSizeBinary = indexOfValue;
IndexOfVisitor.prototype.visitDate = indexOfValue;
IndexOfVisitor.prototype.visitDateDay = indexOfValue;
IndexOfVisitor.prototype.visitDateMillisecond = indexOfValue;
IndexOfVisitor.prototype.visitTimestamp = indexOfValue;
IndexOfVisitor.prototype.visitTimestampSecond = indexOfValue;
IndexOfVisitor.prototype.visitTimestampMillisecond = indexOfValue;
IndexOfVisitor.prototype.visitTimestampMicrosecond = indexOfValue;
IndexOfVisitor.prototype.visitTimestampNanosecond = indexOfValue;
IndexOfVisitor.prototype.visitTime = indexOfValue;
IndexOfVisitor.prototype.visitTimeSecond = indexOfValue;
IndexOfVisitor.prototype.visitTimeMillisecond = indexOfValue;
IndexOfVisitor.prototype.visitTimeMicrosecond = indexOfValue;
IndexOfVisitor.prototype.visitTimeNanosecond = indexOfValue;
IndexOfVisitor.prototype.visitDecimal = indexOfValue;
IndexOfVisitor.prototype.visitList = indexOfValue;
IndexOfVisitor.prototype.visitStruct = indexOfValue;
IndexOfVisitor.prototype.visitUnion = indexOfValue;
IndexOfVisitor.prototype.visitDenseUnion = indexOfUnion;
IndexOfVisitor.prototype.visitSparseUnion = indexOfUnion;
IndexOfVisitor.prototype.visitDictionary = indexOfValue;
IndexOfVisitor.prototype.visitInterval = indexOfValue;
IndexOfVisitor.prototype.visitIntervalDayTime = indexOfValue;
IndexOfVisitor.prototype.visitIntervalYearMonth = indexOfValue;
IndexOfVisitor.prototype.visitDuration = indexOfValue;
IndexOfVisitor.prototype.visitDurationSecond = indexOfValue;
IndexOfVisitor.prototype.visitDurationMillisecond = indexOfValue;
IndexOfVisitor.prototype.visitDurationMicrosecond = indexOfValue;
IndexOfVisitor.prototype.visitDurationNanosecond = indexOfValue;
IndexOfVisitor.prototype.visitFixedSizeList = indexOfValue;
IndexOfVisitor.prototype.visitMap = indexOfValue;
var instance3 = new IndexOfVisitor();

// ../core/node_modules/apache-arrow/visitor/iterator.mjs
var IteratorVisitor = class extends Visitor {
};
function vectorIterator(vector3) {
  const { type: type2 } = vector3;
  if (vector3.nullCount === 0 && vector3.stride === 1 && (type2.typeId === Type2.Timestamp || type2 instanceof Int_ && type2.bitWidth !== 64 || type2 instanceof Time_ && type2.bitWidth !== 64 || type2 instanceof Float && type2.precision !== Precision.HALF)) {
    return new ChunkedIterator(vector3.data.length, (chunkIndex) => {
      const data = vector3.data[chunkIndex];
      return data.values.subarray(0, data.length)[Symbol.iterator]();
    });
  }
  let offset2 = 0;
  return new ChunkedIterator(vector3.data.length, (chunkIndex) => {
    const data = vector3.data[chunkIndex];
    const length4 = data.length;
    const inner = vector3.slice(offset2, offset2 + length4);
    offset2 += length4;
    return new VectorIterator(inner);
  });
}
var VectorIterator = class {
  constructor(vector3) {
    this.vector = vector3;
    this.index = 0;
  }
  next() {
    if (this.index < this.vector.length) {
      return {
        value: this.vector.get(this.index++)
      };
    }
    return { done: true, value: null };
  }
  [Symbol.iterator]() {
    return this;
  }
};
IteratorVisitor.prototype.visitNull = vectorIterator;
IteratorVisitor.prototype.visitBool = vectorIterator;
IteratorVisitor.prototype.visitInt = vectorIterator;
IteratorVisitor.prototype.visitInt8 = vectorIterator;
IteratorVisitor.prototype.visitInt16 = vectorIterator;
IteratorVisitor.prototype.visitInt32 = vectorIterator;
IteratorVisitor.prototype.visitInt64 = vectorIterator;
IteratorVisitor.prototype.visitUint8 = vectorIterator;
IteratorVisitor.prototype.visitUint16 = vectorIterator;
IteratorVisitor.prototype.visitUint32 = vectorIterator;
IteratorVisitor.prototype.visitUint64 = vectorIterator;
IteratorVisitor.prototype.visitFloat = vectorIterator;
IteratorVisitor.prototype.visitFloat16 = vectorIterator;
IteratorVisitor.prototype.visitFloat32 = vectorIterator;
IteratorVisitor.prototype.visitFloat64 = vectorIterator;
IteratorVisitor.prototype.visitUtf8 = vectorIterator;
IteratorVisitor.prototype.visitLargeUtf8 = vectorIterator;
IteratorVisitor.prototype.visitBinary = vectorIterator;
IteratorVisitor.prototype.visitLargeBinary = vectorIterator;
IteratorVisitor.prototype.visitFixedSizeBinary = vectorIterator;
IteratorVisitor.prototype.visitDate = vectorIterator;
IteratorVisitor.prototype.visitDateDay = vectorIterator;
IteratorVisitor.prototype.visitDateMillisecond = vectorIterator;
IteratorVisitor.prototype.visitTimestamp = vectorIterator;
IteratorVisitor.prototype.visitTimestampSecond = vectorIterator;
IteratorVisitor.prototype.visitTimestampMillisecond = vectorIterator;
IteratorVisitor.prototype.visitTimestampMicrosecond = vectorIterator;
IteratorVisitor.prototype.visitTimestampNanosecond = vectorIterator;
IteratorVisitor.prototype.visitTime = vectorIterator;
IteratorVisitor.prototype.visitTimeSecond = vectorIterator;
IteratorVisitor.prototype.visitTimeMillisecond = vectorIterator;
IteratorVisitor.prototype.visitTimeMicrosecond = vectorIterator;
IteratorVisitor.prototype.visitTimeNanosecond = vectorIterator;
IteratorVisitor.prototype.visitDecimal = vectorIterator;
IteratorVisitor.prototype.visitList = vectorIterator;
IteratorVisitor.prototype.visitStruct = vectorIterator;
IteratorVisitor.prototype.visitUnion = vectorIterator;
IteratorVisitor.prototype.visitDenseUnion = vectorIterator;
IteratorVisitor.prototype.visitSparseUnion = vectorIterator;
IteratorVisitor.prototype.visitDictionary = vectorIterator;
IteratorVisitor.prototype.visitInterval = vectorIterator;
IteratorVisitor.prototype.visitIntervalDayTime = vectorIterator;
IteratorVisitor.prototype.visitIntervalYearMonth = vectorIterator;
IteratorVisitor.prototype.visitDuration = vectorIterator;
IteratorVisitor.prototype.visitDurationSecond = vectorIterator;
IteratorVisitor.prototype.visitDurationMillisecond = vectorIterator;
IteratorVisitor.prototype.visitDurationMicrosecond = vectorIterator;
IteratorVisitor.prototype.visitDurationNanosecond = vectorIterator;
IteratorVisitor.prototype.visitFixedSizeList = vectorIterator;
IteratorVisitor.prototype.visitMap = vectorIterator;
var instance4 = new IteratorVisitor();

// ../core/node_modules/apache-arrow/vector.mjs
var _a2;
var visitorsByTypeId = {};
var vectorPrototypesByTypeId = {};
var Vector = class _Vector {
  constructor(input3) {
    var _b3, _c3, _d3;
    const data = input3[0] instanceof _Vector ? input3.flatMap((x4) => x4.data) : input3;
    if (data.length === 0 || data.some((x4) => !(x4 instanceof Data))) {
      throw new TypeError("Vector constructor expects an Array of Data instances.");
    }
    const type2 = (_b3 = data[0]) === null || _b3 === void 0 ? void 0 : _b3.type;
    switch (data.length) {
      case 0:
        this._offsets = [0];
        break;
      case 1: {
        const { get: get3, set: set3, indexOf: indexOf2 } = visitorsByTypeId[type2.typeId];
        const unchunkedData = data[0];
        this.isValid = (index2) => isChunkedValid(unchunkedData, index2);
        this.get = (index2) => get3(unchunkedData, index2);
        this.set = (index2, value) => set3(unchunkedData, index2, value);
        this.indexOf = (index2) => indexOf2(unchunkedData, index2);
        this._offsets = [0, unchunkedData.length];
        break;
      }
      default:
        Object.setPrototypeOf(this, vectorPrototypesByTypeId[type2.typeId]);
        this._offsets = computeChunkOffsets(data);
        break;
    }
    this.data = data;
    this.type = type2;
    this.stride = strideForType(type2);
    this.numChildren = (_d3 = (_c3 = type2.children) === null || _c3 === void 0 ? void 0 : _c3.length) !== null && _d3 !== void 0 ? _d3 : 0;
    this.length = this._offsets.at(-1);
  }
  /**
   * The aggregate size (in bytes) of this Vector's buffers and/or child Vectors.
   */
  get byteLength() {
    return this.data.reduce((byteLength, data) => byteLength + data.byteLength, 0);
  }
  /**
   * Whether this Vector's elements can contain null values.
   */
  get nullable() {
    return computeChunkNullable(this.data);
  }
  /**
   * The number of null elements in this Vector.
   */
  get nullCount() {
    return computeChunkNullCounts(this.data);
  }
  /**
   * The Array or TypedArray constructor used for the JS representation
   *  of the element's values in {@link Vector.prototype.toArray `toArray()`}.
   */
  get ArrayType() {
    return this.type.ArrayType;
  }
  /**
   * The name that should be printed when the Vector is logged in a message.
   */
  get [Symbol.toStringTag]() {
    return `${this.VectorName}<${this.type[Symbol.toStringTag]}>`;
  }
  /**
   * The name of this Vector.
   */
  get VectorName() {
    return `${Type2[this.type.typeId]}Vector`;
  }
  /**
   * Check whether an element is null.
   * @param index The index at which to read the validity bitmap.
   */
  // @ts-ignore
  isValid(index2) {
    return false;
  }
  /**
   * Get an element value by position.
   * @param index The index of the element to read.
   */
  // @ts-ignore
  get(index2) {
    return null;
  }
  /**
   * Set an element value by position.
   * @param index The index of the element to write.
   * @param value The value to set.
   */
  // @ts-ignore
  set(index2, value) {
    return;
  }
  /**
   * Retrieve the index of the first occurrence of a value in an Vector.
   * @param element The value to locate in the Vector.
   * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
   */
  // @ts-ignore
  indexOf(element, offset2) {
    return -1;
  }
  includes(element, offset2) {
    return this.indexOf(element, offset2) > -1;
  }
  /**
   * Iterator for the Vector's elements.
   */
  [Symbol.iterator]() {
    return instance4.visit(this);
  }
  /**
   * Combines two or more Vectors of the same type.
   * @param others Additional Vectors to add to the end of this Vector.
   */
  concat(...others) {
    return new _Vector(this.data.concat(others.flatMap((x4) => x4.data).flat(Number.POSITIVE_INFINITY)));
  }
  /**
   * Return a zero-copy sub-section of this Vector.
   * @param start The beginning of the specified portion of the Vector.
   * @param end The end of the specified portion of the Vector. This is exclusive of the element at the index 'end'.
   */
  slice(begin, end) {
    return new _Vector(clampRange(this, begin, end, ({ data, _offsets }, begin2, end2) => sliceChunks(data, _offsets, begin2, end2)));
  }
  toJSON() {
    return [...this];
  }
  /**
   * Return a JavaScript Array or TypedArray of the Vector's elements.
   *
   * @note If this Vector contains a single Data chunk and the Vector's type is a
   *  primitive numeric type corresponding to one of the JavaScript TypedArrays, this
   *  method returns a zero-copy slice of the underlying TypedArray values. If there's
   *  more than one chunk, the resulting TypedArray will be a copy of the data from each
   *  chunk's underlying TypedArray values.
   *
   * @returns An Array or TypedArray of the Vector's elements, based on the Vector's DataType.
   */
  toArray() {
    const { type: type2, data, length: length4, stride, ArrayType } = this;
    switch (type2.typeId) {
      case Type2.Int:
      case Type2.Float:
      case Type2.Decimal:
      case Type2.Time:
      case Type2.Timestamp:
        switch (data.length) {
          case 0:
            return new ArrayType();
          case 1:
            return data[0].values.subarray(0, length4 * stride);
          default:
            return data.reduce((memo2, { values: values2, length: chunk_length }) => {
              memo2.array.set(values2.subarray(0, chunk_length * stride), memo2.offset);
              memo2.offset += chunk_length * stride;
              return memo2;
            }, { array: new ArrayType(length4 * stride), offset: 0 }).array;
        }
    }
    return [...this];
  }
  /**
   * Returns a string representation of the Vector.
   *
   * @returns A string representation of the Vector.
   */
  toString() {
    return `[${[...this].join(",")}]`;
  }
  /**
   * Returns a child Vector by name, or null if this Vector has no child with the given name.
   * @param name The name of the child to retrieve.
   */
  getChild(name2) {
    var _b3;
    return this.getChildAt((_b3 = this.type.children) === null || _b3 === void 0 ? void 0 : _b3.findIndex((f2) => f2.name === name2));
  }
  /**
   * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
   * @param index The index of the child to retrieve.
   */
  getChildAt(index2) {
    if (index2 > -1 && index2 < this.numChildren) {
      return new _Vector(this.data.map(({ children: children2 }) => children2[index2]));
    }
    return null;
  }
  get isMemoized() {
    if (DataType.isDictionary(this.type)) {
      return this.data[0].dictionary.isMemoized;
    }
    return false;
  }
  /**
   * Adds memoization to the Vector's {@link get} method. For dictionary
   * vectors, this method return a vector that memoizes only the dictionary
   * values.
   *
   * Memoization is very useful when decoding a value is expensive such as
   * Utf8. The memoization creates a cache of the size of the Vector and
   * therefore increases memory usage.
   *
   * @returns A new vector that memoizes calls to {@link get}.
   */
  memoize() {
    if (DataType.isDictionary(this.type)) {
      const dictionary = new MemoizedVector(this.data[0].dictionary);
      const newData = this.data.map((data) => {
        const cloned = data.clone();
        cloned.dictionary = dictionary;
        return cloned;
      });
      return new _Vector(newData);
    }
    return new MemoizedVector(this);
  }
  /**
   * Returns a vector without memoization of the {@link get} method. If this
   * vector is not memoized, this method returns this vector.
   *
   * @returns A new vector without memoization.
   */
  unmemoize() {
    if (DataType.isDictionary(this.type) && this.isMemoized) {
      const dictionary = this.data[0].dictionary.unmemoize();
      const newData = this.data.map((data) => {
        const newData2 = data.clone();
        newData2.dictionary = dictionary;
        return newData2;
      });
      return new _Vector(newData);
    }
    return this;
  }
};
_a2 = Symbol.toStringTag;
Vector[_a2] = ((proto) => {
  proto.type = DataType.prototype;
  proto.data = [];
  proto.length = 0;
  proto.stride = 1;
  proto.numChildren = 0;
  proto._offsets = new Uint32Array([0]);
  proto[Symbol.isConcatSpreadable] = true;
  const typeIds = Object.keys(Type2).map((T) => Type2[T]).filter((T) => typeof T === "number" && T !== Type2.NONE);
  for (const typeId of typeIds) {
    const get3 = instance2.getVisitFnByTypeId(typeId);
    const set3 = instance.getVisitFnByTypeId(typeId);
    const indexOf2 = instance3.getVisitFnByTypeId(typeId);
    visitorsByTypeId[typeId] = { get: get3, set: set3, indexOf: indexOf2 };
    vectorPrototypesByTypeId[typeId] = Object.create(proto, {
      ["isValid"]: { value: wrapChunkedCall1(isChunkedValid) },
      ["get"]: { value: wrapChunkedCall1(instance2.getVisitFnByTypeId(typeId)) },
      ["set"]: { value: wrapChunkedCall2(instance.getVisitFnByTypeId(typeId)) },
      ["indexOf"]: { value: wrapChunkedIndexOf(instance3.getVisitFnByTypeId(typeId)) }
    });
  }
  return "Vector";
})(Vector.prototype);
var MemoizedVector = class _MemoizedVector extends Vector {
  constructor(vector3) {
    super(vector3.data);
    const get3 = this.get;
    const set3 = this.set;
    const slice4 = this.slice;
    const cache = new Array(this.length);
    Object.defineProperty(this, "get", {
      value(index2) {
        const cachedValue = cache[index2];
        if (cachedValue !== void 0) {
          return cachedValue;
        }
        const value = get3.call(this, index2);
        cache[index2] = value;
        return value;
      }
    });
    Object.defineProperty(this, "set", {
      value(index2, value) {
        set3.call(this, index2, value);
        cache[index2] = value;
      }
    });
    Object.defineProperty(this, "slice", {
      value: (begin, end) => new _MemoizedVector(slice4.call(this, begin, end))
    });
    Object.defineProperty(this, "isMemoized", { value: true });
    Object.defineProperty(this, "unmemoize", {
      value: () => new Vector(this.data)
    });
    Object.defineProperty(this, "memoize", {
      value: () => this
    });
  }
};

// ../core/node_modules/apache-arrow/builder/valid.mjs
function createIsValidFunction(nullValues) {
  if (!nullValues || nullValues.length <= 0) {
    return function isValid(value) {
      return true;
    };
  }
  let fnBody = "";
  const noNaNs = nullValues.filter((x4) => x4 === x4);
  if (noNaNs.length > 0) {
    fnBody = `
    switch (x) {${noNaNs.map((x4) => `
        case ${valueToCase(x4)}:`).join("")}
            return false;
    }`;
  }
  if (nullValues.length !== noNaNs.length) {
    fnBody = `if (x !== x) return false;
${fnBody}`;
  }
  return new Function(`x`, `${fnBody}
return true;`);
}
function valueToCase(x4) {
  if (typeof x4 !== "bigint") {
    return valueToString(x4);
  }
  return `${valueToString(x4)}n`;
}

// ../core/node_modules/apache-arrow/builder/buffer.mjs
function roundLengthUpToNearest64Bytes(len, BPE) {
  const bytesMinus1 = Math.ceil(len) * BPE - 1;
  return (bytesMinus1 - bytesMinus1 % 64 + 64 || 64) / BPE;
}
function resizeArray(arr, len = 0) {
  return arr.length >= len ? arr.subarray(0, len) : memcpy(new arr.constructor(len), arr, 0);
}
var BufferBuilder = class {
  constructor(bufferType, initialSize = 0, stride = 1) {
    this.length = Math.ceil(initialSize / stride);
    this.buffer = new bufferType(this.length);
    this.stride = stride;
    this.BYTES_PER_ELEMENT = bufferType.BYTES_PER_ELEMENT;
    this.ArrayType = bufferType;
  }
  get byteLength() {
    return Math.ceil(this.length * this.stride) * this.BYTES_PER_ELEMENT;
  }
  get reservedLength() {
    return this.buffer.length / this.stride;
  }
  get reservedByteLength() {
    return this.buffer.byteLength;
  }
  // @ts-ignore
  set(index2, value) {
    return this;
  }
  append(value) {
    return this.set(this.length, value);
  }
  reserve(extra) {
    if (extra > 0) {
      this.length += extra;
      const stride = this.stride;
      const length4 = this.length * stride;
      const reserved = this.buffer.length;
      if (length4 >= reserved) {
        this._resize(reserved === 0 ? roundLengthUpToNearest64Bytes(length4 * 1, this.BYTES_PER_ELEMENT) : roundLengthUpToNearest64Bytes(length4 * 2, this.BYTES_PER_ELEMENT));
      }
    }
    return this;
  }
  flush(length4 = this.length) {
    length4 = roundLengthUpToNearest64Bytes(length4 * this.stride, this.BYTES_PER_ELEMENT);
    const array4 = resizeArray(this.buffer, length4);
    this.clear();
    return array4;
  }
  clear() {
    this.length = 0;
    this.buffer = new this.ArrayType();
    return this;
  }
  _resize(newLength) {
    return this.buffer = resizeArray(this.buffer, newLength);
  }
};
var DataBufferBuilder = class extends BufferBuilder {
  last() {
    return this.get(this.length - 1);
  }
  get(index2) {
    return this.buffer[index2];
  }
  set(index2, value) {
    this.reserve(index2 - this.length + 1);
    this.buffer[index2 * this.stride] = value;
    return this;
  }
};
var BitmapBufferBuilder = class extends DataBufferBuilder {
  constructor() {
    super(Uint8Array, 0, 1 / 8);
    this.numValid = 0;
  }
  get numInvalid() {
    return this.length - this.numValid;
  }
  get(idx) {
    return this.buffer[idx >> 3] >> idx % 8 & 1;
  }
  set(idx, val) {
    const { buffer } = this.reserve(idx - this.length + 1);
    const byte = idx >> 3, bit = idx % 8, cur = buffer[byte] >> bit & 1;
    val ? cur === 0 && (buffer[byte] |= 1 << bit, ++this.numValid) : cur === 1 && (buffer[byte] &= ~(1 << bit), --this.numValid);
    return this;
  }
  clear() {
    this.numValid = 0;
    return super.clear();
  }
};
var OffsetsBufferBuilder = class extends DataBufferBuilder {
  constructor(type2) {
    super(type2.OffsetArrayType, 1, 1);
  }
  append(value) {
    return this.set(this.length - 1, value);
  }
  set(index2, value) {
    const offset2 = this.length - 1;
    const buffer = this.reserve(index2 - offset2 + 1).buffer;
    if (offset2 < index2++ && offset2 >= 0) {
      buffer.fill(buffer[offset2], offset2, index2);
    }
    buffer[index2] = buffer[index2 - 1] + value;
    return this;
  }
  flush(length4 = this.length - 1) {
    if (length4 > this.length) {
      this.set(length4 - 1, this.BYTES_PER_ELEMENT > 4 ? BigInt(0) : 0);
    }
    return super.flush(length4 + 1);
  }
};

// ../core/node_modules/apache-arrow/builder.mjs
var Builder2 = class {
  /** @nocollapse */
  // @ts-ignore
  static throughNode(options) {
    throw new Error(`"throughNode" not available in this environment`);
  }
  /** @nocollapse */
  // @ts-ignore
  static throughDOM(options) {
    throw new Error(`"throughDOM" not available in this environment`);
  }
  /**
   * Construct a builder with the given Arrow DataType with optional null values,
   * which will be interpreted as "null" when set or appended to the `Builder`.
   * @param {{ type: T, nullValues?: any[] }} options A `BuilderOptions` object used to create this `Builder`.
   */
  constructor({ "type": type2, "nullValues": nulls }) {
    this.length = 0;
    this.finished = false;
    this.type = type2;
    this.children = [];
    this.nullValues = nulls;
    this.stride = strideForType(type2);
    this._nulls = new BitmapBufferBuilder();
    if (nulls && nulls.length > 0) {
      this._isValid = createIsValidFunction(nulls);
    }
  }
  /**
   * Flush the `Builder` and return a `Vector<T>`.
   * @returns {Vector<T>} A `Vector<T>` of the flushed values.
   */
  toVector() {
    return new Vector([this.flush()]);
  }
  get ArrayType() {
    return this.type.ArrayType;
  }
  get nullCount() {
    return this._nulls.numInvalid;
  }
  get numChildren() {
    return this.children.length;
  }
  /**
   * @returns The aggregate length (in bytes) of the values that have been written.
   */
  get byteLength() {
    let size = 0;
    const { _offsets, _values, _nulls, _typeIds, children: children2 } = this;
    _offsets && (size += _offsets.byteLength);
    _values && (size += _values.byteLength);
    _nulls && (size += _nulls.byteLength);
    _typeIds && (size += _typeIds.byteLength);
    return children2.reduce((size2, child) => size2 + child.byteLength, size);
  }
  /**
   * @returns The aggregate number of rows that have been reserved to write new values.
   */
  get reservedLength() {
    return this._nulls.reservedLength;
  }
  /**
   * @returns The aggregate length (in bytes) that has been reserved to write new values.
   */
  get reservedByteLength() {
    let size = 0;
    this._offsets && (size += this._offsets.reservedByteLength);
    this._values && (size += this._values.reservedByteLength);
    this._nulls && (size += this._nulls.reservedByteLength);
    this._typeIds && (size += this._typeIds.reservedByteLength);
    return this.children.reduce((size2, child) => size2 + child.reservedByteLength, size);
  }
  get valueOffsets() {
    return this._offsets ? this._offsets.buffer : null;
  }
  get values() {
    return this._values ? this._values.buffer : null;
  }
  get nullBitmap() {
    return this._nulls ? this._nulls.buffer : null;
  }
  get typeIds() {
    return this._typeIds ? this._typeIds.buffer : null;
  }
  /**
   * Appends a value (or null) to this `Builder`.
   * This is equivalent to `builder.set(builder.length, value)`.
   * @param {T['TValue'] | TNull } value The value to append.
   */
  append(value) {
    return this.set(this.length, value);
  }
  /**
   * Validates whether a value is valid (true), or null (false)
   * @param {T['TValue'] | TNull } value The value to compare against null the value representations
   */
  isValid(value) {
    return this._isValid(value);
  }
  /**
   * Write a value (or null-value sentinel) at the supplied index.
   * If the value matches one of the null-value representations, a 1-bit is
   * written to the null `BitmapBufferBuilder`. Otherwise, a 0 is written to
   * the null `BitmapBufferBuilder`, and the value is passed to
   * `Builder.prototype.setValue()`.
   * @param {number} index The index of the value to write.
   * @param {T['TValue'] | TNull } value The value to write at the supplied index.
   * @returns {this} The updated `Builder` instance.
   */
  set(index2, value) {
    if (this.setValid(index2, this.isValid(value))) {
      this.setValue(index2, value);
    }
    return this;
  }
  /**
   * Write a value to the underlying buffers at the supplied index, bypassing
   * the null-value check. This is a low-level method that
   * @param {number} index
   * @param {T['TValue'] | TNull } value
   */
  setValue(index2, value) {
    this._setValue(this, index2, value);
  }
  setValid(index2, valid2) {
    this.length = this._nulls.set(index2, +valid2).length;
    return valid2;
  }
  // @ts-ignore
  addChild(child, name2 = `${this.numChildren}`) {
    throw new Error(`Cannot append children to non-nested type "${this.type}"`);
  }
  /**
   * Retrieve the child `Builder` at the supplied `index`, or null if no child
   * exists at that index.
   * @param {number} index The index of the child `Builder` to retrieve.
   * @returns {Builder | null} The child Builder at the supplied index or null.
   */
  getChildAt(index2) {
    return this.children[index2] || null;
  }
  /**
   * Commit all the values that have been written to their underlying
   * ArrayBuffers, including any child Builders if applicable, and reset
   * the internal `Builder` state.
   * @returns A `Data<T>` of the buffers and children representing the values written.
   */
  flush() {
    let data;
    let typeIds;
    let nullBitmap;
    let valueOffsets;
    const { type: type2, length: length4, nullCount, _typeIds, _offsets, _values, _nulls } = this;
    if (typeIds = _typeIds === null || _typeIds === void 0 ? void 0 : _typeIds.flush(length4)) {
      valueOffsets = _offsets === null || _offsets === void 0 ? void 0 : _offsets.flush(length4);
    } else if (valueOffsets = _offsets === null || _offsets === void 0 ? void 0 : _offsets.flush(length4)) {
      data = _values === null || _values === void 0 ? void 0 : _values.flush(_offsets.last());
    } else {
      data = _values === null || _values === void 0 ? void 0 : _values.flush(length4);
    }
    if (nullCount > 0) {
      nullBitmap = _nulls === null || _nulls === void 0 ? void 0 : _nulls.flush(length4);
    }
    const children2 = this.children.map((child) => child.flush());
    this.clear();
    return makeData({
      type: type2,
      length: length4,
      nullCount,
      children: children2,
      "child": children2[0],
      data,
      typeIds,
      nullBitmap,
      valueOffsets
    });
  }
  /**
   * Finalize this `Builder`, and child builders if applicable.
   * @returns {this} The finalized `Builder` instance.
   */
  finish() {
    this.finished = true;
    for (const child of this.children)
      child.finish();
    return this;
  }
  /**
   * Clear this Builder's internal state, including child Builders if applicable, and reset the length to 0.
   * @returns {this} The cleared `Builder` instance.
   */
  clear() {
    var _a9, _b3, _c3, _d3;
    this.length = 0;
    (_a9 = this._nulls) === null || _a9 === void 0 ? void 0 : _a9.clear();
    (_b3 = this._values) === null || _b3 === void 0 ? void 0 : _b3.clear();
    (_c3 = this._offsets) === null || _c3 === void 0 ? void 0 : _c3.clear();
    (_d3 = this._typeIds) === null || _d3 === void 0 ? void 0 : _d3.clear();
    for (const child of this.children)
      child.clear();
    return this;
  }
};
Builder2.prototype.length = 1;
Builder2.prototype.stride = 1;
Builder2.prototype.children = null;
Builder2.prototype.finished = false;
Builder2.prototype.nullValues = null;
Builder2.prototype._isValid = () => true;
var FixedWidthBuilder = class extends Builder2 {
  constructor(opts) {
    super(opts);
    this._values = new DataBufferBuilder(this.ArrayType, 0, this.stride);
  }
  setValue(index2, value) {
    const values2 = this._values;
    values2.reserve(index2 - values2.length + 1);
    return super.setValue(index2, value);
  }
};
var VariableWidthBuilder = class extends Builder2 {
  constructor(opts) {
    super(opts);
    this._pendingLength = 0;
    this._offsets = new OffsetsBufferBuilder(opts.type);
  }
  setValue(index2, value) {
    const pending = this._pending || (this._pending = /* @__PURE__ */ new Map());
    const current = pending.get(index2);
    current && (this._pendingLength -= current.length);
    this._pendingLength += value instanceof MapRow ? value[kKeys].length : value.length;
    pending.set(index2, value);
  }
  setValid(index2, isValid) {
    if (!super.setValid(index2, isValid)) {
      (this._pending || (this._pending = /* @__PURE__ */ new Map())).set(index2, void 0);
      return false;
    }
    return true;
  }
  clear() {
    this._pendingLength = 0;
    this._pending = void 0;
    return super.clear();
  }
  flush() {
    this._flush();
    return super.flush();
  }
  finish() {
    this._flush();
    return super.finish();
  }
  _flush() {
    const pending = this._pending;
    const pendingLength = this._pendingLength;
    this._pendingLength = 0;
    this._pending = void 0;
    if (pending && pending.size > 0) {
      this._flushPending(pending, pendingLength);
    }
    return this;
  }
};

// ../core/node_modules/apache-arrow/fb/block.mjs
var Block = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  /**
   * Index to the start of the RecordBlock (note this is past the Message header)
   */
  offset() {
    return this.bb.readInt64(this.bb_pos);
  }
  /**
   * Length of the metadata
   */
  metaDataLength() {
    return this.bb.readInt32(this.bb_pos + 8);
  }
  /**
   * Length of the data (this is aligned so there can be a gap between this and
   * the metadata).
   */
  bodyLength() {
    return this.bb.readInt64(this.bb_pos + 16);
  }
  static sizeOf() {
    return 24;
  }
  static createBlock(builder, offset2, metaDataLength, bodyLength) {
    builder.prep(8, 24);
    builder.writeInt64(BigInt(bodyLength !== null && bodyLength !== void 0 ? bodyLength : 0));
    builder.pad(4);
    builder.writeInt32(metaDataLength);
    builder.writeInt64(BigInt(offset2 !== null && offset2 !== void 0 ? offset2 : 0));
    return builder.offset();
  }
};

// ../core/node_modules/apache-arrow/fb/footer.mjs
var Footer = class _Footer {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsFooter(bb2, obj) {
    return (obj || new _Footer()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsFooter(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Footer()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  version() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : MetadataVersion.V1;
  }
  schema(obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? (obj || new Schema()).__init(this.bb.__indirect(this.bb_pos + offset2), this.bb) : null;
  }
  dictionaries(index2, obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 8);
    return offset2 ? (obj || new Block()).__init(this.bb.__vector(this.bb_pos + offset2) + index2 * 24, this.bb) : null;
  }
  dictionariesLength() {
    const offset2 = this.bb.__offset(this.bb_pos, 8);
    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
  }
  recordBatches(index2, obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 10);
    return offset2 ? (obj || new Block()).__init(this.bb.__vector(this.bb_pos + offset2) + index2 * 24, this.bb) : null;
  }
  recordBatchesLength() {
    const offset2 = this.bb.__offset(this.bb_pos, 10);
    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
  }
  /**
   * User-defined metadata
   */
  customMetadata(index2, obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 12);
    return offset2 ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset2) + index2 * 4), this.bb) : null;
  }
  customMetadataLength() {
    const offset2 = this.bb.__offset(this.bb_pos, 12);
    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
  }
  static startFooter(builder) {
    builder.startObject(5);
  }
  static addVersion(builder, version) {
    builder.addFieldInt16(0, version, MetadataVersion.V1);
  }
  static addSchema(builder, schemaOffset) {
    builder.addFieldOffset(1, schemaOffset, 0);
  }
  static addDictionaries(builder, dictionariesOffset) {
    builder.addFieldOffset(2, dictionariesOffset, 0);
  }
  static startDictionariesVector(builder, numElems) {
    builder.startVector(24, numElems, 8);
  }
  static addRecordBatches(builder, recordBatchesOffset) {
    builder.addFieldOffset(3, recordBatchesOffset, 0);
  }
  static startRecordBatchesVector(builder, numElems) {
    builder.startVector(24, numElems, 8);
  }
  static addCustomMetadata(builder, customMetadataOffset) {
    builder.addFieldOffset(4, customMetadataOffset, 0);
  }
  static createCustomMetadataVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startCustomMetadataVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static endFooter(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static finishFooterBuffer(builder, offset2) {
    builder.finish(offset2);
  }
  static finishSizePrefixedFooterBuffer(builder, offset2) {
    builder.finish(offset2, void 0, true);
  }
};

// ../core/node_modules/apache-arrow/schema.mjs
var Schema2 = class _Schema {
  constructor(fields = [], metadata, dictionaries, metadataVersion = MetadataVersion.V5) {
    this.fields = fields || [];
    this.metadata = metadata || /* @__PURE__ */ new Map();
    if (!dictionaries) {
      dictionaries = generateDictionaryMap(fields);
    }
    this.dictionaries = dictionaries;
    this.metadataVersion = metadataVersion;
  }
  get [Symbol.toStringTag]() {
    return "Schema";
  }
  get names() {
    return this.fields.map((f2) => f2.name);
  }
  toString() {
    return `Schema<{ ${this.fields.map((f2, i) => `${i}: ${f2}`).join(", ")} }>`;
  }
  /**
   * Construct a new Schema containing only specified fields.
   *
   * @param fieldNames Names of fields to keep.
   * @returns A new Schema of fields matching the specified names.
   */
  select(fieldNames) {
    const names = new Set(fieldNames);
    const fields = this.fields.filter((f2) => names.has(f2.name));
    return new _Schema(fields, this.metadata);
  }
  /**
   * Construct a new Schema containing only fields at the specified indices.
   *
   * @param fieldIndices Indices of fields to keep.
   * @returns A new Schema of fields at the specified indices.
   */
  selectAt(fieldIndices) {
    const fields = fieldIndices.map((i) => this.fields[i]).filter(Boolean);
    return new _Schema(fields, this.metadata);
  }
  assign(...args) {
    const other = args[0] instanceof _Schema ? args[0] : Array.isArray(args[0]) ? new _Schema(args[0]) : new _Schema(args);
    const curFields = [...this.fields];
    const metadata = mergeMaps(mergeMaps(/* @__PURE__ */ new Map(), this.metadata), other.metadata);
    const newFields = other.fields.filter((f2) => {
      const i = curFields.findIndex((f3) => f3.name === f2.name);
      return ~i ? (curFields[i] = f2.clone({
        metadata: mergeMaps(mergeMaps(/* @__PURE__ */ new Map(), curFields[i].metadata), f2.metadata)
      })) && false : true;
    });
    const newDictionaries = generateDictionaryMap(newFields, /* @__PURE__ */ new Map());
    return new _Schema([...curFields, ...newFields], metadata, new Map([...this.dictionaries, ...newDictionaries]));
  }
};
Schema2.prototype.fields = null;
Schema2.prototype.metadata = null;
Schema2.prototype.dictionaries = null;
var Field2 = class _Field {
  /** @nocollapse */
  static new(...args) {
    let [name2, type2, nullable, metadata] = args;
    if (args[0] && typeof args[0] === "object") {
      ({ name: name2 } = args[0]);
      type2 === void 0 && (type2 = args[0].type);
      nullable === void 0 && (nullable = args[0].nullable);
      metadata === void 0 && (metadata = args[0].metadata);
    }
    return new _Field(`${name2}`, type2, nullable, metadata);
  }
  constructor(name2, type2, nullable = false, metadata) {
    this.name = name2;
    this.type = type2;
    this.nullable = nullable;
    this.metadata = metadata || /* @__PURE__ */ new Map();
  }
  get typeId() {
    return this.type.typeId;
  }
  get [Symbol.toStringTag]() {
    return "Field";
  }
  toString() {
    return `${this.name}: ${this.type}`;
  }
  clone(...args) {
    let [name2, type2, nullable, metadata] = args;
    !args[0] || typeof args[0] !== "object" ? [name2 = this.name, type2 = this.type, nullable = this.nullable, metadata = this.metadata] = args : { name: name2 = this.name, type: type2 = this.type, nullable = this.nullable, metadata = this.metadata } = args[0];
    return _Field.new(name2, type2, nullable, metadata);
  }
};
Field2.prototype.type = null;
Field2.prototype.name = null;
Field2.prototype.nullable = null;
Field2.prototype.metadata = null;
function mergeMaps(m1, m2) {
  return new Map([...m1 || /* @__PURE__ */ new Map(), ...m2 || /* @__PURE__ */ new Map()]);
}
function generateDictionaryMap(fields, dictionaries = /* @__PURE__ */ new Map()) {
  for (let i = -1, n = fields.length; ++i < n; ) {
    const field2 = fields[i];
    const type2 = field2.type;
    if (DataType.isDictionary(type2)) {
      if (!dictionaries.has(type2.id)) {
        dictionaries.set(type2.id, type2.dictionary);
      } else if (dictionaries.get(type2.id) !== type2.dictionary) {
        throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);
      }
    }
    if (type2.children && type2.children.length > 0) {
      generateDictionaryMap(type2.children, dictionaries);
    }
  }
  return dictionaries;
}

// ../core/node_modules/apache-arrow/ipc/metadata/file.mjs
var Builder3 = Builder;
var ByteBuffer2 = ByteBuffer;
var Footer_ = class {
  /** @nocollapse */
  static decode(buf) {
    buf = new ByteBuffer2(toUint8Array(buf));
    const footer = Footer.getRootAsFooter(buf);
    const schema = Schema2.decode(footer.schema(), /* @__PURE__ */ new Map(), footer.version());
    return new OffHeapFooter(schema, footer);
  }
  /** @nocollapse */
  static encode(footer) {
    const b2 = new Builder3();
    const schemaOffset = Schema2.encode(b2, footer.schema);
    Footer.startRecordBatchesVector(b2, footer.numRecordBatches);
    for (const rb of [...footer.recordBatches()].slice().reverse()) {
      FileBlock.encode(b2, rb);
    }
    const recordBatchesOffset = b2.endVector();
    Footer.startDictionariesVector(b2, footer.numDictionaries);
    for (const db of [...footer.dictionaryBatches()].slice().reverse()) {
      FileBlock.encode(b2, db);
    }
    const dictionaryBatchesOffset = b2.endVector();
    Footer.startFooter(b2);
    Footer.addSchema(b2, schemaOffset);
    Footer.addVersion(b2, MetadataVersion.V5);
    Footer.addRecordBatches(b2, recordBatchesOffset);
    Footer.addDictionaries(b2, dictionaryBatchesOffset);
    Footer.finishFooterBuffer(b2, Footer.endFooter(b2));
    return b2.asUint8Array();
  }
  get numRecordBatches() {
    return this._recordBatches.length;
  }
  get numDictionaries() {
    return this._dictionaryBatches.length;
  }
  constructor(schema, version = MetadataVersion.V5, recordBatches, dictionaryBatches) {
    this.schema = schema;
    this.version = version;
    recordBatches && (this._recordBatches = recordBatches);
    dictionaryBatches && (this._dictionaryBatches = dictionaryBatches);
  }
  *recordBatches() {
    for (let block, i = -1, n = this.numRecordBatches; ++i < n; ) {
      if (block = this.getRecordBatch(i)) {
        yield block;
      }
    }
  }
  *dictionaryBatches() {
    for (let block, i = -1, n = this.numDictionaries; ++i < n; ) {
      if (block = this.getDictionaryBatch(i)) {
        yield block;
      }
    }
  }
  getRecordBatch(index2) {
    return index2 >= 0 && index2 < this.numRecordBatches && this._recordBatches[index2] || null;
  }
  getDictionaryBatch(index2) {
    return index2 >= 0 && index2 < this.numDictionaries && this._dictionaryBatches[index2] || null;
  }
};
var OffHeapFooter = class extends Footer_ {
  get numRecordBatches() {
    return this._footer.recordBatchesLength();
  }
  get numDictionaries() {
    return this._footer.dictionariesLength();
  }
  constructor(schema, _footer) {
    super(schema, _footer.version());
    this._footer = _footer;
  }
  getRecordBatch(index2) {
    if (index2 >= 0 && index2 < this.numRecordBatches) {
      const fileBlock = this._footer.recordBatches(index2);
      if (fileBlock) {
        return FileBlock.decode(fileBlock);
      }
    }
    return null;
  }
  getDictionaryBatch(index2) {
    if (index2 >= 0 && index2 < this.numDictionaries) {
      const fileBlock = this._footer.dictionaries(index2);
      if (fileBlock) {
        return FileBlock.decode(fileBlock);
      }
    }
    return null;
  }
};
var FileBlock = class _FileBlock {
  /** @nocollapse */
  static decode(block) {
    return new _FileBlock(block.metaDataLength(), block.bodyLength(), block.offset());
  }
  /** @nocollapse */
  static encode(b2, fileBlock) {
    const { metaDataLength } = fileBlock;
    const offset2 = BigInt(fileBlock.offset);
    const bodyLength = BigInt(fileBlock.bodyLength);
    return Block.createBlock(b2, offset2, metaDataLength, bodyLength);
  }
  constructor(metaDataLength, bodyLength, offset2) {
    this.metaDataLength = metaDataLength;
    this.offset = bigIntToNumber(offset2);
    this.bodyLength = bigIntToNumber(bodyLength);
  }
};

// ../core/node_modules/apache-arrow/io/interfaces.mjs
var ITERATOR_DONE = Object.freeze({ done: true, value: void 0 });
var ArrowJSON = class {
  constructor(_json) {
    this._json = _json;
  }
  get schema() {
    return this._json["schema"];
  }
  get batches() {
    return this._json["batches"] || [];
  }
  get dictionaries() {
    return this._json["dictionaries"] || [];
  }
};
var ReadableInterop = class {
  tee() {
    return this._getDOMStream().tee();
  }
  pipe(writable, options) {
    return this._getNodeStream().pipe(writable, options);
  }
  pipeTo(writable, options) {
    return this._getDOMStream().pipeTo(writable, options);
  }
  pipeThrough(duplex, options) {
    return this._getDOMStream().pipeThrough(duplex, options);
  }
  _getDOMStream() {
    return this._DOMStream || (this._DOMStream = this.toDOMStream());
  }
  _getNodeStream() {
    return this._nodeStream || (this._nodeStream = this.toNodeStream());
  }
};
var AsyncQueue = class extends ReadableInterop {
  constructor() {
    super();
    this._values = [];
    this.resolvers = [];
    this._closedPromise = new Promise((r) => this._closedPromiseResolve = r);
  }
  get closed() {
    return this._closedPromise;
  }
  cancel(reason) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.return(reason);
    });
  }
  write(value) {
    if (this._ensureOpen()) {
      this.resolvers.length <= 0 ? this._values.push(value) : this.resolvers.shift().resolve({ done: false, value });
    }
  }
  abort(value) {
    if (this._closedPromiseResolve) {
      this.resolvers.length <= 0 ? this._error = { error: value } : this.resolvers.shift().reject({ done: true, value });
    }
  }
  close() {
    if (this._closedPromiseResolve) {
      const { resolvers } = this;
      while (resolvers.length > 0) {
        resolvers.shift().resolve(ITERATOR_DONE);
      }
      this._closedPromiseResolve();
      this._closedPromiseResolve = void 0;
    }
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  toDOMStream(options) {
    return adapters_default.toDOMStream(this._closedPromiseResolve || this._error ? this : this._values, options);
  }
  toNodeStream(options) {
    return adapters_default.toNodeStream(this._closedPromiseResolve || this._error ? this : this._values, options);
  }
  throw(_2) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.abort(_2);
      return ITERATOR_DONE;
    });
  }
  return(_2) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.close();
      return ITERATOR_DONE;
    });
  }
  read(size) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.next(size, "read")).value;
    });
  }
  peek(size) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.next(size, "peek")).value;
    });
  }
  next(..._args) {
    if (this._values.length > 0) {
      return Promise.resolve({ done: false, value: this._values.shift() });
    } else if (this._error) {
      return Promise.reject({ done: true, value: this._error.error });
    } else if (!this._closedPromiseResolve) {
      return Promise.resolve(ITERATOR_DONE);
    } else {
      return new Promise((resolve, reject) => {
        this.resolvers.push({ resolve, reject });
      });
    }
  }
  _ensureOpen() {
    if (this._closedPromiseResolve) {
      return true;
    }
    throw new Error(`AsyncQueue is closed`);
  }
};

// ../core/node_modules/apache-arrow/io/stream.mjs
var AsyncByteQueue = class extends AsyncQueue {
  write(value) {
    if ((value = toUint8Array(value)).byteLength > 0) {
      return super.write(value);
    }
  }
  toString(sync = false) {
    return sync ? decodeUtf8(this.toUint8Array(true)) : this.toUint8Array(false).then(decodeUtf8);
  }
  toUint8Array(sync = false) {
    return sync ? joinUint8Arrays(this._values)[0] : (() => __awaiter(this, void 0, void 0, function* () {
      var _a9, e_1, _b3, _c3;
      const buffers = [];
      let byteLength = 0;
      try {
        for (var _d3 = true, _e3 = __asyncValues(this), _f3; _f3 = yield _e3.next(), _a9 = _f3.done, !_a9; _d3 = true) {
          _c3 = _f3.value;
          _d3 = false;
          const chunk = _c3;
          buffers.push(chunk);
          byteLength += chunk.byteLength;
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (!_d3 && !_a9 && (_b3 = _e3.return))
            yield _b3.call(_e3);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return joinUint8Arrays(buffers, byteLength)[0];
    }))();
  }
};
var ByteStream = class {
  constructor(source) {
    if (source) {
      this.source = new ByteStreamSource(adapters_default.fromIterable(source));
    }
  }
  [Symbol.iterator]() {
    return this;
  }
  next(value) {
    return this.source.next(value);
  }
  throw(value) {
    return this.source.throw(value);
  }
  return(value) {
    return this.source.return(value);
  }
  peek(size) {
    return this.source.peek(size);
  }
  read(size) {
    return this.source.read(size);
  }
};
var AsyncByteStream = class _AsyncByteStream {
  constructor(source) {
    if (source instanceof _AsyncByteStream) {
      this.source = source.source;
    } else if (source instanceof AsyncByteQueue) {
      this.source = new AsyncByteStreamSource(adapters_default.fromAsyncIterable(source));
    } else if (isReadableNodeStream(source)) {
      this.source = new AsyncByteStreamSource(adapters_default.fromNodeStream(source));
    } else if (isReadableDOMStream(source)) {
      this.source = new AsyncByteStreamSource(adapters_default.fromDOMStream(source));
    } else if (isFetchResponse(source)) {
      this.source = new AsyncByteStreamSource(adapters_default.fromDOMStream(source.body));
    } else if (isIterable(source)) {
      this.source = new AsyncByteStreamSource(adapters_default.fromIterable(source));
    } else if (isPromise(source)) {
      this.source = new AsyncByteStreamSource(adapters_default.fromAsyncIterable(source));
    } else if (isAsyncIterable(source)) {
      this.source = new AsyncByteStreamSource(adapters_default.fromAsyncIterable(source));
    }
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  next(value) {
    return this.source.next(value);
  }
  throw(value) {
    return this.source.throw(value);
  }
  return(value) {
    return this.source.return(value);
  }
  get closed() {
    return this.source.closed;
  }
  cancel(reason) {
    return this.source.cancel(reason);
  }
  peek(size) {
    return this.source.peek(size);
  }
  read(size) {
    return this.source.read(size);
  }
};
var ByteStreamSource = class {
  constructor(source) {
    this.source = source;
  }
  cancel(reason) {
    this.return(reason);
  }
  peek(size) {
    return this.next(size, "peek").value;
  }
  read(size) {
    return this.next(size, "read").value;
  }
  next(size, cmd = "read") {
    return this.source.next({ cmd, size });
  }
  throw(value) {
    return Object.create(this.source.throw && this.source.throw(value) || ITERATOR_DONE);
  }
  return(value) {
    return Object.create(this.source.return && this.source.return(value) || ITERATOR_DONE);
  }
};
var AsyncByteStreamSource = class {
  constructor(source) {
    this.source = source;
    this._closedPromise = new Promise((r) => this._closedPromiseResolve = r);
  }
  cancel(reason) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.return(reason);
    });
  }
  get closed() {
    return this._closedPromise;
  }
  read(size) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.next(size, "read")).value;
    });
  }
  peek(size) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.next(size, "peek")).value;
    });
  }
  next(size, cmd = "read") {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this.source.next({ cmd, size });
    });
  }
  throw(value) {
    return __awaiter(this, void 0, void 0, function* () {
      const result = this.source.throw && (yield this.source.throw(value)) || ITERATOR_DONE;
      this._closedPromiseResolve && this._closedPromiseResolve();
      this._closedPromiseResolve = void 0;
      return Object.create(result);
    });
  }
  return(value) {
    return __awaiter(this, void 0, void 0, function* () {
      const result = this.source.return && (yield this.source.return(value)) || ITERATOR_DONE;
      this._closedPromiseResolve && this._closedPromiseResolve();
      this._closedPromiseResolve = void 0;
      return Object.create(result);
    });
  }
};

// ../core/node_modules/apache-arrow/io/file.mjs
var RandomAccessFile = class extends ByteStream {
  constructor(buffer, byteLength) {
    super();
    this.position = 0;
    this.buffer = toUint8Array(buffer);
    this.size = byteLength === void 0 ? this.buffer.byteLength : byteLength;
  }
  readInt32(position3) {
    const { buffer, byteOffset } = this.readAt(position3, 4);
    return new DataView(buffer, byteOffset).getInt32(0, true);
  }
  seek(position3) {
    this.position = Math.min(position3, this.size);
    return position3 < this.size;
  }
  read(nBytes) {
    const { buffer, size, position: position3 } = this;
    if (buffer && position3 < size) {
      if (typeof nBytes !== "number") {
        nBytes = Number.POSITIVE_INFINITY;
      }
      this.position = Math.min(size, position3 + Math.min(size - position3, nBytes));
      return buffer.subarray(position3, this.position);
    }
    return null;
  }
  readAt(position3, nBytes) {
    const buf = this.buffer;
    const end = Math.min(this.size, position3 + nBytes);
    return buf ? buf.subarray(position3, end) : new Uint8Array(nBytes);
  }
  close() {
    this.buffer && (this.buffer = null);
  }
  throw(value) {
    this.close();
    return { done: true, value };
  }
  return(value) {
    this.close();
    return { done: true, value };
  }
};
var AsyncRandomAccessFile = class extends AsyncByteStream {
  constructor(file, byteLength) {
    super();
    this.position = 0;
    this._handle = file;
    if (typeof byteLength === "number") {
      this.size = byteLength;
    } else {
      this._pending = (() => __awaiter(this, void 0, void 0, function* () {
        this.size = (yield file.stat()).size;
        delete this._pending;
      }))();
    }
  }
  readInt32(position3) {
    return __awaiter(this, void 0, void 0, function* () {
      const { buffer, byteOffset } = yield this.readAt(position3, 4);
      return new DataView(buffer, byteOffset).getInt32(0, true);
    });
  }
  seek(position3) {
    return __awaiter(this, void 0, void 0, function* () {
      this._pending && (yield this._pending);
      this.position = Math.min(position3, this.size);
      return position3 < this.size;
    });
  }
  read(nBytes) {
    return __awaiter(this, void 0, void 0, function* () {
      this._pending && (yield this._pending);
      const { _handle: file, size, position: position3 } = this;
      if (file && position3 < size) {
        if (typeof nBytes !== "number") {
          nBytes = Number.POSITIVE_INFINITY;
        }
        let pos = position3, offset2 = 0, bytesRead = 0;
        const end = Math.min(size, pos + Math.min(size - pos, nBytes));
        const buffer = new Uint8Array(Math.max(0, (this.position = end) - pos));
        while ((pos += bytesRead) < end && (offset2 += bytesRead) < buffer.byteLength) {
          ({ bytesRead } = yield file.read(buffer, offset2, buffer.byteLength - offset2, pos));
        }
        return buffer;
      }
      return null;
    });
  }
  readAt(position3, nBytes) {
    return __awaiter(this, void 0, void 0, function* () {
      this._pending && (yield this._pending);
      const { _handle: file, size } = this;
      if (file && position3 + nBytes < size) {
        const end = Math.min(size, position3 + nBytes);
        const buffer = new Uint8Array(end - position3);
        return (yield file.read(buffer, 0, nBytes, position3)).buffer;
      }
      return new Uint8Array(nBytes);
    });
  }
  close() {
    return __awaiter(this, void 0, void 0, function* () {
      const f2 = this._handle;
      this._handle = null;
      f2 && (yield f2.close());
    });
  }
  throw(value) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.close();
      return { done: true, value };
    });
  }
  return(value) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.close();
      return { done: true, value };
    });
  }
};

// ../core/node_modules/apache-arrow/util/int.mjs
var int_exports = {};
__export(int_exports, {
  BaseInt64: () => BaseInt64,
  Int128: () => Int128,
  Int64: () => Int642,
  Uint64: () => Uint642
});
var carryBit16 = 1 << 16;
function intAsHex(value) {
  if (value < 0) {
    value = 4294967295 + value + 1;
  }
  return `0x${value.toString(16)}`;
}
var kInt32DecimalDigits = 8;
var kPowersOfTen = [
  1,
  10,
  100,
  1e3,
  1e4,
  1e5,
  1e6,
  1e7,
  1e8
];
var BaseInt64 = class {
  constructor(buffer) {
    this.buffer = buffer;
  }
  high() {
    return this.buffer[1];
  }
  low() {
    return this.buffer[0];
  }
  _times(other) {
    const L2 = new Uint32Array([
      this.buffer[1] >>> 16,
      this.buffer[1] & 65535,
      this.buffer[0] >>> 16,
      this.buffer[0] & 65535
    ]);
    const R2 = new Uint32Array([
      other.buffer[1] >>> 16,
      other.buffer[1] & 65535,
      other.buffer[0] >>> 16,
      other.buffer[0] & 65535
    ]);
    let product2 = L2[3] * R2[3];
    this.buffer[0] = product2 & 65535;
    let sum5 = product2 >>> 16;
    product2 = L2[2] * R2[3];
    sum5 += product2;
    product2 = L2[3] * R2[2] >>> 0;
    sum5 += product2;
    this.buffer[0] += sum5 << 16;
    this.buffer[1] = sum5 >>> 0 < product2 ? carryBit16 : 0;
    this.buffer[1] += sum5 >>> 16;
    this.buffer[1] += L2[1] * R2[3] + L2[2] * R2[2] + L2[3] * R2[1];
    this.buffer[1] += L2[0] * R2[3] + L2[1] * R2[2] + L2[2] * R2[1] + L2[3] * R2[0] << 16;
    return this;
  }
  _plus(other) {
    const sum5 = this.buffer[0] + other.buffer[0] >>> 0;
    this.buffer[1] += other.buffer[1];
    if (sum5 < this.buffer[0] >>> 0) {
      ++this.buffer[1];
    }
    this.buffer[0] = sum5;
  }
  lessThan(other) {
    return this.buffer[1] < other.buffer[1] || this.buffer[1] === other.buffer[1] && this.buffer[0] < other.buffer[0];
  }
  equals(other) {
    return this.buffer[1] === other.buffer[1] && this.buffer[0] == other.buffer[0];
  }
  greaterThan(other) {
    return other.lessThan(this);
  }
  hex() {
    return `${intAsHex(this.buffer[1])} ${intAsHex(this.buffer[0])}`;
  }
};
var Uint642 = class _Uint64 extends BaseInt64 {
  times(other) {
    this._times(other);
    return this;
  }
  plus(other) {
    this._plus(other);
    return this;
  }
  /** @nocollapse */
  static from(val, out_buffer = new Uint32Array(2)) {
    return _Uint64.fromString(typeof val === "string" ? val : val.toString(), out_buffer);
  }
  /** @nocollapse */
  static fromNumber(num, out_buffer = new Uint32Array(2)) {
    return _Uint64.fromString(num.toString(), out_buffer);
  }
  /** @nocollapse */
  static fromString(str, out_buffer = new Uint32Array(2)) {
    const length4 = str.length;
    const out = new _Uint64(out_buffer);
    for (let posn = 0; posn < length4; ) {
      const group3 = kInt32DecimalDigits < length4 - posn ? kInt32DecimalDigits : length4 - posn;
      const chunk = new _Uint64(new Uint32Array([Number.parseInt(str.slice(posn, posn + group3), 10), 0]));
      const multiple = new _Uint64(new Uint32Array([kPowersOfTen[group3], 0]));
      out.times(multiple);
      out.plus(chunk);
      posn += group3;
    }
    return out;
  }
  /** @nocollapse */
  static convertArray(values2) {
    const data = new Uint32Array(values2.length * 2);
    for (let i = -1, n = values2.length; ++i < n; ) {
      _Uint64.from(values2[i], new Uint32Array(data.buffer, data.byteOffset + 2 * i * 4, 2));
    }
    return data;
  }
  /** @nocollapse */
  static multiply(left2, right2) {
    const rtrn = new _Uint64(new Uint32Array(left2.buffer));
    return rtrn.times(right2);
  }
  /** @nocollapse */
  static add(left2, right2) {
    const rtrn = new _Uint64(new Uint32Array(left2.buffer));
    return rtrn.plus(right2);
  }
};
var Int642 = class _Int64 extends BaseInt64 {
  negate() {
    this.buffer[0] = ~this.buffer[0] + 1;
    this.buffer[1] = ~this.buffer[1];
    if (this.buffer[0] == 0) {
      ++this.buffer[1];
    }
    return this;
  }
  times(other) {
    this._times(other);
    return this;
  }
  plus(other) {
    this._plus(other);
    return this;
  }
  lessThan(other) {
    const this_high = this.buffer[1] << 0;
    const other_high = other.buffer[1] << 0;
    return this_high < other_high || this_high === other_high && this.buffer[0] < other.buffer[0];
  }
  /** @nocollapse */
  static from(val, out_buffer = new Uint32Array(2)) {
    return _Int64.fromString(typeof val === "string" ? val : val.toString(), out_buffer);
  }
  /** @nocollapse */
  static fromNumber(num, out_buffer = new Uint32Array(2)) {
    return _Int64.fromString(num.toString(), out_buffer);
  }
  /** @nocollapse */
  static fromString(str, out_buffer = new Uint32Array(2)) {
    const negate2 = str.startsWith("-");
    const length4 = str.length;
    const out = new _Int64(out_buffer);
    for (let posn = negate2 ? 1 : 0; posn < length4; ) {
      const group3 = kInt32DecimalDigits < length4 - posn ? kInt32DecimalDigits : length4 - posn;
      const chunk = new _Int64(new Uint32Array([Number.parseInt(str.slice(posn, posn + group3), 10), 0]));
      const multiple = new _Int64(new Uint32Array([kPowersOfTen[group3], 0]));
      out.times(multiple);
      out.plus(chunk);
      posn += group3;
    }
    return negate2 ? out.negate() : out;
  }
  /** @nocollapse */
  static convertArray(values2) {
    const data = new Uint32Array(values2.length * 2);
    for (let i = -1, n = values2.length; ++i < n; ) {
      _Int64.from(values2[i], new Uint32Array(data.buffer, data.byteOffset + 2 * i * 4, 2));
    }
    return data;
  }
  /** @nocollapse */
  static multiply(left2, right2) {
    const rtrn = new _Int64(new Uint32Array(left2.buffer));
    return rtrn.times(right2);
  }
  /** @nocollapse */
  static add(left2, right2) {
    const rtrn = new _Int64(new Uint32Array(left2.buffer));
    return rtrn.plus(right2);
  }
};
var Int128 = class _Int128 {
  constructor(buffer) {
    this.buffer = buffer;
  }
  high() {
    return new Int642(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));
  }
  low() {
    return new Int642(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset, 2));
  }
  negate() {
    this.buffer[0] = ~this.buffer[0] + 1;
    this.buffer[1] = ~this.buffer[1];
    this.buffer[2] = ~this.buffer[2];
    this.buffer[3] = ~this.buffer[3];
    if (this.buffer[0] == 0) {
      ++this.buffer[1];
    }
    if (this.buffer[1] == 0) {
      ++this.buffer[2];
    }
    if (this.buffer[2] == 0) {
      ++this.buffer[3];
    }
    return this;
  }
  times(other) {
    const L0 = new Uint642(new Uint32Array([this.buffer[3], 0]));
    const L1 = new Uint642(new Uint32Array([this.buffer[2], 0]));
    const L2 = new Uint642(new Uint32Array([this.buffer[1], 0]));
    const L3 = new Uint642(new Uint32Array([this.buffer[0], 0]));
    const R0 = new Uint642(new Uint32Array([other.buffer[3], 0]));
    const R1 = new Uint642(new Uint32Array([other.buffer[2], 0]));
    const R2 = new Uint642(new Uint32Array([other.buffer[1], 0]));
    const R3 = new Uint642(new Uint32Array([other.buffer[0], 0]));
    let product2 = Uint642.multiply(L3, R3);
    this.buffer[0] = product2.low();
    const sum5 = new Uint642(new Uint32Array([product2.high(), 0]));
    product2 = Uint642.multiply(L2, R3);
    sum5.plus(product2);
    product2 = Uint642.multiply(L3, R2);
    sum5.plus(product2);
    this.buffer[1] = sum5.low();
    this.buffer[3] = sum5.lessThan(product2) ? 1 : 0;
    this.buffer[2] = sum5.high();
    const high = new Uint642(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));
    high.plus(Uint642.multiply(L1, R3)).plus(Uint642.multiply(L2, R2)).plus(Uint642.multiply(L3, R1));
    this.buffer[3] += Uint642.multiply(L0, R3).plus(Uint642.multiply(L1, R2)).plus(Uint642.multiply(L2, R1)).plus(Uint642.multiply(L3, R0)).low();
    return this;
  }
  plus(other) {
    const sums = new Uint32Array(4);
    sums[3] = this.buffer[3] + other.buffer[3] >>> 0;
    sums[2] = this.buffer[2] + other.buffer[2] >>> 0;
    sums[1] = this.buffer[1] + other.buffer[1] >>> 0;
    sums[0] = this.buffer[0] + other.buffer[0] >>> 0;
    if (sums[0] < this.buffer[0] >>> 0) {
      ++sums[1];
    }
    if (sums[1] < this.buffer[1] >>> 0) {
      ++sums[2];
    }
    if (sums[2] < this.buffer[2] >>> 0) {
      ++sums[3];
    }
    this.buffer[3] = sums[3];
    this.buffer[2] = sums[2];
    this.buffer[1] = sums[1];
    this.buffer[0] = sums[0];
    return this;
  }
  hex() {
    return `${intAsHex(this.buffer[3])} ${intAsHex(this.buffer[2])} ${intAsHex(this.buffer[1])} ${intAsHex(this.buffer[0])}`;
  }
  /** @nocollapse */
  static multiply(left2, right2) {
    const rtrn = new _Int128(new Uint32Array(left2.buffer));
    return rtrn.times(right2);
  }
  /** @nocollapse */
  static add(left2, right2) {
    const rtrn = new _Int128(new Uint32Array(left2.buffer));
    return rtrn.plus(right2);
  }
  /** @nocollapse */
  static from(val, out_buffer = new Uint32Array(4)) {
    return _Int128.fromString(typeof val === "string" ? val : val.toString(), out_buffer);
  }
  /** @nocollapse */
  static fromNumber(num, out_buffer = new Uint32Array(4)) {
    return _Int128.fromString(num.toString(), out_buffer);
  }
  /** @nocollapse */
  static fromString(str, out_buffer = new Uint32Array(4)) {
    const negate2 = str.startsWith("-");
    const length4 = str.length;
    const out = new _Int128(out_buffer);
    for (let posn = negate2 ? 1 : 0; posn < length4; ) {
      const group3 = kInt32DecimalDigits < length4 - posn ? kInt32DecimalDigits : length4 - posn;
      const chunk = new _Int128(new Uint32Array([Number.parseInt(str.slice(posn, posn + group3), 10), 0, 0, 0]));
      const multiple = new _Int128(new Uint32Array([kPowersOfTen[group3], 0, 0, 0]));
      out.times(multiple);
      out.plus(chunk);
      posn += group3;
    }
    return negate2 ? out.negate() : out;
  }
  /** @nocollapse */
  static convertArray(values2) {
    const data = new Uint32Array(values2.length * 4);
    for (let i = -1, n = values2.length; ++i < n; ) {
      _Int128.from(values2[i], new Uint32Array(data.buffer, data.byteOffset + 4 * 4 * i, 4));
    }
    return data;
  }
};

// ../core/node_modules/apache-arrow/visitor/vectorloader.mjs
var VectorLoader = class extends Visitor {
  constructor(bytes, nodes, buffers, dictionaries, metadataVersion = MetadataVersion.V5) {
    super();
    this.nodesIndex = -1;
    this.buffersIndex = -1;
    this.bytes = bytes;
    this.nodes = nodes;
    this.buffers = buffers;
    this.dictionaries = dictionaries;
    this.metadataVersion = metadataVersion;
  }
  visit(node) {
    return super.visit(node instanceof Field2 ? node.type : node);
  }
  visitNull(type2, { length: length4 } = this.nextFieldNode()) {
    return makeData({ type: type2, length: length4 });
  }
  visitBool(type2, { length: length4, nullCount } = this.nextFieldNode()) {
    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });
  }
  visitInt(type2, { length: length4, nullCount } = this.nextFieldNode()) {
    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });
  }
  visitFloat(type2, { length: length4, nullCount } = this.nextFieldNode()) {
    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });
  }
  visitUtf8(type2, { length: length4, nullCount } = this.nextFieldNode()) {
    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), valueOffsets: this.readOffsets(type2), data: this.readData(type2) });
  }
  visitLargeUtf8(type2, { length: length4, nullCount } = this.nextFieldNode()) {
    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), valueOffsets: this.readOffsets(type2), data: this.readData(type2) });
  }
  visitBinary(type2, { length: length4, nullCount } = this.nextFieldNode()) {
    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), valueOffsets: this.readOffsets(type2), data: this.readData(type2) });
  }
  visitLargeBinary(type2, { length: length4, nullCount } = this.nextFieldNode()) {
    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), valueOffsets: this.readOffsets(type2), data: this.readData(type2) });
  }
  visitFixedSizeBinary(type2, { length: length4, nullCount } = this.nextFieldNode()) {
    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });
  }
  visitDate(type2, { length: length4, nullCount } = this.nextFieldNode()) {
    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });
  }
  visitTimestamp(type2, { length: length4, nullCount } = this.nextFieldNode()) {
    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });
  }
  visitTime(type2, { length: length4, nullCount } = this.nextFieldNode()) {
    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });
  }
  visitDecimal(type2, { length: length4, nullCount } = this.nextFieldNode()) {
    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });
  }
  visitList(type2, { length: length4, nullCount } = this.nextFieldNode()) {
    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), valueOffsets: this.readOffsets(type2), "child": this.visit(type2.children[0]) });
  }
  visitStruct(type2, { length: length4, nullCount } = this.nextFieldNode()) {
    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), children: this.visitMany(type2.children) });
  }
  visitUnion(type2, { length: length4, nullCount } = this.nextFieldNode()) {
    if (this.metadataVersion < MetadataVersion.V5) {
      this.readNullBitmap(type2, nullCount);
    }
    return type2.mode === UnionMode.Sparse ? this.visitSparseUnion(type2, { length: length4, nullCount }) : this.visitDenseUnion(type2, { length: length4, nullCount });
  }
  visitDenseUnion(type2, { length: length4, nullCount } = this.nextFieldNode()) {
    return makeData({ type: type2, length: length4, nullCount, typeIds: this.readTypeIds(type2), valueOffsets: this.readOffsets(type2), children: this.visitMany(type2.children) });
  }
  visitSparseUnion(type2, { length: length4, nullCount } = this.nextFieldNode()) {
    return makeData({ type: type2, length: length4, nullCount, typeIds: this.readTypeIds(type2), children: this.visitMany(type2.children) });
  }
  visitDictionary(type2, { length: length4, nullCount } = this.nextFieldNode()) {
    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2.indices), dictionary: this.readDictionary(type2) });
  }
  visitInterval(type2, { length: length4, nullCount } = this.nextFieldNode()) {
    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });
  }
  visitDuration(type2, { length: length4, nullCount } = this.nextFieldNode()) {
    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });
  }
  visitFixedSizeList(type2, { length: length4, nullCount } = this.nextFieldNode()) {
    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), "child": this.visit(type2.children[0]) });
  }
  visitMap(type2, { length: length4, nullCount } = this.nextFieldNode()) {
    return makeData({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), valueOffsets: this.readOffsets(type2), "child": this.visit(type2.children[0]) });
  }
  nextFieldNode() {
    return this.nodes[++this.nodesIndex];
  }
  nextBufferRange() {
    return this.buffers[++this.buffersIndex];
  }
  readNullBitmap(type2, nullCount, buffer = this.nextBufferRange()) {
    return nullCount > 0 && this.readData(type2, buffer) || new Uint8Array(0);
  }
  readOffsets(type2, buffer) {
    return this.readData(type2, buffer);
  }
  readTypeIds(type2, buffer) {
    return this.readData(type2, buffer);
  }
  readData(_type, { length: length4, offset: offset2 } = this.nextBufferRange()) {
    return this.bytes.subarray(offset2, offset2 + length4);
  }
  readDictionary(type2) {
    return this.dictionaries.get(type2.id);
  }
};
var JSONVectorLoader = class extends VectorLoader {
  constructor(sources, nodes, buffers, dictionaries, metadataVersion) {
    super(new Uint8Array(0), nodes, buffers, dictionaries, metadataVersion);
    this.sources = sources;
  }
  readNullBitmap(_type, nullCount, { offset: offset2 } = this.nextBufferRange()) {
    return nullCount <= 0 ? new Uint8Array(0) : packBools(this.sources[offset2]);
  }
  readOffsets(_type, { offset: offset2 } = this.nextBufferRange()) {
    return toArrayBufferView(Uint8Array, toArrayBufferView(_type.OffsetArrayType, this.sources[offset2]));
  }
  readTypeIds(type2, { offset: offset2 } = this.nextBufferRange()) {
    return toArrayBufferView(Uint8Array, toArrayBufferView(type2.ArrayType, this.sources[offset2]));
  }
  readData(type2, { offset: offset2 } = this.nextBufferRange()) {
    const { sources } = this;
    if (DataType.isTimestamp(type2)) {
      return toArrayBufferView(Uint8Array, Int642.convertArray(sources[offset2]));
    } else if ((DataType.isInt(type2) || DataType.isTime(type2)) && type2.bitWidth === 64 || DataType.isDuration(type2)) {
      return toArrayBufferView(Uint8Array, Int642.convertArray(sources[offset2]));
    } else if (DataType.isDate(type2) && type2.unit === DateUnit.MILLISECOND) {
      return toArrayBufferView(Uint8Array, Int642.convertArray(sources[offset2]));
    } else if (DataType.isDecimal(type2)) {
      return toArrayBufferView(Uint8Array, Int128.convertArray(sources[offset2]));
    } else if (DataType.isBinary(type2) || DataType.isLargeBinary(type2) || DataType.isFixedSizeBinary(type2)) {
      return binaryDataFromJSON(sources[offset2]);
    } else if (DataType.isBool(type2)) {
      return packBools(sources[offset2]);
    } else if (DataType.isUtf8(type2) || DataType.isLargeUtf8(type2)) {
      return encodeUtf8(sources[offset2].join(""));
    }
    return toArrayBufferView(Uint8Array, toArrayBufferView(type2.ArrayType, sources[offset2].map((x4) => +x4)));
  }
};
function binaryDataFromJSON(values2) {
  const joined = values2.join("");
  const data = new Uint8Array(joined.length / 2);
  for (let i = 0; i < joined.length; i += 2) {
    data[i >> 1] = Number.parseInt(joined.slice(i, i + 2), 16);
  }
  return data;
}

// ../core/node_modules/apache-arrow/builder/binary.mjs
var BinaryBuilder = class extends VariableWidthBuilder {
  constructor(opts) {
    super(opts);
    this._values = new BufferBuilder(Uint8Array);
  }
  get byteLength() {
    let size = this._pendingLength + this.length * 4;
    this._offsets && (size += this._offsets.byteLength);
    this._values && (size += this._values.byteLength);
    this._nulls && (size += this._nulls.byteLength);
    return size;
  }
  setValue(index2, value) {
    return super.setValue(index2, toUint8Array(value));
  }
  _flushPending(pending, pendingLength) {
    const offsets = this._offsets;
    const data = this._values.reserve(pendingLength).buffer;
    let offset2 = 0;
    for (const [index2, value] of pending) {
      if (value === void 0) {
        offsets.set(index2, 0);
      } else {
        const length4 = value.length;
        data.set(value, offset2);
        offsets.set(index2, length4);
        offset2 += length4;
      }
    }
  }
};

// ../core/node_modules/apache-arrow/builder/largebinary.mjs
var LargeBinaryBuilder = class extends VariableWidthBuilder {
  constructor(opts) {
    super(opts);
    this._values = new BufferBuilder(Uint8Array);
  }
  get byteLength() {
    let size = this._pendingLength + this.length * 4;
    this._offsets && (size += this._offsets.byteLength);
    this._values && (size += this._values.byteLength);
    this._nulls && (size += this._nulls.byteLength);
    return size;
  }
  setValue(index2, value) {
    return super.setValue(index2, toUint8Array(value));
  }
  _flushPending(pending, pendingLength) {
    const offsets = this._offsets;
    const data = this._values.reserve(pendingLength).buffer;
    let offset2 = 0;
    for (const [index2, value] of pending) {
      if (value === void 0) {
        offsets.set(index2, BigInt(0));
      } else {
        const length4 = value.length;
        data.set(value, offset2);
        offsets.set(index2, BigInt(length4));
        offset2 += length4;
      }
    }
  }
};

// ../core/node_modules/apache-arrow/builder/bool.mjs
var BoolBuilder = class extends Builder2 {
  constructor(options) {
    super(options);
    this._values = new BitmapBufferBuilder();
  }
  setValue(index2, value) {
    this._values.set(index2, +value);
  }
};

// ../core/node_modules/apache-arrow/builder/date.mjs
var DateBuilder = class extends FixedWidthBuilder {
};
DateBuilder.prototype._setValue = setDate;
var DateDayBuilder = class extends DateBuilder {
};
DateDayBuilder.prototype._setValue = setDateDay;
var DateMillisecondBuilder = class extends DateBuilder {
};
DateMillisecondBuilder.prototype._setValue = setDateMillisecond;

// ../core/node_modules/apache-arrow/builder/decimal.mjs
var DecimalBuilder = class extends FixedWidthBuilder {
};
DecimalBuilder.prototype._setValue = setDecimal;

// ../core/node_modules/apache-arrow/builder/dictionary.mjs
var DictionaryBuilder = class extends Builder2 {
  constructor({ "type": type2, "nullValues": nulls, "dictionaryHashFunction": hashFn }) {
    super({ type: new Dictionary(type2.dictionary, type2.indices, type2.id, type2.isOrdered) });
    this._nulls = null;
    this._dictionaryOffset = 0;
    this._keysToIndices = /* @__PURE__ */ Object.create(null);
    this.indices = makeBuilder({ "type": this.type.indices, "nullValues": nulls });
    this.dictionary = makeBuilder({ "type": this.type.dictionary, "nullValues": null });
    if (typeof hashFn === "function") {
      this.valueToKey = hashFn;
    }
  }
  get values() {
    return this.indices.values;
  }
  get nullCount() {
    return this.indices.nullCount;
  }
  get nullBitmap() {
    return this.indices.nullBitmap;
  }
  get byteLength() {
    return this.indices.byteLength + this.dictionary.byteLength;
  }
  get reservedLength() {
    return this.indices.reservedLength + this.dictionary.reservedLength;
  }
  get reservedByteLength() {
    return this.indices.reservedByteLength + this.dictionary.reservedByteLength;
  }
  isValid(value) {
    return this.indices.isValid(value);
  }
  setValid(index2, valid2) {
    const indices = this.indices;
    valid2 = indices.setValid(index2, valid2);
    this.length = indices.length;
    return valid2;
  }
  setValue(index2, value) {
    const keysToIndices = this._keysToIndices;
    const key = this.valueToKey(value);
    let idx = keysToIndices[key];
    if (idx === void 0) {
      keysToIndices[key] = idx = this._dictionaryOffset + this.dictionary.append(value).length - 1;
    }
    return this.indices.setValue(index2, idx);
  }
  flush() {
    const type2 = this.type;
    const prev = this._dictionary;
    const curr = this.dictionary.toVector();
    const data = this.indices.flush().clone(type2);
    data.dictionary = prev ? prev.concat(curr) : curr;
    this.finished || (this._dictionaryOffset += curr.length);
    this._dictionary = data.dictionary;
    this.clear();
    return data;
  }
  finish() {
    this.indices.finish();
    this.dictionary.finish();
    this._dictionaryOffset = 0;
    this._keysToIndices = /* @__PURE__ */ Object.create(null);
    return super.finish();
  }
  clear() {
    this.indices.clear();
    this.dictionary.clear();
    return super.clear();
  }
  valueToKey(val) {
    return typeof val === "string" ? val : `${val}`;
  }
};

// ../core/node_modules/apache-arrow/builder/fixedsizebinary.mjs
var FixedSizeBinaryBuilder = class extends FixedWidthBuilder {
};
FixedSizeBinaryBuilder.prototype._setValue = setFixedSizeBinary;

// ../core/node_modules/apache-arrow/builder/fixedsizelist.mjs
var FixedSizeListBuilder = class extends Builder2 {
  setValue(index2, value) {
    const [child] = this.children;
    const start2 = index2 * this.stride;
    for (let i = -1, n = value.length; ++i < n; ) {
      child.set(start2 + i, value[i]);
    }
  }
  addChild(child, name2 = "0") {
    if (this.numChildren > 0) {
      throw new Error("FixedSizeListBuilder can only have one child.");
    }
    const childIndex = this.children.push(child);
    this.type = new FixedSizeList2(this.type.listSize, new Field2(name2, child.type, true));
    return childIndex;
  }
};

// ../core/node_modules/apache-arrow/builder/float.mjs
var FloatBuilder = class extends FixedWidthBuilder {
  setValue(index2, value) {
    this._values.set(index2, value);
  }
};
var Float16Builder = class extends FloatBuilder {
  setValue(index2, value) {
    super.setValue(index2, float64ToUint16(value));
  }
};
var Float32Builder = class extends FloatBuilder {
};
var Float64Builder = class extends FloatBuilder {
};

// ../core/node_modules/apache-arrow/builder/interval.mjs
var IntervalBuilder = class extends FixedWidthBuilder {
};
IntervalBuilder.prototype._setValue = setIntervalValue;
var IntervalDayTimeBuilder = class extends IntervalBuilder {
};
IntervalDayTimeBuilder.prototype._setValue = setIntervalDayTime;
var IntervalYearMonthBuilder = class extends IntervalBuilder {
};
IntervalYearMonthBuilder.prototype._setValue = setIntervalYearMonth;

// ../core/node_modules/apache-arrow/builder/duration.mjs
var DurationBuilder = class extends FixedWidthBuilder {
};
DurationBuilder.prototype._setValue = setDuration;
var DurationSecondBuilder = class extends DurationBuilder {
};
DurationSecondBuilder.prototype._setValue = setDurationSecond;
var DurationMillisecondBuilder = class extends DurationBuilder {
};
DurationMillisecondBuilder.prototype._setValue = setDurationMillisecond;
var DurationMicrosecondBuilder = class extends DurationBuilder {
};
DurationMicrosecondBuilder.prototype._setValue = setDurationMicrosecond;
var DurationNanosecondBuilder = class extends DurationBuilder {
};
DurationNanosecondBuilder.prototype._setValue = setDurationNanosecond;

// ../core/node_modules/apache-arrow/builder/int.mjs
var IntBuilder = class extends FixedWidthBuilder {
  setValue(index2, value) {
    this._values.set(index2, value);
  }
};
var Int8Builder = class extends IntBuilder {
};
var Int16Builder = class extends IntBuilder {
};
var Int32Builder = class extends IntBuilder {
};
var Int64Builder = class extends IntBuilder {
};
var Uint8Builder = class extends IntBuilder {
};
var Uint16Builder = class extends IntBuilder {
};
var Uint32Builder = class extends IntBuilder {
};
var Uint64Builder = class extends IntBuilder {
};

// ../core/node_modules/apache-arrow/builder/list.mjs
var ListBuilder = class extends VariableWidthBuilder {
  constructor(opts) {
    super(opts);
    this._offsets = new OffsetsBufferBuilder(opts.type);
  }
  addChild(child, name2 = "0") {
    if (this.numChildren > 0) {
      throw new Error("ListBuilder can only have one child.");
    }
    this.children[this.numChildren] = child;
    this.type = new List2(new Field2(name2, child.type, true));
    return this.numChildren - 1;
  }
  _flushPending(pending) {
    const offsets = this._offsets;
    const [child] = this.children;
    for (const [index2, value] of pending) {
      if (typeof value === "undefined") {
        offsets.set(index2, 0);
      } else {
        const v3 = value;
        const n = v3.length;
        const start2 = offsets.set(index2, n).buffer[index2];
        for (let i = -1; ++i < n; ) {
          child.set(start2 + i, v3[i]);
        }
      }
    }
  }
};

// ../core/node_modules/apache-arrow/builder/map.mjs
var MapBuilder = class extends VariableWidthBuilder {
  set(index2, value) {
    return super.set(index2, value);
  }
  setValue(index2, value) {
    const row = value instanceof Map ? value : new Map(Object.entries(value));
    const pending = this._pending || (this._pending = /* @__PURE__ */ new Map());
    const current = pending.get(index2);
    current && (this._pendingLength -= current.size);
    this._pendingLength += row.size;
    pending.set(index2, row);
  }
  addChild(child, name2 = `${this.numChildren}`) {
    if (this.numChildren > 0) {
      throw new Error("ListBuilder can only have one child.");
    }
    this.children[this.numChildren] = child;
    this.type = new Map_(new Field2(name2, child.type, true), this.type.keysSorted);
    return this.numChildren - 1;
  }
  _flushPending(pending) {
    const offsets = this._offsets;
    const [child] = this.children;
    for (const [index2, value] of pending) {
      if (value === void 0) {
        offsets.set(index2, 0);
      } else {
        let { [index2]: idx, [index2 + 1]: end } = offsets.set(index2, value.size).buffer;
        for (const val of value.entries()) {
          child.set(idx, val);
          if (++idx >= end)
            break;
        }
      }
    }
  }
};

// ../core/node_modules/apache-arrow/builder/null.mjs
var NullBuilder = class extends Builder2 {
  // @ts-ignore
  setValue(index2, value) {
  }
  setValid(index2, valid2) {
    this.length = Math.max(index2 + 1, this.length);
    return valid2;
  }
};

// ../core/node_modules/apache-arrow/builder/struct.mjs
var StructBuilder = class extends Builder2 {
  setValue(index2, value) {
    const { children: children2, type: type2 } = this;
    switch (Array.isArray(value) || value.constructor) {
      case true:
        return type2.children.forEach((_2, i) => children2[i].set(index2, value[i]));
      case Map:
        return type2.children.forEach((f2, i) => children2[i].set(index2, value.get(f2.name)));
      default:
        return type2.children.forEach((f2, i) => children2[i].set(index2, value[f2.name]));
    }
  }
  /** @inheritdoc */
  setValid(index2, valid2) {
    if (!super.setValid(index2, valid2)) {
      this.children.forEach((child) => child.setValid(index2, valid2));
    }
    return valid2;
  }
  addChild(child, name2 = `${this.numChildren}`) {
    const childIndex = this.children.push(child);
    this.type = new Struct([...this.type.children, new Field2(name2, child.type, true)]);
    return childIndex;
  }
};

// ../core/node_modules/apache-arrow/builder/timestamp.mjs
var TimestampBuilder = class extends FixedWidthBuilder {
};
TimestampBuilder.prototype._setValue = setTimestamp;
var TimestampSecondBuilder = class extends TimestampBuilder {
};
TimestampSecondBuilder.prototype._setValue = setTimestampSecond;
var TimestampMillisecondBuilder = class extends TimestampBuilder {
};
TimestampMillisecondBuilder.prototype._setValue = setTimestampMillisecond;
var TimestampMicrosecondBuilder = class extends TimestampBuilder {
};
TimestampMicrosecondBuilder.prototype._setValue = setTimestampMicrosecond;
var TimestampNanosecondBuilder = class extends TimestampBuilder {
};
TimestampNanosecondBuilder.prototype._setValue = setTimestampNanosecond;

// ../core/node_modules/apache-arrow/builder/time.mjs
var TimeBuilder = class extends FixedWidthBuilder {
};
TimeBuilder.prototype._setValue = setTime;
var TimeSecondBuilder = class extends TimeBuilder {
};
TimeSecondBuilder.prototype._setValue = setTimeSecond;
var TimeMillisecondBuilder = class extends TimeBuilder {
};
TimeMillisecondBuilder.prototype._setValue = setTimeMillisecond;
var TimeMicrosecondBuilder = class extends TimeBuilder {
};
TimeMicrosecondBuilder.prototype._setValue = setTimeMicrosecond;
var TimeNanosecondBuilder = class extends TimeBuilder {
};
TimeNanosecondBuilder.prototype._setValue = setTimeNanosecond;

// ../core/node_modules/apache-arrow/builder/union.mjs
var UnionBuilder = class extends Builder2 {
  constructor(options) {
    super(options);
    this._typeIds = new DataBufferBuilder(Int8Array, 0, 1);
    if (typeof options["valueToChildTypeId"] === "function") {
      this._valueToChildTypeId = options["valueToChildTypeId"];
    }
  }
  get typeIdToChildIndex() {
    return this.type.typeIdToChildIndex;
  }
  append(value, childTypeId) {
    return this.set(this.length, value, childTypeId);
  }
  set(index2, value, childTypeId) {
    if (childTypeId === void 0) {
      childTypeId = this._valueToChildTypeId(this, value, index2);
    }
    this.setValue(index2, value, childTypeId);
    return this;
  }
  setValue(index2, value, childTypeId) {
    this._typeIds.set(index2, childTypeId);
    const childIndex = this.type.typeIdToChildIndex[childTypeId];
    const child = this.children[childIndex];
    child === null || child === void 0 ? void 0 : child.set(index2, value);
  }
  addChild(child, name2 = `${this.children.length}`) {
    const childTypeId = this.children.push(child);
    const { type: { children: children2, mode: mode3, typeIds } } = this;
    const fields = [...children2, new Field2(name2, child.type)];
    this.type = new Union_(mode3, [...typeIds, childTypeId], fields);
    return childTypeId;
  }
  /** @ignore */
  // @ts-ignore
  _valueToChildTypeId(builder, value, offset2) {
    throw new Error(`Cannot map UnionBuilder value to child typeId. Pass the \`childTypeId\` as the second argument to unionBuilder.append(), or supply a \`valueToChildTypeId\` function as part of the UnionBuilder constructor options.`);
  }
};
var SparseUnionBuilder = class extends UnionBuilder {
};
var DenseUnionBuilder = class extends UnionBuilder {
  constructor(options) {
    super(options);
    this._offsets = new DataBufferBuilder(Int32Array);
  }
  /** @ignore */
  setValue(index2, value, childTypeId) {
    const id2 = this._typeIds.set(index2, childTypeId).buffer[index2];
    const child = this.getChildAt(this.type.typeIdToChildIndex[id2]);
    const denseIndex = this._offsets.set(index2, child.length).buffer[index2];
    child === null || child === void 0 ? void 0 : child.set(denseIndex, value);
  }
};

// ../core/node_modules/apache-arrow/builder/utf8.mjs
var Utf8Builder = class extends VariableWidthBuilder {
  constructor(opts) {
    super(opts);
    this._values = new BufferBuilder(Uint8Array);
  }
  get byteLength() {
    let size = this._pendingLength + this.length * 4;
    this._offsets && (size += this._offsets.byteLength);
    this._values && (size += this._values.byteLength);
    this._nulls && (size += this._nulls.byteLength);
    return size;
  }
  setValue(index2, value) {
    return super.setValue(index2, encodeUtf8(value));
  }
  // @ts-ignore
  _flushPending(pending, pendingLength) {
  }
};
Utf8Builder.prototype._flushPending = BinaryBuilder.prototype._flushPending;

// ../core/node_modules/apache-arrow/builder/largeutf8.mjs
var LargeUtf8Builder = class extends VariableWidthBuilder {
  constructor(opts) {
    super(opts);
    this._values = new BufferBuilder(Uint8Array);
  }
  get byteLength() {
    let size = this._pendingLength + this.length * 4;
    this._offsets && (size += this._offsets.byteLength);
    this._values && (size += this._values.byteLength);
    this._nulls && (size += this._nulls.byteLength);
    return size;
  }
  setValue(index2, value) {
    return super.setValue(index2, encodeUtf8(value));
  }
  // @ts-ignore
  _flushPending(pending, pendingLength) {
  }
};
LargeUtf8Builder.prototype._flushPending = LargeBinaryBuilder.prototype._flushPending;

// ../core/node_modules/apache-arrow/visitor/builderctor.mjs
var GetBuilderCtor = class extends Visitor {
  visitNull() {
    return NullBuilder;
  }
  visitBool() {
    return BoolBuilder;
  }
  visitInt() {
    return IntBuilder;
  }
  visitInt8() {
    return Int8Builder;
  }
  visitInt16() {
    return Int16Builder;
  }
  visitInt32() {
    return Int32Builder;
  }
  visitInt64() {
    return Int64Builder;
  }
  visitUint8() {
    return Uint8Builder;
  }
  visitUint16() {
    return Uint16Builder;
  }
  visitUint32() {
    return Uint32Builder;
  }
  visitUint64() {
    return Uint64Builder;
  }
  visitFloat() {
    return FloatBuilder;
  }
  visitFloat16() {
    return Float16Builder;
  }
  visitFloat32() {
    return Float32Builder;
  }
  visitFloat64() {
    return Float64Builder;
  }
  visitUtf8() {
    return Utf8Builder;
  }
  visitLargeUtf8() {
    return LargeUtf8Builder;
  }
  visitBinary() {
    return BinaryBuilder;
  }
  visitLargeBinary() {
    return LargeBinaryBuilder;
  }
  visitFixedSizeBinary() {
    return FixedSizeBinaryBuilder;
  }
  visitDate() {
    return DateBuilder;
  }
  visitDateDay() {
    return DateDayBuilder;
  }
  visitDateMillisecond() {
    return DateMillisecondBuilder;
  }
  visitTimestamp() {
    return TimestampBuilder;
  }
  visitTimestampSecond() {
    return TimestampSecondBuilder;
  }
  visitTimestampMillisecond() {
    return TimestampMillisecondBuilder;
  }
  visitTimestampMicrosecond() {
    return TimestampMicrosecondBuilder;
  }
  visitTimestampNanosecond() {
    return TimestampNanosecondBuilder;
  }
  visitTime() {
    return TimeBuilder;
  }
  visitTimeSecond() {
    return TimeSecondBuilder;
  }
  visitTimeMillisecond() {
    return TimeMillisecondBuilder;
  }
  visitTimeMicrosecond() {
    return TimeMicrosecondBuilder;
  }
  visitTimeNanosecond() {
    return TimeNanosecondBuilder;
  }
  visitDecimal() {
    return DecimalBuilder;
  }
  visitList() {
    return ListBuilder;
  }
  visitStruct() {
    return StructBuilder;
  }
  visitUnion() {
    return UnionBuilder;
  }
  visitDenseUnion() {
    return DenseUnionBuilder;
  }
  visitSparseUnion() {
    return SparseUnionBuilder;
  }
  visitDictionary() {
    return DictionaryBuilder;
  }
  visitInterval() {
    return IntervalBuilder;
  }
  visitIntervalDayTime() {
    return IntervalDayTimeBuilder;
  }
  visitIntervalYearMonth() {
    return IntervalYearMonthBuilder;
  }
  visitDuration() {
    return DurationBuilder;
  }
  visitDurationSecond() {
    return DurationSecondBuilder;
  }
  visitDurationMillisecond() {
    return DurationMillisecondBuilder;
  }
  visitDurationMicrosecond() {
    return DurationMicrosecondBuilder;
  }
  visitDurationNanosecond() {
    return DurationNanosecondBuilder;
  }
  visitFixedSizeList() {
    return FixedSizeListBuilder;
  }
  visitMap() {
    return MapBuilder;
  }
};
var instance5 = new GetBuilderCtor();

// ../core/node_modules/apache-arrow/visitor/typecomparator.mjs
var TypeComparator = class extends Visitor {
  compareSchemas(schema, other) {
    return schema === other || other instanceof schema.constructor && this.compareManyFields(schema.fields, other.fields);
  }
  compareManyFields(fields, others) {
    return fields === others || Array.isArray(fields) && Array.isArray(others) && fields.length === others.length && fields.every((f2, i) => this.compareFields(f2, others[i]));
  }
  compareFields(field2, other) {
    return field2 === other || other instanceof field2.constructor && field2.name === other.name && field2.nullable === other.nullable && this.visit(field2.type, other.type);
  }
};
function compareConstructor(type2, other) {
  return other instanceof type2.constructor;
}
function compareAny(type2, other) {
  return type2 === other || compareConstructor(type2, other);
}
function compareInt(type2, other) {
  return type2 === other || compareConstructor(type2, other) && type2.bitWidth === other.bitWidth && type2.isSigned === other.isSigned;
}
function compareFloat(type2, other) {
  return type2 === other || compareConstructor(type2, other) && type2.precision === other.precision;
}
function compareFixedSizeBinary(type2, other) {
  return type2 === other || compareConstructor(type2, other) && type2.byteWidth === other.byteWidth;
}
function compareDate(type2, other) {
  return type2 === other || compareConstructor(type2, other) && type2.unit === other.unit;
}
function compareTimestamp(type2, other) {
  return type2 === other || compareConstructor(type2, other) && type2.unit === other.unit && type2.timezone === other.timezone;
}
function compareTime(type2, other) {
  return type2 === other || compareConstructor(type2, other) && type2.unit === other.unit && type2.bitWidth === other.bitWidth;
}
function compareList(type2, other) {
  return type2 === other || compareConstructor(type2, other) && type2.children.length === other.children.length && instance6.compareManyFields(type2.children, other.children);
}
function compareStruct(type2, other) {
  return type2 === other || compareConstructor(type2, other) && type2.children.length === other.children.length && instance6.compareManyFields(type2.children, other.children);
}
function compareUnion(type2, other) {
  return type2 === other || compareConstructor(type2, other) && type2.mode === other.mode && type2.typeIds.every((x4, i) => x4 === other.typeIds[i]) && instance6.compareManyFields(type2.children, other.children);
}
function compareDictionary(type2, other) {
  return type2 === other || compareConstructor(type2, other) && type2.id === other.id && type2.isOrdered === other.isOrdered && instance6.visit(type2.indices, other.indices) && instance6.visit(type2.dictionary, other.dictionary);
}
function compareInterval(type2, other) {
  return type2 === other || compareConstructor(type2, other) && type2.unit === other.unit;
}
function compareDuration(type2, other) {
  return type2 === other || compareConstructor(type2, other) && type2.unit === other.unit;
}
function compareFixedSizeList(type2, other) {
  return type2 === other || compareConstructor(type2, other) && type2.listSize === other.listSize && type2.children.length === other.children.length && instance6.compareManyFields(type2.children, other.children);
}
function compareMap(type2, other) {
  return type2 === other || compareConstructor(type2, other) && type2.keysSorted === other.keysSorted && type2.children.length === other.children.length && instance6.compareManyFields(type2.children, other.children);
}
TypeComparator.prototype.visitNull = compareAny;
TypeComparator.prototype.visitBool = compareAny;
TypeComparator.prototype.visitInt = compareInt;
TypeComparator.prototype.visitInt8 = compareInt;
TypeComparator.prototype.visitInt16 = compareInt;
TypeComparator.prototype.visitInt32 = compareInt;
TypeComparator.prototype.visitInt64 = compareInt;
TypeComparator.prototype.visitUint8 = compareInt;
TypeComparator.prototype.visitUint16 = compareInt;
TypeComparator.prototype.visitUint32 = compareInt;
TypeComparator.prototype.visitUint64 = compareInt;
TypeComparator.prototype.visitFloat = compareFloat;
TypeComparator.prototype.visitFloat16 = compareFloat;
TypeComparator.prototype.visitFloat32 = compareFloat;
TypeComparator.prototype.visitFloat64 = compareFloat;
TypeComparator.prototype.visitUtf8 = compareAny;
TypeComparator.prototype.visitLargeUtf8 = compareAny;
TypeComparator.prototype.visitBinary = compareAny;
TypeComparator.prototype.visitLargeBinary = compareAny;
TypeComparator.prototype.visitFixedSizeBinary = compareFixedSizeBinary;
TypeComparator.prototype.visitDate = compareDate;
TypeComparator.prototype.visitDateDay = compareDate;
TypeComparator.prototype.visitDateMillisecond = compareDate;
TypeComparator.prototype.visitTimestamp = compareTimestamp;
TypeComparator.prototype.visitTimestampSecond = compareTimestamp;
TypeComparator.prototype.visitTimestampMillisecond = compareTimestamp;
TypeComparator.prototype.visitTimestampMicrosecond = compareTimestamp;
TypeComparator.prototype.visitTimestampNanosecond = compareTimestamp;
TypeComparator.prototype.visitTime = compareTime;
TypeComparator.prototype.visitTimeSecond = compareTime;
TypeComparator.prototype.visitTimeMillisecond = compareTime;
TypeComparator.prototype.visitTimeMicrosecond = compareTime;
TypeComparator.prototype.visitTimeNanosecond = compareTime;
TypeComparator.prototype.visitDecimal = compareAny;
TypeComparator.prototype.visitList = compareList;
TypeComparator.prototype.visitStruct = compareStruct;
TypeComparator.prototype.visitUnion = compareUnion;
TypeComparator.prototype.visitDenseUnion = compareUnion;
TypeComparator.prototype.visitSparseUnion = compareUnion;
TypeComparator.prototype.visitDictionary = compareDictionary;
TypeComparator.prototype.visitInterval = compareInterval;
TypeComparator.prototype.visitIntervalDayTime = compareInterval;
TypeComparator.prototype.visitIntervalYearMonth = compareInterval;
TypeComparator.prototype.visitDuration = compareDuration;
TypeComparator.prototype.visitDurationSecond = compareDuration;
TypeComparator.prototype.visitDurationMillisecond = compareDuration;
TypeComparator.prototype.visitDurationMicrosecond = compareDuration;
TypeComparator.prototype.visitDurationNanosecond = compareDuration;
TypeComparator.prototype.visitFixedSizeList = compareFixedSizeList;
TypeComparator.prototype.visitMap = compareMap;
var instance6 = new TypeComparator();
function compareSchemas(schema, other) {
  return instance6.compareSchemas(schema, other);
}
function compareFields(field2, other) {
  return instance6.compareFields(field2, other);
}
function compareTypes(type2, other) {
  return instance6.visit(type2, other);
}

// ../core/node_modules/apache-arrow/factories.mjs
function makeBuilder(options) {
  const type2 = options.type;
  const builder = new (instance5.getVisitFn(type2)())(options);
  if (type2.children && type2.children.length > 0) {
    const children2 = options["children"] || [];
    const defaultOptions = { "nullValues": options["nullValues"] };
    const getChildOptions = Array.isArray(children2) ? (_2, i) => children2[i] || defaultOptions : ({ name: name2 }) => children2[name2] || defaultOptions;
    for (const [index2, field2] of type2.children.entries()) {
      const { type: type3 } = field2;
      const opts = getChildOptions(field2, index2);
      builder.children.push(makeBuilder(Object.assign(Object.assign({}, opts), { type: type3 })));
    }
  }
  return builder;
}

// ../core/node_modules/apache-arrow/util/recordbatch.mjs
function distributeVectorsIntoRecordBatches(schema, vecs) {
  return uniformlyDistributeChunksAcrossRecordBatches(schema, vecs.map((v3) => v3.data.concat()));
}
function uniformlyDistributeChunksAcrossRecordBatches(schema, cols) {
  const fields = [...schema.fields];
  const batches = [];
  const memo2 = { numBatches: cols.reduce((n, c4) => Math.max(n, c4.length), 0) };
  let numBatches = 0, batchLength = 0;
  let i = -1;
  const numColumns = cols.length;
  let child, children2 = [];
  while (memo2.numBatches-- > 0) {
    for (batchLength = Number.POSITIVE_INFINITY, i = -1; ++i < numColumns; ) {
      children2[i] = child = cols[i].shift();
      batchLength = Math.min(batchLength, child ? child.length : batchLength);
    }
    if (Number.isFinite(batchLength)) {
      children2 = distributeChildren(fields, batchLength, children2, cols, memo2);
      if (batchLength > 0) {
        batches[numBatches++] = makeData({
          type: new Struct(fields),
          length: batchLength,
          nullCount: 0,
          children: children2.slice()
        });
      }
    }
  }
  return [
    schema = schema.assign(fields),
    batches.map((data) => new RecordBatch2(schema, data))
  ];
}
function distributeChildren(fields, batchLength, children2, columns, memo2) {
  var _a9;
  const nullBitmapSize = (batchLength + 63 & ~63) >> 3;
  for (let i = -1, n = columns.length; ++i < n; ) {
    const child = children2[i];
    const length4 = child === null || child === void 0 ? void 0 : child.length;
    if (length4 >= batchLength) {
      if (length4 === batchLength) {
        children2[i] = child;
      } else {
        children2[i] = child.slice(0, batchLength);
        memo2.numBatches = Math.max(memo2.numBatches, columns[i].unshift(child.slice(batchLength, length4 - batchLength)));
      }
    } else {
      const field2 = fields[i];
      fields[i] = field2.clone({ nullable: true });
      children2[i] = (_a9 = child === null || child === void 0 ? void 0 : child._changeLengthAndBackfillNullBitmap(batchLength)) !== null && _a9 !== void 0 ? _a9 : makeData({
        type: field2.type,
        length: batchLength,
        nullCount: batchLength,
        nullBitmap: new Uint8Array(nullBitmapSize)
      });
    }
  }
  return children2;
}

// ../core/node_modules/apache-arrow/table.mjs
var _a3;
var Table = class _Table {
  constructor(...args) {
    var _b3, _c3;
    if (args.length === 0) {
      this.batches = [];
      this.schema = new Schema2([]);
      this._offsets = [0];
      return this;
    }
    let schema;
    let offsets;
    if (args[0] instanceof Schema2) {
      schema = args.shift();
    }
    if (args.at(-1) instanceof Uint32Array) {
      offsets = args.pop();
    }
    const unwrap = (x4) => {
      if (x4) {
        if (x4 instanceof RecordBatch2) {
          return [x4];
        } else if (x4 instanceof _Table) {
          return x4.batches;
        } else if (x4 instanceof Data) {
          if (x4.type instanceof Struct) {
            return [new RecordBatch2(new Schema2(x4.type.children), x4)];
          }
        } else if (Array.isArray(x4)) {
          return x4.flatMap((v3) => unwrap(v3));
        } else if (typeof x4[Symbol.iterator] === "function") {
          return [...x4].flatMap((v3) => unwrap(v3));
        } else if (typeof x4 === "object") {
          const keys = Object.keys(x4);
          const vecs = keys.map((k3) => new Vector([x4[k3]]));
          const batchSchema = schema !== null && schema !== void 0 ? schema : new Schema2(keys.map((k3, i) => new Field2(String(k3), vecs[i].type, vecs[i].nullable)));
          const [, batches2] = distributeVectorsIntoRecordBatches(batchSchema, vecs);
          return batches2.length === 0 ? [new RecordBatch2(x4)] : batches2;
        }
      }
      return [];
    };
    const batches = args.flatMap((v3) => unwrap(v3));
    schema = (_c3 = schema !== null && schema !== void 0 ? schema : (_b3 = batches[0]) === null || _b3 === void 0 ? void 0 : _b3.schema) !== null && _c3 !== void 0 ? _c3 : new Schema2([]);
    if (!(schema instanceof Schema2)) {
      throw new TypeError("Table constructor expects a [Schema, RecordBatch[]] pair.");
    }
    for (const batch of batches) {
      if (!(batch instanceof RecordBatch2)) {
        throw new TypeError("Table constructor expects a [Schema, RecordBatch[]] pair.");
      }
      if (!compareSchemas(schema, batch.schema)) {
        throw new TypeError("Table and inner RecordBatch schemas must be equivalent.");
      }
    }
    this.schema = schema;
    this.batches = batches;
    this._offsets = offsets !== null && offsets !== void 0 ? offsets : computeChunkOffsets(this.data);
  }
  /**
   * The contiguous {@link RecordBatch `RecordBatch`} chunks of the Table rows.
   */
  get data() {
    return this.batches.map(({ data }) => data);
  }
  /**
   * The number of columns in this Table.
   */
  get numCols() {
    return this.schema.fields.length;
  }
  /**
   * The number of rows in this Table.
   */
  get numRows() {
    return this.data.reduce((numRows, data) => numRows + data.length, 0);
  }
  /**
   * The number of null rows in this Table.
   */
  get nullCount() {
    if (this._nullCount === -1) {
      this._nullCount = computeChunkNullCounts(this.data);
    }
    return this._nullCount;
  }
  /**
   * Check whether an element is null.
   *
   * @param index The index at which to read the validity bitmap.
   */
  // @ts-ignore
  isValid(index2) {
    return false;
  }
  /**
   * Get an element value by position.
   *
   * @param index The index of the element to read.
   */
  // @ts-ignore
  get(index2) {
    return null;
  }
  /**
   * Set an element value by position.
   *
   * @param index The index of the element to write.
   * @param value The value to set.
   */
  // @ts-ignore
  set(index2, value) {
    return;
  }
  /**
   * Retrieve the index of the first occurrence of a value in an Vector.
   *
   * @param element The value to locate in the Vector.
   * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
   */
  // @ts-ignore
  indexOf(element, offset2) {
    return -1;
  }
  /**
   * Iterator for rows in this Table.
   */
  [Symbol.iterator]() {
    if (this.batches.length > 0) {
      return instance4.visit(new Vector(this.data));
    }
    return new Array(0)[Symbol.iterator]();
  }
  /**
   * Return a JavaScript Array of the Table rows.
   *
   * @returns An Array of Table rows.
   */
  toArray() {
    return [...this];
  }
  /**
   * Returns a string representation of the Table rows.
   *
   * @returns A string representation of the Table rows.
   */
  toString() {
    return `[
  ${this.toArray().join(",\n  ")}
]`;
  }
  /**
   * Combines two or more Tables of the same schema.
   *
   * @param others Additional Tables to add to the end of this Tables.
   */
  concat(...others) {
    const schema = this.schema;
    const data = this.data.concat(others.flatMap(({ data: data2 }) => data2));
    return new _Table(schema, data.map((data2) => new RecordBatch2(schema, data2)));
  }
  /**
   * Return a zero-copy sub-section of this Table.
   *
   * @param begin The beginning of the specified portion of the Table.
   * @param end The end of the specified portion of the Table. This is exclusive of the element at the index 'end'.
   */
  slice(begin, end) {
    const schema = this.schema;
    [begin, end] = clampRange({ length: this.numRows }, begin, end);
    const data = sliceChunks(this.data, this._offsets, begin, end);
    return new _Table(schema, data.map((chunk) => new RecordBatch2(schema, chunk)));
  }
  /**
   * Returns a child Vector by name, or null if this Vector has no child with the given name.
   *
   * @param name The name of the child to retrieve.
   */
  getChild(name2) {
    return this.getChildAt(this.schema.fields.findIndex((f2) => f2.name === name2));
  }
  /**
   * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
   *
   * @param index The index of the child to retrieve.
   */
  getChildAt(index2) {
    if (index2 > -1 && index2 < this.schema.fields.length) {
      const data = this.data.map((data2) => data2.children[index2]);
      if (data.length === 0) {
        const { type: type2 } = this.schema.fields[index2];
        const empty4 = makeData({ type: type2, length: 0, nullCount: 0 });
        data.push(empty4._changeLengthAndBackfillNullBitmap(this.numRows));
      }
      return new Vector(data);
    }
    return null;
  }
  /**
   * Sets a child Vector by name.
   *
   * @param name The name of the child to overwrite.
   * @returns A new Table with the supplied child for the specified name.
   */
  setChild(name2, child) {
    var _b3;
    return this.setChildAt((_b3 = this.schema.fields) === null || _b3 === void 0 ? void 0 : _b3.findIndex((f2) => f2.name === name2), child);
  }
  setChildAt(index2, child) {
    let schema = this.schema;
    let batches = [...this.batches];
    if (index2 > -1 && index2 < this.numCols) {
      if (!child) {
        child = new Vector([makeData({ type: new Null2(), length: this.numRows })]);
      }
      const fields = schema.fields.slice();
      const field2 = fields[index2].clone({ type: child.type });
      const children2 = this.schema.fields.map((_2, i) => this.getChildAt(i));
      [fields[index2], children2[index2]] = [field2, child];
      [schema, batches] = distributeVectorsIntoRecordBatches(schema, children2);
    }
    return new _Table(schema, batches);
  }
  /**
   * Construct a new Table containing only specified columns.
   *
   * @param columnNames Names of columns to keep.
   * @returns A new Table of columns matching the specified names.
   */
  select(columnNames) {
    const nameToIndex = this.schema.fields.reduce((m2, f2, i) => m2.set(f2.name, i), /* @__PURE__ */ new Map());
    return this.selectAt(columnNames.map((columnName) => nameToIndex.get(columnName)).filter((x4) => x4 > -1));
  }
  /**
   * Construct a new Table containing only columns at the specified indices.
   *
   * @param columnIndices Indices of columns to keep.
   * @returns A new Table of columns at the specified indices.
   */
  selectAt(columnIndices) {
    const schema = this.schema.selectAt(columnIndices);
    const data = this.batches.map((batch) => batch.selectAt(columnIndices));
    return new _Table(schema, data);
  }
  assign(other) {
    const fields = this.schema.fields;
    const [indices, oldToNew] = other.schema.fields.reduce((memo2, f2, newIdx) => {
      const [indices2, oldToNew2] = memo2;
      const i = fields.findIndex((f3) => f3.name === f2.name);
      ~i ? oldToNew2[i] = newIdx : indices2.push(newIdx);
      return memo2;
    }, [[], []]);
    const schema = this.schema.assign(other.schema);
    const columns = [
      ...fields.map((_2, i) => [i, oldToNew[i]]).map(([i, j2]) => j2 === void 0 ? this.getChildAt(i) : other.getChildAt(j2)),
      ...indices.map((i) => other.getChildAt(i))
    ].filter(Boolean);
    return new _Table(...distributeVectorsIntoRecordBatches(schema, columns));
  }
};
_a3 = Symbol.toStringTag;
Table[_a3] = ((proto) => {
  proto.schema = null;
  proto.batches = [];
  proto._offsets = new Uint32Array([0]);
  proto._nullCount = -1;
  proto[Symbol.isConcatSpreadable] = true;
  proto["isValid"] = wrapChunkedCall1(isChunkedValid);
  proto["get"] = wrapChunkedCall1(instance2.getVisitFn(Type2.Struct));
  proto["set"] = wrapChunkedCall2(instance.getVisitFn(Type2.Struct));
  proto["indexOf"] = wrapChunkedIndexOf(instance3.getVisitFn(Type2.Struct));
  return "Table";
})(Table.prototype);

// ../core/node_modules/apache-arrow/recordbatch.mjs
var _a4;
var RecordBatch2 = class _RecordBatch {
  constructor(...args) {
    switch (args.length) {
      case 2: {
        [this.schema] = args;
        if (!(this.schema instanceof Schema2)) {
          throw new TypeError("RecordBatch constructor expects a [Schema, Data] pair.");
        }
        [
          ,
          this.data = makeData({
            nullCount: 0,
            type: new Struct(this.schema.fields),
            children: this.schema.fields.map((f2) => makeData({ type: f2.type, nullCount: 0 }))
          })
        ] = args;
        if (!(this.data instanceof Data)) {
          throw new TypeError("RecordBatch constructor expects a [Schema, Data] pair.");
        }
        [this.schema, this.data] = ensureSameLengthData(this.schema, this.data.children);
        break;
      }
      case 1: {
        const [obj] = args;
        const { fields, children: children2, length: length4 } = Object.keys(obj).reduce((memo2, name2, i) => {
          memo2.children[i] = obj[name2];
          memo2.length = Math.max(memo2.length, obj[name2].length);
          memo2.fields[i] = Field2.new({ name: name2, type: obj[name2].type, nullable: true });
          return memo2;
        }, {
          length: 0,
          fields: new Array(),
          children: new Array()
        });
        const schema = new Schema2(fields);
        const data = makeData({ type: new Struct(fields), length: length4, children: children2, nullCount: 0 });
        [this.schema, this.data] = ensureSameLengthData(schema, data.children, length4);
        break;
      }
      default:
        throw new TypeError("RecordBatch constructor expects an Object mapping names to child Data, or a [Schema, Data] pair.");
    }
  }
  get dictionaries() {
    return this._dictionaries || (this._dictionaries = collectDictionaries(this.schema.fields, this.data.children));
  }
  /**
   * The number of columns in this RecordBatch.
   */
  get numCols() {
    return this.schema.fields.length;
  }
  /**
   * The number of rows in this RecordBatch.
   */
  get numRows() {
    return this.data.length;
  }
  /**
   * The number of null rows in this RecordBatch.
   */
  get nullCount() {
    return this.data.nullCount;
  }
  /**
   * Check whether an element is null.
   * @param index The index at which to read the validity bitmap.
   */
  isValid(index2) {
    return this.data.getValid(index2);
  }
  /**
   * Get a row by position.
   * @param index The index of the element to read.
   */
  get(index2) {
    return instance2.visit(this.data, index2);
  }
  /**
   * Set a row by position.
   * @param index The index of the element to write.
   * @param value The value to set.
   */
  set(index2, value) {
    return instance.visit(this.data, index2, value);
  }
  /**
   * Retrieve the index of the first occurrence of a row in an RecordBatch.
   * @param element The row to locate in the RecordBatch.
   * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
   */
  indexOf(element, offset2) {
    return instance3.visit(this.data, element, offset2);
  }
  /**
   * Iterator for rows in this RecordBatch.
   */
  [Symbol.iterator]() {
    return instance4.visit(new Vector([this.data]));
  }
  /**
   * Return a JavaScript Array of the RecordBatch rows.
   * @returns An Array of RecordBatch rows.
   */
  toArray() {
    return [...this];
  }
  /**
   * Combines two or more RecordBatch of the same schema.
   * @param others Additional RecordBatch to add to the end of this RecordBatch.
   */
  concat(...others) {
    return new Table(this.schema, [this, ...others]);
  }
  /**
   * Return a zero-copy sub-section of this RecordBatch.
   * @param start The beginning of the specified portion of the RecordBatch.
   * @param end The end of the specified portion of the RecordBatch. This is exclusive of the element at the index 'end'.
   */
  slice(begin, end) {
    const [slice4] = new Vector([this.data]).slice(begin, end).data;
    return new _RecordBatch(this.schema, slice4);
  }
  /**
   * Returns a child Vector by name, or null if this Vector has no child with the given name.
   * @param name The name of the child to retrieve.
   */
  getChild(name2) {
    var _b3;
    return this.getChildAt((_b3 = this.schema.fields) === null || _b3 === void 0 ? void 0 : _b3.findIndex((f2) => f2.name === name2));
  }
  /**
   * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
   * @param index The index of the child to retrieve.
   */
  getChildAt(index2) {
    if (index2 > -1 && index2 < this.schema.fields.length) {
      return new Vector([this.data.children[index2]]);
    }
    return null;
  }
  /**
   * Sets a child Vector by name.
   * @param name The name of the child to overwrite.
   * @returns A new RecordBatch with the new child for the specified name.
   */
  setChild(name2, child) {
    var _b3;
    return this.setChildAt((_b3 = this.schema.fields) === null || _b3 === void 0 ? void 0 : _b3.findIndex((f2) => f2.name === name2), child);
  }
  setChildAt(index2, child) {
    let schema = this.schema;
    let data = this.data;
    if (index2 > -1 && index2 < this.numCols) {
      if (!child) {
        child = new Vector([makeData({ type: new Null2(), length: this.numRows })]);
      }
      const fields = schema.fields.slice();
      const children2 = data.children.slice();
      const field2 = fields[index2].clone({ type: child.type });
      [fields[index2], children2[index2]] = [field2, child.data[0]];
      schema = new Schema2(fields, new Map(this.schema.metadata));
      data = makeData({ type: new Struct(fields), children: children2 });
    }
    return new _RecordBatch(schema, data);
  }
  /**
   * Construct a new RecordBatch containing only specified columns.
   *
   * @param columnNames Names of columns to keep.
   * @returns A new RecordBatch of columns matching the specified names.
   */
  select(columnNames) {
    const schema = this.schema.select(columnNames);
    const type2 = new Struct(schema.fields);
    const children2 = [];
    for (const name2 of columnNames) {
      const index2 = this.schema.fields.findIndex((f2) => f2.name === name2);
      if (~index2) {
        children2[index2] = this.data.children[index2];
      }
    }
    return new _RecordBatch(schema, makeData({ type: type2, length: this.numRows, children: children2 }));
  }
  /**
   * Construct a new RecordBatch containing only columns at the specified indices.
   *
   * @param columnIndices Indices of columns to keep.
   * @returns A new RecordBatch of columns matching at the specified indices.
   */
  selectAt(columnIndices) {
    const schema = this.schema.selectAt(columnIndices);
    const children2 = columnIndices.map((i) => this.data.children[i]).filter(Boolean);
    const subset = makeData({ type: new Struct(schema.fields), length: this.numRows, children: children2 });
    return new _RecordBatch(schema, subset);
  }
};
_a4 = Symbol.toStringTag;
RecordBatch2[_a4] = ((proto) => {
  proto._nullCount = -1;
  proto[Symbol.isConcatSpreadable] = true;
  return "RecordBatch";
})(RecordBatch2.prototype);
function ensureSameLengthData(schema, chunks, maxLength = chunks.reduce((max4, col) => Math.max(max4, col.length), 0)) {
  var _b3;
  const fields = [...schema.fields];
  const children2 = [...chunks];
  const nullBitmapSize = (maxLength + 63 & ~63) >> 3;
  for (const [idx, field2] of schema.fields.entries()) {
    const chunk = chunks[idx];
    if (!chunk || chunk.length !== maxLength) {
      fields[idx] = field2.clone({ nullable: true });
      children2[idx] = (_b3 = chunk === null || chunk === void 0 ? void 0 : chunk._changeLengthAndBackfillNullBitmap(maxLength)) !== null && _b3 !== void 0 ? _b3 : makeData({
        type: field2.type,
        length: maxLength,
        nullCount: maxLength,
        nullBitmap: new Uint8Array(nullBitmapSize)
      });
    }
  }
  return [
    schema.assign(fields),
    makeData({ type: new Struct(fields), length: maxLength, children: children2 })
  ];
}
function collectDictionaries(fields, children2, dictionaries = /* @__PURE__ */ new Map()) {
  var _b3, _c3;
  if (((_b3 = fields === null || fields === void 0 ? void 0 : fields.length) !== null && _b3 !== void 0 ? _b3 : 0) > 0 && (fields === null || fields === void 0 ? void 0 : fields.length) === (children2 === null || children2 === void 0 ? void 0 : children2.length)) {
    for (let i = -1, n = fields.length; ++i < n; ) {
      const { type: type2 } = fields[i];
      const data = children2[i];
      for (const next of [data, ...((_c3 = data === null || data === void 0 ? void 0 : data.dictionary) === null || _c3 === void 0 ? void 0 : _c3.data) || []]) {
        collectDictionaries(type2.children, next === null || next === void 0 ? void 0 : next.children, dictionaries);
      }
      if (DataType.isDictionary(type2)) {
        const { id: id2 } = type2;
        if (!dictionaries.has(id2)) {
          if (data === null || data === void 0 ? void 0 : data.dictionary) {
            dictionaries.set(id2, data.dictionary);
          }
        } else if (dictionaries.get(id2) !== data.dictionary) {
          throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);
        }
      }
    }
  }
  return dictionaries;
}
var _InternalEmptyPlaceholderRecordBatch = class extends RecordBatch2 {
  constructor(schema) {
    const children2 = schema.fields.map((f2) => makeData({ type: f2.type }));
    const data = makeData({ type: new Struct(schema.fields), nullCount: 0, children: children2 });
    super(schema, data);
  }
};

// ../core/node_modules/apache-arrow/fb/message.mjs
var Message = class _Message {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsMessage(bb2, obj) {
    return (obj || new _Message()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsMessage(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Message()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  version() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : MetadataVersion.V1;
  }
  headerType() {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? this.bb.readUint8(this.bb_pos + offset2) : MessageHeader.NONE;
  }
  header(obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 8);
    return offset2 ? this.bb.__union(obj, this.bb_pos + offset2) : null;
  }
  bodyLength() {
    const offset2 = this.bb.__offset(this.bb_pos, 10);
    return offset2 ? this.bb.readInt64(this.bb_pos + offset2) : BigInt("0");
  }
  customMetadata(index2, obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 12);
    return offset2 ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset2) + index2 * 4), this.bb) : null;
  }
  customMetadataLength() {
    const offset2 = this.bb.__offset(this.bb_pos, 12);
    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
  }
  static startMessage(builder) {
    builder.startObject(5);
  }
  static addVersion(builder, version) {
    builder.addFieldInt16(0, version, MetadataVersion.V1);
  }
  static addHeaderType(builder, headerType) {
    builder.addFieldInt8(1, headerType, MessageHeader.NONE);
  }
  static addHeader(builder, headerOffset) {
    builder.addFieldOffset(2, headerOffset, 0);
  }
  static addBodyLength(builder, bodyLength) {
    builder.addFieldInt64(3, bodyLength, BigInt("0"));
  }
  static addCustomMetadata(builder, customMetadataOffset) {
    builder.addFieldOffset(4, customMetadataOffset, 0);
  }
  static createCustomMetadataVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startCustomMetadataVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static endMessage(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static finishMessageBuffer(builder, offset2) {
    builder.finish(offset2);
  }
  static finishSizePrefixedMessageBuffer(builder, offset2) {
    builder.finish(offset2, void 0, true);
  }
  static createMessage(builder, version, headerType, headerOffset, bodyLength, customMetadataOffset) {
    _Message.startMessage(builder);
    _Message.addVersion(builder, version);
    _Message.addHeaderType(builder, headerType);
    _Message.addHeader(builder, headerOffset);
    _Message.addBodyLength(builder, bodyLength);
    _Message.addCustomMetadata(builder, customMetadataOffset);
    return _Message.endMessage(builder);
  }
};

// ../core/node_modules/apache-arrow/visitor/typeassembler.mjs
var TypeAssembler = class extends Visitor {
  visit(node, builder) {
    return node == null || builder == null ? void 0 : super.visit(node, builder);
  }
  visitNull(_node, b2) {
    Null.startNull(b2);
    return Null.endNull(b2);
  }
  visitInt(node, b2) {
    Int.startInt(b2);
    Int.addBitWidth(b2, node.bitWidth);
    Int.addIsSigned(b2, node.isSigned);
    return Int.endInt(b2);
  }
  visitFloat(node, b2) {
    FloatingPoint.startFloatingPoint(b2);
    FloatingPoint.addPrecision(b2, node.precision);
    return FloatingPoint.endFloatingPoint(b2);
  }
  visitBinary(_node, b2) {
    Binary.startBinary(b2);
    return Binary.endBinary(b2);
  }
  visitLargeBinary(_node, b2) {
    LargeBinary.startLargeBinary(b2);
    return LargeBinary.endLargeBinary(b2);
  }
  visitBool(_node, b2) {
    Bool.startBool(b2);
    return Bool.endBool(b2);
  }
  visitUtf8(_node, b2) {
    Utf8.startUtf8(b2);
    return Utf8.endUtf8(b2);
  }
  visitLargeUtf8(_node, b2) {
    LargeUtf8.startLargeUtf8(b2);
    return LargeUtf8.endLargeUtf8(b2);
  }
  visitDecimal(node, b2) {
    Decimal.startDecimal(b2);
    Decimal.addScale(b2, node.scale);
    Decimal.addPrecision(b2, node.precision);
    Decimal.addBitWidth(b2, node.bitWidth);
    return Decimal.endDecimal(b2);
  }
  visitDate(node, b2) {
    Date2.startDate(b2);
    Date2.addUnit(b2, node.unit);
    return Date2.endDate(b2);
  }
  visitTime(node, b2) {
    Time.startTime(b2);
    Time.addUnit(b2, node.unit);
    Time.addBitWidth(b2, node.bitWidth);
    return Time.endTime(b2);
  }
  visitTimestamp(node, b2) {
    const timezone = node.timezone && b2.createString(node.timezone) || void 0;
    Timestamp.startTimestamp(b2);
    Timestamp.addUnit(b2, node.unit);
    if (timezone !== void 0) {
      Timestamp.addTimezone(b2, timezone);
    }
    return Timestamp.endTimestamp(b2);
  }
  visitInterval(node, b2) {
    Interval.startInterval(b2);
    Interval.addUnit(b2, node.unit);
    return Interval.endInterval(b2);
  }
  visitDuration(node, b2) {
    Duration.startDuration(b2);
    Duration.addUnit(b2, node.unit);
    return Duration.endDuration(b2);
  }
  visitList(_node, b2) {
    List.startList(b2);
    return List.endList(b2);
  }
  visitStruct(_node, b2) {
    Struct_.startStruct_(b2);
    return Struct_.endStruct_(b2);
  }
  visitUnion(node, b2) {
    Union.startTypeIdsVector(b2, node.typeIds.length);
    const typeIds = Union.createTypeIdsVector(b2, node.typeIds);
    Union.startUnion(b2);
    Union.addMode(b2, node.mode);
    Union.addTypeIds(b2, typeIds);
    return Union.endUnion(b2);
  }
  visitDictionary(node, b2) {
    const indexType = this.visit(node.indices, b2);
    DictionaryEncoding.startDictionaryEncoding(b2);
    DictionaryEncoding.addId(b2, BigInt(node.id));
    DictionaryEncoding.addIsOrdered(b2, node.isOrdered);
    if (indexType !== void 0) {
      DictionaryEncoding.addIndexType(b2, indexType);
    }
    return DictionaryEncoding.endDictionaryEncoding(b2);
  }
  visitFixedSizeBinary(node, b2) {
    FixedSizeBinary.startFixedSizeBinary(b2);
    FixedSizeBinary.addByteWidth(b2, node.byteWidth);
    return FixedSizeBinary.endFixedSizeBinary(b2);
  }
  visitFixedSizeList(node, b2) {
    FixedSizeList.startFixedSizeList(b2);
    FixedSizeList.addListSize(b2, node.listSize);
    return FixedSizeList.endFixedSizeList(b2);
  }
  visitMap(node, b2) {
    Map2.startMap(b2);
    Map2.addKeysSorted(b2, node.keysSorted);
    return Map2.endMap(b2);
  }
};
var instance7 = new TypeAssembler();

// ../core/node_modules/apache-arrow/ipc/metadata/json.mjs
function schemaFromJSON(_schema, dictionaries = /* @__PURE__ */ new Map()) {
  return new Schema2(schemaFieldsFromJSON(_schema, dictionaries), customMetadataFromJSON(_schema["metadata"]), dictionaries);
}
function recordBatchFromJSON(b2) {
  return new RecordBatch3(b2["count"], fieldNodesFromJSON(b2["columns"]), buffersFromJSON(b2["columns"]));
}
function dictionaryBatchFromJSON(b2) {
  return new DictionaryBatch2(recordBatchFromJSON(b2["data"]), b2["id"], b2["isDelta"]);
}
function schemaFieldsFromJSON(_schema, dictionaries) {
  return (_schema["fields"] || []).filter(Boolean).map((f2) => Field2.fromJSON(f2, dictionaries));
}
function fieldChildrenFromJSON(_field, dictionaries) {
  return (_field["children"] || []).filter(Boolean).map((f2) => Field2.fromJSON(f2, dictionaries));
}
function fieldNodesFromJSON(xs) {
  return (xs || []).reduce((fieldNodes, column3) => [
    ...fieldNodes,
    new FieldNode2(column3["count"], nullCountFromJSON(column3["VALIDITY"])),
    ...fieldNodesFromJSON(column3["children"])
  ], []);
}
function buffersFromJSON(xs, buffers = []) {
  for (let i = -1, n = (xs || []).length; ++i < n; ) {
    const column3 = xs[i];
    column3["VALIDITY"] && buffers.push(new BufferRegion(buffers.length, column3["VALIDITY"].length));
    column3["TYPE_ID"] && buffers.push(new BufferRegion(buffers.length, column3["TYPE_ID"].length));
    column3["OFFSET"] && buffers.push(new BufferRegion(buffers.length, column3["OFFSET"].length));
    column3["DATA"] && buffers.push(new BufferRegion(buffers.length, column3["DATA"].length));
    buffers = buffersFromJSON(column3["children"], buffers);
  }
  return buffers;
}
function nullCountFromJSON(validity) {
  return (validity || []).reduce((sum5, val) => sum5 + +(val === 0), 0);
}
function fieldFromJSON(_field, dictionaries) {
  let id2;
  let keys;
  let field2;
  let dictMeta;
  let type2;
  let dictType;
  if (!dictionaries || !(dictMeta = _field["dictionary"])) {
    type2 = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries));
    field2 = new Field2(_field["name"], type2, _field["nullable"], customMetadataFromJSON(_field["metadata"]));
  } else if (!dictionaries.has(id2 = dictMeta["id"])) {
    keys = (keys = dictMeta["indexType"]) ? indexTypeFromJSON(keys) : new Int32();
    dictionaries.set(id2, type2 = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries)));
    dictType = new Dictionary(type2, keys, id2, dictMeta["isOrdered"]);
    field2 = new Field2(_field["name"], dictType, _field["nullable"], customMetadataFromJSON(_field["metadata"]));
  } else {
    keys = (keys = dictMeta["indexType"]) ? indexTypeFromJSON(keys) : new Int32();
    dictType = new Dictionary(dictionaries.get(id2), keys, id2, dictMeta["isOrdered"]);
    field2 = new Field2(_field["name"], dictType, _field["nullable"], customMetadataFromJSON(_field["metadata"]));
  }
  return field2 || null;
}
function customMetadataFromJSON(metadata = []) {
  return new Map(metadata.map(({ key, value }) => [key, value]));
}
function indexTypeFromJSON(_type) {
  return new Int_(_type["isSigned"], _type["bitWidth"]);
}
function typeFromJSON(f2, children2) {
  const typeId = f2["type"]["name"];
  switch (typeId) {
    case "NONE":
      return new Null2();
    case "null":
      return new Null2();
    case "binary":
      return new Binary2();
    case "largebinary":
      return new LargeBinary2();
    case "utf8":
      return new Utf82();
    case "largeutf8":
      return new LargeUtf82();
    case "bool":
      return new Bool2();
    case "list":
      return new List2((children2 || [])[0]);
    case "struct":
      return new Struct(children2 || []);
    case "struct_":
      return new Struct(children2 || []);
  }
  switch (typeId) {
    case "int": {
      const t = f2["type"];
      return new Int_(t["isSigned"], t["bitWidth"]);
    }
    case "floatingpoint": {
      const t = f2["type"];
      return new Float(Precision[t["precision"]]);
    }
    case "decimal": {
      const t = f2["type"];
      return new Decimal2(t["scale"], t["precision"], t["bitWidth"]);
    }
    case "date": {
      const t = f2["type"];
      return new Date_(DateUnit[t["unit"]]);
    }
    case "time": {
      const t = f2["type"];
      return new Time_(TimeUnit[t["unit"]], t["bitWidth"]);
    }
    case "timestamp": {
      const t = f2["type"];
      return new Timestamp_(TimeUnit[t["unit"]], t["timezone"]);
    }
    case "interval": {
      const t = f2["type"];
      return new Interval_(IntervalUnit[t["unit"]]);
    }
    case "duration": {
      const t = f2["type"];
      return new Duration2(TimeUnit[t["unit"]]);
    }
    case "union": {
      const t = f2["type"];
      const [m2, ...ms] = (t["mode"] + "").toLowerCase();
      const mode3 = m2.toUpperCase() + ms.join("");
      return new Union_(UnionMode[mode3], t["typeIds"] || [], children2 || []);
    }
    case "fixedsizebinary": {
      const t = f2["type"];
      return new FixedSizeBinary2(t["byteWidth"]);
    }
    case "fixedsizelist": {
      const t = f2["type"];
      return new FixedSizeList2(t["listSize"], (children2 || [])[0]);
    }
    case "map": {
      const t = f2["type"];
      return new Map_((children2 || [])[0], t["keysSorted"]);
    }
  }
  throw new Error(`Unrecognized type: "${typeId}"`);
}

// ../core/node_modules/apache-arrow/ipc/metadata/message.mjs
var Builder4 = Builder;
var ByteBuffer3 = ByteBuffer;
var Message2 = class _Message {
  /** @nocollapse */
  static fromJSON(msg, headerType) {
    const message = new _Message(0, MetadataVersion.V5, headerType);
    message._createHeader = messageHeaderFromJSON(msg, headerType);
    return message;
  }
  /** @nocollapse */
  static decode(buf) {
    buf = new ByteBuffer3(toUint8Array(buf));
    const _message = Message.getRootAsMessage(buf);
    const bodyLength = _message.bodyLength();
    const version = _message.version();
    const headerType = _message.headerType();
    const message = new _Message(bodyLength, version, headerType);
    message._createHeader = decodeMessageHeader(_message, headerType);
    return message;
  }
  /** @nocollapse */
  static encode(message) {
    const b2 = new Builder4();
    let headerOffset = -1;
    if (message.isSchema()) {
      headerOffset = Schema2.encode(b2, message.header());
    } else if (message.isRecordBatch()) {
      headerOffset = RecordBatch3.encode(b2, message.header());
    } else if (message.isDictionaryBatch()) {
      headerOffset = DictionaryBatch2.encode(b2, message.header());
    }
    Message.startMessage(b2);
    Message.addVersion(b2, MetadataVersion.V5);
    Message.addHeader(b2, headerOffset);
    Message.addHeaderType(b2, message.headerType);
    Message.addBodyLength(b2, BigInt(message.bodyLength));
    Message.finishMessageBuffer(b2, Message.endMessage(b2));
    return b2.asUint8Array();
  }
  /** @nocollapse */
  static from(header, bodyLength = 0) {
    if (header instanceof Schema2) {
      return new _Message(0, MetadataVersion.V5, MessageHeader.Schema, header);
    }
    if (header instanceof RecordBatch3) {
      return new _Message(bodyLength, MetadataVersion.V5, MessageHeader.RecordBatch, header);
    }
    if (header instanceof DictionaryBatch2) {
      return new _Message(bodyLength, MetadataVersion.V5, MessageHeader.DictionaryBatch, header);
    }
    throw new Error(`Unrecognized Message header: ${header}`);
  }
  get type() {
    return this.headerType;
  }
  get version() {
    return this._version;
  }
  get headerType() {
    return this._headerType;
  }
  get bodyLength() {
    return this._bodyLength;
  }
  header() {
    return this._createHeader();
  }
  isSchema() {
    return this.headerType === MessageHeader.Schema;
  }
  isRecordBatch() {
    return this.headerType === MessageHeader.RecordBatch;
  }
  isDictionaryBatch() {
    return this.headerType === MessageHeader.DictionaryBatch;
  }
  constructor(bodyLength, version, headerType, header) {
    this._version = version;
    this._headerType = headerType;
    this.body = new Uint8Array(0);
    header && (this._createHeader = () => header);
    this._bodyLength = bigIntToNumber(bodyLength);
  }
};
var RecordBatch3 = class {
  get nodes() {
    return this._nodes;
  }
  get length() {
    return this._length;
  }
  get buffers() {
    return this._buffers;
  }
  constructor(length4, nodes, buffers) {
    this._nodes = nodes;
    this._buffers = buffers;
    this._length = bigIntToNumber(length4);
  }
};
var DictionaryBatch2 = class {
  get id() {
    return this._id;
  }
  get data() {
    return this._data;
  }
  get isDelta() {
    return this._isDelta;
  }
  get length() {
    return this.data.length;
  }
  get nodes() {
    return this.data.nodes;
  }
  get buffers() {
    return this.data.buffers;
  }
  constructor(data, id2, isDelta = false) {
    this._data = data;
    this._isDelta = isDelta;
    this._id = bigIntToNumber(id2);
  }
};
var BufferRegion = class {
  constructor(offset2, length4) {
    this.offset = bigIntToNumber(offset2);
    this.length = bigIntToNumber(length4);
  }
};
var FieldNode2 = class {
  constructor(length4, nullCount) {
    this.length = bigIntToNumber(length4);
    this.nullCount = bigIntToNumber(nullCount);
  }
};
function messageHeaderFromJSON(message, type2) {
  return () => {
    switch (type2) {
      case MessageHeader.Schema:
        return Schema2.fromJSON(message);
      case MessageHeader.RecordBatch:
        return RecordBatch3.fromJSON(message);
      case MessageHeader.DictionaryBatch:
        return DictionaryBatch2.fromJSON(message);
    }
    throw new Error(`Unrecognized Message type: { name: ${MessageHeader[type2]}, type: ${type2} }`);
  };
}
function decodeMessageHeader(message, type2) {
  return () => {
    switch (type2) {
      case MessageHeader.Schema:
        return Schema2.decode(message.header(new Schema()), /* @__PURE__ */ new Map(), message.version());
      case MessageHeader.RecordBatch:
        return RecordBatch3.decode(message.header(new RecordBatch()), message.version());
      case MessageHeader.DictionaryBatch:
        return DictionaryBatch2.decode(message.header(new DictionaryBatch()), message.version());
    }
    throw new Error(`Unrecognized Message type: { name: ${MessageHeader[type2]}, type: ${type2} }`);
  };
}
Field2["encode"] = encodeField;
Field2["decode"] = decodeField;
Field2["fromJSON"] = fieldFromJSON;
Schema2["encode"] = encodeSchema;
Schema2["decode"] = decodeSchema;
Schema2["fromJSON"] = schemaFromJSON;
RecordBatch3["encode"] = encodeRecordBatch;
RecordBatch3["decode"] = decodeRecordBatch;
RecordBatch3["fromJSON"] = recordBatchFromJSON;
DictionaryBatch2["encode"] = encodeDictionaryBatch;
DictionaryBatch2["decode"] = decodeDictionaryBatch;
DictionaryBatch2["fromJSON"] = dictionaryBatchFromJSON;
FieldNode2["encode"] = encodeFieldNode;
FieldNode2["decode"] = decodeFieldNode;
BufferRegion["encode"] = encodeBufferRegion;
BufferRegion["decode"] = decodeBufferRegion;
function decodeSchema(_schema, dictionaries = /* @__PURE__ */ new Map(), version = MetadataVersion.V5) {
  const fields = decodeSchemaFields(_schema, dictionaries);
  return new Schema2(fields, decodeCustomMetadata(_schema), dictionaries, version);
}
function decodeRecordBatch(batch, version = MetadataVersion.V5) {
  if (batch.compression() !== null) {
    throw new Error("Record batch compression not implemented");
  }
  return new RecordBatch3(batch.length(), decodeFieldNodes(batch), decodeBuffers(batch, version));
}
function decodeDictionaryBatch(batch, version = MetadataVersion.V5) {
  return new DictionaryBatch2(RecordBatch3.decode(batch.data(), version), batch.id(), batch.isDelta());
}
function decodeBufferRegion(b2) {
  return new BufferRegion(b2.offset(), b2.length());
}
function decodeFieldNode(f2) {
  return new FieldNode2(f2.length(), f2.nullCount());
}
function decodeFieldNodes(batch) {
  const nodes = [];
  for (let f2, i = -1, j2 = -1, n = batch.nodesLength(); ++i < n; ) {
    if (f2 = batch.nodes(i)) {
      nodes[++j2] = FieldNode2.decode(f2);
    }
  }
  return nodes;
}
function decodeBuffers(batch, version) {
  const bufferRegions = [];
  for (let b2, i = -1, j2 = -1, n = batch.buffersLength(); ++i < n; ) {
    if (b2 = batch.buffers(i)) {
      if (version < MetadataVersion.V4) {
        b2.bb_pos += 8 * (i + 1);
      }
      bufferRegions[++j2] = BufferRegion.decode(b2);
    }
  }
  return bufferRegions;
}
function decodeSchemaFields(schema, dictionaries) {
  const fields = [];
  for (let f2, i = -1, j2 = -1, n = schema.fieldsLength(); ++i < n; ) {
    if (f2 = schema.fields(i)) {
      fields[++j2] = Field2.decode(f2, dictionaries);
    }
  }
  return fields;
}
function decodeFieldChildren(field2, dictionaries) {
  const children2 = [];
  for (let f2, i = -1, j2 = -1, n = field2.childrenLength(); ++i < n; ) {
    if (f2 = field2.children(i)) {
      children2[++j2] = Field2.decode(f2, dictionaries);
    }
  }
  return children2;
}
function decodeField(f2, dictionaries) {
  let id2;
  let field2;
  let type2;
  let keys;
  let dictType;
  let dictMeta;
  if (!dictionaries || !(dictMeta = f2.dictionary())) {
    type2 = decodeFieldType(f2, decodeFieldChildren(f2, dictionaries));
    field2 = new Field2(f2.name(), type2, f2.nullable(), decodeCustomMetadata(f2));
  } else if (!dictionaries.has(id2 = bigIntToNumber(dictMeta.id()))) {
    keys = (keys = dictMeta.indexType()) ? decodeIndexType(keys) : new Int32();
    dictionaries.set(id2, type2 = decodeFieldType(f2, decodeFieldChildren(f2, dictionaries)));
    dictType = new Dictionary(type2, keys, id2, dictMeta.isOrdered());
    field2 = new Field2(f2.name(), dictType, f2.nullable(), decodeCustomMetadata(f2));
  } else {
    keys = (keys = dictMeta.indexType()) ? decodeIndexType(keys) : new Int32();
    dictType = new Dictionary(dictionaries.get(id2), keys, id2, dictMeta.isOrdered());
    field2 = new Field2(f2.name(), dictType, f2.nullable(), decodeCustomMetadata(f2));
  }
  return field2 || null;
}
function decodeCustomMetadata(parent) {
  const data = /* @__PURE__ */ new Map();
  if (parent) {
    for (let entry, key, i = -1, n = Math.trunc(parent.customMetadataLength()); ++i < n; ) {
      if ((entry = parent.customMetadata(i)) && (key = entry.key()) != null) {
        data.set(key, entry.value());
      }
    }
  }
  return data;
}
function decodeIndexType(_type) {
  return new Int_(_type.isSigned(), _type.bitWidth());
}
function decodeFieldType(f2, children2) {
  const typeId = f2.typeType();
  switch (typeId) {
    case Type["NONE"]:
      return new Null2();
    case Type["Null"]:
      return new Null2();
    case Type["Binary"]:
      return new Binary2();
    case Type["LargeBinary"]:
      return new LargeBinary2();
    case Type["Utf8"]:
      return new Utf82();
    case Type["LargeUtf8"]:
      return new LargeUtf82();
    case Type["Bool"]:
      return new Bool2();
    case Type["List"]:
      return new List2((children2 || [])[0]);
    case Type["Struct_"]:
      return new Struct(children2 || []);
  }
  switch (typeId) {
    case Type["Int"]: {
      const t = f2.type(new Int());
      return new Int_(t.isSigned(), t.bitWidth());
    }
    case Type["FloatingPoint"]: {
      const t = f2.type(new FloatingPoint());
      return new Float(t.precision());
    }
    case Type["Decimal"]: {
      const t = f2.type(new Decimal());
      return new Decimal2(t.scale(), t.precision(), t.bitWidth());
    }
    case Type["Date"]: {
      const t = f2.type(new Date2());
      return new Date_(t.unit());
    }
    case Type["Time"]: {
      const t = f2.type(new Time());
      return new Time_(t.unit(), t.bitWidth());
    }
    case Type["Timestamp"]: {
      const t = f2.type(new Timestamp());
      return new Timestamp_(t.unit(), t.timezone());
    }
    case Type["Interval"]: {
      const t = f2.type(new Interval());
      return new Interval_(t.unit());
    }
    case Type["Duration"]: {
      const t = f2.type(new Duration());
      return new Duration2(t.unit());
    }
    case Type["Union"]: {
      const t = f2.type(new Union());
      return new Union_(t.mode(), t.typeIdsArray() || [], children2 || []);
    }
    case Type["FixedSizeBinary"]: {
      const t = f2.type(new FixedSizeBinary());
      return new FixedSizeBinary2(t.byteWidth());
    }
    case Type["FixedSizeList"]: {
      const t = f2.type(new FixedSizeList());
      return new FixedSizeList2(t.listSize(), (children2 || [])[0]);
    }
    case Type["Map"]: {
      const t = f2.type(new Map2());
      return new Map_((children2 || [])[0], t.keysSorted());
    }
  }
  throw new Error(`Unrecognized type: "${Type[typeId]}" (${typeId})`);
}
function encodeSchema(b2, schema) {
  const fieldOffsets = schema.fields.map((f2) => Field2.encode(b2, f2));
  Schema.startFieldsVector(b2, fieldOffsets.length);
  const fieldsVectorOffset = Schema.createFieldsVector(b2, fieldOffsets);
  const metadataOffset = !(schema.metadata && schema.metadata.size > 0) ? -1 : Schema.createCustomMetadataVector(b2, [...schema.metadata].map(([k3, v3]) => {
    const key = b2.createString(`${k3}`);
    const val = b2.createString(`${v3}`);
    KeyValue.startKeyValue(b2);
    KeyValue.addKey(b2, key);
    KeyValue.addValue(b2, val);
    return KeyValue.endKeyValue(b2);
  }));
  Schema.startSchema(b2);
  Schema.addFields(b2, fieldsVectorOffset);
  Schema.addEndianness(b2, platformIsLittleEndian ? Endianness.Little : Endianness.Big);
  if (metadataOffset !== -1) {
    Schema.addCustomMetadata(b2, metadataOffset);
  }
  return Schema.endSchema(b2);
}
function encodeField(b2, field2) {
  let nameOffset = -1;
  let typeOffset = -1;
  let dictionaryOffset = -1;
  const type2 = field2.type;
  let typeId = field2.typeId;
  if (!DataType.isDictionary(type2)) {
    typeOffset = instance7.visit(type2, b2);
  } else {
    typeId = type2.dictionary.typeId;
    dictionaryOffset = instance7.visit(type2, b2);
    typeOffset = instance7.visit(type2.dictionary, b2);
  }
  const childOffsets = (type2.children || []).map((f2) => Field2.encode(b2, f2));
  const childrenVectorOffset = Field.createChildrenVector(b2, childOffsets);
  const metadataOffset = !(field2.metadata && field2.metadata.size > 0) ? -1 : Field.createCustomMetadataVector(b2, [...field2.metadata].map(([k3, v3]) => {
    const key = b2.createString(`${k3}`);
    const val = b2.createString(`${v3}`);
    KeyValue.startKeyValue(b2);
    KeyValue.addKey(b2, key);
    KeyValue.addValue(b2, val);
    return KeyValue.endKeyValue(b2);
  }));
  if (field2.name) {
    nameOffset = b2.createString(field2.name);
  }
  Field.startField(b2);
  Field.addType(b2, typeOffset);
  Field.addTypeType(b2, typeId);
  Field.addChildren(b2, childrenVectorOffset);
  Field.addNullable(b2, !!field2.nullable);
  if (nameOffset !== -1) {
    Field.addName(b2, nameOffset);
  }
  if (dictionaryOffset !== -1) {
    Field.addDictionary(b2, dictionaryOffset);
  }
  if (metadataOffset !== -1) {
    Field.addCustomMetadata(b2, metadataOffset);
  }
  return Field.endField(b2);
}
function encodeRecordBatch(b2, recordBatch) {
  const nodes = recordBatch.nodes || [];
  const buffers = recordBatch.buffers || [];
  RecordBatch.startNodesVector(b2, nodes.length);
  for (const n of nodes.slice().reverse())
    FieldNode2.encode(b2, n);
  const nodesVectorOffset = b2.endVector();
  RecordBatch.startBuffersVector(b2, buffers.length);
  for (const b_ of buffers.slice().reverse())
    BufferRegion.encode(b2, b_);
  const buffersVectorOffset = b2.endVector();
  RecordBatch.startRecordBatch(b2);
  RecordBatch.addLength(b2, BigInt(recordBatch.length));
  RecordBatch.addNodes(b2, nodesVectorOffset);
  RecordBatch.addBuffers(b2, buffersVectorOffset);
  return RecordBatch.endRecordBatch(b2);
}
function encodeDictionaryBatch(b2, dictionaryBatch) {
  const dataOffset = RecordBatch3.encode(b2, dictionaryBatch.data);
  DictionaryBatch.startDictionaryBatch(b2);
  DictionaryBatch.addId(b2, BigInt(dictionaryBatch.id));
  DictionaryBatch.addIsDelta(b2, dictionaryBatch.isDelta);
  DictionaryBatch.addData(b2, dataOffset);
  return DictionaryBatch.endDictionaryBatch(b2);
}
function encodeFieldNode(b2, node) {
  return FieldNode.createFieldNode(b2, BigInt(node.length), BigInt(node.nullCount));
}
function encodeBufferRegion(b2, node) {
  return Buffer2.createBuffer(b2, BigInt(node.offset), BigInt(node.length));
}
var platformIsLittleEndian = (() => {
  const buffer = new ArrayBuffer(2);
  new DataView(buffer).setInt16(
    0,
    256,
    true
    /* littleEndian */
  );
  return new Int16Array(buffer)[0] === 256;
})();

// ../core/node_modules/apache-arrow/ipc/message.mjs
var invalidMessageType = (type2) => `Expected ${MessageHeader[type2]} Message in stream, but was null or length 0.`;
var nullMessage = (type2) => `Header pointer of flatbuffer-encoded ${MessageHeader[type2]} Message is null or length 0.`;
var invalidMessageMetadata = (expected, actual) => `Expected to read ${expected} metadata bytes, but only read ${actual}.`;
var invalidMessageBodyLength = (expected, actual) => `Expected to read ${expected} bytes for message body, but only read ${actual}.`;
var MessageReader = class {
  constructor(source) {
    this.source = source instanceof ByteStream ? source : new ByteStream(source);
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    let r;
    if ((r = this.readMetadataLength()).done) {
      return ITERATOR_DONE;
    }
    if (r.value === -1 && (r = this.readMetadataLength()).done) {
      return ITERATOR_DONE;
    }
    if ((r = this.readMetadata(r.value)).done) {
      return ITERATOR_DONE;
    }
    return r;
  }
  throw(value) {
    return this.source.throw(value);
  }
  return(value) {
    return this.source.return(value);
  }
  readMessage(type2) {
    let r;
    if ((r = this.next()).done) {
      return null;
    }
    if (type2 != null && r.value.headerType !== type2) {
      throw new Error(invalidMessageType(type2));
    }
    return r.value;
  }
  readMessageBody(bodyLength) {
    if (bodyLength <= 0) {
      return new Uint8Array(0);
    }
    const buf = toUint8Array(this.source.read(bodyLength));
    if (buf.byteLength < bodyLength) {
      throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));
    }
    return (
      /* 1. */
      buf.byteOffset % 8 === 0 && /* 2. */
      buf.byteOffset + buf.byteLength <= buf.buffer.byteLength ? buf : buf.slice()
    );
  }
  readSchema(throwIfNull = false) {
    const type2 = MessageHeader.Schema;
    const message = this.readMessage(type2);
    const schema = message === null || message === void 0 ? void 0 : message.header();
    if (throwIfNull && !schema) {
      throw new Error(nullMessage(type2));
    }
    return schema;
  }
  readMetadataLength() {
    const buf = this.source.read(PADDING);
    const bb2 = buf && new ByteBuffer(buf);
    const len = (bb2 === null || bb2 === void 0 ? void 0 : bb2.readInt32(0)) || 0;
    return { done: len === 0, value: len };
  }
  readMetadata(metadataLength) {
    const buf = this.source.read(metadataLength);
    if (!buf) {
      return ITERATOR_DONE;
    }
    if (buf.byteLength < metadataLength) {
      throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));
    }
    return { done: false, value: Message2.decode(buf) };
  }
};
var AsyncMessageReader = class {
  constructor(source, byteLength) {
    this.source = source instanceof AsyncByteStream ? source : isFileHandle(source) ? new AsyncRandomAccessFile(source, byteLength) : new AsyncByteStream(source);
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  next() {
    return __awaiter(this, void 0, void 0, function* () {
      let r;
      if ((r = yield this.readMetadataLength()).done) {
        return ITERATOR_DONE;
      }
      if (r.value === -1 && (r = yield this.readMetadataLength()).done) {
        return ITERATOR_DONE;
      }
      if ((r = yield this.readMetadata(r.value)).done) {
        return ITERATOR_DONE;
      }
      return r;
    });
  }
  throw(value) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this.source.throw(value);
    });
  }
  return(value) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this.source.return(value);
    });
  }
  readMessage(type2) {
    return __awaiter(this, void 0, void 0, function* () {
      let r;
      if ((r = yield this.next()).done) {
        return null;
      }
      if (type2 != null && r.value.headerType !== type2) {
        throw new Error(invalidMessageType(type2));
      }
      return r.value;
    });
  }
  readMessageBody(bodyLength) {
    return __awaiter(this, void 0, void 0, function* () {
      if (bodyLength <= 0) {
        return new Uint8Array(0);
      }
      const buf = toUint8Array(yield this.source.read(bodyLength));
      if (buf.byteLength < bodyLength) {
        throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));
      }
      return (
        /* 1. */
        buf.byteOffset % 8 === 0 && /* 2. */
        buf.byteOffset + buf.byteLength <= buf.buffer.byteLength ? buf : buf.slice()
      );
    });
  }
  readSchema(throwIfNull = false) {
    return __awaiter(this, void 0, void 0, function* () {
      const type2 = MessageHeader.Schema;
      const message = yield this.readMessage(type2);
      const schema = message === null || message === void 0 ? void 0 : message.header();
      if (throwIfNull && !schema) {
        throw new Error(nullMessage(type2));
      }
      return schema;
    });
  }
  readMetadataLength() {
    return __awaiter(this, void 0, void 0, function* () {
      const buf = yield this.source.read(PADDING);
      const bb2 = buf && new ByteBuffer(buf);
      const len = (bb2 === null || bb2 === void 0 ? void 0 : bb2.readInt32(0)) || 0;
      return { done: len === 0, value: len };
    });
  }
  readMetadata(metadataLength) {
    return __awaiter(this, void 0, void 0, function* () {
      const buf = yield this.source.read(metadataLength);
      if (!buf) {
        return ITERATOR_DONE;
      }
      if (buf.byteLength < metadataLength) {
        throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));
      }
      return { done: false, value: Message2.decode(buf) };
    });
  }
};
var JSONMessageReader = class extends MessageReader {
  constructor(source) {
    super(new Uint8Array(0));
    this._schema = false;
    this._body = [];
    this._batchIndex = 0;
    this._dictionaryIndex = 0;
    this._json = source instanceof ArrowJSON ? source : new ArrowJSON(source);
  }
  next() {
    const { _json } = this;
    if (!this._schema) {
      this._schema = true;
      const message = Message2.fromJSON(_json.schema, MessageHeader.Schema);
      return { done: false, value: message };
    }
    if (this._dictionaryIndex < _json.dictionaries.length) {
      const batch = _json.dictionaries[this._dictionaryIndex++];
      this._body = batch["data"]["columns"];
      const message = Message2.fromJSON(batch, MessageHeader.DictionaryBatch);
      return { done: false, value: message };
    }
    if (this._batchIndex < _json.batches.length) {
      const batch = _json.batches[this._batchIndex++];
      this._body = batch["columns"];
      const message = Message2.fromJSON(batch, MessageHeader.RecordBatch);
      return { done: false, value: message };
    }
    this._body = [];
    return ITERATOR_DONE;
  }
  readMessageBody(_bodyLength) {
    return flattenDataSources(this._body);
    function flattenDataSources(xs) {
      return (xs || []).reduce((buffers, column3) => [
        ...buffers,
        ...column3["VALIDITY"] && [column3["VALIDITY"]] || [],
        ...column3["TYPE_ID"] && [column3["TYPE_ID"]] || [],
        ...column3["OFFSET"] && [column3["OFFSET"]] || [],
        ...column3["DATA"] && [column3["DATA"]] || [],
        ...flattenDataSources(column3["children"])
      ], []);
    }
  }
  readMessage(type2) {
    let r;
    if ((r = this.next()).done) {
      return null;
    }
    if (type2 != null && r.value.headerType !== type2) {
      throw new Error(invalidMessageType(type2));
    }
    return r.value;
  }
  readSchema() {
    const type2 = MessageHeader.Schema;
    const message = this.readMessage(type2);
    const schema = message === null || message === void 0 ? void 0 : message.header();
    if (!message || !schema) {
      throw new Error(nullMessage(type2));
    }
    return schema;
  }
};
var PADDING = 4;
var MAGIC_STR = "ARROW1";
var MAGIC = new Uint8Array(MAGIC_STR.length);
for (let i = 0; i < MAGIC_STR.length; i += 1) {
  MAGIC[i] = MAGIC_STR.codePointAt(i);
}
function checkForMagicArrowString(buffer, index2 = 0) {
  for (let i = -1, n = MAGIC.length; ++i < n; ) {
    if (MAGIC[i] !== buffer[index2 + i]) {
      return false;
    }
  }
  return true;
}
var magicLength = MAGIC.length;
var magicAndPadding = magicLength + PADDING;
var magicX2AndPadding = magicLength * 2 + PADDING;

// ../core/node_modules/apache-arrow/ipc/reader.mjs
var RecordBatchReader = class _RecordBatchReader extends ReadableInterop {
  constructor(impl) {
    super();
    this._impl = impl;
  }
  get closed() {
    return this._impl.closed;
  }
  get schema() {
    return this._impl.schema;
  }
  get autoDestroy() {
    return this._impl.autoDestroy;
  }
  get dictionaries() {
    return this._impl.dictionaries;
  }
  get numDictionaries() {
    return this._impl.numDictionaries;
  }
  get numRecordBatches() {
    return this._impl.numRecordBatches;
  }
  get footer() {
    return this._impl.isFile() ? this._impl.footer : null;
  }
  isSync() {
    return this._impl.isSync();
  }
  isAsync() {
    return this._impl.isAsync();
  }
  isFile() {
    return this._impl.isFile();
  }
  isStream() {
    return this._impl.isStream();
  }
  next() {
    return this._impl.next();
  }
  throw(value) {
    return this._impl.throw(value);
  }
  return(value) {
    return this._impl.return(value);
  }
  cancel() {
    return this._impl.cancel();
  }
  reset(schema) {
    this._impl.reset(schema);
    this._DOMStream = void 0;
    this._nodeStream = void 0;
    return this;
  }
  open(options) {
    const opening = this._impl.open(options);
    return isPromise(opening) ? opening.then(() => this) : this;
  }
  readRecordBatch(index2) {
    return this._impl.isFile() ? this._impl.readRecordBatch(index2) : null;
  }
  [Symbol.iterator]() {
    return this._impl[Symbol.iterator]();
  }
  [Symbol.asyncIterator]() {
    return this._impl[Symbol.asyncIterator]();
  }
  toDOMStream() {
    return adapters_default.toDOMStream(this.isSync() ? { [Symbol.iterator]: () => this } : { [Symbol.asyncIterator]: () => this });
  }
  toNodeStream() {
    return adapters_default.toNodeStream(this.isSync() ? { [Symbol.iterator]: () => this } : { [Symbol.asyncIterator]: () => this }, { objectMode: true });
  }
  /** @nocollapse */
  // @ts-ignore
  static throughNode(options) {
    throw new Error(`"throughNode" not available in this environment`);
  }
  /** @nocollapse */
  static throughDOM(writableStrategy, readableStrategy) {
    throw new Error(`"throughDOM" not available in this environment`);
  }
  /** @nocollapse */
  static from(source) {
    if (source instanceof _RecordBatchReader) {
      return source;
    } else if (isArrowJSON(source)) {
      return fromArrowJSON(source);
    } else if (isFileHandle(source)) {
      return fromFileHandle(source);
    } else if (isPromise(source)) {
      return (() => __awaiter(this, void 0, void 0, function* () {
        return yield _RecordBatchReader.from(yield source);
      }))();
    } else if (isFetchResponse(source) || isReadableDOMStream(source) || isReadableNodeStream(source) || isAsyncIterable(source)) {
      return fromAsyncByteStream(new AsyncByteStream(source));
    }
    return fromByteStream(new ByteStream(source));
  }
  /** @nocollapse */
  static readAll(source) {
    if (source instanceof _RecordBatchReader) {
      return source.isSync() ? readAllSync(source) : readAllAsync(source);
    } else if (isArrowJSON(source) || ArrayBuffer.isView(source) || isIterable(source) || isIteratorResult(source)) {
      return readAllSync(source);
    }
    return readAllAsync(source);
  }
};
var RecordBatchStreamReader = class extends RecordBatchReader {
  constructor(_impl) {
    super(_impl);
    this._impl = _impl;
  }
  readAll() {
    return [...this];
  }
  [Symbol.iterator]() {
    return this._impl[Symbol.iterator]();
  }
  [Symbol.asyncIterator]() {
    return __asyncGenerator(this, arguments, function* _a9() {
      yield __await(yield* __asyncDelegator(__asyncValues(this[Symbol.iterator]())));
    });
  }
};
var AsyncRecordBatchStreamReader = class extends RecordBatchReader {
  constructor(_impl) {
    super(_impl);
    this._impl = _impl;
  }
  readAll() {
    var _a9, e_1, _b3, _c3;
    return __awaiter(this, void 0, void 0, function* () {
      const batches = new Array();
      try {
        for (var _d3 = true, _e3 = __asyncValues(this), _f3; _f3 = yield _e3.next(), _a9 = _f3.done, !_a9; _d3 = true) {
          _c3 = _f3.value;
          _d3 = false;
          const batch = _c3;
          batches.push(batch);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (!_d3 && !_a9 && (_b3 = _e3.return))
            yield _b3.call(_e3);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return batches;
    });
  }
  [Symbol.iterator]() {
    throw new Error(`AsyncRecordBatchStreamReader is not Iterable`);
  }
  [Symbol.asyncIterator]() {
    return this._impl[Symbol.asyncIterator]();
  }
};
var RecordBatchFileReader = class extends RecordBatchStreamReader {
  constructor(_impl) {
    super(_impl);
    this._impl = _impl;
  }
};
var AsyncRecordBatchFileReader = class extends AsyncRecordBatchStreamReader {
  constructor(_impl) {
    super(_impl);
    this._impl = _impl;
  }
};
var RecordBatchReaderImpl = class {
  get numDictionaries() {
    return this._dictionaryIndex;
  }
  get numRecordBatches() {
    return this._recordBatchIndex;
  }
  constructor(dictionaries = /* @__PURE__ */ new Map()) {
    this.closed = false;
    this.autoDestroy = true;
    this._dictionaryIndex = 0;
    this._recordBatchIndex = 0;
    this.dictionaries = dictionaries;
  }
  isSync() {
    return false;
  }
  isAsync() {
    return false;
  }
  isFile() {
    return false;
  }
  isStream() {
    return false;
  }
  reset(schema) {
    this._dictionaryIndex = 0;
    this._recordBatchIndex = 0;
    this.schema = schema;
    this.dictionaries = /* @__PURE__ */ new Map();
    return this;
  }
  _loadRecordBatch(header, body) {
    const children2 = this._loadVectors(header, body, this.schema.fields);
    const data = makeData({ type: new Struct(this.schema.fields), length: header.length, children: children2 });
    return new RecordBatch2(this.schema, data);
  }
  _loadDictionaryBatch(header, body) {
    const { id: id2, isDelta } = header;
    const { dictionaries, schema } = this;
    const dictionary = dictionaries.get(id2);
    if (isDelta || !dictionary) {
      const type2 = schema.dictionaries.get(id2);
      const data = this._loadVectors(header.data, body, [type2]);
      return (dictionary && isDelta ? dictionary.concat(new Vector(data)) : new Vector(data)).memoize();
    }
    return dictionary.memoize();
  }
  _loadVectors(header, body, types) {
    return new VectorLoader(body, header.nodes, header.buffers, this.dictionaries, this.schema.metadataVersion).visitMany(types);
  }
};
var RecordBatchStreamReaderImpl = class extends RecordBatchReaderImpl {
  constructor(source, dictionaries) {
    super(dictionaries);
    this._reader = !isArrowJSON(source) ? new MessageReader(this._handle = source) : new JSONMessageReader(this._handle = source);
  }
  isSync() {
    return true;
  }
  isStream() {
    return true;
  }
  [Symbol.iterator]() {
    return this;
  }
  cancel() {
    if (!this.closed && (this.closed = true)) {
      this.reset()._reader.return();
      this._reader = null;
      this.dictionaries = null;
    }
  }
  open(options) {
    if (!this.closed) {
      this.autoDestroy = shouldAutoDestroy(this, options);
      if (!(this.schema || (this.schema = this._reader.readSchema()))) {
        this.cancel();
      }
    }
    return this;
  }
  throw(value) {
    if (!this.closed && this.autoDestroy && (this.closed = true)) {
      return this.reset()._reader.throw(value);
    }
    return ITERATOR_DONE;
  }
  return(value) {
    if (!this.closed && this.autoDestroy && (this.closed = true)) {
      return this.reset()._reader.return(value);
    }
    return ITERATOR_DONE;
  }
  next() {
    if (this.closed) {
      return ITERATOR_DONE;
    }
    let message;
    const { _reader: reader } = this;
    while (message = this._readNextMessageAndValidate()) {
      if (message.isSchema()) {
        this.reset(message.header());
      } else if (message.isRecordBatch()) {
        this._recordBatchIndex++;
        const header = message.header();
        const buffer = reader.readMessageBody(message.bodyLength);
        const recordBatch = this._loadRecordBatch(header, buffer);
        return { done: false, value: recordBatch };
      } else if (message.isDictionaryBatch()) {
        this._dictionaryIndex++;
        const header = message.header();
        const buffer = reader.readMessageBody(message.bodyLength);
        const vector3 = this._loadDictionaryBatch(header, buffer);
        this.dictionaries.set(header.id, vector3);
      }
    }
    if (this.schema && this._recordBatchIndex === 0) {
      this._recordBatchIndex++;
      return { done: false, value: new _InternalEmptyPlaceholderRecordBatch(this.schema) };
    }
    return this.return();
  }
  _readNextMessageAndValidate(type2) {
    return this._reader.readMessage(type2);
  }
};
var AsyncRecordBatchStreamReaderImpl = class extends RecordBatchReaderImpl {
  constructor(source, dictionaries) {
    super(dictionaries);
    this._reader = new AsyncMessageReader(this._handle = source);
  }
  isAsync() {
    return true;
  }
  isStream() {
    return true;
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  cancel() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.closed && (this.closed = true)) {
        yield this.reset()._reader.return();
        this._reader = null;
        this.dictionaries = null;
      }
    });
  }
  open(options) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.closed) {
        this.autoDestroy = shouldAutoDestroy(this, options);
        if (!(this.schema || (this.schema = yield this._reader.readSchema()))) {
          yield this.cancel();
        }
      }
      return this;
    });
  }
  throw(value) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.closed && this.autoDestroy && (this.closed = true)) {
        return yield this.reset()._reader.throw(value);
      }
      return ITERATOR_DONE;
    });
  }
  return(value) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.closed && this.autoDestroy && (this.closed = true)) {
        return yield this.reset()._reader.return(value);
      }
      return ITERATOR_DONE;
    });
  }
  next() {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.closed) {
        return ITERATOR_DONE;
      }
      let message;
      const { _reader: reader } = this;
      while (message = yield this._readNextMessageAndValidate()) {
        if (message.isSchema()) {
          yield this.reset(message.header());
        } else if (message.isRecordBatch()) {
          this._recordBatchIndex++;
          const header = message.header();
          const buffer = yield reader.readMessageBody(message.bodyLength);
          const recordBatch = this._loadRecordBatch(header, buffer);
          return { done: false, value: recordBatch };
        } else if (message.isDictionaryBatch()) {
          this._dictionaryIndex++;
          const header = message.header();
          const buffer = yield reader.readMessageBody(message.bodyLength);
          const vector3 = this._loadDictionaryBatch(header, buffer);
          this.dictionaries.set(header.id, vector3);
        }
      }
      if (this.schema && this._recordBatchIndex === 0) {
        this._recordBatchIndex++;
        return { done: false, value: new _InternalEmptyPlaceholderRecordBatch(this.schema) };
      }
      return yield this.return();
    });
  }
  _readNextMessageAndValidate(type2) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this._reader.readMessage(type2);
    });
  }
};
var RecordBatchFileReaderImpl = class extends RecordBatchStreamReaderImpl {
  get footer() {
    return this._footer;
  }
  get numDictionaries() {
    return this._footer ? this._footer.numDictionaries : 0;
  }
  get numRecordBatches() {
    return this._footer ? this._footer.numRecordBatches : 0;
  }
  constructor(source, dictionaries) {
    super(source instanceof RandomAccessFile ? source : new RandomAccessFile(source), dictionaries);
  }
  isSync() {
    return true;
  }
  isFile() {
    return true;
  }
  open(options) {
    if (!this.closed && !this._footer) {
      this.schema = (this._footer = this._readFooter()).schema;
      for (const block of this._footer.dictionaryBatches()) {
        block && this._readDictionaryBatch(this._dictionaryIndex++);
      }
    }
    return super.open(options);
  }
  readRecordBatch(index2) {
    var _a9;
    if (this.closed) {
      return null;
    }
    if (!this._footer) {
      this.open();
    }
    const block = (_a9 = this._footer) === null || _a9 === void 0 ? void 0 : _a9.getRecordBatch(index2);
    if (block && this._handle.seek(block.offset)) {
      const message = this._reader.readMessage(MessageHeader.RecordBatch);
      if (message === null || message === void 0 ? void 0 : message.isRecordBatch()) {
        const header = message.header();
        const buffer = this._reader.readMessageBody(message.bodyLength);
        const recordBatch = this._loadRecordBatch(header, buffer);
        return recordBatch;
      }
    }
    return null;
  }
  _readDictionaryBatch(index2) {
    var _a9;
    const block = (_a9 = this._footer) === null || _a9 === void 0 ? void 0 : _a9.getDictionaryBatch(index2);
    if (block && this._handle.seek(block.offset)) {
      const message = this._reader.readMessage(MessageHeader.DictionaryBatch);
      if (message === null || message === void 0 ? void 0 : message.isDictionaryBatch()) {
        const header = message.header();
        const buffer = this._reader.readMessageBody(message.bodyLength);
        const vector3 = this._loadDictionaryBatch(header, buffer);
        this.dictionaries.set(header.id, vector3);
      }
    }
  }
  _readFooter() {
    const { _handle } = this;
    const offset2 = _handle.size - magicAndPadding;
    const length4 = _handle.readInt32(offset2);
    const buffer = _handle.readAt(offset2 - length4, length4);
    return Footer_.decode(buffer);
  }
  _readNextMessageAndValidate(type2) {
    var _a9;
    if (!this._footer) {
      this.open();
    }
    if (this._footer && this._recordBatchIndex < this.numRecordBatches) {
      const block = (_a9 = this._footer) === null || _a9 === void 0 ? void 0 : _a9.getRecordBatch(this._recordBatchIndex);
      if (block && this._handle.seek(block.offset)) {
        return this._reader.readMessage(type2);
      }
    }
    return null;
  }
};
var AsyncRecordBatchFileReaderImpl = class extends AsyncRecordBatchStreamReaderImpl {
  get footer() {
    return this._footer;
  }
  get numDictionaries() {
    return this._footer ? this._footer.numDictionaries : 0;
  }
  get numRecordBatches() {
    return this._footer ? this._footer.numRecordBatches : 0;
  }
  constructor(source, ...rest) {
    const byteLength = typeof rest[0] !== "number" ? rest.shift() : void 0;
    const dictionaries = rest[0] instanceof Map ? rest.shift() : void 0;
    super(source instanceof AsyncRandomAccessFile ? source : new AsyncRandomAccessFile(source, byteLength), dictionaries);
  }
  isFile() {
    return true;
  }
  isAsync() {
    return true;
  }
  open(options) {
    const _super = Object.create(null, {
      open: { get: () => super.open }
    });
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.closed && !this._footer) {
        this.schema = (this._footer = yield this._readFooter()).schema;
        for (const block of this._footer.dictionaryBatches()) {
          block && (yield this._readDictionaryBatch(this._dictionaryIndex++));
        }
      }
      return yield _super.open.call(this, options);
    });
  }
  readRecordBatch(index2) {
    var _a9;
    return __awaiter(this, void 0, void 0, function* () {
      if (this.closed) {
        return null;
      }
      if (!this._footer) {
        yield this.open();
      }
      const block = (_a9 = this._footer) === null || _a9 === void 0 ? void 0 : _a9.getRecordBatch(index2);
      if (block && (yield this._handle.seek(block.offset))) {
        const message = yield this._reader.readMessage(MessageHeader.RecordBatch);
        if (message === null || message === void 0 ? void 0 : message.isRecordBatch()) {
          const header = message.header();
          const buffer = yield this._reader.readMessageBody(message.bodyLength);
          const recordBatch = this._loadRecordBatch(header, buffer);
          return recordBatch;
        }
      }
      return null;
    });
  }
  _readDictionaryBatch(index2) {
    var _a9;
    return __awaiter(this, void 0, void 0, function* () {
      const block = (_a9 = this._footer) === null || _a9 === void 0 ? void 0 : _a9.getDictionaryBatch(index2);
      if (block && (yield this._handle.seek(block.offset))) {
        const message = yield this._reader.readMessage(MessageHeader.DictionaryBatch);
        if (message === null || message === void 0 ? void 0 : message.isDictionaryBatch()) {
          const header = message.header();
          const buffer = yield this._reader.readMessageBody(message.bodyLength);
          const vector3 = this._loadDictionaryBatch(header, buffer);
          this.dictionaries.set(header.id, vector3);
        }
      }
    });
  }
  _readFooter() {
    return __awaiter(this, void 0, void 0, function* () {
      const { _handle } = this;
      _handle._pending && (yield _handle._pending);
      const offset2 = _handle.size - magicAndPadding;
      const length4 = yield _handle.readInt32(offset2);
      const buffer = yield _handle.readAt(offset2 - length4, length4);
      return Footer_.decode(buffer);
    });
  }
  _readNextMessageAndValidate(type2) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this._footer) {
        yield this.open();
      }
      if (this._footer && this._recordBatchIndex < this.numRecordBatches) {
        const block = this._footer.getRecordBatch(this._recordBatchIndex);
        if (block && (yield this._handle.seek(block.offset))) {
          return yield this._reader.readMessage(type2);
        }
      }
      return null;
    });
  }
};
var RecordBatchJSONReaderImpl = class extends RecordBatchStreamReaderImpl {
  constructor(source, dictionaries) {
    super(source, dictionaries);
  }
  _loadVectors(header, body, types) {
    return new JSONVectorLoader(body, header.nodes, header.buffers, this.dictionaries, this.schema.metadataVersion).visitMany(types);
  }
};
function shouldAutoDestroy(self, options) {
  return options && typeof options["autoDestroy"] === "boolean" ? options["autoDestroy"] : self["autoDestroy"];
}
function* readAllSync(source) {
  const reader = RecordBatchReader.from(source);
  try {
    if (!reader.open({ autoDestroy: false }).closed) {
      do {
        yield reader;
      } while (!reader.reset().open().closed);
    }
  } finally {
    reader.cancel();
  }
}
function readAllAsync(source) {
  return __asyncGenerator(this, arguments, function* readAllAsync_1() {
    const reader = yield __await(RecordBatchReader.from(source));
    try {
      if (!(yield __await(reader.open({ autoDestroy: false }))).closed) {
        do {
          yield yield __await(reader);
        } while (!(yield __await(reader.reset().open())).closed);
      }
    } finally {
      yield __await(reader.cancel());
    }
  });
}
function fromArrowJSON(source) {
  return new RecordBatchStreamReader(new RecordBatchJSONReaderImpl(source));
}
function fromByteStream(source) {
  const bytes = source.peek(magicLength + 7 & ~7);
  return bytes && bytes.byteLength >= 4 ? !checkForMagicArrowString(bytes) ? new RecordBatchStreamReader(new RecordBatchStreamReaderImpl(source)) : new RecordBatchFileReader(new RecordBatchFileReaderImpl(source.read())) : new RecordBatchStreamReader(new RecordBatchStreamReaderImpl(function* () {
  }()));
}
function fromAsyncByteStream(source) {
  return __awaiter(this, void 0, void 0, function* () {
    const bytes = yield source.peek(magicLength + 7 & ~7);
    return bytes && bytes.byteLength >= 4 ? !checkForMagicArrowString(bytes) ? new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(source)) : new RecordBatchFileReader(new RecordBatchFileReaderImpl(yield source.read())) : new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(function() {
      return __asyncGenerator(this, arguments, function* () {
      });
    }()));
  });
}
function fromFileHandle(source) {
  return __awaiter(this, void 0, void 0, function* () {
    const { size } = yield source.stat();
    const file = new AsyncRandomAccessFile(source, size);
    if (size >= magicX2AndPadding && checkForMagicArrowString(yield file.readAt(0, magicLength + 7 & ~7))) {
      return new AsyncRecordBatchFileReader(new AsyncRecordBatchFileReaderImpl(file));
    }
    return new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(file));
  });
}

// ../core/node_modules/apache-arrow/visitor/vectorassembler.mjs
var VectorAssembler = class _VectorAssembler extends Visitor {
  /** @nocollapse */
  static assemble(...args) {
    const unwrap = (nodes) => nodes.flatMap((node) => Array.isArray(node) ? unwrap(node) : node instanceof RecordBatch2 ? node.data.children : node.data);
    const assembler = new _VectorAssembler();
    assembler.visitMany(unwrap(args));
    return assembler;
  }
  constructor() {
    super();
    this._byteLength = 0;
    this._nodes = [];
    this._buffers = [];
    this._bufferRegions = [];
  }
  visit(data) {
    if (data instanceof Vector) {
      this.visitMany(data.data);
      return this;
    }
    const { type: type2 } = data;
    if (!DataType.isDictionary(type2)) {
      const { length: length4 } = data;
      if (length4 > 2147483647) {
        throw new RangeError("Cannot write arrays larger than 2^31 - 1 in length");
      }
      if (DataType.isUnion(type2)) {
        this.nodes.push(new FieldNode2(length4, 0));
      } else {
        const { nullCount } = data;
        if (!DataType.isNull(type2)) {
          addBuffer.call(this, nullCount <= 0 ? new Uint8Array(0) : truncateBitmap(data.offset, length4, data.nullBitmap));
        }
        this.nodes.push(new FieldNode2(length4, nullCount));
      }
    }
    return super.visit(data);
  }
  visitNull(_null) {
    return this;
  }
  visitDictionary(data) {
    return this.visit(data.clone(data.type.indices));
  }
  get nodes() {
    return this._nodes;
  }
  get buffers() {
    return this._buffers;
  }
  get byteLength() {
    return this._byteLength;
  }
  get bufferRegions() {
    return this._bufferRegions;
  }
};
function addBuffer(values2) {
  const byteLength = values2.byteLength + 7 & ~7;
  this.buffers.push(values2);
  this.bufferRegions.push(new BufferRegion(this._byteLength, byteLength));
  this._byteLength += byteLength;
  return this;
}
function assembleUnion(data) {
  var _a9;
  const { type: type2, length: length4, typeIds, valueOffsets } = data;
  addBuffer.call(this, typeIds);
  if (type2.mode === UnionMode.Sparse) {
    return assembleNestedVector.call(this, data);
  } else if (type2.mode === UnionMode.Dense) {
    if (data.offset <= 0) {
      addBuffer.call(this, valueOffsets);
      return assembleNestedVector.call(this, data);
    } else {
      const shiftedOffsets = new Int32Array(length4);
      const childOffsets = /* @__PURE__ */ Object.create(null);
      const childLengths = /* @__PURE__ */ Object.create(null);
      for (let typeId, shift, index2 = -1; ++index2 < length4; ) {
        if ((typeId = typeIds[index2]) === void 0) {
          continue;
        }
        if ((shift = childOffsets[typeId]) === void 0) {
          shift = childOffsets[typeId] = valueOffsets[index2];
        }
        shiftedOffsets[index2] = valueOffsets[index2] - shift;
        childLengths[typeId] = ((_a9 = childLengths[typeId]) !== null && _a9 !== void 0 ? _a9 : 0) + 1;
      }
      addBuffer.call(this, shiftedOffsets);
      this.visitMany(data.children.map((child, childIndex) => {
        const typeId = type2.typeIds[childIndex];
        const childOffset = childOffsets[typeId];
        const childLength = childLengths[typeId];
        return child.slice(childOffset, Math.min(length4, childLength));
      }));
    }
  }
  return this;
}
function assembleBoolVector(data) {
  let values2;
  if (data.nullCount >= data.length) {
    return addBuffer.call(this, new Uint8Array(0));
  } else if ((values2 = data.values) instanceof Uint8Array) {
    return addBuffer.call(this, truncateBitmap(data.offset, data.length, values2));
  }
  return addBuffer.call(this, packBools(data.values));
}
function assembleFlatVector(data) {
  return addBuffer.call(this, data.values.subarray(0, data.length * data.stride));
}
function assembleFlatListVector(data) {
  const { length: length4, values: values2, valueOffsets } = data;
  const begin = bigIntToNumber(valueOffsets[0]);
  const end = bigIntToNumber(valueOffsets[length4]);
  const byteLength = Math.min(end - begin, values2.byteLength - begin);
  addBuffer.call(this, rebaseValueOffsets(-begin, length4 + 1, valueOffsets));
  addBuffer.call(this, values2.subarray(begin, begin + byteLength));
  return this;
}
function assembleListVector(data) {
  const { length: length4, valueOffsets } = data;
  if (valueOffsets) {
    const { [0]: begin, [length4]: end } = valueOffsets;
    addBuffer.call(this, rebaseValueOffsets(-begin, length4 + 1, valueOffsets));
    return this.visit(data.children[0].slice(begin, end - begin));
  }
  return this.visit(data.children[0]);
}
function assembleNestedVector(data) {
  return this.visitMany(data.type.children.map((_2, i) => data.children[i]).filter(Boolean))[0];
}
VectorAssembler.prototype.visitBool = assembleBoolVector;
VectorAssembler.prototype.visitInt = assembleFlatVector;
VectorAssembler.prototype.visitFloat = assembleFlatVector;
VectorAssembler.prototype.visitUtf8 = assembleFlatListVector;
VectorAssembler.prototype.visitLargeUtf8 = assembleFlatListVector;
VectorAssembler.prototype.visitBinary = assembleFlatListVector;
VectorAssembler.prototype.visitLargeBinary = assembleFlatListVector;
VectorAssembler.prototype.visitFixedSizeBinary = assembleFlatVector;
VectorAssembler.prototype.visitDate = assembleFlatVector;
VectorAssembler.prototype.visitTimestamp = assembleFlatVector;
VectorAssembler.prototype.visitTime = assembleFlatVector;
VectorAssembler.prototype.visitDecimal = assembleFlatVector;
VectorAssembler.prototype.visitList = assembleListVector;
VectorAssembler.prototype.visitStruct = assembleNestedVector;
VectorAssembler.prototype.visitUnion = assembleUnion;
VectorAssembler.prototype.visitInterval = assembleFlatVector;
VectorAssembler.prototype.visitDuration = assembleFlatVector;
VectorAssembler.prototype.visitFixedSizeList = assembleListVector;
VectorAssembler.prototype.visitMap = assembleListVector;

// ../core/node_modules/apache-arrow/ipc/writer.mjs
var RecordBatchWriter = class extends ReadableInterop {
  /** @nocollapse */
  // @ts-ignore
  static throughNode(options) {
    throw new Error(`"throughNode" not available in this environment`);
  }
  /** @nocollapse */
  static throughDOM(writableStrategy, readableStrategy) {
    throw new Error(`"throughDOM" not available in this environment`);
  }
  constructor(options) {
    super();
    this._position = 0;
    this._started = false;
    this._sink = new AsyncByteQueue();
    this._schema = null;
    this._dictionaryBlocks = [];
    this._recordBatchBlocks = [];
    this._dictionaryDeltaOffsets = /* @__PURE__ */ new Map();
    isObject(options) || (options = { autoDestroy: true, writeLegacyIpcFormat: false });
    this._autoDestroy = typeof options.autoDestroy === "boolean" ? options.autoDestroy : true;
    this._writeLegacyIpcFormat = typeof options.writeLegacyIpcFormat === "boolean" ? options.writeLegacyIpcFormat : false;
  }
  toString(sync = false) {
    return this._sink.toString(sync);
  }
  toUint8Array(sync = false) {
    return this._sink.toUint8Array(sync);
  }
  writeAll(input3) {
    if (isPromise(input3)) {
      return input3.then((x4) => this.writeAll(x4));
    } else if (isAsyncIterable(input3)) {
      return writeAllAsync(this, input3);
    }
    return writeAll(this, input3);
  }
  get closed() {
    return this._sink.closed;
  }
  [Symbol.asyncIterator]() {
    return this._sink[Symbol.asyncIterator]();
  }
  toDOMStream(options) {
    return this._sink.toDOMStream(options);
  }
  toNodeStream(options) {
    return this._sink.toNodeStream(options);
  }
  close() {
    return this.reset()._sink.close();
  }
  abort(reason) {
    return this.reset()._sink.abort(reason);
  }
  finish() {
    this._autoDestroy ? this.close() : this.reset(this._sink, this._schema);
    return this;
  }
  reset(sink = this._sink, schema = null) {
    if (sink === this._sink || sink instanceof AsyncByteQueue) {
      this._sink = sink;
    } else {
      this._sink = new AsyncByteQueue();
      if (sink && isWritableDOMStream(sink)) {
        this.toDOMStream({ type: "bytes" }).pipeTo(sink);
      } else if (sink && isWritableNodeStream(sink)) {
        this.toNodeStream({ objectMode: false }).pipe(sink);
      }
    }
    if (this._started && this._schema) {
      this._writeFooter(this._schema);
    }
    this._started = false;
    this._dictionaryBlocks = [];
    this._recordBatchBlocks = [];
    this._dictionaryDeltaOffsets = /* @__PURE__ */ new Map();
    if (!schema || !compareSchemas(schema, this._schema)) {
      if (schema == null) {
        this._position = 0;
        this._schema = null;
      } else {
        this._started = true;
        this._schema = schema;
        this._writeSchema(schema);
      }
    }
    return this;
  }
  write(payload) {
    let schema = null;
    if (!this._sink) {
      throw new Error(`RecordBatchWriter is closed`);
    } else if (payload == null) {
      return this.finish() && void 0;
    } else if (payload instanceof Table && !(schema = payload.schema)) {
      return this.finish() && void 0;
    } else if (payload instanceof RecordBatch2 && !(schema = payload.schema)) {
      return this.finish() && void 0;
    }
    if (schema && !compareSchemas(schema, this._schema)) {
      if (this._started && this._autoDestroy) {
        return this.close();
      }
      this.reset(this._sink, schema);
    }
    if (payload instanceof RecordBatch2) {
      if (!(payload instanceof _InternalEmptyPlaceholderRecordBatch)) {
        this._writeRecordBatch(payload);
      }
    } else if (payload instanceof Table) {
      this.writeAll(payload.batches);
    } else if (isIterable(payload)) {
      this.writeAll(payload);
    }
  }
  _writeMessage(message, alignment = 8) {
    const a3 = alignment - 1;
    const buffer = Message2.encode(message);
    const flatbufferSize = buffer.byteLength;
    const prefixSize = !this._writeLegacyIpcFormat ? 8 : 4;
    const alignedSize = flatbufferSize + prefixSize + a3 & ~a3;
    const nPaddingBytes = alignedSize - flatbufferSize - prefixSize;
    if (message.headerType === MessageHeader.RecordBatch) {
      this._recordBatchBlocks.push(new FileBlock(alignedSize, message.bodyLength, this._position));
    } else if (message.headerType === MessageHeader.DictionaryBatch) {
      this._dictionaryBlocks.push(new FileBlock(alignedSize, message.bodyLength, this._position));
    }
    if (!this._writeLegacyIpcFormat) {
      this._write(Int32Array.of(-1));
    }
    this._write(Int32Array.of(alignedSize - prefixSize));
    if (flatbufferSize > 0) {
      this._write(buffer);
    }
    return this._writePadding(nPaddingBytes);
  }
  _write(chunk) {
    if (this._started) {
      const buffer = toUint8Array(chunk);
      if (buffer && buffer.byteLength > 0) {
        this._sink.write(buffer);
        this._position += buffer.byteLength;
      }
    }
    return this;
  }
  _writeSchema(schema) {
    return this._writeMessage(Message2.from(schema));
  }
  // @ts-ignore
  _writeFooter(schema) {
    return this._writeLegacyIpcFormat ? this._write(Int32Array.of(0)) : this._write(Int32Array.of(-1, 0));
  }
  _writeMagic() {
    return this._write(MAGIC);
  }
  _writePadding(nBytes) {
    return nBytes > 0 ? this._write(new Uint8Array(nBytes)) : this;
  }
  _writeRecordBatch(batch) {
    const { byteLength, nodes, bufferRegions, buffers } = VectorAssembler.assemble(batch);
    const recordBatch = new RecordBatch3(batch.numRows, nodes, bufferRegions);
    const message = Message2.from(recordBatch, byteLength);
    return this._writeDictionaries(batch)._writeMessage(message)._writeBodyBuffers(buffers);
  }
  _writeDictionaryBatch(dictionary, id2, isDelta = false) {
    this._dictionaryDeltaOffsets.set(id2, dictionary.length + (this._dictionaryDeltaOffsets.get(id2) || 0));
    const { byteLength, nodes, bufferRegions, buffers } = VectorAssembler.assemble(new Vector([dictionary]));
    const recordBatch = new RecordBatch3(dictionary.length, nodes, bufferRegions);
    const dictionaryBatch = new DictionaryBatch2(recordBatch, id2, isDelta);
    const message = Message2.from(dictionaryBatch, byteLength);
    return this._writeMessage(message)._writeBodyBuffers(buffers);
  }
  _writeBodyBuffers(buffers) {
    let buffer;
    let size, padding2;
    for (let i = -1, n = buffers.length; ++i < n; ) {
      if ((buffer = buffers[i]) && (size = buffer.byteLength) > 0) {
        this._write(buffer);
        if ((padding2 = (size + 7 & ~7) - size) > 0) {
          this._writePadding(padding2);
        }
      }
    }
    return this;
  }
  _writeDictionaries(batch) {
    for (let [id2, dictionary] of batch.dictionaries) {
      let offset2 = this._dictionaryDeltaOffsets.get(id2) || 0;
      if (offset2 === 0 || (dictionary = dictionary === null || dictionary === void 0 ? void 0 : dictionary.slice(offset2)).length > 0) {
        for (const data of dictionary.data) {
          this._writeDictionaryBatch(data, id2, offset2 > 0);
          offset2 += data.length;
        }
      }
    }
    return this;
  }
};
var RecordBatchStreamWriter = class _RecordBatchStreamWriter extends RecordBatchWriter {
  /** @nocollapse */
  static writeAll(input3, options) {
    const writer = new _RecordBatchStreamWriter(options);
    if (isPromise(input3)) {
      return input3.then((x4) => writer.writeAll(x4));
    } else if (isAsyncIterable(input3)) {
      return writeAllAsync(writer, input3);
    }
    return writeAll(writer, input3);
  }
};
var RecordBatchFileWriter = class _RecordBatchFileWriter extends RecordBatchWriter {
  /** @nocollapse */
  static writeAll(input3) {
    const writer = new _RecordBatchFileWriter();
    if (isPromise(input3)) {
      return input3.then((x4) => writer.writeAll(x4));
    } else if (isAsyncIterable(input3)) {
      return writeAllAsync(writer, input3);
    }
    return writeAll(writer, input3);
  }
  constructor() {
    super();
    this._autoDestroy = true;
  }
  // @ts-ignore
  _writeSchema(schema) {
    return this._writeMagic()._writePadding(2);
  }
  _writeFooter(schema) {
    const buffer = Footer_.encode(new Footer_(schema, MetadataVersion.V5, this._recordBatchBlocks, this._dictionaryBlocks));
    return super._writeFooter(schema)._write(buffer)._write(Int32Array.of(buffer.byteLength))._writeMagic();
  }
};
function writeAll(writer, input3) {
  let chunks = input3;
  if (input3 instanceof Table) {
    chunks = input3.batches;
    writer.reset(void 0, input3.schema);
  }
  for (const batch of chunks) {
    writer.write(batch);
  }
  return writer.finish();
}
function writeAllAsync(writer, batches) {
  var _a9, batches_1, batches_1_1;
  var _b3, e_1, _c3, _d3;
  return __awaiter(this, void 0, void 0, function* () {
    try {
      for (_a9 = true, batches_1 = __asyncValues(batches); batches_1_1 = yield batches_1.next(), _b3 = batches_1_1.done, !_b3; _a9 = true) {
        _d3 = batches_1_1.value;
        _a9 = false;
        const batch = _d3;
        writer.write(batch);
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (!_a9 && !_b3 && (_c3 = batches_1.return))
          yield _c3.call(batches_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    return writer.finish();
  });
}

// ../core/node_modules/apache-arrow/io/whatwg/iterable.mjs
function toDOMStream(source, options) {
  if (isAsyncIterable(source)) {
    return asyncIterableAsReadableDOMStream(source, options);
  }
  if (isIterable(source)) {
    return iterableAsReadableDOMStream(source, options);
  }
  throw new Error(`toDOMStream() must be called with an Iterable or AsyncIterable`);
}
function iterableAsReadableDOMStream(source, options) {
  let it2 = null;
  const bm = (options === null || options === void 0 ? void 0 : options.type) === "bytes" || false;
  const hwm = (options === null || options === void 0 ? void 0 : options.highWaterMark) || Math.pow(2, 24);
  return new ReadableStream(Object.assign(Object.assign({}, options), {
    start(controller) {
      next(controller, it2 || (it2 = source[Symbol.iterator]()));
    },
    pull(controller) {
      it2 ? next(controller, it2) : controller.close();
    },
    cancel() {
      ((it2 === null || it2 === void 0 ? void 0 : it2.return) && it2.return() || true) && (it2 = null);
    }
  }), Object.assign({ highWaterMark: bm ? hwm : void 0 }, options));
  function next(controller, it3) {
    let buf;
    let r = null;
    let size = controller.desiredSize || null;
    while (!(r = it3.next(bm ? size : null)).done) {
      if (ArrayBuffer.isView(r.value) && (buf = toUint8Array(r.value))) {
        size != null && bm && (size = size - buf.byteLength + 1);
        r.value = buf;
      }
      controller.enqueue(r.value);
      if (size != null && --size <= 0) {
        return;
      }
    }
    controller.close();
  }
}
function asyncIterableAsReadableDOMStream(source, options) {
  let it2 = null;
  const bm = (options === null || options === void 0 ? void 0 : options.type) === "bytes" || false;
  const hwm = (options === null || options === void 0 ? void 0 : options.highWaterMark) || Math.pow(2, 24);
  return new ReadableStream(Object.assign(Object.assign({}, options), {
    start(controller) {
      return __awaiter(this, void 0, void 0, function* () {
        yield next(controller, it2 || (it2 = source[Symbol.asyncIterator]()));
      });
    },
    pull(controller) {
      return __awaiter(this, void 0, void 0, function* () {
        it2 ? yield next(controller, it2) : controller.close();
      });
    },
    cancel() {
      return __awaiter(this, void 0, void 0, function* () {
        ((it2 === null || it2 === void 0 ? void 0 : it2.return) && (yield it2.return()) || true) && (it2 = null);
      });
    }
  }), Object.assign({ highWaterMark: bm ? hwm : void 0 }, options));
  function next(controller, it3) {
    return __awaiter(this, void 0, void 0, function* () {
      let buf;
      let r = null;
      let size = controller.desiredSize || null;
      while (!(r = yield it3.next(bm ? size : null)).done) {
        if (ArrayBuffer.isView(r.value) && (buf = toUint8Array(r.value))) {
          size != null && bm && (size = size - buf.byteLength + 1);
          r.value = buf;
        }
        controller.enqueue(r.value);
        if (size != null && --size <= 0) {
          return;
        }
      }
      controller.close();
    });
  }
}

// ../core/node_modules/apache-arrow/io/whatwg/builder.mjs
function builderThroughDOMStream(options) {
  return new BuilderTransform(options);
}
var BuilderTransform = class {
  constructor(options) {
    this._numChunks = 0;
    this._finished = false;
    this._bufferedSize = 0;
    const { ["readableStrategy"]: readableStrategy, ["writableStrategy"]: writableStrategy, ["queueingStrategy"]: queueingStrategy = "count" } = options, builderOptions = __rest(options, ["readableStrategy", "writableStrategy", "queueingStrategy"]);
    this._controller = null;
    this._builder = makeBuilder(builderOptions);
    this._getSize = queueingStrategy !== "bytes" ? chunkLength : chunkByteLength;
    const { ["highWaterMark"]: readableHighWaterMark = queueingStrategy === "bytes" ? Math.pow(2, 14) : 1e3 } = Object.assign({}, readableStrategy);
    const { ["highWaterMark"]: writableHighWaterMark = queueingStrategy === "bytes" ? Math.pow(2, 14) : 1e3 } = Object.assign({}, writableStrategy);
    this["readable"] = new ReadableStream({
      ["cancel"]: () => {
        this._builder.clear();
      },
      ["pull"]: (c4) => {
        this._maybeFlush(this._builder, this._controller = c4);
      },
      ["start"]: (c4) => {
        this._maybeFlush(this._builder, this._controller = c4);
      }
    }, {
      "highWaterMark": readableHighWaterMark,
      "size": queueingStrategy !== "bytes" ? chunkLength : chunkByteLength
    });
    this["writable"] = new WritableStream({
      ["abort"]: () => {
        this._builder.clear();
      },
      ["write"]: () => {
        this._maybeFlush(this._builder, this._controller);
      },
      ["close"]: () => {
        this._maybeFlush(this._builder.finish(), this._controller);
      }
    }, {
      "highWaterMark": writableHighWaterMark,
      "size": (value) => this._writeValueAndReturnChunkSize(value)
    });
  }
  _writeValueAndReturnChunkSize(value) {
    const bufferedSize = this._bufferedSize;
    this._bufferedSize = this._getSize(this._builder.append(value));
    return this._bufferedSize - bufferedSize;
  }
  _maybeFlush(builder, controller) {
    if (controller == null) {
      return;
    }
    if (this._bufferedSize >= controller.desiredSize) {
      ++this._numChunks && this._enqueue(controller, builder.toVector());
    }
    if (builder.finished) {
      if (builder.length > 0 || this._numChunks === 0) {
        ++this._numChunks && this._enqueue(controller, builder.toVector());
      }
      if (!this._finished && (this._finished = true)) {
        this._enqueue(controller, null);
      }
    }
  }
  _enqueue(controller, chunk) {
    this._bufferedSize = 0;
    this._controller = null;
    chunk == null ? controller.close() : controller.enqueue(chunk);
  }
};
var chunkLength = (chunk) => {
  var _a9;
  return (_a9 = chunk === null || chunk === void 0 ? void 0 : chunk.length) !== null && _a9 !== void 0 ? _a9 : 0;
};
var chunkByteLength = (chunk) => {
  var _a9;
  return (_a9 = chunk === null || chunk === void 0 ? void 0 : chunk.byteLength) !== null && _a9 !== void 0 ? _a9 : 0;
};

// ../core/node_modules/apache-arrow/io/whatwg/reader.mjs
function recordBatchReaderThroughDOMStream(writableStrategy, readableStrategy) {
  const queue = new AsyncByteQueue();
  let reader = null;
  const readable = new ReadableStream({
    cancel() {
      return __awaiter(this, void 0, void 0, function* () {
        yield queue.close();
      });
    },
    start(controller) {
      return __awaiter(this, void 0, void 0, function* () {
        yield next(controller, reader || (reader = yield open()));
      });
    },
    pull(controller) {
      return __awaiter(this, void 0, void 0, function* () {
        reader ? yield next(controller, reader) : controller.close();
      });
    }
  });
  return { writable: new WritableStream(queue, Object.assign({ "highWaterMark": Math.pow(2, 14) }, writableStrategy)), readable };
  function open() {
    return __awaiter(this, void 0, void 0, function* () {
      return yield (yield RecordBatchReader.from(queue)).open(readableStrategy);
    });
  }
  function next(controller, reader2) {
    return __awaiter(this, void 0, void 0, function* () {
      let size = controller.desiredSize;
      let r = null;
      while (!(r = yield reader2.next()).done) {
        controller.enqueue(r.value);
        if (size != null && --size <= 0) {
          return;
        }
      }
      controller.close();
    });
  }
}

// ../core/node_modules/apache-arrow/io/whatwg/writer.mjs
function recordBatchWriterThroughDOMStream(writableStrategy, readableStrategy) {
  const writer = new this(writableStrategy);
  const reader = new AsyncByteStream(writer);
  const readable = new ReadableStream({
    // type: 'bytes',
    cancel() {
      return __awaiter(this, void 0, void 0, function* () {
        yield reader.cancel();
      });
    },
    pull(controller) {
      return __awaiter(this, void 0, void 0, function* () {
        yield next(controller);
      });
    },
    start(controller) {
      return __awaiter(this, void 0, void 0, function* () {
        yield next(controller);
      });
    }
  }, Object.assign({ "highWaterMark": Math.pow(2, 14) }, readableStrategy));
  return { writable: new WritableStream(writer, writableStrategy), readable };
  function next(controller) {
    return __awaiter(this, void 0, void 0, function* () {
      let buf = null;
      let size = controller.desiredSize;
      while (buf = yield reader.read(size || null)) {
        controller.enqueue(buf);
        if (size != null && (size -= buf.byteLength) <= 0) {
          return;
        }
      }
      controller.close();
    });
  }
}

// ../core/node_modules/apache-arrow/ipc/serialization.mjs
function tableFromIPC(input3) {
  const reader = RecordBatchReader.from(input3);
  if (isPromise(reader)) {
    return reader.then((reader2) => tableFromIPC(reader2));
  }
  if (reader.isAsync()) {
    return reader.readAll().then((xs) => new Table(xs));
  }
  return new Table(reader.readAll());
}

// ../core/node_modules/apache-arrow/Arrow.mjs
var util = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, bn_exports), int_exports), bit_exports), math_exports), buffer_exports), vector_exports), pretty_exports), {
  compareSchemas,
  compareFields,
  compareTypes
});

// ../core/node_modules/apache-arrow/Arrow.dom.mjs
adapters_default.toDOMStream = toDOMStream;
Builder2["throughDOM"] = builderThroughDOMStream;
RecordBatchReader["throughDOM"] = recordBatchReaderThroughDOMStream;
RecordBatchFileReader["throughDOM"] = recordBatchReaderThroughDOMStream;
RecordBatchStreamReader["throughDOM"] = recordBatchReaderThroughDOMStream;
RecordBatchWriter["throughDOM"] = recordBatchWriterThroughDOMStream;
RecordBatchFileWriter["throughDOM"] = recordBatchWriterThroughDOMStream;
RecordBatchStreamWriter["throughDOM"] = recordBatchWriterThroughDOMStream;

// ../core/src/connectors/socket.js
function socketConnector(uri = "ws://localhost:3000/") {
  const queue = [];
  let connected = false;
  let request = null;
  let ws;
  const events = {
    open() {
      connected = true;
      next();
    },
    close() {
      connected = false;
      request = null;
      ws = null;
      while (queue.length) {
        queue.shift().reject("Socket closed");
      }
    },
    error(event) {
      if (request) {
        const { reject } = request;
        request = null;
        next();
        reject(event);
      } else {
        console.error("WebSocket error: ", event);
      }
    },
    message({ data }) {
      if (request) {
        const { query, resolve, reject } = request;
        request = null;
        next();
        if (typeof data === "string") {
          const json = JSON.parse(data);
          json.error ? reject(json.error) : resolve(json);
        } else if (query.type === "exec") {
          resolve();
        } else if (query.type === "arrow") {
          resolve(tableFromIPC(data.arrayBuffer()));
        } else {
          throw new Error(`Unexpected socket data: ${data}`);
        }
      } else {
        console.log("WebSocket message: ", data);
      }
    }
  };
  function init2() {
    ws = new WebSocket(uri);
    for (const type2 in events) {
      ws.addEventListener(type2, events[type2]);
    }
  }
  function enqueue(query, resolve, reject) {
    if (ws == null)
      init2();
    queue.push({ query, resolve, reject });
    if (connected && !request)
      next();
  }
  function next() {
    if (queue.length) {
      request = queue.shift();
      ws.send(JSON.stringify(request.query));
    }
  }
  return {
    get connected() {
      return connected;
    },
    query(query) {
      return new Promise(
        (resolve, reject) => enqueue(query, resolve, reject)
      );
    }
  };
}

// ../sql/src/ref.js
var Ref = class {
  /**
   * Create a new Ref instance.
   * @param {string|Ref|null} table The table name.
   * @param {string|null} [column] The column name.
   */
  constructor(table3, column3) {
    if (table3)
      this.table = String(table3);
    if (column3)
      this.column = column3;
  }
  /**
   * Get the list of referenced columns. Either a single element array
   * if column is non-null, otherwise an empty array.
   */
  get columns() {
    return this.column ? [this.column] : [];
  }
  /**
   * Generate a SQL string for this reference.
   * @returns {string} The SQL string.
   */
  toString() {
    const { table: table3, column: column3 } = this;
    if (column3) {
      const col = column3.startsWith("*") ? column3 : `"${column3}"`;
      return `${table3 ? `${quoteTableName(table3)}.` : ""}${col}`;
    } else {
      return table3 ? quoteTableName(table3) : "NULL";
    }
  }
};
function quoteTableName(table3) {
  const pieces = table3.split(".");
  return pieces.map((p2) => `"${p2}"`).join(".");
}
function isColumnRefFor(ref, name2) {
  return ref instanceof Ref && ref.column === name2;
}
function asColumn(value) {
  return typeof value === "string" ? column(value) : value;
}
function asRelation(value) {
  return typeof value === "string" ? relation(value) : value;
}
function relation(name2) {
  return new Ref(name2);
}
function column(table3, column3 = null) {
  if (arguments.length === 1) {
    column3 = table3;
    table3 = null;
  }
  return new Ref(table3, column3);
}

// ../sql/src/to-sql.js
function literalToSQL(value) {
  switch (typeof value) {
    case "boolean":
      return value ? "TRUE" : "FALSE";
    case "string":
      return `'${value}'`;
    case "number":
      return Number.isFinite(value) ? String(value) : "NULL";
    default:
      if (value == null) {
        return "NULL";
      } else if (value instanceof Date) {
        const ts = +value;
        if (Number.isNaN(ts))
          return "NULL";
        const y4 = value.getUTCFullYear();
        const m2 = value.getUTCMonth();
        const d = value.getUTCDate();
        return ts === Date.UTC(y4, m2, d) ? `MAKE_DATE(${y4}, ${m2 + 1}, ${d})` : `EPOCH_MS(${ts})`;
      } else if (value instanceof RegExp) {
        return `'${value.source}'`;
      } else {
        return String(value);
      }
  }
}

// ../sql/src/expression.js
var isParamLike = (value) => typeof value?.addEventListener === "function";
function isSQLExpression(value) {
  return value instanceof SQLExpression;
}
var SQLExpression = class {
  /**
   * Create a new SQL expression instance.
   * @param {(string | ParamLike | SQLExpression | import('./ref.js').Ref)[]} parts The parts of the expression.
   * @param {string[]} [columns=[]] The column dependencies
   * @param {object} [props] Additional properties for this expression.
   */
  constructor(parts, columns, props) {
    this._expr = Array.isArray(parts) ? parts : [parts];
    this._deps = columns || [];
    this.annotate(props);
    const params = this._expr.filter((part) => isParamLike(part));
    if (params.length > 0) {
      this._params = Array.from(new Set(params));
      this._params.forEach((param) => {
        param.addEventListener("value", () => update(this, this.map?.get("value")));
      });
    } else {
      this.addEventListener = void 0;
    }
  }
  /**
   * A reference to this expression.
   * Provides compatibility with param-like objects.
   */
  get value() {
    return this;
  }
  /**
   * The column dependencies of this expression.
   * @returns {string[]} The columns dependencies.
   */
  get columns() {
    const { _params, _deps } = this;
    if (_params) {
      const pset = new Set(_params.flatMap((p2) => {
        const cols = p2.value?.columns;
        return Array.isArray(cols) ? cols : [];
      }));
      if (pset.size) {
        const set3 = new Set(_deps);
        pset.forEach((col) => set3.add(col));
        return Array.from(set3);
      }
    }
    return _deps;
  }
  /**
   * The first column dependency in this expression, or undefined if none.
   * @returns {string} The first column dependency.
   */
  get column() {
    return this._deps.length ? this._deps[0] : this.columns[0];
  }
  /**
   * Annotate this expression instance with additional properties.
   * @param {object[]} [props] One or more objects with properties to add.
   * @returns {this} This SQL expression.
   */
  annotate(...props) {
    return Object.assign(this, ...props);
  }
  /**
   * Generate a SQL code string corresponding to this expression.
   * @returns {string} A SQL code string.
   */
  toString() {
    return this._expr.map((p2) => isParamLike(p2) && !isSQLExpression(p2) ? literalToSQL(p2.value) : p2).join("");
  }
  /**
   * Add an event listener callback for the provided event type.
   * @param {string} type The event type to listen for (for example, "value").
   * @param {(a: SQLExpression) => Promise?} callback The callback function to
   *  invoke upon updates. A callback may optionally return a Promise that
   *  upstream listeners may await before proceeding.
   */
  addEventListener(type2, callback) {
    const map4 = this.map || (this.map = /* @__PURE__ */ new Map());
    const set3 = map4.get(type2) || (map4.set(type2, /* @__PURE__ */ new Set()), map4.get(type2));
    set3.add(callback);
  }
};
function update(expr, callbacks) {
  if (callbacks?.size) {
    return Promise.allSettled(Array.from(callbacks, (fn) => fn(expr)));
  }
}
function parseSQL(strings, exprs) {
  const spans = [strings[0]];
  const cols = /* @__PURE__ */ new Set();
  const n = exprs.length;
  for (let i = 0, k3 = 0; i < n; ) {
    const e = exprs[i];
    if (isParamLike(e)) {
      spans[++k3] = e;
    } else {
      if (Array.isArray(e?.columns)) {
        e.columns.forEach((col) => cols.add(col));
      }
      spans[k3] += typeof e === "string" ? e : literalToSQL(e);
    }
    const s2 = strings[++i];
    if (isParamLike(spans[k3])) {
      spans[++k3] = s2;
    } else {
      spans[k3] += s2;
    }
  }
  return { spans, cols: Array.from(cols) };
}
function sql(strings, ...exprs) {
  const { spans, cols } = parseSQL(strings, exprs);
  return new SQLExpression(spans, cols);
}

// ../sql/src/desc.js
function desc(expr) {
  const e = asColumn(expr);
  return sql`${e} DESC NULLS LAST`.annotate({ label: e?.label, desc: true });
}

// ../sql/src/literal.js
var literal = (value) => ({
  value,
  toString: () => literalToSQL(value)
});

// ../sql/src/operators.js
function visit(callback) {
  callback(this.op, this);
  this.children?.forEach((v3) => v3.visit(callback));
}
function logical(op, clauses) {
  const children2 = clauses.filter((x4) => x4 != null).map(asColumn);
  const strings = children2.map((c4, i) => i ? ` ${op} ` : "");
  if (children2.length === 1) {
    strings.push("");
  } else if (children2.length > 1) {
    strings[0] = "(";
    strings.push(")");
  }
  return sql(strings, ...children2).annotate({ op, children: children2, visit });
}
var and = (...clauses) => logical("AND", clauses.flat());
var or = (...clauses) => logical("OR", clauses.flat());
var unaryOp = (op) => (a3) => sql`(${op} ${asColumn(a3)})`.annotate({ op, a: a3, visit });
var not = unaryOp("NOT");
var unaryPostOp = (op) => (a3) => sql`(${asColumn(a3)} ${op})`.annotate({ op, a: a3, visit });
var isNull = unaryPostOp("IS NULL");
var isNotNull = unaryPostOp("IS NOT NULL");
var binaryOp = (op) => (a3, b2) => sql`(${asColumn(a3)} ${op} ${asColumn(b2)})`.annotate({ op, a: a3, b: b2, visit });
var eq = binaryOp("=");
var neq = binaryOp("<>");
var lt = binaryOp("<");
var gt = binaryOp(">");
var lte = binaryOp("<=");
var gte = binaryOp(">=");
var isDistinct = binaryOp("IS DISTINCT FROM");
var isNotDistinct = binaryOp("IS NOT DISTINCT FROM");
function rangeOp(op, a3, range3, exclusive) {
  a3 = asColumn(a3);
  const prefix2 = op.startsWith("NOT ") ? "NOT " : "";
  const expr = !range3 ? sql`` : exclusive ? sql`${prefix2}(${range3[0]} <= ${a3} AND ${a3} < ${range3[1]})` : sql`(${a3} ${op} ${range3[0]} AND ${range3[1]})`;
  return expr.annotate({ op, visit, field: a3, range: range3 });
}
var isBetween = (a3, range3, exclusive) => rangeOp("BETWEEN", a3, range3, exclusive);
var isNotBetween = (a3, range3, exclusive) => rangeOp("NOT BETWEEN", a3, range3, exclusive);

// ../sql/src/repeat.js
function repeat(length4, str) {
  return Array.from({ length: length4 }, () => str);
}

// ../sql/src/functions.js
function functionCall(op, type2) {
  return (...values2) => {
    const args = values2.map(asColumn);
    const cast2 = type2 ? `::${type2}` : "";
    const expr = args.length ? sql([`${op}(`, ...repeat(args.length - 1, ", "), `)${cast2}`], ...args) : sql`${op}()${cast2}`;
    return expr.annotate({ func: op, args });
  };
}
var regexp_matches = functionCall("REGEXP_MATCHES");
var contains = functionCall("CONTAINS");
var prefix = functionCall("PREFIX");
var suffix = functionCall("SUFFIX");
var lower = functionCall("LOWER");
var upper = functionCall("UPPER");
var length = functionCall("LENGTH");
var isNaN2 = functionCall("ISNAN");
var isFinite2 = functionCall("ISFINITE");
var isInfinite = functionCall("ISINF");

// ../sql/src/windows.js
var WindowFunction = class _WindowFunction extends SQLExpression {
  /**
   * Create a new WindowFunction instance.
   * @param {string} op The window operation indicator.
   * @param {*} func The window function expression.
   * @param {*} [type] The SQL data type to cast to.
   * @param {string} [name] The window definition name.
   * @param {*} [group] Grouping (partition by) expressions.
   * @param {*} [order] Sorting (order by) expressions.
   * @param {*} [frame] The window frame definition.
   */
  constructor(op, func, type2, name2, group3 = "", order = "", frame4 = "") {
    let expr;
    const noWindowParams = !(group3 || order || frame4);
    if (name2 && noWindowParams) {
      expr = name2 ? sql`${func} OVER "${name2}"` : sql`${func} OVER ()`;
    } else {
      const s1 = group3 && order ? " " : "";
      const s2 = (group3 || order) && frame4 ? " " : "";
      expr = sql`${func} OVER (${name2 ? `"${name2}" ` : ""}${group3}${s1}${order}${s2}${frame4})`;
    }
    if (type2) {
      expr = sql`(${expr})::${type2}`;
    }
    const { _expr, _deps } = expr;
    super(_expr, _deps);
    this.window = op;
    this.func = func;
    this.type = type2;
    this.name = name2;
    this.group = group3;
    this.order = order;
    this.frame = frame4;
  }
  get basis() {
    return this.column;
  }
  get label() {
    const { func } = this;
    return func.label ?? func.toString();
  }
  /**
   * Return an updated window function over a named window definition.
   * @param {string} name The window definition name.
   * @returns {WindowFunction} A new window function.
   */
  over(name2) {
    const { window: op, func, type: type2, group: group3, order, frame: frame4 } = this;
    return new _WindowFunction(op, func, type2, name2, group3, order, frame4);
  }
  /**
   * Return an updated window function with the given partitioning.
   * @param {*} expr The grouping (partition by) criteria for the window function.
   * @returns {WindowFunction} A new window function.
   */
  partitionby(...expr) {
    const exprs = expr.flat().filter((x4) => x4).map(asColumn);
    const group3 = sql(
      ["PARTITION BY ", repeat(exprs.length - 1, ", "), ""],
      ...exprs
    );
    const { window: op, func, type: type2, name: name2, order, frame: frame4 } = this;
    return new _WindowFunction(op, func, type2, name2, group3, order, frame4);
  }
  /**
   * Return an updated window function with the given ordering.
   * @param {*} expr The sorting (order by) criteria for the window function.
   * @returns {WindowFunction} A new window function.
   */
  orderby(...expr) {
    const exprs = expr.flat().filter((x4) => x4).map(asColumn);
    const order = sql(
      ["ORDER BY ", repeat(exprs.length - 1, ", "), ""],
      ...exprs
    );
    const { window: op, func, type: type2, name: name2, group: group3, frame: frame4 } = this;
    return new _WindowFunction(op, func, type2, name2, group3, order, frame4);
  }
  /**
   * Return an updated window function with the given rows frame.
   * @param {(number|null)[] | import('./expression.js').ParamLike} expr The row-based window frame.
   * @returns {WindowFunction} A new window function.
   */
  rows(expr) {
    const frame4 = windowFrame("ROWS", expr);
    const { window: op, func, type: type2, name: name2, group: group3, order } = this;
    return new _WindowFunction(op, func, type2, name2, group3, order, frame4);
  }
  /**
   * Return an updated window function with the given range frame.
   * @param {(number|null)[] | import('./expression.js').ParamLike} expr The range-based window frame.
   * @returns {WindowFunction} A new window function.
   */
  range(expr) {
    const frame4 = windowFrame("RANGE", expr);
    const { window: op, func, type: type2, name: name2, group: group3, order } = this;
    return new _WindowFunction(op, func, type2, name2, group3, order, frame4);
  }
};
function windowFrame(type2, frame4) {
  if (isParamLike(frame4)) {
    const expr = sql`${frame4}`;
    expr.toString = () => `${type2} ${frameToSQL(frame4.value)}`;
    return expr;
  }
  return `${type2} ${frameToSQL(frame4)}`;
}
function frameToSQL(frame4) {
  const [prev, next] = frame4;
  const a3 = prev === 0 ? "CURRENT ROW" : Number.isFinite(prev) ? `${Math.abs(prev)} PRECEDING` : "UNBOUNDED PRECEDING";
  const b2 = next === 0 ? "CURRENT ROW" : Number.isFinite(next) ? `${Math.abs(next)} FOLLOWING` : "UNBOUNDED FOLLOWING";
  return `BETWEEN ${a3} AND ${b2}`;
}
function winf(op, type2) {
  return (...values2) => {
    const func = functionCall(op)(...values2);
    return new WindowFunction(op, func, type2);
  };
}
var row_number = winf("ROW_NUMBER", "INTEGER");
var rank = winf("RANK", "INTEGER");
var dense_rank = winf("DENSE_RANK", "INTEGER");
var percent_rank = winf("PERCENT_RANK");
var cume_dist = winf("CUME_DIST");
var ntile = winf("NTILE");
var lag = winf("LAG");
var lead = winf("LEAD");
var first_value = winf("FIRST_VALUE");
var last_value = winf("LAST_VALUE");
var nth_value = winf("NTH_VALUE");

// ../sql/src/aggregates.js
function agg(strings, ...exprs) {
  return sql(strings, ...exprs).annotate({ aggregate: true });
}
var AggregateFunction = class _AggregateFunction extends SQLExpression {
  /**
   * Create a new AggregateFunction instance.
   * @param {*} op The aggregate operation.
   * @param {*} [args] The aggregate function arguments.
   * @param {*} [type] The SQL data type to cast to.
   * @param {boolean} [isDistinct] Flag indicating if this is a distinct value aggregate.
   * @param {*} [filter] Filtering expression to apply prior to aggregation.
   */
  constructor(op, args, type2, isDistinct2, filter3) {
    args = (args || []).map(asColumn);
    const { strings, exprs } = aggExpr(op, args, type2, isDistinct2, filter3);
    const { spans, cols } = parseSQL(strings, exprs);
    super(spans, cols);
    this.aggregate = op;
    this.args = args;
    this.type = type2;
    this.isDistinct = isDistinct2;
    this.filter = filter3;
  }
  get basis() {
    return this.column;
  }
  get label() {
    const { aggregate: op, args, isDistinct: isDistinct2 } = this;
    const dist2 = isDistinct2 ? "DISTINCT" + (args.length ? " " : "") : "";
    const tail = args.length ? `(${dist2}${args.map(unquoted).join(", ")})` : "";
    return `${op.toLowerCase()}${tail}`;
  }
  /**
   * Return a new derived aggregate function over distinct values.
   * @returns {AggregateFunction} A new aggregate function.
   */
  distinct() {
    const { aggregate: op, args, type: type2, filter: filter3 } = this;
    return new _AggregateFunction(op, args, type2, true, filter3);
  }
  /**
   * Return a new derived aggregate function that filters values.
   * @param {*} filter The filter expresion.
   * @returns {AggregateFunction} A new aggregate function.
   */
  where(filter3) {
    const { aggregate: op, args, type: type2, isDistinct: isDistinct2 } = this;
    return new _AggregateFunction(op, args, type2, isDistinct2, filter3);
  }
  /**
   * Return a new window function over this aggregate.
   * @returns {WindowFunction} A new aggregate function.
   */
  window() {
    const { aggregate: op, args, type: type2, isDistinct: isDistinct2 } = this;
    const func = new _AggregateFunction(op, args, null, isDistinct2);
    return new WindowFunction(op, func, type2);
  }
  /**
   * Return a window function over this aggregate with the given partitioning.
   * @param {*} expr The grouping (partition by) criteria for the window function.
   * @returns {WindowFunction} A new window function.
   */
  partitionby(...expr) {
    return this.window().partitionby(...expr);
  }
  /**
   * Return a window function over this aggregate with the given ordering.
   * @param {*} expr The sorting (order by) criteria for the window function.
   * @returns {WindowFunction} A new window function.
   */
  orderby(...expr) {
    return this.window().orderby(...expr);
  }
  /**
   * Return a window function over this aggregate with the given row frame.
   * @param {(number|null)[] | import('./expression.js').ParamLike} frame The row-based window frame.
   * @returns {WindowFunction} A new window function.
   */
  rows(frame4) {
    return this.window().rows(frame4);
  }
  /**
   * Return a window function over this aggregate with the given range frame.
   * @param {(number|null)[] | import('./expression.js').ParamLike} frame The range-based window frame.
   * @returns {WindowFunction} A new window function.
   */
  range(frame4) {
    return this.window().range(frame4);
  }
};
function aggExpr(op, args, type2, isDistinct2, filter3) {
  const close = `)${type2 ? `::${type2}` : ""}`;
  let strings = [`${op}(${isDistinct2 ? "DISTINCT " : ""}`];
  let exprs = [];
  if (args.length) {
    strings = strings.concat([
      ...repeat(args.length - 1, ", "),
      `${close}${filter3 ? " FILTER (WHERE " : ""}`,
      ...filter3 ? [")"] : []
    ]);
    exprs = [...args, ...filter3 ? [filter3] : []];
  } else {
    strings[0] += "*" + close;
  }
  return { exprs, strings };
}
function unquoted(value) {
  const s2 = literalToSQL(value);
  return s2 && s2.startsWith('"') && s2.endsWith('"') ? s2.slice(1, -1) : s2;
}
function aggf(op, type2) {
  return (...args) => new AggregateFunction(op, args, type2);
}
var count = aggf("COUNT", "INTEGER");
var avg = aggf("AVG");
var mean = aggf("AVG");
var mad = aggf("MAD");
var max = aggf("MAX");
var min = aggf("MIN");
var sum = aggf("SUM", "DOUBLE");
var product = aggf("PRODUCT");
var median = aggf("MEDIAN");
var quantile = aggf("QUANTILE");
var mode = aggf("MODE");
var variance = aggf("VARIANCE");
var stddev = aggf("STDDEV");
var skewness = aggf("SKEWNESS");
var kurtosis = aggf("KURTOSIS");
var entropy = aggf("ENTROPY");
var varPop = aggf("VAR_POP");
var stddevPop = aggf("STDDEV_POP");
var corr = aggf("CORR");
var covarPop = aggf("COVAR_POP");
var regrIntercept = aggf("REGR_INTERCEPT");
var regrSlope = aggf("REGR_SLOPE");
var regrCount = aggf("REGR_COUNT");
var regrR2 = aggf("REGR_R2");
var regrSYY = aggf("REGR_SYY");
var regrSXX = aggf("REGR_SXX");
var regrSXY = aggf("REGR_SXY");
var regrAvgX = aggf("REGR_AVGX");
var regrAvgY = aggf("REGR_AVGY");
var first = aggf("FIRST");
var last = aggf("LAST");
var argmin = aggf("ARG_MIN");
var argmax = aggf("ARG_MAX");
var stringAgg = aggf("STRING_AGG");
var arrayAgg = aggf("ARRAY_AGG");

// ../sql/src/cast.js
function cast(expr, type2) {
  const arg = asColumn(expr);
  const e = sql`CAST(${arg} AS ${type2})`;
  Object.defineProperty(e, "label", {
    enumerable: true,
    get() {
      return expr.label;
    }
  });
  Object.defineProperty(e, "aggregate", {
    enumerable: true,
    get() {
      return expr.aggregate || false;
    }
  });
  return e;
}
var castDouble = (expr) => cast(expr, "DOUBLE");
var castInteger = (expr) => cast(expr, "INTEGER");

// ../sql/src/datetime.js
var epoch_ms = (expr) => {
  return sql`epoch_ms(${asColumn(expr)})`;
};
var dateMonth = (expr) => {
  const d = asColumn(expr);
  return sql`MAKE_DATE(2012, MONTH(${d}), 1)`.annotate({ label: "month" });
};
var dateMonthDay = (expr) => {
  const d = asColumn(expr);
  return sql`MAKE_DATE(2012, MONTH(${d}), DAY(${d}))`.annotate({ label: "date" });
};
var dateDay = (expr) => {
  const d = asColumn(expr);
  return sql`MAKE_DATE(2012, 1, DAY(${d}))`.annotate({ label: "date" });
};

// ../sql/src/spatial.js
var geojson = functionCall("ST_AsGeoJSON");
var x = functionCall("ST_X");
var y = functionCall("ST_Y");
var centroid = functionCall("ST_CENTROID");
var centroidX = (geom) => x(centroid(geom));
var centroidY = (geom) => y(centroid(geom));

// ../sql/src/Query.js
var Query = class _Query {
  static select(...expr) {
    return new _Query().select(...expr);
  }
  static from(...expr) {
    return new _Query().from(...expr);
  }
  static with(...expr) {
    return new _Query().with(...expr);
  }
  static union(...queries) {
    return new SetOperation("UNION", queries.flat());
  }
  static unionAll(...queries) {
    return new SetOperation("UNION ALL", queries.flat());
  }
  static intersect(...queries) {
    return new SetOperation("INTERSECT", queries.flat());
  }
  static except(...queries) {
    return new SetOperation("EXCEPT", queries.flat());
  }
  static describe(query) {
    const q2 = query.clone();
    const { clone, toString } = q2;
    return Object.assign(q2, {
      describe: true,
      clone: () => _Query.describe(clone.call(q2)),
      toString: () => `DESCRIBE ${toString.call(q2)}`
    });
  }
  constructor() {
    this.query = {
      with: [],
      select: [],
      from: [],
      where: [],
      groupby: [],
      having: [],
      window: [],
      qualify: [],
      orderby: []
    };
    this.cteFor = null;
  }
  clone() {
    const q2 = new _Query();
    q2.query = { ...this.query };
    return q2;
  }
  /**
   * Retrieve current WITH common table expressions (CTEs).
   * @returns {any[]}
   */
  /**
  * Add WITH common table expressions (CTEs).
  * @param  {...any} expr Expressions to add.
  * @returns {this}
  */
  with(...expr) {
    const { query } = this;
    if (expr.length === 0) {
      return query.with;
    } else {
      const list = [];
      const add = (as, q2) => {
        const query2 = q2.clone();
        query2.cteFor = this;
        list.push({ as, query: query2 });
      };
      expr.flat().forEach((e) => {
        if (e == null) {
        } else if (e.as && e.query) {
          add(e.as, e.query);
        } else {
          for (const as in e) {
            add(as, e[as]);
          }
        }
      });
      query.with = query.with.concat(list);
      return this;
    }
  }
  /**
   * Retrieve current SELECT expressions.
   * @returns {any[]}
   */
  /**
  * Add SELECT expressions.
  * @param {...any} expr Expressions to add.
  * @returns {this}
  */
  select(...expr) {
    const { query } = this;
    if (expr.length === 0) {
      return query.select;
    } else {
      const list = [];
      for (const e of expr.flat()) {
        if (e == null) {
        } else if (typeof e === "string") {
          list.push({ as: e, expr: asColumn(e) });
        } else if (e instanceof Ref) {
          list.push({ as: e.column, expr: e });
        } else if (Array.isArray(e)) {
          list.push({ as: e[0], expr: e[1] });
        } else {
          for (const as in e) {
            list.push({ as: unquote(as), expr: asColumn(e[as]) });
          }
        }
      }
      query.select = query.select.concat(list);
      return this;
    }
  }
  $select(...expr) {
    this.query.select = [];
    return this.select(...expr);
  }
  distinct(value = true) {
    this.query.distinct = !!value;
    return this;
  }
  /**
   * Retrieve current from expressions.
   * @returns {any[]}
   */
  /**
  * Provide table from expressions.
  * @param  {...any} expr
  * @returns {this}
  */
  from(...expr) {
    const { query } = this;
    if (expr.length === 0) {
      return query.from;
    } else {
      const list = [];
      expr.flat().forEach((e) => {
        if (e == null) {
        } else if (typeof e === "string") {
          list.push({ as: e, from: asRelation(e) });
        } else if (e instanceof Ref) {
          list.push({ as: e.table, from: e });
        } else if (isQuery(e) || isSQLExpression(e)) {
          list.push({ from: e });
        } else if (Array.isArray(e)) {
          list.push({ as: unquote(e[0]), from: asRelation(e[1]) });
        } else {
          for (const as in e) {
            list.push({ as: unquote(as), from: asRelation(e[as]) });
          }
        }
      });
      query.from = query.from.concat(list);
      return this;
    }
  }
  $from(...expr) {
    this.query.from = [];
    return this.from(...expr);
  }
  /**
   * Retrieve current SAMPLE settings.
   * @returns {any[]}
   */
  /**
  * Set SAMPLE settings.
  * @param {number|object} value The percentage or number of rows to sample.
  * @param {string} [method] The sampling method to use.
  * @returns {this}
  */
  sample(value, method) {
    const { query } = this;
    if (arguments.length === 0) {
      return query.sample;
    } else {
      let spec = value;
      if (typeof value === "number") {
        spec = value > 0 && value < 1 ? { perc: 100 * value, method } : { rows: Math.round(value), method };
      }
      query.sample = spec;
      return this;
    }
  }
  /**
   * Retrieve current WHERE expressions.
   * @returns {any[]}
   */
  /**
  * Add WHERE expressions.
  * @param  {...any} expr Expressions to add.
  * @returns {this}
  */
  where(...expr) {
    const { query } = this;
    if (expr.length === 0) {
      return query.where;
    } else {
      query.where = query.where.concat(
        expr.flat().filter((x4) => x4)
      );
      return this;
    }
  }
  $where(...expr) {
    this.query.where = [];
    return this.where(...expr);
  }
  /**
   * Retrieve current GROUP BY expressions.
   * @returns {any[]}
   */
  /**
  * Add GROUP BY expressions.
  * @param  {...any} expr Expressions to add.
  * @returns {this}
  */
  groupby(...expr) {
    const { query } = this;
    if (expr.length === 0) {
      return query.groupby;
    } else {
      query.groupby = query.groupby.concat(
        expr.flat().filter((x4) => x4).map(asColumn)
      );
      return this;
    }
  }
  $groupby(...expr) {
    this.query.groupby = [];
    return this.groupby(...expr);
  }
  /**
   * Retrieve current HAVING expressions.
   * @returns {any[]}
   */
  /**
  * Add HAVING expressions.
  * @param  {...any} expr Expressions to add.
  * @returns {this}
  */
  having(...expr) {
    const { query } = this;
    if (expr.length === 0) {
      return query.having;
    } else {
      query.having = query.having.concat(
        expr.flat().filter((x4) => x4)
      );
      return this;
    }
  }
  /**
   * Retrieve current WINDOW definitions.
   * @returns {any[]}
   */
  /**
  * Add WINDOW definitions.
  * @param  {...any} expr Expressions to add.
  * @returns {this}
  */
  window(...expr) {
    const { query } = this;
    if (expr.length === 0) {
      return query.window;
    } else {
      const list = [];
      expr.flat().forEach((e) => {
        if (e == null) {
        } else {
          for (const as in e) {
            list.push({ as: unquote(as), expr: e[as] });
          }
        }
      });
      query.window = query.window.concat(list);
      return this;
    }
  }
  /**
   * Retrieve current QUALIFY expressions.
   * @returns {any[]}
   */
  /**
  * Add QUALIFY expressions.
  * @param  {...any} expr Expressions to add.
  * @returns {this}
  */
  qualify(...expr) {
    const { query } = this;
    if (expr.length === 0) {
      return query.qualify;
    } else {
      query.qualify = query.qualify.concat(
        expr.flat().filter((x4) => x4)
      );
      return this;
    }
  }
  /**
   * Retrieve current ORDER BY expressions.
   * @returns {any[]}
   */
  /**
  * Add ORDER BY expressions.
  * @param  {...any} expr Expressions to add.
  * @returns {this}
  */
  orderby(...expr) {
    const { query } = this;
    if (expr.length === 0) {
      return query.orderby;
    } else {
      query.orderby = query.orderby.concat(
        expr.flat().filter((x4) => x4).map(asColumn)
      );
      return this;
    }
  }
  /**
   * Retrieve current LIMIT value.
   * @returns {number|null}
   */
  /**
  * Set the query result LIMIT.
  * @param {number} value The limit value.
  * @returns {this}
  */
  limit(value) {
    const { query } = this;
    if (arguments.length === 0) {
      return query.limit;
    } else {
      query.limit = Number.isFinite(value) ? value : void 0;
      return this;
    }
  }
  /**
   * Retrieve current OFFSET value.
   * @returns {number|null}
   */
  /**
  * Set the query result OFFSET.
  * @param {number} value The offset value.
  * @returns {this}
  */
  offset(value) {
    const { query } = this;
    if (arguments.length === 0) {
      return query.offset;
    } else {
      query.offset = Number.isFinite(value) ? value : void 0;
      return this;
    }
  }
  get subqueries() {
    const { query, cteFor } = this;
    const ctes = (cteFor?.query || query).with;
    const cte = ctes?.reduce((o, { as, query: query2 }) => (o[as] = query2, o), {});
    const q2 = [];
    query.from.forEach(({ from: from2 }) => {
      if (isQuery(from2)) {
        q2.push(from2);
      } else if (cte[from2.table]) {
        const sub = cte[from2.table];
        q2.push(sub);
      }
    });
    return q2;
  }
  toString() {
    const {
      with: cte,
      select: select2,
      distinct: distinct2,
      from: from2,
      sample,
      where,
      groupby,
      having,
      window: window3,
      qualify,
      orderby,
      limit,
      offset: offset2
    } = this.query;
    const sql2 = [];
    if (cte.length) {
      const list = cte.map(({ as, query }) => `"${as}" AS (${query})`);
      sql2.push(`WITH ${list.join(", ")}`);
    }
    const sels = select2.map(
      ({ as, expr }) => isColumnRefFor(expr, as) && !expr.table ? `${expr}` : `${expr} AS "${as}"`
    );
    sql2.push(`SELECT${distinct2 ? " DISTINCT" : ""} ${sels.join(", ")}`);
    if (from2.length) {
      const rels = from2.map(({ as, from: from3 }) => {
        const rel = isQuery(from3) ? `(${from3})` : `${from3}`;
        return !as || as === from3.table ? rel : `${rel} AS "${as}"`;
      });
      sql2.push(`FROM ${rels.join(", ")}`);
    }
    if (where.length) {
      const clauses = where.map(String).filter((x4) => x4).join(" AND ");
      if (clauses)
        sql2.push(`WHERE ${clauses}`);
    }
    if (sample) {
      const { rows, perc, method, seed } = sample;
      const size = rows ? `${rows} ROWS` : `${perc} PERCENT`;
      const how = method ? ` (${method}${seed != null ? `, ${seed}` : ""})` : "";
      sql2.push(`USING SAMPLE ${size}${how}`);
    }
    if (groupby.length) {
      sql2.push(`GROUP BY ${groupby.join(", ")}`);
    }
    if (having.length) {
      const clauses = having.map(String).filter((x4) => x4).join(" AND ");
      if (clauses)
        sql2.push(`HAVING ${clauses}`);
    }
    if (window3.length) {
      const windows = window3.map(({ as, expr }) => `"${as}" AS (${expr})`);
      sql2.push(`WINDOW ${windows.join(", ")}`);
    }
    if (qualify.length) {
      const clauses = qualify.map(String).filter((x4) => x4).join(" AND ");
      if (clauses)
        sql2.push(`QUALIFY ${clauses}`);
    }
    if (orderby.length) {
      sql2.push(`ORDER BY ${orderby.join(", ")}`);
    }
    if (Number.isFinite(limit)) {
      sql2.push(`LIMIT ${limit}`);
    }
    if (Number.isFinite(offset2)) {
      sql2.push(`OFFSET ${offset2}`);
    }
    return sql2.join(" ");
  }
};
var SetOperation = class _SetOperation {
  constructor(op, queries) {
    this.op = op;
    this.queries = queries.map((q2) => q2.clone());
    this.query = { orderby: [] };
    this.cteFor = null;
  }
  clone() {
    const q2 = new _SetOperation(this.op, this.queries);
    q2.query = { ...this.query };
    return q2;
  }
  orderby(...expr) {
    const { query } = this;
    if (expr.length === 0) {
      return query.orderby;
    } else {
      query.orderby = query.orderby.concat(
        expr.flat().filter((x4) => x4).map(asColumn)
      );
      return this;
    }
  }
  limit(value) {
    const { query } = this;
    if (arguments.length === 0) {
      return query.limit;
    } else {
      query.limit = Number.isFinite(value) ? value : void 0;
      return this;
    }
  }
  offset(value) {
    const { query } = this;
    if (arguments.length === 0) {
      return query.offset;
    } else {
      query.offset = Number.isFinite(value) ? value : void 0;
      return this;
    }
  }
  get subqueries() {
    const { queries, cteFor } = this;
    if (cteFor)
      queries.forEach((q2) => q2.cteFor = cteFor);
    return queries;
  }
  toString() {
    const { op, queries, query: { orderby, limit, offset: offset2 } } = this;
    const sql2 = [queries.join(` ${op} `)];
    if (orderby.length) {
      sql2.push(`ORDER BY ${orderby.join(", ")}`);
    }
    if (Number.isFinite(limit)) {
      sql2.push(`LIMIT ${limit}`);
    }
    if (Number.isFinite(offset2)) {
      sql2.push(`OFFSET ${offset2}`);
    }
    return sql2.join(" ");
  }
};
function isQuery(value) {
  return value instanceof Query || value instanceof SetOperation;
}
function isDescribeQuery(value) {
  return isQuery(value) && value.describe;
}
function unquote(s2) {
  return isDoubleQuoted(s2) ? s2.slice(1, -1) : s2;
}
function isDoubleQuoted(s2) {
  return s2[0] === '"' && s2[s2.length - 1] === '"';
}

// ../sql/src/scales.js
var identity = (x4) => x4;
function scaleLinear() {
  return {
    apply: identity,
    invert: identity,
    sqlApply: asColumn,
    sqlInvert: identity
  };
}
function scaleLog({ base = null } = {}) {
  if (base == null || base === Math.E) {
    return {
      apply: Math.log,
      invert: Math.exp,
      sqlApply: (c4) => sql`LN(${asColumn(c4)})`,
      sqlInvert: (c4) => sql`EXP(${c4})`
    };
  } else if (base === 10) {
    return {
      apply: Math.log10,
      invert: (x4) => Math.pow(10, x4),
      sqlApply: (c4) => sql`LOG(${asColumn(c4)})`,
      sqlInvert: (c4) => sql`POW(10, ${c4})`
    };
  } else {
    const b2 = +base;
    return {
      apply: (x4) => Math.log(x4) / Math.log(b2),
      invert: (x4) => Math.pow(b2, x4),
      sqlApply: (c4) => sql`LN(${asColumn(c4)}) / LN(${b2})`,
      sqlInvert: (c4) => sql`POW(${b2}, ${c4})`
    };
  }
}
function scaleSymlog({ constant: constant2 = 1 } = {}) {
  const _2 = +constant2;
  return {
    apply: (x4) => Math.sign(x4) * Math.log1p(Math.abs(x4)),
    invert: (x4) => Math.sign(x4) * Math.exp(Math.abs(x4) - _2),
    sqlApply: (c4) => (c4 = asColumn(c4), sql`SIGN(${c4}) * LN(${_2} + ABS(${c4}))`),
    sqlInvert: (c4) => sql`SIGN(${c4}) * (EXP(ABS(${c4})) - ${_2})`
  };
}
function scaleSqrt() {
  return {
    apply: (x4) => Math.sign(x4) * Math.sqrt(Math.abs(x4)),
    invert: (x4) => Math.sign(x4) * x4 * x4,
    sqlApply: (c4) => (c4 = asColumn(c4), sql`SIGN(${c4}) * SQRT(ABS(${c4}))`),
    sqlInvert: (c4) => sql`SIGN(${c4}) * (${c4}) ** 2`
  };
}
function scalePow({ exponent = 1 } = {}) {
  const e = +exponent;
  return {
    apply: (x4) => Math.sign(x4) * Math.pow(Math.abs(x4), e),
    invert: (x4) => Math.sign(x4) * Math.pow(Math.abs(x4), 1 / e),
    sqlApply: (c4) => (c4 = asColumn(c4), sql`SIGN(${c4}) * POW(ABS(${c4}), ${e})`),
    sqlInvert: (c4) => sql`SIGN(${c4}) * POW(ABS(${c4}), 1/${e})`
  };
}
function scaleTime() {
  return {
    apply: (x4) => +x4,
    invert: (x4) => new Date(x4),
    sqlApply: (c4) => c4 instanceof Date ? +c4 : epoch_ms(asColumn(c4)),
    sqlInvert: identity
  };
}
var scales = {
  linear: scaleLinear,
  log: scaleLog,
  symlog: scaleSymlog,
  sqrt: scaleSqrt,
  pow: scalePow,
  time: scaleTime,
  utc: scaleTime
};
function scaleTransform(options) {
  const scale3 = scales[options.type];
  return scale3 ? { ...options, ...scale3(options) } : null;
}

// ../sql/src/load/create.js
function create(name2, query, {
  replace = false,
  temp = true,
  view = false
} = {}) {
  return "CREATE" + (replace ? " OR REPLACE " : " ") + (temp ? "TEMP " : "") + (view ? "VIEW" : "TABLE") + (replace ? " " : " IF NOT EXISTS ") + name2 + " AS " + query;
}

// ../sql/src/load/extension.js
function loadExtension(name2) {
  return `INSTALL ${name2}; LOAD ${name2}`;
}

// ../sql/src/load/sql-from.js
function sqlFrom(data, {
  columns = Object.keys(data?.[0] || {})
} = {}) {
  let keys = [];
  if (Array.isArray(columns)) {
    keys = columns;
    columns = keys.reduce((m2, k3) => (m2[k3] = k3, m2), {});
  } else if (columns) {
    keys = Object.keys(columns);
  }
  if (!keys.length) {
    throw new Error("Can not create table from empty column set.");
  }
  const subq = [];
  for (const datum2 of data) {
    const sel = keys.map((k3) => `${literalToSQL(datum2[k3])} AS "${columns[k3]}"`);
    subq.push(`(SELECT ${sel.join(", ")})`);
  }
  return subq.join(" UNION ALL ");
}

// ../sql/src/load/load.js
function load(method, tableName, fileName, options = {}, defaults23 = {}) {
  const { select: select2 = ["*"], where, view, temp, replace, ...file } = options;
  const params = parameters({ ...defaults23, ...file });
  const read = `${method}('${fileName}'${params ? ", " + params : ""})`;
  const filter3 = where ? ` WHERE ${where}` : "";
  const query = `SELECT ${select2.join(", ")} FROM ${read}${filter3}`;
  return create(tableName, query, { view, temp, replace });
}
function loadCSV(tableName, fileName, options) {
  return load("read_csv", tableName, fileName, options, { auto_detect: true, sample_size: -1 });
}
function loadJSON(tableName, fileName, options) {
  return load("read_json", tableName, fileName, options, { auto_detect: true, json_format: "auto" });
}
function loadParquet(tableName, fileName, options) {
  return load("read_parquet", tableName, fileName, options);
}
function loadSpatial(tableName, fileName, options = {}) {
  const { options: opt, ...rest } = options;
  if (opt) {
    const open = Array.isArray(opt) ? opt.join(", ") : typeof opt === "string" ? opt : Object.entries(opt).map(([key, value]) => `${key}=${value}`).join(", ");
    Object.assign(rest, { open_options: open.toUpperCase() });
  }
  return load("st_read", tableName, fileName, rest);
}
function loadObjects(tableName, data, options = {}) {
  const { select: select2 = ["*"], ...opt } = options;
  const values2 = sqlFrom(data);
  const query = select2.length === 1 && select2[0] === "*" ? values2 : `SELECT ${select2} FROM ${values2}`;
  return create(tableName, query, opt);
}
function parameters(options) {
  return Object.entries(options).map(([key, value]) => `${key}=${toDuckDBValue(value)}`).join(", ");
}
function toDuckDBValue(value) {
  switch (typeof value) {
    case "boolean":
      return String(value);
    case "string":
      return `'${value}'`;
    case "undefined":
    case "object":
      if (value == null) {
        return "NULL";
      } else if (Array.isArray(value)) {
        return "[" + value.map((v3) => toDuckDBValue(v3)).join(", ") + "]";
      } else {
        return "{" + Object.entries(value).map(([k3, v3]) => `'${k3}': ${toDuckDBValue(v3)}`).join(", ") + "}";
      }
    default:
      return value;
  }
}

// ../core/src/util/hash.js
function fnv_hash(v3) {
  let a3 = 2166136261;
  for (let i = 0, n = v3.length; i < n; ++i) {
    const c4 = v3.charCodeAt(i);
    const d = c4 & 65280;
    if (d)
      a3 = fnv_multiply(a3 ^ d >> 8);
    a3 = fnv_multiply(a3 ^ c4 & 255);
  }
  return fnv_mix(a3);
}
function fnv_multiply(a3) {
  return a3 + (a3 << 1) + (a3 << 4) + (a3 << 7) + (a3 << 8) + (a3 << 24);
}
function fnv_mix(a3) {
  a3 += a3 << 13;
  a3 ^= a3 >>> 7;
  a3 += a3 << 3;
  a3 ^= a3 >>> 17;
  a3 += a3 << 5;
  return a3 & 4294967295;
}

// ../core/src/DataCubeIndexer.js
var DataCubeIndexer = class {
  /**
   *
   * @param {import('./Coordinator.js').Coordinator} mc a Mosaic coordinator
   * @param {*} options Options hash to configure the data cube indexes and pass selections to the coordinator.
   */
  constructor(mc, { selection: selection2, temp = true }) {
    this.mc = mc;
    this.selection = selection2;
    this.temp = temp;
    this.reset();
  }
  reset() {
    this.enabled = false;
    this.clients = null;
    this.indices = null;
    this.activeView = null;
  }
  clear() {
    if (this.indices) {
      this.mc.cancel(Array.from(this.indices.values(), (index2) => index2.result));
      this.indices = null;
    }
  }
  index(clients, active) {
    if (this.clients !== clients) {
      const cols = Array.from(clients, getIndexColumns);
      const from2 = cols[0]?.from;
      this.enabled = cols.every((c4) => c4 && c4.from === from2);
      this.clients = clients;
      this.activeView = null;
      this.clear();
    }
    if (!this.enabled)
      return false;
    active = active || this.selection.active;
    const { source } = active;
    if (source && source === this.activeView?.source)
      return true;
    this.clear();
    if (!source)
      return false;
    const activeView = this.activeView = getActiveView(active);
    if (!activeView)
      return false;
    this.mc.logger().warn("DATA CUBE INDEX CONSTRUCTION");
    const sel = this.selection.remove(source);
    const indices = this.indices = /* @__PURE__ */ new Map();
    const { mc, temp } = this;
    for (const client of clients) {
      if (sel.skip(client, active))
        continue;
      const index2 = getIndexColumns(client);
      const query = client.query(sel.predicate(client)).select({ ...activeView.columns, ...index2.count }).groupby(Object.keys(activeView.columns));
      const [subq] = query.subqueries;
      if (subq) {
        const cols = Object.values(activeView.columns).map((c4) => c4.columns[0]);
        subqueryPushdown(subq, cols);
      }
      const order = query.orderby();
      query.query.orderby = [];
      const sql2 = query.toString();
      const id2 = (fnv_hash(sql2) >>> 0).toString(16);
      const table3 = `cube_index_${id2}`;
      const result = mc.exec(create(table3, sql2, { temp }));
      indices.set(client, { table: table3, result, order, ...index2 });
    }
  }
  async update() {
    const { clients, selection: selection2, activeView } = this;
    const filter3 = activeView.predicate(selection2.active.predicate);
    return Promise.all(
      Array.from(clients).map((client) => this.updateClient(client, filter3))
    );
  }
  async updateClient(client, filter3) {
    const index2 = this.indices.get(client);
    if (!index2)
      return;
    if (!filter3) {
      filter3 = this.activeView.predicate(this.selection.active.predicate);
    }
    const { table: table3, dims, aggr, order = [] } = index2;
    const query = Query.select(dims, aggr).from(table3).groupby(dims).where(filter3).orderby(order);
    return this.mc.updateClient(client, query);
  }
};
function getActiveView(clause) {
  const { source, schema } = clause;
  let columns = clause.predicate?.columns;
  if (!schema || !columns)
    return null;
  const { type: type2, scales: scales2, pixelSize = 1 } = schema;
  let predicate;
  if (type2 === "interval" && scales2) {
    const bins2 = scales2.map((s2) => binInterval(s2, pixelSize));
    if (bins2.some((b2) => b2 == null))
      return null;
    if (bins2.length === 1) {
      predicate = (p2) => p2 ? isBetween("active0", p2.range.map(bins2[0])) : [];
      columns = { active0: bins2[0](clause.predicate.field) };
    } else {
      predicate = (p2) => p2 ? and(p2.children.map(({ range: range3 }, i) => isBetween(`active${i}`, range3.map(bins2[i])))) : [];
      columns = Object.fromEntries(
        clause.predicate.children.map((p2, i) => [`active${i}`, bins2[i](p2.field)])
      );
    }
  } else if (type2 === "point") {
    predicate = (x4) => x4;
    columns = Object.fromEntries(columns.map((col) => [col.toString(), col]));
  } else {
    return null;
  }
  return { source, columns, predicate };
}
function binInterval(scale3, pixelSize) {
  const { apply: apply2, sqlApply } = scaleTransform(scale3);
  if (apply2) {
    const { domain, range: range3 } = scale3;
    const lo = apply2(Math.min(...domain));
    const hi = apply2(Math.max(...domain));
    const a3 = Math.abs(range3[1] - range3[0]) / (hi - lo) / pixelSize;
    const s2 = pixelSize === 1 ? "" : `${pixelSize}::INTEGER * `;
    return (value) => sql`${s2}FLOOR(${a3}::DOUBLE * (${sqlApply(value)} - ${lo}::DOUBLE))::INTEGER`;
  }
}
var NO_INDEX = { from: NaN };
function getIndexColumns(client) {
  if (!client.filterIndexable)
    return NO_INDEX;
  const q2 = client.query();
  const from2 = getBaseTable(q2);
  if (!from2 || !q2.groupby)
    return NO_INDEX;
  const g2 = new Set(q2.groupby().map((c4) => c4.column));
  const aggr = [];
  const dims = [];
  let count4;
  for (const { as, expr: { aggregate } } of q2.select()) {
    switch (aggregate?.toUpperCase?.()) {
      case "COUNT":
      case "SUM":
        aggr.push({ [as]: sql`SUM("${as}")::DOUBLE` });
        break;
      case "AVG":
        count4 = "_count_";
        aggr.push({ [as]: sql`(SUM("${as}" * ${count4}) / SUM(${count4}))::DOUBLE` });
        break;
      case "MAX":
        aggr.push({ [as]: sql`MAX("${as}")` });
        break;
      case "MIN":
        aggr.push({ [as]: sql`MIN("${as}")` });
        break;
      default:
        if (g2.has(as))
          dims.push(as);
        else
          return null;
    }
  }
  return {
    aggr,
    dims,
    count: count4 ? { [count4]: sql`COUNT(*)` } : {},
    from: from2
  };
}
function getBaseTable(query) {
  const subq = query.subqueries;
  if (query.select) {
    const from2 = query.from();
    if (!from2.length)
      return void 0;
    if (subq.length === 0)
      return from2[0].from.table;
  }
  const base = getBaseTable(subq[0]);
  for (let i = 1; i < subq.length; ++i) {
    const from2 = getBaseTable(subq[i]);
    if (from2 === void 0)
      continue;
    if (from2 !== base)
      return NaN;
  }
  return base;
}
function subqueryPushdown(query, cols) {
  const memo2 = /* @__PURE__ */ new Set();
  const pushdown = (q2) => {
    if (memo2.has(q2))
      return;
    memo2.add(q2);
    if (q2.select && q2.from().length) {
      q2.select(cols);
    }
    q2.subqueries.forEach(pushdown);
  };
  pushdown(query);
}

// ../core/src/FilterGroup.js
var FilterGroup = class {
  /**
   * @param {import('./Coordinator.js').Coordinator} coordinator The Mosaic coordinator.
   * @param {*} selection The shared filter selection.
   * @param {*} index Boolean flag or options hash for data cube indexer.
   *  Falsy values disable indexing.
   */
  constructor(coordinator2, selection2, index2 = true) {
    this.mc = coordinator2;
    this.selection = selection2;
    this.clients = /* @__PURE__ */ new Set();
    this.indexer = index2 ? new DataCubeIndexer(this.mc, { ...index2, selection: selection2 }) : null;
    const { value, activate } = this.handlers = {
      value: () => this.update(),
      activate: (clause) => this.indexer?.index(this.clients, clause)
    };
    selection2.addEventListener("value", value);
    selection2.addEventListener("activate", activate);
  }
  finalize() {
    const { value, activate } = this.handlers;
    this.selection.removeEventListener("value", value);
    this.selection.removeEventListener("activate", activate);
  }
  reset() {
    this.indexer?.reset();
  }
  add(client) {
    (this.clients = new Set(this.clients)).add(client);
    return this;
  }
  remove(client) {
    if (this.clients.has(client)) {
      (this.clients = new Set(this.clients)).delete(client);
    }
    return this;
  }
  update() {
    const { mc, indexer, clients, selection: selection2 } = this;
    return indexer?.index(clients) ? indexer.update() : defaultUpdate(mc, clients, selection2);
  }
};
function defaultUpdate(mc, clients, selection2) {
  return Promise.all(Array.from(clients).map((client) => {
    const filter3 = selection2.predicate(client);
    if (filter3 != null) {
      return mc.updateClient(client, client.query(filter3));
    }
  }));
}

// ../core/src/util/query-result.js
function queryResult() {
  let resolve;
  let reject;
  const p2 = new Promise((r, e) => {
    resolve = r;
    reject = e;
  });
  return Object.assign(p2, {
    fulfill: (value) => (resolve(value), p2),
    reject: (err) => (reject(err), p2)
  });
}

// ../core/src/QueryConsolidator.js
function wait(callback) {
  const method = typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : typeof setImmediate !== "undefined" ? setImmediate : setTimeout;
  return method(callback);
}
function consolidator(enqueue, cache, record) {
  let pending = [];
  let id2 = 0;
  function run() {
    const groups2 = entryGroups(pending, cache);
    pending = [];
    id2 = 0;
    for (const group3 of groups2) {
      consolidate(group3, enqueue, record);
      processResults(group3, cache);
    }
  }
  return {
    add(entry, priority) {
      if (entry.request.type === "arrow") {
        id2 = id2 || wait(() => run());
        pending.push({ entry, priority, index: pending.length });
      } else {
        enqueue(entry, priority);
      }
    }
  };
}
function entryGroups(entries, cache) {
  const groups2 = [];
  const groupMap = /* @__PURE__ */ new Map();
  for (const query of entries) {
    const { entry: { request } } = query;
    const key = consolidationKey(request.query, cache);
    if (!groupMap.has(key)) {
      const list = [];
      groups2.push(list);
      groupMap.set(key, list);
    }
    groupMap.get(key).push(query);
  }
  return groups2;
}
function consolidationKey(query, cache) {
  const sql2 = `${query}`;
  if (query instanceof Query && !cache.get(sql2)) {
    if (
      // @ts-ignore
      query.orderby().length || query.where().length || // @ts-ignore
      query.qualify().length || query.having().length
    ) {
      return sql2;
    }
    const q2 = query.clone().$select("*");
    const groupby = query.groupby();
    if (groupby.length) {
      const map4 = {};
      query.select().forEach(({ as, expr }) => map4[as] = expr);
      q2.$groupby(groupby.map((e) => e instanceof Ref && map4[e.column] || e));
    }
    return `${q2}`;
  } else {
    return sql2;
  }
}
function consolidate(group3, enqueue, record) {
  if (shouldConsolidate(group3)) {
    enqueue({
      request: {
        type: "arrow",
        cache: false,
        record: false,
        query: group3.query = consolidatedQuery(group3, record)
      },
      result: group3.result = queryResult()
    });
  } else {
    for (const { entry, priority } of group3) {
      enqueue(entry, priority);
    }
  }
}
function shouldConsolidate(group3) {
  if (group3.length > 1) {
    const sql2 = `${group3[0].entry.request.query}`;
    for (let i = 1; i < group3.length; ++i) {
      if (sql2 !== `${group3[i].entry.request.query}`) {
        return true;
      }
    }
  }
  return false;
}
function consolidatedQuery(group3, record) {
  const maps = group3.maps = [];
  const fields = /* @__PURE__ */ new Map();
  for (const item of group3) {
    const { query: query2 } = item.entry.request;
    const fieldMap = [];
    maps.push(fieldMap);
    for (const { as, expr } of query2.select()) {
      const e = `${expr}`;
      if (!fields.has(e)) {
        fields.set(e, [`col${fields.size}`, expr]);
      }
      const [name2] = fields.get(e);
      fieldMap.push([name2, as]);
    }
    record(`${query2}`);
  }
  const query = group3[0].entry.request.query.clone();
  const groupby = query.groupby();
  if (groupby.length) {
    const map4 = {};
    group3.maps[0].forEach(([name2, as]) => map4[as] = name2);
    query.$groupby(groupby.map((e) => e instanceof Ref && map4[e.column] || e));
  }
  return query.$select(Array.from(fields.values()));
}
async function processResults(group3, cache) {
  const { maps, query, result } = group3;
  if (!maps)
    return;
  let data;
  try {
    data = await result;
  } catch (err) {
    for (const { entry } of group3) {
      entry.result.reject(err);
    }
    return;
  }
  const describe = isDescribeQuery(query);
  group3.forEach(({ entry }, index2) => {
    const { request, result: result2 } = entry;
    const map4 = maps[index2];
    const extract = describe && map4 ? filterResult(data, map4) : map4 ? projectResult(data, map4) : data;
    if (request.cache) {
      cache.set(String(request.query), extract);
    }
    result2.fulfill(extract);
  });
}
function projectResult(data, map4) {
  const cols = {};
  for (const [name2, as] of map4) {
    cols[as] = data.getChild(name2);
  }
  return new data.constructor(cols);
}
function filterResult(data, map4) {
  const lookup = new Map(map4);
  const result = [];
  for (const d of data) {
    if (lookup.has(d.column_name)) {
      result.push({ ...d, column_name: lookup.get(d.column_name) });
    }
  }
  return result;
}

// ../core/src/util/cache.js
var requestIdle = typeof requestIdleCallback !== "undefined" ? requestIdleCallback : setTimeout;
var voidCache = () => ({
  get: () => void 0,
  set: (key, value) => value,
  clear: () => {
  }
});
function lruCache({
  max: max4 = 1e3,
  // max entries
  ttl = 3 * 60 * 60 * 1e3
  // time-to-live, default 3 hours
} = {}) {
  let cache = /* @__PURE__ */ new Map();
  function evict() {
    const expire = performance.now() - ttl;
    let lruKey = null;
    let lruLast = Infinity;
    for (const [key, value] of cache) {
      const { last: last2 } = value;
      if (last2 < lruLast) {
        lruKey = key;
        lruLast = last2;
      }
      if (expire > last2) {
        cache.delete(key);
      }
    }
    if (lruKey) {
      cache.delete(lruKey);
    }
  }
  return {
    get(key) {
      const entry = cache.get(key);
      if (entry) {
        entry.last = performance.now();
        return entry.value;
      }
    },
    set(key, value) {
      cache.set(key, { last: performance.now(), value });
      if (cache.size > max4)
        requestIdle(evict);
      return value;
    },
    clear() {
      cache = /* @__PURE__ */ new Map();
    }
  };
}

// ../core/src/util/priority-queue.js
function priorityQueue(ranks) {
  const queue = Array.from(
    { length: ranks },
    () => ({ head: null, tail: null })
  );
  return {
    /**
     * Indicate if the queue is empty.
     * @returns [boolean] true if empty, false otherwise.
     */
    isEmpty() {
      return queue.every((list) => !list.head);
    },
    /**
     * Insert an item into the queue with a given priority rank.
     * @param {*} item The item to add.
     * @param {number} rank The integer priority rank.
     *  Priority ranks are integers starting at zero.
     *  Lower ranks indicate higher priority.
     */
    insert(item, rank3) {
      const list = queue[rank3];
      if (!list) {
        throw new Error(`Invalid queue priority rank: ${rank3}`);
      }
      const node = { item, next: null };
      if (list.head === null) {
        list.head = list.tail = node;
      } else {
        list.tail = list.tail.next = node;
      }
    },
    /**
     * Remove a set of items from the queue, regardless of priority rank.
     * If a provided item is not in the queue it will be ignored.
     * @param {(item: *) => boolean} test A predicate function to test
     * 	if an item should be removed (true to drop, false to keep).
     */
    remove(test) {
      for (const list of queue) {
        let { head, tail } = list;
        for (let prev = null, curr = head; curr; prev = curr, curr = curr.next) {
          if (test(curr.item)) {
            if (curr === head) {
              head = curr.next;
            } else {
              prev.next = curr.next;
            }
            if (curr === tail)
              tail = prev || head;
          }
        }
        list.head = head;
        list.tail = tail;
      }
    },
    /**
     * Remove and return the next highest priority item.
     * @returns {*} The next item in the queue,
     *  or undefined if this queue is empty.
     */
    next() {
      for (const list of queue) {
        const { head } = list;
        if (head !== null) {
          list.head = head.next;
          if (list.tail === head) {
            list.tail = null;
          }
          return head.item;
        }
      }
    }
  };
}

// ../core/src/QueryManager.js
var Priority = { High: 0, Normal: 1, Low: 2 };
function QueryManager() {
  const queue = priorityQueue(3);
  let db;
  let clientCache;
  let logger;
  let recorders = [];
  let pending = null;
  let consolidate2;
  function next() {
    if (pending || queue.isEmpty())
      return;
    const { request, result } = queue.next();
    pending = submit(request, result);
    pending.finally(() => {
      pending = null;
      next();
    });
  }
  function enqueue(entry, priority = Priority.Normal) {
    queue.insert(entry, priority);
    next();
  }
  function recordQuery(sql2) {
    if (recorders.length && sql2) {
      recorders.forEach((rec) => rec.add(sql2));
    }
  }
  async function submit(request, result) {
    try {
      const { query, type: type2, cache = false, record = true, options } = request;
      const sql2 = query ? `${query}` : null;
      if (record) {
        recordQuery(sql2);
      }
      if (cache) {
        const cached = clientCache.get(sql2);
        if (cached) {
          logger.debug("Cache");
          result.fulfill(cached);
          return;
        }
      }
      const t03 = performance.now();
      const data = await db.query({ type: type2, sql: sql2, ...options });
      if (cache)
        clientCache.set(sql2, data);
      logger.debug(`Request: ${(performance.now() - t03).toFixed(1)}`);
      result.fulfill(data);
    } catch (err) {
      result.reject(err);
    }
  }
  return {
    cache(value) {
      return value !== void 0 ? clientCache = value === true ? lruCache() : value || voidCache() : clientCache;
    },
    logger(value) {
      return value ? logger = value : logger;
    },
    connector(connector) {
      return connector ? db = connector : db;
    },
    consolidate(flag) {
      if (flag && !consolidate2) {
        consolidate2 = consolidator(enqueue, clientCache, recordQuery);
      } else if (!flag && consolidate2) {
        consolidate2 = null;
      }
    },
    request(request, priority = Priority.Normal) {
      const result = queryResult();
      const entry = { request, result };
      if (consolidate2) {
        consolidate2.add(entry, priority);
      } else {
        enqueue(entry, priority);
      }
      return result;
    },
    cancel(requests) {
      const set3 = new Set(requests);
      queue.remove(({ result }) => set3.has(result));
    },
    clear() {
      queue.remove(({ result }) => {
        result.reject("Cleared");
        return true;
      });
    },
    record() {
      let state = [];
      const recorder = {
        add(query) {
          state.push(query);
        },
        reset() {
          state = [];
        },
        snapshot() {
          return state.slice();
        },
        stop() {
          recorders = recorders.filter((x4) => x4 !== recorder);
          return state;
        }
      };
      recorders.push(recorder);
      return recorder;
    }
  };
}

// ../core/src/util/js-type.js
function jsType(type2) {
  switch (type2) {
    case "BIGINT":
    case "HUGEINT":
    case "INTEGER":
    case "SMALLINT":
    case "TINYINT":
    case "UBIGINT":
    case "UINTEGER":
    case "USMALLINT":
    case "UTINYINT":
    case "DOUBLE":
    case "FLOAT":
    case "REAL":
      return "number";
    case "DATE":
    case "TIMESTAMP":
    case "TIMESTAMPTZ":
    case "TIMESTAMP WITH TIME ZONE":
    case "TIME":
    case "TIMESTAMP_NS":
      return "date";
    case "BOOLEAN":
      return "boolean";
    case "VARCHAR":
    case "UUID":
      return "string";
    case "ARRAY":
    case "LIST":
      return "array";
    case "BLOB":
    case "STRUCT":
    case "MAP":
    case "GEOMETRY":
      return "object";
    default:
      if (type2.startsWith("DECIMAL")) {
        return "number";
      } else if (type2.startsWith("STRUCT") || type2.startsWith("MAP")) {
        return "object";
      } else if (type2.endsWith("]")) {
        return "array";
      }
      throw new Error(`Unsupported type: ${type2}`);
  }
}

// ../core/src/util/convert-arrow.js
function isArrowTable(values2) {
  return typeof values2?.getChild === "function";
}
function convertArrowValue(type2) {
  if (DataType.isTimestamp(type2)) {
    return (v3) => v3 == null ? v3 : new Date(v3);
  }
  if (DataType.isInt(type2) && type2.bitWidth >= 64) {
    return (v3) => v3 == null ? v3 : Number(v3);
  }
  if (DataType.isDecimal(type2)) {
    const scale3 = 1 / Math.pow(10, type2.scale);
    return (v3) => v3 == null ? v3 : decimalToNumber(v3, scale3);
  }
  return (v3) => v3;
}
function convertArrowColumn(column3) {
  const { type: type2 } = column3;
  if (DataType.isTimestamp(type2)) {
    const size = column3.length;
    const array4 = new Array(size);
    for (let row = 0; row < size; ++row) {
      const v3 = column3.get(row);
      array4[row] = v3 == null ? null : new Date(v3);
    }
    return array4;
  }
  if (DataType.isInt(type2) && type2.bitWidth >= 64) {
    const size = column3.length;
    const array4 = new Float64Array(size);
    for (let row = 0; row < size; ++row) {
      const v3 = column3.get(row);
      array4[row] = v3 == null ? NaN : Number(v3);
    }
    return array4;
  }
  if (DataType.isDecimal(type2)) {
    const scale3 = 1 / Math.pow(10, type2.scale);
    const size = column3.length;
    const array4 = new Float64Array(size);
    for (let row = 0; row < size; ++row) {
      const v3 = column3.get(row);
      array4[row] = v3 == null ? NaN : decimalToNumber(v3, scale3);
    }
    return array4;
  }
  return column3.toArray();
}
var BASE32 = Array.from(
  { length: 8 },
  (_2, i) => Math.pow(2, i * 32)
);
function decimalToNumber(v3, scale3) {
  const n = v3.length;
  let x4 = 0;
  if (v3.signed && (v3[n - 1] | 0) < 0) {
    for (let i = 0; i < n; ++i) {
      x4 += ~v3[i] * BASE32[i];
    }
    x4 = -(x4 + 1);
  } else {
    for (let i = 0; i < n; ++i) {
      x4 += v3[i] * BASE32[i];
    }
  }
  return x4 * scale3;
}

// ../core/src/util/field-info.js
var Count = "count";
var Nulls = "nulls";
var Max = "max";
var Min = "min";
var Distinct = "distinct";
var statMap = {
  [Count]: count,
  [Distinct]: (column3) => count(column3).distinct(),
  [Max]: max,
  [Min]: min,
  [Nulls]: (column3) => count().where(isNull(column3))
};
function summarize(table3, column3, stats) {
  return Query.from(table3).select(Array.from(stats, (s2) => [s2, statMap[s2](column3)]));
}
async function queryFieldInfo(mc, fields) {
  if (fields.length === 1 && `${fields[0].column}` === "*") {
    return getTableInfo(mc, fields[0].table);
  } else {
    return (await Promise.all(fields.map((f2) => getFieldInfo(mc, f2)))).filter((x4) => x4);
  }
}
async function getFieldInfo(mc, { table: table3, column: column3, stats }) {
  const q2 = Query.from({ source: table3 }).select({ column: column3 }).groupby(column3.aggregate ? sql`ALL` : []);
  const [desc2] = Array.from(await mc.query(Query.describe(q2)));
  const info = {
    table: table3,
    column: `${column3}`,
    sqlType: desc2.column_type,
    type: jsType(desc2.column_type),
    nullable: desc2.null === "YES"
  };
  if (!(stats?.length || stats?.size))
    return info;
  const result = await mc.query(
    summarize(table3, column3, stats),
    { persist: true }
  );
  for (let i = 0; i < result.numCols; ++i) {
    const { name: name2 } = result.schema.fields[i];
    const child = result.getChildAt(i);
    const convert = convertArrowValue(child.type);
    info[name2] = convert(child.get(0));
  }
  return info;
}
async function getTableInfo(mc, table3) {
  const result = await mc.query(`DESCRIBE ${asRelation(table3)}`);
  return Array.from(result).map((desc2) => ({
    table: table3,
    column: desc2.column_name,
    sqlType: desc2.column_type,
    type: jsType(desc2.column_type),
    nullable: desc2.null === "YES"
  }));
}

// ../core/src/util/void-logger.js
function voidLogger() {
  return {
    debug() {
    },
    info() {
    },
    log() {
    },
    warn() {
    },
    error() {
    }
  };
}

// ../core/src/Coordinator.js
var _instance;
function coordinator(instance16) {
  if (instance16) {
    _instance = instance16;
  } else if (_instance == null) {
    _instance = new Coordinator();
  }
  return _instance;
}
var Coordinator = class {
  constructor(db = socketConnector(), options = {}) {
    const {
      logger = console,
      manager = QueryManager()
    } = options;
    this.manager = manager;
    this.logger(logger);
    this.configure(options);
    this.databaseConnector(db);
    this.clear();
  }
  logger(logger) {
    if (arguments.length) {
      this._logger = logger || voidLogger();
      this.manager.logger(this._logger);
    }
    return this._logger;
  }
  /**
   * Set configuration options for this coordinator.
   * @param {object} [options] Configration options.
   * @param {boolean} [options.cache=true] Boolean flag to enable/disable query caching.
   * @param {boolean} [options.consolidate=true] Boolean flag to enable/disable query consolidation.
   * @param {boolean|object} [options.indexes=true] Boolean flag to enable/disable
   *  automatic data cube indexes or an index options object.
   */
  configure({ cache = true, consolidate: consolidate2 = true, indexes: indexes2 = true } = {}) {
    this.manager.cache(cache);
    this.manager.consolidate(consolidate2);
    this.indexes = indexes2;
  }
  clear({ clients = true, cache = true } = {}) {
    this.manager.clear();
    if (clients) {
      this.clients?.forEach((client) => this.disconnect(client));
      this.filterGroups?.forEach((group3) => group3.finalize());
      this.clients = /* @__PURE__ */ new Set();
      this.filterGroups = /* @__PURE__ */ new Map();
    }
    if (cache)
      this.manager.cache().clear();
  }
  databaseConnector(db) {
    return this.manager.connector(db);
  }
  // -- Query Management ----
  cancel(requests) {
    this.manager.cancel(requests);
  }
  exec(query, { priority = Priority.Normal } = {}) {
    query = Array.isArray(query) ? query.join(";\n") : query;
    return this.manager.request({ type: "exec", query }, priority);
  }
  query(query, {
    type: type2 = "arrow",
    cache = true,
    priority = Priority.Normal,
    ...options
  } = {}) {
    return this.manager.request({ type: type2, query, cache, options }, priority);
  }
  prefetch(query, options = {}) {
    return this.query(query, { ...options, cache: true, priority: Priority.Low });
  }
  createBundle(name2, queries, priority = Priority.Low) {
    const options = { name: name2, queries };
    return this.manager.request({ type: "create-bundle", options }, priority);
  }
  loadBundle(name2, priority = Priority.High) {
    const options = { name: name2 };
    return this.manager.request({ type: "load-bundle", options }, priority);
  }
  // -- Client Management ----
  updateClient(client, query, priority = Priority.Normal) {
    client.queryPending();
    return this.query(query, { priority }).then(
      (data) => client.queryResult(data).update(),
      (err) => {
        client.queryError(err);
        this._logger.error(err);
      }
    );
  }
  requestQuery(client, query) {
    this.filterGroups.get(client.filterBy)?.reset();
    return query ? this.updateClient(client, query) : client.update();
  }
  /**
   * Connect a client to the coordinator.
   * @param {import('./MosaicClient.js').MosaicClient} client the client to disconnect
   */
  async connect(client) {
    const { clients, filterGroups, indexes: indexes2 } = this;
    if (clients.has(client)) {
      throw new Error("Client already connected.");
    }
    clients.add(client);
    client.coordinator = this;
    const fields = client.fields();
    if (fields?.length) {
      client.fieldInfo(await queryFieldInfo(this, fields));
    }
    const filter3 = client.filterBy;
    if (filter3) {
      if (filterGroups.has(filter3)) {
        filterGroups.get(filter3).add(client);
      } else {
        const group3 = new FilterGroup(this, filter3, indexes2);
        filterGroups.set(filter3, group3.add(client));
      }
    }
    client.requestQuery();
  }
  /**
   * Disconnect a client from the coordinator.
   *
   * @param {import('./MosaicClient.js').MosaicClient} client the client to disconnect
   */
  disconnect(client) {
    const { clients, filterGroups } = this;
    if (!clients.has(client))
      return;
    clients.delete(client);
    filterGroups.get(client.filterBy)?.remove(client);
    client.coordinator = null;
  }
};

// ../core/src/util/AsyncDispatch.js
var AsyncDispatch = class {
  /**
   * Create a new asynchronous dispatcher instance.
   */
  constructor() {
    this._callbacks = /* @__PURE__ */ new Map();
  }
  /**
   * Add an event listener callback for the provided event type.
   * @param {string} type The event type.
   * @param {(value: *) => void | Promise} callback The event handler
   *  callback function to add. If the callback has already been
   *  added for the event type, this method has no effect.
   */
  addEventListener(type2, callback) {
    if (!this._callbacks.has(type2)) {
      this._callbacks.set(type2, {
        callbacks: /* @__PURE__ */ new Set(),
        pending: null,
        queue: new DispatchQueue()
      });
    }
    const entry = this._callbacks.get(type2);
    entry.callbacks.add(callback);
  }
  /**
   * Remove an event listener callback for the provided event type.
   * @param {string} type The event type.
   * @param {(value: *) => void | Promise} callback The event handler
   *  callback function to remove.
   */
  removeEventListener(type2, callback) {
    const entry = this._callbacks.get(type2);
    if (entry) {
      entry.callbacks.delete(callback);
    }
  }
  /**
   * Lifecycle method that returns the event value to emit.
   * This default implementation simply returns the input value as-is.
   * Subclasses may override this method to implement custom transformations
   * prior to emitting an event value to all listeners.
   * @param {string} type The event type.
   * @param {*} value The event value.
   * @returns The (possibly transformed) event value to emit.
   */
  willEmit(type2, value) {
    return value;
  }
  /**
   * Lifecycle method that returns a filter function for updating the
   * queue of unemitted event values prior to enqueueing a new value.
   * This default implementation simply returns null, indicating that
   * any other unemitted event values should be dropped (that is, all
   * queued events are filtered)
   * @param {string} type The event type.
   * @param {*} value The new event value that will be enqueued.
   * @returns {(value: *) => boolean|null} A dispatch queue filter
   *  function, or null if all unemitted event values should be filtered.
   */
  emitQueueFilter(type2, value) {
    return null;
  }
  /**
   * Cancel all unemitted event values for the given event type.
   * @param {string} type The event type.
   */
  cancel(type2) {
    const entry = this._callbacks.get(type2);
    entry?.queue.clear();
  }
  /**
   * Emit an event value to listeners for the given event type.
   * If a previous emit has not yet resolved, the event value
   * will be queued to be emitted later.
   * The actual event value given to listeners will be the result
   * of passing the input value through the emitValue() method.
   * @param {string} type The event type.
   * @param {*} value The event value.
   */
  emit(type2, value) {
    const entry = this._callbacks.get(type2) || {};
    if (entry.pending) {
      entry.queue.enqueue(value, this.emitQueueFilter(type2, value));
    } else {
      const event = this.willEmit(type2, value);
      const { callbacks, queue } = entry;
      if (callbacks?.size) {
        const promise = Promise.allSettled(Array.from(callbacks, (callback) => callback(event))).then(() => {
          entry.pending = null;
          if (!queue.isEmpty()) {
            this.emit(type2, queue.dequeue());
          }
        });
        entry.pending = promise;
      }
    }
  }
};
var DispatchQueue = class {
  /**
   * Create a new dispatch queue instance.
   */
  constructor() {
    this.clear();
  }
  /**
   * Clear the queue state of all event values.
   */
  clear() {
    this.next = null;
  }
  /**
   * Indicate if the queue is empty.
   * @returns {boolean} True if queue is empty, false otherwise.
   */
  isEmpty() {
    return !this.next;
  }
  /**
   * Add a new value to the queue, and optionally filter the
   * current queue content in response.
   * @param {*} value The value to add.
   * @param {(value: *) => boolean} [filter] An optional filter
   *  function to apply to existing queue content. If unspecified
   *  or falsy, all previously queued values are removed. Otherwise,
   *  the provided function is applied to all queue entries. The
   *  entry is retained if the filter function returns a truthy value,
   *  otherwise the entry is removed.
   */
  enqueue(value, filter3) {
    const tail = { value };
    if (filter3 && this.next) {
      let curr = this;
      while (curr.next) {
        if (filter3(curr.next.value)) {
          curr = curr.next;
        } else {
          curr.next = curr.next.next;
        }
      }
      curr.next = tail;
    } else {
      this.next = tail;
    }
  }
  /**
   * Remove and return the next queued event value.
   * @returns {*} The next event value in the queue.
   */
  dequeue() {
    const { next } = this;
    this.next = next?.next;
    return next?.value;
  }
};

// ../core/src/util/distinct.js
function distinct(a3, b2) {
  return a3 === b2 ? false : a3 instanceof Date && b2 instanceof Date ? +a3 !== +b2 : Array.isArray(a3) && Array.isArray(b2) ? distinctArray(a3, b2) : true;
}
function distinctArray(a3, b2) {
  if (a3.length !== b2.length)
    return true;
  for (let i = 0; i < a3.length; ++i) {
    if (a3[i] !== b2[i])
      return true;
  }
  return false;
}

// ../core/src/Param.js
function isParam(x4) {
  return x4 instanceof Param;
}
var Param = class _Param extends AsyncDispatch {
  /**
   * Create a new Param instance.
   * @param {*} value The initial value of the Param.
   */
  constructor(value) {
    super();
    this._value = value;
  }
  /**
   * Create a new Param instance with the given initial value.
   * @param {*} value The initial value of the Param.
   * @returns {Param} The new Param instance.
   */
  static value(value) {
    return new _Param(value);
  }
  /**
   * Create a new Param instance over an array of initial values,
   * which may contain nested Params.
   * @param {*} values The initial values of the Param.
   * @returns {Param} The new Param instance.
   */
  static array(values2) {
    if (values2.some((v3) => isParam(v3))) {
      const p2 = new _Param();
      const update2 = () => {
        p2.update(values2.map((v3) => isParam(v3) ? v3.value : v3));
      };
      update2();
      values2.forEach((v3) => isParam(v3) ? v3.addEventListener("value", update2) : 0);
      return p2;
    }
    return new _Param(values2);
  }
  /**
   * The current value of the Param.
   */
  get value() {
    return this._value;
  }
  /**
   * Update the Param value
   * @param {*} value The new value of the Param.
   * @param {object} [options] The update options.
   * @param {boolean} [options.force] A boolean flag indicating if the Param
   *  should emit a 'value' event even if the internal value is unchanged.
   * @returns {this} This Param instance.
   */
  update(value, { force } = {}) {
    const shouldEmit = distinct(this._value, value) || force;
    if (shouldEmit) {
      this.emit("value", value);
    } else {
      this.cancel("value");
    }
    return this;
  }
  /**
   * Upon value-typed updates, sets the current value to the input value
   * immediately prior to the event value being emitted to listeners.
   * @param {string} type The event type.
   * @param {*} value The input event value.
   * @returns {*} The input event value.
   */
  willEmit(type2, value) {
    if (type2 === "value") {
      this._value = value;
    }
    return value;
  }
};

// ../core/src/Selection.js
function isSelection(x4) {
  return x4 instanceof Selection;
}
var Selection = class _Selection extends Param {
  /**
   * Create a new Selection instance with an
   * intersect (conjunction) resolution strategy.
   * @param {object} [options] The selection options.
   * @param {boolean} [options.cross=false] Boolean flag indicating
   *  cross-filtered resolution. If true, selection clauses will not
   *  be applied to the clients they are associated with.
   * @returns {Selection} The new Selection instance.
   */
  static intersect({ cross: cross3 = false } = {}) {
    return new _Selection(new SelectionResolver({ cross: cross3 }));
  }
  /**
   * Create a new Selection instance with a
   * union (disjunction) resolution strategy.
   * @param {object} [options] The selection options.
   * @param {boolean} [options.cross=false] Boolean flag indicating
   *  cross-filtered resolution. If true, selection clauses will not
   *  be applied to the clients they are associated with.
   * @returns {Selection} The new Selection instance.
   */
  static union({ cross: cross3 = false } = {}) {
    return new _Selection(new SelectionResolver({ cross: cross3, union: true }));
  }
  /**
   * Create a new Selection instance with a singular resolution strategy
   * that keeps only the most recent selection clause.
   * @param {object} [options] The selection options.
   * @param {boolean} [options.cross=false] Boolean flag indicating
   *  cross-filtered resolution. If true, selection clauses will not
   *  be applied to the clients they are associated with.
   * @returns {Selection} The new Selection instance.
   */
  static single({ cross: cross3 = false } = {}) {
    return new _Selection(new SelectionResolver({ cross: cross3, single: true }));
  }
  /**
   * Create a new Selection instance with a
   * cross-filtered intersect resolution strategy.
   * @returns {Selection} The new Selection instance.
   */
  static crossfilter() {
    return new _Selection(new SelectionResolver({ cross: true }));
  }
  /**
   * Create a new Selection instance.
   * @param {SelectionResolver} resolver The selection resolution
   *  strategy to apply.
   */
  constructor(resolver = new SelectionResolver()) {
    super([]);
    this._resolved = this._value;
    this._resolver = resolver;
  }
  /**
   * Create a cloned copy of this Selection instance.
   * @returns {Selection} A clone of this selection.
   */
  clone() {
    const s2 = new _Selection(this._resolver);
    s2._value = s2._resolved = this._value;
    return s2;
  }
  /**
   * Create a clone of this Selection with clauses corresponding
   * to the provided source removed.
   * @param {*} source The clause source to remove.
   * @returns {Selection} A cloned and updated Selection.
   */
  remove(source) {
    const s2 = this.clone();
    s2._value = s2._resolved = s2._resolver.resolve(this._resolved, { source });
    s2._value.active = { source };
    return s2;
  }
  /**
   * The current active (most recently updated) selection clause.
   */
  get active() {
    return this.clauses.active;
  }
  /**
   * The value corresponding to the current active selection clause.
   * This method ensures compatibility where a normal Param is expected.
   */
  get value() {
    return this.active?.value;
  }
  /**
   * The current array of selection clauses.
   */
  get clauses() {
    return super.value;
  }
  /**
   * Indicate if this selection has a single resolution strategy.
   */
  get single() {
    return this._resolver.single;
  }
  /**
   * Emit an activate event with the given selection clause.
   * @param {*} clause The clause repesenting the potential activation.
   */
  activate(clause) {
    this.emit("activate", clause);
  }
  /**
   * Update the selection with a new selection clause.
   * @param {*} clause The selection clause to add.
   * @returns {this} This Selection instance.
   */
  update(clause) {
    this._resolved = this._resolver.resolve(this._resolved, clause, true);
    this._resolved.active = clause;
    return super.update(this._resolved);
  }
  /**
   * Upon value-typed updates, sets the current clause list to the
   * input value and returns the active clause value.
   * @param {string} type The event type.
   * @param {*} value The input event value.
   * @returns {*} For value-typed events, returns the active clause
   *  values. Otherwise returns the input event value as-is.
   */
  willEmit(type2, value) {
    if (type2 === "value") {
      this._value = value;
      return this.value;
    }
    return value;
  }
  /**
   * Upon value-typed updates, returns a dispatch queue filter function.
   * The return value depends on the selection resolution strategy.
   * @param {string} type The event type.
   * @param {*} value The new event value that will be enqueued.
   * @returns {(value: *) => boolean|null} For value-typed events,
   *  returns a dispatch queue filter function. Otherwise returns null.
   */
  emitQueueFilter(type2, value) {
    return type2 === "value" ? this._resolver.queueFilter(value) : null;
  }
  /**
   * Indicates if a selection clause should not be applied to a given client.
   * The return value depends on the selection resolution strategy.
   * @param {*} client The selection clause.
   * @param {*} clause The client to test.
   * @returns True if the client should be skipped, false otherwise.
   */
  skip(client, clause) {
    return this._resolver.skip(client, clause);
  }
  /**
   * Return a selection query predicate for the given client.
   * @param {*} client The client whose data may be filtered.
   * @param {boolean} [noSkip=false] Disable skipping of active
   *  cross-filtered sources. If set true, the source of the active
   *  clause in a cross-filtered selection will not be skipped.
   * @returns {*} The query predicate for filtering client data,
   *  based on the current state of this selection.
   */
  predicate(client, noSkip = false) {
    const { clauses } = this;
    const active = noSkip ? null : clauses.active;
    return this._resolver.predicate(clauses, active, client);
  }
};
var SelectionResolver = class {
  /**
   * Create a new selection resolved instance.
   * @param {object} [options] The resolution strategy options.
   * @param {boolean} [options.union=false] Boolean flag to indicate a union strategy.
   *  If false, an intersection strategy is used.
   * @param {boolean} [options.cross=false] Boolean flag to indicate cross-filtering.
   * @param {boolean} [options.single=false] Boolean flag to indicate single clauses only.
   */
  constructor({ union, cross: cross3, single } = {}) {
    this.union = !!union;
    this.cross = !!cross3;
    this.single = !!single;
  }
  /**
   * Resolve a list of selection clauses according to the resolution strategy.
   * @param {*[]} clauseList An array of selection clauses.
   * @param {*} clause A new selection clause to add.
   * @returns {*[]} An updated array of selection clauses.
   */
  resolve(clauseList, clause, reset = false) {
    const { source, predicate } = clause;
    const filtered = clauseList.filter((c4) => source !== c4.source);
    const clauses = this.single ? [] : filtered;
    if (this.single && reset)
      filtered.forEach((c4) => c4.source?.reset?.());
    if (predicate)
      clauses.push(clause);
    return clauses;
  }
  /**
   * Indicates if a selection clause should not be applied to a given client.
   * The return value depends on the resolution strategy.
   * @param {*} client The selection clause.
   * @param {*} clause The client to test.
   * @returns True if the client should be skipped, false otherwise.
   */
  skip(client, clause) {
    return this.cross && clause?.clients?.has(client);
  }
  /**
   * Return a selection query predicate for the given client.
   * @param {*[]} clauseList An array of selection clauses.
   * @param {*} active The current active selection clause.
   * @param {*} client The client whose data may be filtered.
   * @returns {*} The query predicate for filtering client data,
   *  based on the current state of this selection.
   */
  predicate(clauseList, active, client) {
    const { union } = this;
    if (this.skip(client, active))
      return void 0;
    const predicates = clauseList.filter((clause) => !this.skip(client, clause)).map((clause) => clause.predicate);
    return union && predicates.length > 1 ? or(predicates) : predicates;
  }
  /**
   * Returns a filter function for queued selection updates.
   * @param {*} value The new event value that will be enqueued.
   * @returns {(value: *) => boolean|null} A dispatch queue filter
   *  function, or null if all unemitted event values should be filtered.
   */
  queueFilter(value) {
    if (this.cross) {
      const source = value.active?.source;
      return (clauses) => clauses.active?.source !== source;
    }
    return null;
  }
};

// ../core/src/connectors/rest.js
function restConnector(uri = "http://localhost:3000/") {
  return {
    async query(query) {
      const req = fetch(uri, {
        method: "POST",
        mode: "cors",
        cache: "no-cache",
        credentials: "omit",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(query)
      });
      return query.type === "exec" ? req : query.type === "arrow" ? tableFromIPC(req) : (await req).json();
    }
  };
}

// ../../node_modules/apache-arrow/util/buffer.mjs
var buffer_exports2 = {};
__export(buffer_exports2, {
  compareArrayLike: () => compareArrayLike2,
  joinUint8Arrays: () => joinUint8Arrays2,
  memcpy: () => memcpy2,
  rebaseValueOffsets: () => rebaseValueOffsets2,
  toArrayBufferView: () => toArrayBufferView2,
  toArrayBufferViewAsyncIterator: () => toArrayBufferViewAsyncIterator2,
  toArrayBufferViewIterator: () => toArrayBufferViewIterator2,
  toBigInt64Array: () => toBigInt64Array2,
  toBigUint64Array: () => toBigUint64Array2,
  toFloat32Array: () => toFloat32Array2,
  toFloat32ArrayAsyncIterator: () => toFloat32ArrayAsyncIterator2,
  toFloat32ArrayIterator: () => toFloat32ArrayIterator2,
  toFloat64Array: () => toFloat64Array2,
  toFloat64ArrayAsyncIterator: () => toFloat64ArrayAsyncIterator2,
  toFloat64ArrayIterator: () => toFloat64ArrayIterator2,
  toInt16Array: () => toInt16Array2,
  toInt16ArrayAsyncIterator: () => toInt16ArrayAsyncIterator2,
  toInt16ArrayIterator: () => toInt16ArrayIterator2,
  toInt32Array: () => toInt32Array2,
  toInt32ArrayAsyncIterator: () => toInt32ArrayAsyncIterator2,
  toInt32ArrayIterator: () => toInt32ArrayIterator2,
  toInt8Array: () => toInt8Array2,
  toInt8ArrayAsyncIterator: () => toInt8ArrayAsyncIterator2,
  toInt8ArrayIterator: () => toInt8ArrayIterator2,
  toUint16Array: () => toUint16Array2,
  toUint16ArrayAsyncIterator: () => toUint16ArrayAsyncIterator2,
  toUint16ArrayIterator: () => toUint16ArrayIterator2,
  toUint32Array: () => toUint32Array2,
  toUint32ArrayAsyncIterator: () => toUint32ArrayAsyncIterator2,
  toUint32ArrayIterator: () => toUint32ArrayIterator2,
  toUint8Array: () => toUint8Array2,
  toUint8ArrayAsyncIterator: () => toUint8ArrayAsyncIterator2,
  toUint8ArrayIterator: () => toUint8ArrayIterator2,
  toUint8ClampedArray: () => toUint8ClampedArray2,
  toUint8ClampedArrayAsyncIterator: () => toUint8ClampedArrayAsyncIterator2,
  toUint8ClampedArrayIterator: () => toUint8ClampedArrayIterator2
});

// ../../node_modules/apache-arrow/util/utf8.mjs
var decoder2 = new TextDecoder("utf-8");
var decodeUtf82 = (buffer) => decoder2.decode(buffer);
var encoder2 = new TextEncoder();
var encodeUtf82 = (value) => encoder2.encode(value);

// ../../node_modules/apache-arrow/util/compat.mjs
var isNumber2 = (x4) => typeof x4 === "number";
var isBoolean2 = (x4) => typeof x4 === "boolean";
var isFunction2 = (x4) => typeof x4 === "function";
var isObject2 = (x4) => x4 != null && Object(x4) === x4;
var isPromise2 = (x4) => {
  return isObject2(x4) && isFunction2(x4.then);
};
var isIterable2 = (x4) => {
  return isObject2(x4) && isFunction2(x4[Symbol.iterator]);
};
var isAsyncIterable2 = (x4) => {
  return isObject2(x4) && isFunction2(x4[Symbol.asyncIterator]);
};
var isArrowJSON2 = (x4) => {
  return isObject2(x4) && isObject2(x4["schema"]);
};
var isIteratorResult2 = (x4) => {
  return isObject2(x4) && "done" in x4 && "value" in x4;
};
var isFileHandle2 = (x4) => {
  return isObject2(x4) && isFunction2(x4["stat"]) && isNumber2(x4["fd"]);
};
var isFetchResponse2 = (x4) => {
  return isObject2(x4) && isReadableDOMStream2(x4["body"]);
};
var isReadableInterop2 = (x4) => "_getDOMStream" in x4 && "_getNodeStream" in x4;
var isWritableDOMStream2 = (x4) => {
  return isObject2(x4) && isFunction2(x4["abort"]) && isFunction2(x4["getWriter"]) && !isReadableInterop2(x4);
};
var isReadableDOMStream2 = (x4) => {
  return isObject2(x4) && isFunction2(x4["cancel"]) && isFunction2(x4["getReader"]) && !isReadableInterop2(x4);
};
var isWritableNodeStream2 = (x4) => {
  return isObject2(x4) && isFunction2(x4["end"]) && isFunction2(x4["write"]) && isBoolean2(x4["writable"]) && !isReadableInterop2(x4);
};
var isReadableNodeStream2 = (x4) => {
  return isObject2(x4) && isFunction2(x4["read"]) && isFunction2(x4["pipe"]) && isBoolean2(x4["readable"]) && !isReadableInterop2(x4);
};
var isFlatbuffersByteBuffer2 = (x4) => {
  return isObject2(x4) && isFunction2(x4["clear"]) && isFunction2(x4["bytes"]) && isFunction2(x4["position"]) && isFunction2(x4["setPosition"]) && isFunction2(x4["capacity"]) && isFunction2(x4["getBufferIdentifier"]) && isFunction2(x4["createLong"]);
};

// ../../node_modules/apache-arrow/util/buffer.mjs
var SharedArrayBuf2 = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : ArrayBuffer;
function collapseContiguousByteRanges2(chunks) {
  const result = chunks[0] ? [chunks[0]] : [];
  let xOffset, yOffset, xLen, yLen;
  for (let x4, y4, i = 0, j2 = 0, n = chunks.length; ++i < n; ) {
    x4 = result[j2];
    y4 = chunks[i];
    if (!x4 || !y4 || x4.buffer !== y4.buffer || y4.byteOffset < x4.byteOffset) {
      y4 && (result[++j2] = y4);
      continue;
    }
    ({ byteOffset: xOffset, byteLength: xLen } = x4);
    ({ byteOffset: yOffset, byteLength: yLen } = y4);
    if (xOffset + xLen < yOffset || yOffset + yLen < xOffset) {
      y4 && (result[++j2] = y4);
      continue;
    }
    result[j2] = new Uint8Array(x4.buffer, xOffset, yOffset - xOffset + yLen);
  }
  return result;
}
function memcpy2(target, source, targetByteOffset = 0, sourceByteLength = source.byteLength) {
  const targetByteLength = target.byteLength;
  const dst = new Uint8Array(target.buffer, target.byteOffset, targetByteLength);
  const src = new Uint8Array(source.buffer, source.byteOffset, Math.min(sourceByteLength, targetByteLength));
  dst.set(src, targetByteOffset);
  return target;
}
function joinUint8Arrays2(chunks, size) {
  const result = collapseContiguousByteRanges2(chunks);
  const byteLength = result.reduce((x4, b2) => x4 + b2.byteLength, 0);
  let source, sliced, buffer;
  let offset2 = 0, index2 = -1;
  const length4 = Math.min(size || Number.POSITIVE_INFINITY, byteLength);
  for (const n = result.length; ++index2 < n; ) {
    source = result[index2];
    sliced = source.subarray(0, Math.min(source.length, length4 - offset2));
    if (length4 <= offset2 + sliced.length) {
      if (sliced.length < source.length) {
        result[index2] = source.subarray(sliced.length);
      } else if (sliced.length === source.length) {
        index2++;
      }
      buffer ? memcpy2(buffer, sliced, offset2) : buffer = sliced;
      break;
    }
    memcpy2(buffer || (buffer = new Uint8Array(length4)), sliced, offset2);
    offset2 += sliced.length;
  }
  return [buffer || new Uint8Array(0), result.slice(index2), byteLength - (buffer ? buffer.byteLength : 0)];
}
function toArrayBufferView2(ArrayBufferViewCtor, input3) {
  let value = isIteratorResult2(input3) ? input3.value : input3;
  if (value instanceof ArrayBufferViewCtor) {
    if (ArrayBufferViewCtor === Uint8Array) {
      return new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength);
    }
    return value;
  }
  if (!value) {
    return new ArrayBufferViewCtor(0);
  }
  if (typeof value === "string") {
    value = encodeUtf82(value);
  }
  if (value instanceof ArrayBuffer) {
    return new ArrayBufferViewCtor(value);
  }
  if (value instanceof SharedArrayBuf2) {
    return new ArrayBufferViewCtor(value);
  }
  if (isFlatbuffersByteBuffer2(value)) {
    return toArrayBufferView2(ArrayBufferViewCtor, value.bytes());
  }
  return !ArrayBuffer.isView(value) ? ArrayBufferViewCtor.from(value) : value.byteLength <= 0 ? new ArrayBufferViewCtor(0) : new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength / ArrayBufferViewCtor.BYTES_PER_ELEMENT);
}
var toInt8Array2 = (input3) => toArrayBufferView2(Int8Array, input3);
var toInt16Array2 = (input3) => toArrayBufferView2(Int16Array, input3);
var toInt32Array2 = (input3) => toArrayBufferView2(Int32Array, input3);
var toBigInt64Array2 = (input3) => toArrayBufferView2(BigInt64Array, input3);
var toUint8Array2 = (input3) => toArrayBufferView2(Uint8Array, input3);
var toUint16Array2 = (input3) => toArrayBufferView2(Uint16Array, input3);
var toUint32Array2 = (input3) => toArrayBufferView2(Uint32Array, input3);
var toBigUint64Array2 = (input3) => toArrayBufferView2(BigUint64Array, input3);
var toFloat32Array2 = (input3) => toArrayBufferView2(Float32Array, input3);
var toFloat64Array2 = (input3) => toArrayBufferView2(Float64Array, input3);
var toUint8ClampedArray2 = (input3) => toArrayBufferView2(Uint8ClampedArray, input3);
var pump3 = (iterator) => {
  iterator.next();
  return iterator;
};
function* toArrayBufferViewIterator2(ArrayCtor, source) {
  const wrap2 = function* (x4) {
    yield x4;
  };
  const buffers = typeof source === "string" ? wrap2(source) : ArrayBuffer.isView(source) ? wrap2(source) : source instanceof ArrayBuffer ? wrap2(source) : source instanceof SharedArrayBuf2 ? wrap2(source) : !isIterable2(source) ? wrap2(source) : source;
  yield* pump3(function* (it2) {
    let r = null;
    do {
      r = it2.next(yield toArrayBufferView2(ArrayCtor, r));
    } while (!r.done);
  }(buffers[Symbol.iterator]()));
  return new ArrayCtor();
}
var toInt8ArrayIterator2 = (input3) => toArrayBufferViewIterator2(Int8Array, input3);
var toInt16ArrayIterator2 = (input3) => toArrayBufferViewIterator2(Int16Array, input3);
var toInt32ArrayIterator2 = (input3) => toArrayBufferViewIterator2(Int32Array, input3);
var toUint8ArrayIterator2 = (input3) => toArrayBufferViewIterator2(Uint8Array, input3);
var toUint16ArrayIterator2 = (input3) => toArrayBufferViewIterator2(Uint16Array, input3);
var toUint32ArrayIterator2 = (input3) => toArrayBufferViewIterator2(Uint32Array, input3);
var toFloat32ArrayIterator2 = (input3) => toArrayBufferViewIterator2(Float32Array, input3);
var toFloat64ArrayIterator2 = (input3) => toArrayBufferViewIterator2(Float64Array, input3);
var toUint8ClampedArrayIterator2 = (input3) => toArrayBufferViewIterator2(Uint8ClampedArray, input3);
function toArrayBufferViewAsyncIterator2(ArrayCtor, source) {
  return __asyncGenerator(this, arguments, function* toArrayBufferViewAsyncIterator_1() {
    if (isPromise2(source)) {
      return yield __await(yield __await(yield* __asyncDelegator(__asyncValues(toArrayBufferViewAsyncIterator2(ArrayCtor, yield __await(source))))));
    }
    const wrap2 = function(x4) {
      return __asyncGenerator(this, arguments, function* () {
        yield yield __await(yield __await(x4));
      });
    };
    const emit = function(source2) {
      return __asyncGenerator(this, arguments, function* () {
        yield __await(yield* __asyncDelegator(__asyncValues(pump3(function* (it2) {
          let r = null;
          do {
            r = it2.next(yield r === null || r === void 0 ? void 0 : r.value);
          } while (!r.done);
        }(source2[Symbol.iterator]())))));
      });
    };
    const buffers = typeof source === "string" ? wrap2(source) : ArrayBuffer.isView(source) ? wrap2(source) : source instanceof ArrayBuffer ? wrap2(source) : source instanceof SharedArrayBuf2 ? wrap2(source) : isIterable2(source) ? emit(source) : !isAsyncIterable2(source) ? wrap2(source) : source;
    yield __await(
      // otherwise if AsyncIterable, use it
      yield* __asyncDelegator(__asyncValues(pump3(function(it2) {
        return __asyncGenerator(this, arguments, function* () {
          let r = null;
          do {
            r = yield __await(it2.next(yield yield __await(toArrayBufferView2(ArrayCtor, r))));
          } while (!r.done);
        });
      }(buffers[Symbol.asyncIterator]()))))
    );
    return yield __await(new ArrayCtor());
  });
}
var toInt8ArrayAsyncIterator2 = (input3) => toArrayBufferViewAsyncIterator2(Int8Array, input3);
var toInt16ArrayAsyncIterator2 = (input3) => toArrayBufferViewAsyncIterator2(Int16Array, input3);
var toInt32ArrayAsyncIterator2 = (input3) => toArrayBufferViewAsyncIterator2(Int32Array, input3);
var toUint8ArrayAsyncIterator2 = (input3) => toArrayBufferViewAsyncIterator2(Uint8Array, input3);
var toUint16ArrayAsyncIterator2 = (input3) => toArrayBufferViewAsyncIterator2(Uint16Array, input3);
var toUint32ArrayAsyncIterator2 = (input3) => toArrayBufferViewAsyncIterator2(Uint32Array, input3);
var toFloat32ArrayAsyncIterator2 = (input3) => toArrayBufferViewAsyncIterator2(Float32Array, input3);
var toFloat64ArrayAsyncIterator2 = (input3) => toArrayBufferViewAsyncIterator2(Float64Array, input3);
var toUint8ClampedArrayAsyncIterator2 = (input3) => toArrayBufferViewAsyncIterator2(Uint8ClampedArray, input3);
function rebaseValueOffsets2(offset2, length4, valueOffsets) {
  if (offset2 !== 0) {
    valueOffsets = valueOffsets.slice(0, length4);
    for (let i = -1, n = valueOffsets.length; ++i < n; ) {
      valueOffsets[i] += offset2;
    }
  }
  return valueOffsets.subarray(0, length4);
}
function compareArrayLike2(a3, b2) {
  let i = 0;
  const n = a3.length;
  if (n !== b2.length) {
    return false;
  }
  if (n > 0) {
    do {
      if (a3[i] !== b2[i]) {
        return false;
      }
    } while (++i < n);
  }
  return true;
}

// ../../node_modules/apache-arrow/io/adapters.mjs
var adapters_default2 = {
  fromIterable(source) {
    return pump4(fromIterable2(source));
  },
  fromAsyncIterable(source) {
    return pump4(fromAsyncIterable2(source));
  },
  fromDOMStream(source) {
    return pump4(fromDOMStream2(source));
  },
  fromNodeStream(stream) {
    return pump4(fromNodeStream2(stream));
  },
  // @ts-ignore
  toDOMStream(source, options) {
    throw new Error(`"toDOMStream" not available in this environment`);
  },
  // @ts-ignore
  toNodeStream(source, options) {
    throw new Error(`"toNodeStream" not available in this environment`);
  }
};
var pump4 = (iterator) => {
  iterator.next();
  return iterator;
};
function* fromIterable2(source) {
  let done, threw = false;
  let buffers = [], buffer;
  let cmd, size, bufferLength = 0;
  function byteRange() {
    if (cmd === "peek") {
      return joinUint8Arrays2(buffers, size)[0];
    }
    [buffer, buffers, bufferLength] = joinUint8Arrays2(buffers, size);
    return buffer;
  }
  ({ cmd, size } = yield null);
  const it2 = toUint8ArrayIterator2(source)[Symbol.iterator]();
  try {
    do {
      ({ done, value: buffer } = Number.isNaN(size - bufferLength) ? it2.next() : it2.next(size - bufferLength));
      if (!done && buffer.byteLength > 0) {
        buffers.push(buffer);
        bufferLength += buffer.byteLength;
      }
      if (done || size <= bufferLength) {
        do {
          ({ cmd, size } = yield byteRange());
        } while (size < bufferLength);
      }
    } while (!done);
  } catch (e) {
    (threw = true) && typeof it2.throw === "function" && it2.throw(e);
  } finally {
    threw === false && typeof it2.return === "function" && it2.return(null);
  }
  return null;
}
function fromAsyncIterable2(source) {
  return __asyncGenerator(this, arguments, function* fromAsyncIterable_1() {
    let done, threw = false;
    let buffers = [], buffer;
    let cmd, size, bufferLength = 0;
    function byteRange() {
      if (cmd === "peek") {
        return joinUint8Arrays2(buffers, size)[0];
      }
      [buffer, buffers, bufferLength] = joinUint8Arrays2(buffers, size);
      return buffer;
    }
    ({ cmd, size } = yield yield __await(null));
    const it2 = toUint8ArrayAsyncIterator2(source)[Symbol.asyncIterator]();
    try {
      do {
        ({ done, value: buffer } = Number.isNaN(size - bufferLength) ? yield __await(it2.next()) : yield __await(it2.next(size - bufferLength)));
        if (!done && buffer.byteLength > 0) {
          buffers.push(buffer);
          bufferLength += buffer.byteLength;
        }
        if (done || size <= bufferLength) {
          do {
            ({ cmd, size } = yield yield __await(byteRange()));
          } while (size < bufferLength);
        }
      } while (!done);
    } catch (e) {
      (threw = true) && typeof it2.throw === "function" && (yield __await(it2.throw(e)));
    } finally {
      threw === false && typeof it2.return === "function" && (yield __await(it2.return(new Uint8Array(0))));
    }
    return yield __await(null);
  });
}
function fromDOMStream2(source) {
  return __asyncGenerator(this, arguments, function* fromDOMStream_1() {
    let done = false, threw = false;
    let buffers = [], buffer;
    let cmd, size, bufferLength = 0;
    function byteRange() {
      if (cmd === "peek") {
        return joinUint8Arrays2(buffers, size)[0];
      }
      [buffer, buffers, bufferLength] = joinUint8Arrays2(buffers, size);
      return buffer;
    }
    ({ cmd, size } = yield yield __await(null));
    const it2 = new AdaptiveByteReader2(source);
    try {
      do {
        ({ done, value: buffer } = Number.isNaN(size - bufferLength) ? yield __await(it2["read"]()) : yield __await(it2["read"](size - bufferLength)));
        if (!done && buffer.byteLength > 0) {
          buffers.push(toUint8Array2(buffer));
          bufferLength += buffer.byteLength;
        }
        if (done || size <= bufferLength) {
          do {
            ({ cmd, size } = yield yield __await(byteRange()));
          } while (size < bufferLength);
        }
      } while (!done);
    } catch (e) {
      (threw = true) && (yield __await(it2["cancel"](e)));
    } finally {
      threw === false ? yield __await(it2["cancel"]()) : source["locked"] && it2.releaseLock();
    }
    return yield __await(null);
  });
}
var AdaptiveByteReader2 = class {
  constructor(source) {
    this.source = source;
    this.reader = null;
    this.reader = this.source["getReader"]();
    this.reader["closed"].catch(() => {
    });
  }
  get closed() {
    return this.reader ? this.reader["closed"].catch(() => {
    }) : Promise.resolve();
  }
  releaseLock() {
    if (this.reader) {
      this.reader.releaseLock();
    }
    this.reader = null;
  }
  cancel(reason) {
    return __awaiter(this, void 0, void 0, function* () {
      const { reader, source } = this;
      reader && (yield reader["cancel"](reason).catch(() => {
      }));
      source && (source["locked"] && this.releaseLock());
    });
  }
  read(size) {
    return __awaiter(this, void 0, void 0, function* () {
      if (size === 0) {
        return { done: this.reader == null, value: new Uint8Array(0) };
      }
      const result = yield this.reader.read();
      !result.done && (result.value = toUint8Array2(result));
      return result;
    });
  }
};
var onEvent2 = (stream, event) => {
  const handler = (_2) => resolve([event, _2]);
  let resolve;
  return [event, handler, new Promise((r) => (resolve = r) && stream["once"](event, handler))];
};
function fromNodeStream2(stream) {
  return __asyncGenerator(this, arguments, function* fromNodeStream_1() {
    const events = [];
    let event = "error";
    let done = false, err = null;
    let cmd, size, bufferLength = 0;
    let buffers = [], buffer;
    function byteRange() {
      if (cmd === "peek") {
        return joinUint8Arrays2(buffers, size)[0];
      }
      [buffer, buffers, bufferLength] = joinUint8Arrays2(buffers, size);
      return buffer;
    }
    ({ cmd, size } = yield yield __await(null));
    if (stream["isTTY"]) {
      yield yield __await(new Uint8Array(0));
      return yield __await(null);
    }
    try {
      events[0] = onEvent2(stream, "end");
      events[1] = onEvent2(stream, "error");
      do {
        events[2] = onEvent2(stream, "readable");
        [event, err] = yield __await(Promise.race(events.map((x4) => x4[2])));
        if (event === "error") {
          break;
        }
        if (!(done = event === "end")) {
          if (!Number.isFinite(size - bufferLength)) {
            buffer = toUint8Array2(stream["read"]());
          } else {
            buffer = toUint8Array2(stream["read"](size - bufferLength));
            if (buffer.byteLength < size - bufferLength) {
              buffer = toUint8Array2(stream["read"]());
            }
          }
          if (buffer.byteLength > 0) {
            buffers.push(buffer);
            bufferLength += buffer.byteLength;
          }
        }
        if (done || size <= bufferLength) {
          do {
            ({ cmd, size } = yield yield __await(byteRange()));
          } while (size < bufferLength);
        }
      } while (!done);
    } finally {
      yield __await(cleanup(events, event === "error" ? err : null));
    }
    return yield __await(null);
    function cleanup(events2, err2) {
      buffer = buffers = null;
      return new Promise((resolve, reject) => {
        for (const [evt, fn] of events2) {
          stream["off"](evt, fn);
        }
        try {
          const destroy = stream["destroy"];
          destroy && destroy.call(stream, err2);
          err2 = void 0;
        } catch (e) {
          err2 = e || err2;
        } finally {
          err2 != null ? reject(err2) : resolve();
        }
      });
    }
  });
}

// ../../node_modules/apache-arrow/enum.mjs
var MetadataVersion2;
(function(MetadataVersion4) {
  MetadataVersion4[MetadataVersion4["V1"] = 0] = "V1";
  MetadataVersion4[MetadataVersion4["V2"] = 1] = "V2";
  MetadataVersion4[MetadataVersion4["V3"] = 2] = "V3";
  MetadataVersion4[MetadataVersion4["V4"] = 3] = "V4";
  MetadataVersion4[MetadataVersion4["V5"] = 4] = "V5";
})(MetadataVersion2 || (MetadataVersion2 = {}));
var UnionMode2;
(function(UnionMode4) {
  UnionMode4[UnionMode4["Sparse"] = 0] = "Sparse";
  UnionMode4[UnionMode4["Dense"] = 1] = "Dense";
})(UnionMode2 || (UnionMode2 = {}));
var Precision2;
(function(Precision4) {
  Precision4[Precision4["HALF"] = 0] = "HALF";
  Precision4[Precision4["SINGLE"] = 1] = "SINGLE";
  Precision4[Precision4["DOUBLE"] = 2] = "DOUBLE";
})(Precision2 || (Precision2 = {}));
var DateUnit2;
(function(DateUnit4) {
  DateUnit4[DateUnit4["DAY"] = 0] = "DAY";
  DateUnit4[DateUnit4["MILLISECOND"] = 1] = "MILLISECOND";
})(DateUnit2 || (DateUnit2 = {}));
var TimeUnit2;
(function(TimeUnit4) {
  TimeUnit4[TimeUnit4["SECOND"] = 0] = "SECOND";
  TimeUnit4[TimeUnit4["MILLISECOND"] = 1] = "MILLISECOND";
  TimeUnit4[TimeUnit4["MICROSECOND"] = 2] = "MICROSECOND";
  TimeUnit4[TimeUnit4["NANOSECOND"] = 3] = "NANOSECOND";
})(TimeUnit2 || (TimeUnit2 = {}));
var IntervalUnit2;
(function(IntervalUnit4) {
  IntervalUnit4[IntervalUnit4["YEAR_MONTH"] = 0] = "YEAR_MONTH";
  IntervalUnit4[IntervalUnit4["DAY_TIME"] = 1] = "DAY_TIME";
  IntervalUnit4[IntervalUnit4["MONTH_DAY_NANO"] = 2] = "MONTH_DAY_NANO";
})(IntervalUnit2 || (IntervalUnit2 = {}));
var MessageHeader2;
(function(MessageHeader4) {
  MessageHeader4[MessageHeader4["NONE"] = 0] = "NONE";
  MessageHeader4[MessageHeader4["Schema"] = 1] = "Schema";
  MessageHeader4[MessageHeader4["DictionaryBatch"] = 2] = "DictionaryBatch";
  MessageHeader4[MessageHeader4["RecordBatch"] = 3] = "RecordBatch";
  MessageHeader4[MessageHeader4["Tensor"] = 4] = "Tensor";
  MessageHeader4[MessageHeader4["SparseTensor"] = 5] = "SparseTensor";
})(MessageHeader2 || (MessageHeader2 = {}));
var Type3;
(function(Type5) {
  Type5[Type5["NONE"] = 0] = "NONE";
  Type5[Type5["Null"] = 1] = "Null";
  Type5[Type5["Int"] = 2] = "Int";
  Type5[Type5["Float"] = 3] = "Float";
  Type5[Type5["Binary"] = 4] = "Binary";
  Type5[Type5["Utf8"] = 5] = "Utf8";
  Type5[Type5["Bool"] = 6] = "Bool";
  Type5[Type5["Decimal"] = 7] = "Decimal";
  Type5[Type5["Date"] = 8] = "Date";
  Type5[Type5["Time"] = 9] = "Time";
  Type5[Type5["Timestamp"] = 10] = "Timestamp";
  Type5[Type5["Interval"] = 11] = "Interval";
  Type5[Type5["List"] = 12] = "List";
  Type5[Type5["Struct"] = 13] = "Struct";
  Type5[Type5["Union"] = 14] = "Union";
  Type5[Type5["FixedSizeBinary"] = 15] = "FixedSizeBinary";
  Type5[Type5["FixedSizeList"] = 16] = "FixedSizeList";
  Type5[Type5["Map"] = 17] = "Map";
  Type5[Type5["Duration"] = 18] = "Duration";
  Type5[Type5["Dictionary"] = -1] = "Dictionary";
  Type5[Type5["Int8"] = -2] = "Int8";
  Type5[Type5["Int16"] = -3] = "Int16";
  Type5[Type5["Int32"] = -4] = "Int32";
  Type5[Type5["Int64"] = -5] = "Int64";
  Type5[Type5["Uint8"] = -6] = "Uint8";
  Type5[Type5["Uint16"] = -7] = "Uint16";
  Type5[Type5["Uint32"] = -8] = "Uint32";
  Type5[Type5["Uint64"] = -9] = "Uint64";
  Type5[Type5["Float16"] = -10] = "Float16";
  Type5[Type5["Float32"] = -11] = "Float32";
  Type5[Type5["Float64"] = -12] = "Float64";
  Type5[Type5["DateDay"] = -13] = "DateDay";
  Type5[Type5["DateMillisecond"] = -14] = "DateMillisecond";
  Type5[Type5["TimestampSecond"] = -15] = "TimestampSecond";
  Type5[Type5["TimestampMillisecond"] = -16] = "TimestampMillisecond";
  Type5[Type5["TimestampMicrosecond"] = -17] = "TimestampMicrosecond";
  Type5[Type5["TimestampNanosecond"] = -18] = "TimestampNanosecond";
  Type5[Type5["TimeSecond"] = -19] = "TimeSecond";
  Type5[Type5["TimeMillisecond"] = -20] = "TimeMillisecond";
  Type5[Type5["TimeMicrosecond"] = -21] = "TimeMicrosecond";
  Type5[Type5["TimeNanosecond"] = -22] = "TimeNanosecond";
  Type5[Type5["DenseUnion"] = -23] = "DenseUnion";
  Type5[Type5["SparseUnion"] = -24] = "SparseUnion";
  Type5[Type5["IntervalDayTime"] = -25] = "IntervalDayTime";
  Type5[Type5["IntervalYearMonth"] = -26] = "IntervalYearMonth";
  Type5[Type5["DurationSecond"] = -27] = "DurationSecond";
  Type5[Type5["DurationMillisecond"] = -28] = "DurationMillisecond";
  Type5[Type5["DurationMicrosecond"] = -29] = "DurationMicrosecond";
  Type5[Type5["DurationNanosecond"] = -30] = "DurationNanosecond";
})(Type3 || (Type3 = {}));
var BufferType2;
(function(BufferType3) {
  BufferType3[BufferType3["OFFSET"] = 0] = "OFFSET";
  BufferType3[BufferType3["DATA"] = 1] = "DATA";
  BufferType3[BufferType3["VALIDITY"] = 2] = "VALIDITY";
  BufferType3[BufferType3["TYPE"] = 3] = "TYPE";
})(BufferType2 || (BufferType2 = {}));

// ../../node_modules/apache-arrow/util/vector.mjs
var vector_exports2 = {};
__export(vector_exports2, {
  clampIndex: () => clampIndex2,
  clampRange: () => clampRange2,
  createElementComparator: () => createElementComparator2
});

// ../../node_modules/apache-arrow/util/pretty.mjs
var pretty_exports2 = {};
__export(pretty_exports2, {
  valueToString: () => valueToString2
});
var undf2 = void 0;
function valueToString2(x4) {
  if (x4 === null) {
    return "null";
  }
  if (x4 === undf2) {
    return "undefined";
  }
  switch (typeof x4) {
    case "number":
      return `${x4}`;
    case "bigint":
      return `${x4}`;
    case "string":
      return `"${x4}"`;
  }
  if (typeof x4[Symbol.toPrimitive] === "function") {
    return x4[Symbol.toPrimitive]("string");
  }
  if (ArrayBuffer.isView(x4)) {
    if (x4 instanceof BigInt64Array || x4 instanceof BigUint64Array) {
      return `[${[...x4].map((x5) => valueToString2(x5))}]`;
    }
    return `[${x4}]`;
  }
  return ArrayBuffer.isView(x4) ? `[${x4}]` : JSON.stringify(x4, (_2, y4) => typeof y4 === "bigint" ? `${y4}` : y4);
}

// ../../node_modules/apache-arrow/util/bn.mjs
var bn_exports2 = {};
__export(bn_exports2, {
  BN: () => BN2,
  bigNumToBigInt: () => bigNumToBigInt2,
  bigNumToString: () => bigNumToString2,
  isArrowBigNumSymbol: () => isArrowBigNumSymbol2
});
var isArrowBigNumSymbol2 = Symbol.for("isArrowBigNum");
function BigNum2(x4, ...xs) {
  if (xs.length === 0) {
    return Object.setPrototypeOf(toArrayBufferView2(this["TypedArray"], x4), this.constructor.prototype);
  }
  return Object.setPrototypeOf(new this["TypedArray"](x4, ...xs), this.constructor.prototype);
}
BigNum2.prototype[isArrowBigNumSymbol2] = true;
BigNum2.prototype.toJSON = function() {
  return `"${bigNumToString2(this)}"`;
};
BigNum2.prototype.valueOf = function() {
  return bigNumToNumber2(this);
};
BigNum2.prototype.toString = function() {
  return bigNumToString2(this);
};
BigNum2.prototype[Symbol.toPrimitive] = function(hint = "default") {
  switch (hint) {
    case "number":
      return bigNumToNumber2(this);
    case "string":
      return bigNumToString2(this);
    case "default":
      return bigNumToBigInt2(this);
  }
  return bigNumToString2(this);
};
function SignedBigNum2(...args) {
  return BigNum2.apply(this, args);
}
function UnsignedBigNum2(...args) {
  return BigNum2.apply(this, args);
}
function DecimalBigNum2(...args) {
  return BigNum2.apply(this, args);
}
Object.setPrototypeOf(SignedBigNum2.prototype, Object.create(Int32Array.prototype));
Object.setPrototypeOf(UnsignedBigNum2.prototype, Object.create(Uint32Array.prototype));
Object.setPrototypeOf(DecimalBigNum2.prototype, Object.create(Uint32Array.prototype));
Object.assign(SignedBigNum2.prototype, BigNum2.prototype, { "constructor": SignedBigNum2, "signed": true, "TypedArray": Int32Array, "BigIntArray": BigInt64Array });
Object.assign(UnsignedBigNum2.prototype, BigNum2.prototype, { "constructor": UnsignedBigNum2, "signed": false, "TypedArray": Uint32Array, "BigIntArray": BigUint64Array });
Object.assign(DecimalBigNum2.prototype, BigNum2.prototype, { "constructor": DecimalBigNum2, "signed": true, "TypedArray": Uint32Array, "BigIntArray": BigUint64Array });
function bigNumToNumber2(bn) {
  const { buffer, byteOffset, length: length4, "signed": signed } = bn;
  const words = new BigUint64Array(buffer, byteOffset, length4);
  const negative2 = signed && words.at(-1) & BigInt(1) << BigInt(63);
  let number7 = negative2 ? BigInt(1) : BigInt(0);
  let i = BigInt(0);
  if (!negative2) {
    for (const word of words) {
      number7 += word * (BigInt(1) << BigInt(32) * i++);
    }
  } else {
    for (const word of words) {
      number7 += ~word * (BigInt(1) << BigInt(32) * i++);
    }
    number7 *= BigInt(-1);
  }
  return number7;
}
var bigNumToString2 = (a3) => {
  if (a3.byteLength === 8) {
    const bigIntArray = new a3["BigIntArray"](a3.buffer, a3.byteOffset, 1);
    return `${bigIntArray[0]}`;
  }
  if (!a3["signed"]) {
    return unsignedBigNumToString2(a3);
  }
  let array4 = new Uint16Array(a3.buffer, a3.byteOffset, a3.byteLength / 2);
  const highOrderWord = new Int16Array([array4.at(-1)])[0];
  if (highOrderWord >= 0) {
    return unsignedBigNumToString2(a3);
  }
  array4 = array4.slice();
  let carry = 1;
  for (let i = 0; i < array4.length; i++) {
    const elem = array4[i];
    const updated = ~elem + carry;
    array4[i] = updated;
    carry &= elem === 0 ? 1 : 0;
  }
  const negated = unsignedBigNumToString2(array4);
  return `-${negated}`;
};
var bigNumToBigInt2 = (a3) => {
  if (a3.byteLength === 8) {
    const bigIntArray = new a3["BigIntArray"](a3.buffer, a3.byteOffset, 1);
    return bigIntArray[0];
  } else {
    return bigNumToString2(a3);
  }
};
function unsignedBigNumToString2(a3) {
  let digits = "";
  const base64 = new Uint32Array(2);
  let base32 = new Uint16Array(a3.buffer, a3.byteOffset, a3.byteLength / 2);
  const checks = new Uint32Array((base32 = new Uint16Array(base32).reverse()).buffer);
  let i = -1;
  const n = base32.length - 1;
  do {
    for (base64[0] = base32[i = 0]; i < n; ) {
      base32[i++] = base64[1] = base64[0] / 10;
      base64[0] = (base64[0] - base64[1] * 10 << 16) + base32[i];
    }
    base32[i] = base64[1] = base64[0] / 10;
    base64[0] = base64[0] - base64[1] * 10;
    digits = `${base64[0]}${digits}`;
  } while (checks[0] || checks[1] || checks[2] || checks[3]);
  return digits !== null && digits !== void 0 ? digits : `0`;
}
var BN2 = class _BN {
  /** @nocollapse */
  static new(num, isSigned) {
    switch (isSigned) {
      case true:
        return new SignedBigNum2(num);
      case false:
        return new UnsignedBigNum2(num);
    }
    switch (num.constructor) {
      case Int8Array:
      case Int16Array:
      case Int32Array:
      case BigInt64Array:
        return new SignedBigNum2(num);
    }
    if (num.byteLength === 16) {
      return new DecimalBigNum2(num);
    }
    return new UnsignedBigNum2(num);
  }
  /** @nocollapse */
  static signed(num) {
    return new SignedBigNum2(num);
  }
  /** @nocollapse */
  static unsigned(num) {
    return new UnsignedBigNum2(num);
  }
  /** @nocollapse */
  static decimal(num) {
    return new DecimalBigNum2(num);
  }
  constructor(num, isSigned) {
    return _BN.new(num, isSigned);
  }
};

// ../../node_modules/apache-arrow/util/bigint.mjs
function bigIntToNumber2(number7) {
  if (typeof number7 === "bigint" && (number7 < Number.MIN_SAFE_INTEGER || number7 > Number.MAX_SAFE_INTEGER)) {
    throw new TypeError(`${number7} is not safe to convert to a number.`);
  }
  return Number(number7);
}

// ../../node_modules/apache-arrow/type.mjs
var _a5;
var _b2;
var _c2;
var _d2;
var _e2;
var _f2;
var _g2;
var _h2;
var _j2;
var _k2;
var _l2;
var _m2;
var _o2;
var _p2;
var _q2;
var _r2;
var _s2;
var _t2;
var _u2;
var _v2;
var DataType2 = class _DataType {
  /** @nocollapse */
  static isNull(x4) {
    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type3.Null;
  }
  /** @nocollapse */
  static isInt(x4) {
    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type3.Int;
  }
  /** @nocollapse */
  static isFloat(x4) {
    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type3.Float;
  }
  /** @nocollapse */
  static isBinary(x4) {
    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type3.Binary;
  }
  /** @nocollapse */
  static isUtf8(x4) {
    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type3.Utf8;
  }
  /** @nocollapse */
  static isBool(x4) {
    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type3.Bool;
  }
  /** @nocollapse */
  static isDecimal(x4) {
    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type3.Decimal;
  }
  /** @nocollapse */
  static isDate(x4) {
    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type3.Date;
  }
  /** @nocollapse */
  static isTime(x4) {
    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type3.Time;
  }
  /** @nocollapse */
  static isTimestamp(x4) {
    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type3.Timestamp;
  }
  /** @nocollapse */
  static isInterval(x4) {
    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type3.Interval;
  }
  /** @nocollapse */
  static isDuration(x4) {
    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type3.Duration;
  }
  /** @nocollapse */
  static isList(x4) {
    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type3.List;
  }
  /** @nocollapse */
  static isStruct(x4) {
    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type3.Struct;
  }
  /** @nocollapse */
  static isUnion(x4) {
    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type3.Union;
  }
  /** @nocollapse */
  static isFixedSizeBinary(x4) {
    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type3.FixedSizeBinary;
  }
  /** @nocollapse */
  static isFixedSizeList(x4) {
    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type3.FixedSizeList;
  }
  /** @nocollapse */
  static isMap(x4) {
    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type3.Map;
  }
  /** @nocollapse */
  static isDictionary(x4) {
    return (x4 === null || x4 === void 0 ? void 0 : x4.typeId) === Type3.Dictionary;
  }
  /** @nocollapse */
  static isDenseUnion(x4) {
    return _DataType.isUnion(x4) && x4.mode === UnionMode2.Dense;
  }
  /** @nocollapse */
  static isSparseUnion(x4) {
    return _DataType.isUnion(x4) && x4.mode === UnionMode2.Sparse;
  }
  get typeId() {
    return Type3.NONE;
  }
};
_a5 = Symbol.toStringTag;
DataType2[_a5] = ((proto) => {
  proto.children = null;
  proto.ArrayType = Array;
  return proto[Symbol.toStringTag] = "DataType";
})(DataType2.prototype);
var Null3 = class extends DataType2 {
  toString() {
    return `Null`;
  }
  get typeId() {
    return Type3.Null;
  }
};
_b2 = Symbol.toStringTag;
Null3[_b2] = ((proto) => proto[Symbol.toStringTag] = "Null")(Null3.prototype);
var Int_2 = class extends DataType2 {
  constructor(isSigned, bitWidth) {
    super();
    this.isSigned = isSigned;
    this.bitWidth = bitWidth;
  }
  get typeId() {
    return Type3.Int;
  }
  get ArrayType() {
    switch (this.bitWidth) {
      case 8:
        return this.isSigned ? Int8Array : Uint8Array;
      case 16:
        return this.isSigned ? Int16Array : Uint16Array;
      case 32:
        return this.isSigned ? Int32Array : Uint32Array;
      case 64:
        return this.isSigned ? BigInt64Array : BigUint64Array;
    }
    throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
  }
  toString() {
    return `${this.isSigned ? `I` : `Ui`}nt${this.bitWidth}`;
  }
};
_c2 = Symbol.toStringTag;
Int_2[_c2] = ((proto) => {
  proto.isSigned = null;
  proto.bitWidth = null;
  return proto[Symbol.toStringTag] = "Int";
})(Int_2.prototype);
var Int82 = class extends Int_2 {
  constructor() {
    super(true, 8);
  }
  get ArrayType() {
    return Int8Array;
  }
};
var Int162 = class extends Int_2 {
  constructor() {
    super(true, 16);
  }
  get ArrayType() {
    return Int16Array;
  }
};
var Int322 = class extends Int_2 {
  constructor() {
    super(true, 32);
  }
  get ArrayType() {
    return Int32Array;
  }
};
var Int643 = class extends Int_2 {
  constructor() {
    super(true, 64);
  }
  get ArrayType() {
    return BigInt64Array;
  }
};
var Uint82 = class extends Int_2 {
  constructor() {
    super(false, 8);
  }
  get ArrayType() {
    return Uint8Array;
  }
};
var Uint162 = class extends Int_2 {
  constructor() {
    super(false, 16);
  }
  get ArrayType() {
    return Uint16Array;
  }
};
var Uint322 = class extends Int_2 {
  constructor() {
    super(false, 32);
  }
  get ArrayType() {
    return Uint32Array;
  }
};
var Uint643 = class extends Int_2 {
  constructor() {
    super(false, 64);
  }
  get ArrayType() {
    return BigUint64Array;
  }
};
Object.defineProperty(Int82.prototype, "ArrayType", { value: Int8Array });
Object.defineProperty(Int162.prototype, "ArrayType", { value: Int16Array });
Object.defineProperty(Int322.prototype, "ArrayType", { value: Int32Array });
Object.defineProperty(Int643.prototype, "ArrayType", { value: BigInt64Array });
Object.defineProperty(Uint82.prototype, "ArrayType", { value: Uint8Array });
Object.defineProperty(Uint162.prototype, "ArrayType", { value: Uint16Array });
Object.defineProperty(Uint322.prototype, "ArrayType", { value: Uint32Array });
Object.defineProperty(Uint643.prototype, "ArrayType", { value: BigUint64Array });
var Float2 = class extends DataType2 {
  constructor(precision) {
    super();
    this.precision = precision;
  }
  get typeId() {
    return Type3.Float;
  }
  get ArrayType() {
    switch (this.precision) {
      case Precision2.HALF:
        return Uint16Array;
      case Precision2.SINGLE:
        return Float32Array;
      case Precision2.DOUBLE:
        return Float64Array;
    }
    throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
  }
  toString() {
    return `Float${this.precision << 5 || 16}`;
  }
};
_d2 = Symbol.toStringTag;
Float2[_d2] = ((proto) => {
  proto.precision = null;
  return proto[Symbol.toStringTag] = "Float";
})(Float2.prototype);
var Float162 = class extends Float2 {
  constructor() {
    super(Precision2.HALF);
  }
};
var Float322 = class extends Float2 {
  constructor() {
    super(Precision2.SINGLE);
  }
};
var Float642 = class extends Float2 {
  constructor() {
    super(Precision2.DOUBLE);
  }
};
Object.defineProperty(Float162.prototype, "ArrayType", { value: Uint16Array });
Object.defineProperty(Float322.prototype, "ArrayType", { value: Float32Array });
Object.defineProperty(Float642.prototype, "ArrayType", { value: Float64Array });
var Binary3 = class extends DataType2 {
  constructor() {
    super();
  }
  get typeId() {
    return Type3.Binary;
  }
  toString() {
    return `Binary`;
  }
};
_e2 = Symbol.toStringTag;
Binary3[_e2] = ((proto) => {
  proto.ArrayType = Uint8Array;
  return proto[Symbol.toStringTag] = "Binary";
})(Binary3.prototype);
var Utf83 = class extends DataType2 {
  constructor() {
    super();
  }
  get typeId() {
    return Type3.Utf8;
  }
  toString() {
    return `Utf8`;
  }
};
_f2 = Symbol.toStringTag;
Utf83[_f2] = ((proto) => {
  proto.ArrayType = Uint8Array;
  return proto[Symbol.toStringTag] = "Utf8";
})(Utf83.prototype);
var Bool3 = class extends DataType2 {
  constructor() {
    super();
  }
  get typeId() {
    return Type3.Bool;
  }
  toString() {
    return `Bool`;
  }
};
_g2 = Symbol.toStringTag;
Bool3[_g2] = ((proto) => {
  proto.ArrayType = Uint8Array;
  return proto[Symbol.toStringTag] = "Bool";
})(Bool3.prototype);
var Decimal3 = class extends DataType2 {
  constructor(scale3, precision, bitWidth = 128) {
    super();
    this.scale = scale3;
    this.precision = precision;
    this.bitWidth = bitWidth;
  }
  get typeId() {
    return Type3.Decimal;
  }
  toString() {
    return `Decimal[${this.precision}e${this.scale > 0 ? `+` : ``}${this.scale}]`;
  }
};
_h2 = Symbol.toStringTag;
Decimal3[_h2] = ((proto) => {
  proto.scale = null;
  proto.precision = null;
  proto.ArrayType = Uint32Array;
  return proto[Symbol.toStringTag] = "Decimal";
})(Decimal3.prototype);
var Date_2 = class extends DataType2 {
  constructor(unit3) {
    super();
    this.unit = unit3;
  }
  get typeId() {
    return Type3.Date;
  }
  toString() {
    return `Date${(this.unit + 1) * 32}<${DateUnit2[this.unit]}>`;
  }
};
_j2 = Symbol.toStringTag;
Date_2[_j2] = ((proto) => {
  proto.unit = null;
  proto.ArrayType = Int32Array;
  return proto[Symbol.toStringTag] = "Date";
})(Date_2.prototype);
var Time_2 = class extends DataType2 {
  constructor(unit3, bitWidth) {
    super();
    this.unit = unit3;
    this.bitWidth = bitWidth;
  }
  get typeId() {
    return Type3.Time;
  }
  toString() {
    return `Time${this.bitWidth}<${TimeUnit2[this.unit]}>`;
  }
  get ArrayType() {
    switch (this.bitWidth) {
      case 32:
        return Int32Array;
      case 64:
        return BigInt64Array;
    }
    throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
  }
};
_k2 = Symbol.toStringTag;
Time_2[_k2] = ((proto) => {
  proto.unit = null;
  proto.bitWidth = null;
  return proto[Symbol.toStringTag] = "Time";
})(Time_2.prototype);
var Timestamp_2 = class extends DataType2 {
  constructor(unit3, timezone) {
    super();
    this.unit = unit3;
    this.timezone = timezone;
  }
  get typeId() {
    return Type3.Timestamp;
  }
  toString() {
    return `Timestamp<${TimeUnit2[this.unit]}${this.timezone ? `, ${this.timezone}` : ``}>`;
  }
};
_l2 = Symbol.toStringTag;
Timestamp_2[_l2] = ((proto) => {
  proto.unit = null;
  proto.timezone = null;
  proto.ArrayType = Int32Array;
  return proto[Symbol.toStringTag] = "Timestamp";
})(Timestamp_2.prototype);
var Interval_2 = class extends DataType2 {
  constructor(unit3) {
    super();
    this.unit = unit3;
  }
  get typeId() {
    return Type3.Interval;
  }
  toString() {
    return `Interval<${IntervalUnit2[this.unit]}>`;
  }
};
_m2 = Symbol.toStringTag;
Interval_2[_m2] = ((proto) => {
  proto.unit = null;
  proto.ArrayType = Int32Array;
  return proto[Symbol.toStringTag] = "Interval";
})(Interval_2.prototype);
var Duration3 = class extends DataType2 {
  constructor(unit3) {
    super();
    this.unit = unit3;
  }
  get typeId() {
    return Type3.Duration;
  }
  toString() {
    return `Duration<${TimeUnit2[this.unit]}>`;
  }
};
_o2 = Symbol.toStringTag;
Duration3[_o2] = ((proto) => {
  proto.unit = null;
  proto.ArrayType = BigInt64Array;
  return proto[Symbol.toStringTag] = "Duration";
})(Duration3.prototype);
var List3 = class extends DataType2 {
  constructor(child) {
    super();
    this.children = [child];
  }
  get typeId() {
    return Type3.List;
  }
  toString() {
    return `List<${this.valueType}>`;
  }
  get valueType() {
    return this.children[0].type;
  }
  get valueField() {
    return this.children[0];
  }
  get ArrayType() {
    return this.valueType.ArrayType;
  }
};
_p2 = Symbol.toStringTag;
List3[_p2] = ((proto) => {
  proto.children = null;
  return proto[Symbol.toStringTag] = "List";
})(List3.prototype);
var Struct2 = class extends DataType2 {
  constructor(children2) {
    super();
    this.children = children2;
  }
  get typeId() {
    return Type3.Struct;
  }
  toString() {
    return `Struct<{${this.children.map((f2) => `${f2.name}:${f2.type}`).join(`, `)}}>`;
  }
};
_q2 = Symbol.toStringTag;
Struct2[_q2] = ((proto) => {
  proto.children = null;
  return proto[Symbol.toStringTag] = "Struct";
})(Struct2.prototype);
var Union_2 = class extends DataType2 {
  constructor(mode3, typeIds, children2) {
    super();
    this.mode = mode3;
    this.children = children2;
    this.typeIds = typeIds = Int32Array.from(typeIds);
    this.typeIdToChildIndex = typeIds.reduce((typeIdToChildIndex, typeId, idx) => (typeIdToChildIndex[typeId] = idx) && typeIdToChildIndex || typeIdToChildIndex, /* @__PURE__ */ Object.create(null));
  }
  get typeId() {
    return Type3.Union;
  }
  toString() {
    return `${this[Symbol.toStringTag]}<${this.children.map((x4) => `${x4.type}`).join(` | `)}>`;
  }
};
_r2 = Symbol.toStringTag;
Union_2[_r2] = ((proto) => {
  proto.mode = null;
  proto.typeIds = null;
  proto.children = null;
  proto.typeIdToChildIndex = null;
  proto.ArrayType = Int8Array;
  return proto[Symbol.toStringTag] = "Union";
})(Union_2.prototype);
var FixedSizeBinary3 = class extends DataType2 {
  constructor(byteWidth) {
    super();
    this.byteWidth = byteWidth;
  }
  get typeId() {
    return Type3.FixedSizeBinary;
  }
  toString() {
    return `FixedSizeBinary[${this.byteWidth}]`;
  }
};
_s2 = Symbol.toStringTag;
FixedSizeBinary3[_s2] = ((proto) => {
  proto.byteWidth = null;
  proto.ArrayType = Uint8Array;
  return proto[Symbol.toStringTag] = "FixedSizeBinary";
})(FixedSizeBinary3.prototype);
var FixedSizeList3 = class extends DataType2 {
  constructor(listSize, child) {
    super();
    this.listSize = listSize;
    this.children = [child];
  }
  get typeId() {
    return Type3.FixedSizeList;
  }
  get valueType() {
    return this.children[0].type;
  }
  get valueField() {
    return this.children[0];
  }
  get ArrayType() {
    return this.valueType.ArrayType;
  }
  toString() {
    return `FixedSizeList[${this.listSize}]<${this.valueType}>`;
  }
};
_t2 = Symbol.toStringTag;
FixedSizeList3[_t2] = ((proto) => {
  proto.children = null;
  proto.listSize = null;
  return proto[Symbol.toStringTag] = "FixedSizeList";
})(FixedSizeList3.prototype);
var Map_2 = class extends DataType2 {
  constructor(entries, keysSorted = false) {
    var _w2, _x2, _y;
    super();
    this.children = [entries];
    this.keysSorted = keysSorted;
    if (entries) {
      entries["name"] = "entries";
      if ((_w2 = entries === null || entries === void 0 ? void 0 : entries.type) === null || _w2 === void 0 ? void 0 : _w2.children) {
        const key = (_x2 = entries === null || entries === void 0 ? void 0 : entries.type) === null || _x2 === void 0 ? void 0 : _x2.children[0];
        if (key) {
          key["name"] = "key";
        }
        const val = (_y = entries === null || entries === void 0 ? void 0 : entries.type) === null || _y === void 0 ? void 0 : _y.children[1];
        if (val) {
          val["name"] = "value";
        }
      }
    }
  }
  get typeId() {
    return Type3.Map;
  }
  get keyType() {
    return this.children[0].type.children[0].type;
  }
  get valueType() {
    return this.children[0].type.children[1].type;
  }
  get childType() {
    return this.children[0].type;
  }
  toString() {
    return `Map<{${this.children[0].type.children.map((f2) => `${f2.name}:${f2.type}`).join(`, `)}}>`;
  }
};
_u2 = Symbol.toStringTag;
Map_2[_u2] = ((proto) => {
  proto.children = null;
  proto.keysSorted = null;
  return proto[Symbol.toStringTag] = "Map_";
})(Map_2.prototype);
var getId2 = /* @__PURE__ */ ((atomicDictionaryId) => () => ++atomicDictionaryId)(-1);
var Dictionary2 = class extends DataType2 {
  constructor(dictionary, indices, id2, isOrdered2) {
    super();
    this.indices = indices;
    this.dictionary = dictionary;
    this.isOrdered = isOrdered2 || false;
    this.id = id2 == null ? getId2() : bigIntToNumber2(id2);
  }
  get typeId() {
    return Type3.Dictionary;
  }
  get children() {
    return this.dictionary.children;
  }
  get valueType() {
    return this.dictionary;
  }
  get ArrayType() {
    return this.dictionary.ArrayType;
  }
  toString() {
    return `Dictionary<${this.indices}, ${this.dictionary}>`;
  }
};
_v2 = Symbol.toStringTag;
Dictionary2[_v2] = ((proto) => {
  proto.id = null;
  proto.indices = null;
  proto.isOrdered = null;
  proto.dictionary = null;
  return proto[Symbol.toStringTag] = "Dictionary";
})(Dictionary2.prototype);
function strideForType2(type2) {
  const t = type2;
  switch (type2.typeId) {
    case Type3.Decimal:
      return type2.bitWidth / 32;
    case Type3.Timestamp:
      return 2;
    case Type3.Date:
      return 1 + t.unit;
    case Type3.Interval:
      return 1 + t.unit;
    case Type3.FixedSizeList:
      return t.listSize;
    case Type3.FixedSizeBinary:
      return t.byteWidth;
    default:
      return 1;
  }
}

// ../../node_modules/apache-arrow/visitor.mjs
var Visitor2 = class {
  visitMany(nodes, ...args) {
    return nodes.map((node, i) => this.visit(node, ...args.map((x4) => x4[i])));
  }
  visit(...args) {
    return this.getVisitFn(args[0], false).apply(this, args);
  }
  getVisitFn(node, throwIfNotFound = true) {
    return getVisitFn2(this, node, throwIfNotFound);
  }
  getVisitFnByTypeId(typeId, throwIfNotFound = true) {
    return getVisitFnByTypeId2(this, typeId, throwIfNotFound);
  }
  visitNull(_node, ..._args) {
    return null;
  }
  visitBool(_node, ..._args) {
    return null;
  }
  visitInt(_node, ..._args) {
    return null;
  }
  visitFloat(_node, ..._args) {
    return null;
  }
  visitUtf8(_node, ..._args) {
    return null;
  }
  visitBinary(_node, ..._args) {
    return null;
  }
  visitFixedSizeBinary(_node, ..._args) {
    return null;
  }
  visitDate(_node, ..._args) {
    return null;
  }
  visitTimestamp(_node, ..._args) {
    return null;
  }
  visitTime(_node, ..._args) {
    return null;
  }
  visitDecimal(_node, ..._args) {
    return null;
  }
  visitList(_node, ..._args) {
    return null;
  }
  visitStruct(_node, ..._args) {
    return null;
  }
  visitUnion(_node, ..._args) {
    return null;
  }
  visitDictionary(_node, ..._args) {
    return null;
  }
  visitInterval(_node, ..._args) {
    return null;
  }
  visitDuration(_node, ..._args) {
    return null;
  }
  visitFixedSizeList(_node, ..._args) {
    return null;
  }
  visitMap(_node, ..._args) {
    return null;
  }
};
function getVisitFn2(visitor, node, throwIfNotFound = true) {
  if (typeof node === "number") {
    return getVisitFnByTypeId2(visitor, node, throwIfNotFound);
  }
  if (typeof node === "string" && node in Type3) {
    return getVisitFnByTypeId2(visitor, Type3[node], throwIfNotFound);
  }
  if (node && node instanceof DataType2) {
    return getVisitFnByTypeId2(visitor, inferDType2(node), throwIfNotFound);
  }
  if ((node === null || node === void 0 ? void 0 : node.type) && node.type instanceof DataType2) {
    return getVisitFnByTypeId2(visitor, inferDType2(node.type), throwIfNotFound);
  }
  return getVisitFnByTypeId2(visitor, Type3.NONE, throwIfNotFound);
}
function getVisitFnByTypeId2(visitor, dtype, throwIfNotFound = true) {
  let fn = null;
  switch (dtype) {
    case Type3.Null:
      fn = visitor.visitNull;
      break;
    case Type3.Bool:
      fn = visitor.visitBool;
      break;
    case Type3.Int:
      fn = visitor.visitInt;
      break;
    case Type3.Int8:
      fn = visitor.visitInt8 || visitor.visitInt;
      break;
    case Type3.Int16:
      fn = visitor.visitInt16 || visitor.visitInt;
      break;
    case Type3.Int32:
      fn = visitor.visitInt32 || visitor.visitInt;
      break;
    case Type3.Int64:
      fn = visitor.visitInt64 || visitor.visitInt;
      break;
    case Type3.Uint8:
      fn = visitor.visitUint8 || visitor.visitInt;
      break;
    case Type3.Uint16:
      fn = visitor.visitUint16 || visitor.visitInt;
      break;
    case Type3.Uint32:
      fn = visitor.visitUint32 || visitor.visitInt;
      break;
    case Type3.Uint64:
      fn = visitor.visitUint64 || visitor.visitInt;
      break;
    case Type3.Float:
      fn = visitor.visitFloat;
      break;
    case Type3.Float16:
      fn = visitor.visitFloat16 || visitor.visitFloat;
      break;
    case Type3.Float32:
      fn = visitor.visitFloat32 || visitor.visitFloat;
      break;
    case Type3.Float64:
      fn = visitor.visitFloat64 || visitor.visitFloat;
      break;
    case Type3.Utf8:
      fn = visitor.visitUtf8;
      break;
    case Type3.Binary:
      fn = visitor.visitBinary;
      break;
    case Type3.FixedSizeBinary:
      fn = visitor.visitFixedSizeBinary;
      break;
    case Type3.Date:
      fn = visitor.visitDate;
      break;
    case Type3.DateDay:
      fn = visitor.visitDateDay || visitor.visitDate;
      break;
    case Type3.DateMillisecond:
      fn = visitor.visitDateMillisecond || visitor.visitDate;
      break;
    case Type3.Timestamp:
      fn = visitor.visitTimestamp;
      break;
    case Type3.TimestampSecond:
      fn = visitor.visitTimestampSecond || visitor.visitTimestamp;
      break;
    case Type3.TimestampMillisecond:
      fn = visitor.visitTimestampMillisecond || visitor.visitTimestamp;
      break;
    case Type3.TimestampMicrosecond:
      fn = visitor.visitTimestampMicrosecond || visitor.visitTimestamp;
      break;
    case Type3.TimestampNanosecond:
      fn = visitor.visitTimestampNanosecond || visitor.visitTimestamp;
      break;
    case Type3.Time:
      fn = visitor.visitTime;
      break;
    case Type3.TimeSecond:
      fn = visitor.visitTimeSecond || visitor.visitTime;
      break;
    case Type3.TimeMillisecond:
      fn = visitor.visitTimeMillisecond || visitor.visitTime;
      break;
    case Type3.TimeMicrosecond:
      fn = visitor.visitTimeMicrosecond || visitor.visitTime;
      break;
    case Type3.TimeNanosecond:
      fn = visitor.visitTimeNanosecond || visitor.visitTime;
      break;
    case Type3.Decimal:
      fn = visitor.visitDecimal;
      break;
    case Type3.List:
      fn = visitor.visitList;
      break;
    case Type3.Struct:
      fn = visitor.visitStruct;
      break;
    case Type3.Union:
      fn = visitor.visitUnion;
      break;
    case Type3.DenseUnion:
      fn = visitor.visitDenseUnion || visitor.visitUnion;
      break;
    case Type3.SparseUnion:
      fn = visitor.visitSparseUnion || visitor.visitUnion;
      break;
    case Type3.Dictionary:
      fn = visitor.visitDictionary;
      break;
    case Type3.Interval:
      fn = visitor.visitInterval;
      break;
    case Type3.IntervalDayTime:
      fn = visitor.visitIntervalDayTime || visitor.visitInterval;
      break;
    case Type3.IntervalYearMonth:
      fn = visitor.visitIntervalYearMonth || visitor.visitInterval;
      break;
    case Type3.Duration:
      fn = visitor.visitDuration;
      break;
    case Type3.DurationSecond:
      fn = visitor.visitDurationSecond || visitor.visitDuration;
      break;
    case Type3.DurationMillisecond:
      fn = visitor.visitDurationMillisecond || visitor.visitDuration;
      break;
    case Type3.DurationMicrosecond:
      fn = visitor.visitDurationMicrosecond || visitor.visitDuration;
      break;
    case Type3.DurationNanosecond:
      fn = visitor.visitDurationNanosecond || visitor.visitDuration;
      break;
    case Type3.FixedSizeList:
      fn = visitor.visitFixedSizeList;
      break;
    case Type3.Map:
      fn = visitor.visitMap;
      break;
  }
  if (typeof fn === "function")
    return fn;
  if (!throwIfNotFound)
    return () => null;
  throw new Error(`Unrecognized type '${Type3[dtype]}'`);
}
function inferDType2(type2) {
  switch (type2.typeId) {
    case Type3.Null:
      return Type3.Null;
    case Type3.Int: {
      const { bitWidth, isSigned } = type2;
      switch (bitWidth) {
        case 8:
          return isSigned ? Type3.Int8 : Type3.Uint8;
        case 16:
          return isSigned ? Type3.Int16 : Type3.Uint16;
        case 32:
          return isSigned ? Type3.Int32 : Type3.Uint32;
        case 64:
          return isSigned ? Type3.Int64 : Type3.Uint64;
      }
      return Type3.Int;
    }
    case Type3.Float:
      switch (type2.precision) {
        case Precision2.HALF:
          return Type3.Float16;
        case Precision2.SINGLE:
          return Type3.Float32;
        case Precision2.DOUBLE:
          return Type3.Float64;
      }
      return Type3.Float;
    case Type3.Binary:
      return Type3.Binary;
    case Type3.Utf8:
      return Type3.Utf8;
    case Type3.Bool:
      return Type3.Bool;
    case Type3.Decimal:
      return Type3.Decimal;
    case Type3.Time:
      switch (type2.unit) {
        case TimeUnit2.SECOND:
          return Type3.TimeSecond;
        case TimeUnit2.MILLISECOND:
          return Type3.TimeMillisecond;
        case TimeUnit2.MICROSECOND:
          return Type3.TimeMicrosecond;
        case TimeUnit2.NANOSECOND:
          return Type3.TimeNanosecond;
      }
      return Type3.Time;
    case Type3.Timestamp:
      switch (type2.unit) {
        case TimeUnit2.SECOND:
          return Type3.TimestampSecond;
        case TimeUnit2.MILLISECOND:
          return Type3.TimestampMillisecond;
        case TimeUnit2.MICROSECOND:
          return Type3.TimestampMicrosecond;
        case TimeUnit2.NANOSECOND:
          return Type3.TimestampNanosecond;
      }
      return Type3.Timestamp;
    case Type3.Date:
      switch (type2.unit) {
        case DateUnit2.DAY:
          return Type3.DateDay;
        case DateUnit2.MILLISECOND:
          return Type3.DateMillisecond;
      }
      return Type3.Date;
    case Type3.Interval:
      switch (type2.unit) {
        case IntervalUnit2.DAY_TIME:
          return Type3.IntervalDayTime;
        case IntervalUnit2.YEAR_MONTH:
          return Type3.IntervalYearMonth;
      }
      return Type3.Interval;
    case Type3.Duration:
      switch (type2.unit) {
        case TimeUnit2.SECOND:
          return Type3.DurationSecond;
        case TimeUnit2.MILLISECOND:
          return Type3.DurationMillisecond;
        case TimeUnit2.MICROSECOND:
          return Type3.DurationMicrosecond;
        case TimeUnit2.NANOSECOND:
          return Type3.DurationNanosecond;
      }
      return Type3.Duration;
    case Type3.Map:
      return Type3.Map;
    case Type3.List:
      return Type3.List;
    case Type3.Struct:
      return Type3.Struct;
    case Type3.Union:
      switch (type2.mode) {
        case UnionMode2.Dense:
          return Type3.DenseUnion;
        case UnionMode2.Sparse:
          return Type3.SparseUnion;
      }
      return Type3.Union;
    case Type3.FixedSizeBinary:
      return Type3.FixedSizeBinary;
    case Type3.FixedSizeList:
      return Type3.FixedSizeList;
    case Type3.Dictionary:
      return Type3.Dictionary;
  }
  throw new Error(`Unrecognized type '${Type3[type2.typeId]}'`);
}
Visitor2.prototype.visitInt8 = null;
Visitor2.prototype.visitInt16 = null;
Visitor2.prototype.visitInt32 = null;
Visitor2.prototype.visitInt64 = null;
Visitor2.prototype.visitUint8 = null;
Visitor2.prototype.visitUint16 = null;
Visitor2.prototype.visitUint32 = null;
Visitor2.prototype.visitUint64 = null;
Visitor2.prototype.visitFloat16 = null;
Visitor2.prototype.visitFloat32 = null;
Visitor2.prototype.visitFloat64 = null;
Visitor2.prototype.visitDateDay = null;
Visitor2.prototype.visitDateMillisecond = null;
Visitor2.prototype.visitTimestampSecond = null;
Visitor2.prototype.visitTimestampMillisecond = null;
Visitor2.prototype.visitTimestampMicrosecond = null;
Visitor2.prototype.visitTimestampNanosecond = null;
Visitor2.prototype.visitTimeSecond = null;
Visitor2.prototype.visitTimeMillisecond = null;
Visitor2.prototype.visitTimeMicrosecond = null;
Visitor2.prototype.visitTimeNanosecond = null;
Visitor2.prototype.visitDenseUnion = null;
Visitor2.prototype.visitSparseUnion = null;
Visitor2.prototype.visitIntervalDayTime = null;
Visitor2.prototype.visitIntervalYearMonth = null;
Visitor2.prototype.visitDuration = null;
Visitor2.prototype.visitDurationSecond = null;
Visitor2.prototype.visitDurationMillisecond = null;
Visitor2.prototype.visitDurationMicrosecond = null;
Visitor2.prototype.visitDurationNanosecond = null;

// ../../node_modules/apache-arrow/util/math.mjs
var math_exports2 = {};
__export(math_exports2, {
  float64ToUint16: () => float64ToUint162,
  uint16ToFloat64: () => uint16ToFloat642
});
var f642 = new Float64Array(1);
var u322 = new Uint32Array(f642.buffer);
function uint16ToFloat642(h2) {
  const expo = (h2 & 31744) >> 10;
  const sigf = (h2 & 1023) / 1024;
  const sign3 = Math.pow(-1, (h2 & 32768) >> 15);
  switch (expo) {
    case 31:
      return sign3 * (sigf ? Number.NaN : 1 / 0);
    case 0:
      return sign3 * (sigf ? 6103515625e-14 * sigf : 0);
  }
  return sign3 * Math.pow(2, expo - 15) * (1 + sigf);
}
function float64ToUint162(d) {
  if (d !== d) {
    return 32256;
  }
  f642[0] = d;
  const sign3 = (u322[1] & 2147483648) >> 16 & 65535;
  let expo = u322[1] & 2146435072, sigf = 0;
  if (expo >= 1089470464) {
    if (u322[0] > 0) {
      expo = 31744;
    } else {
      expo = (expo & 2080374784) >> 16;
      sigf = (u322[1] & 1048575) >> 10;
    }
  } else if (expo <= 1056964608) {
    sigf = 1048576 + (u322[1] & 1048575);
    sigf = 1048576 + (sigf << (expo >> 20) - 998) >> 21;
    expo = 0;
  } else {
    expo = expo - 1056964608 >> 10;
    sigf = (u322[1] & 1048575) + 512 >> 10;
  }
  return sign3 | expo | sigf & 65535;
}

// ../../node_modules/apache-arrow/visitor/set.mjs
var SetVisitor2 = class extends Visitor2 {
};
function wrapSet2(fn) {
  return (data, _1, _2) => {
    if (data.setValid(_1, _2 != null)) {
      return fn(data, _1, _2);
    }
  };
}
var setEpochMsToDays2 = (data, index2, epochMs) => {
  data[index2] = Math.trunc(epochMs / 864e5);
};
var setEpochMsToMillisecondsLong2 = (data, index2, epochMs) => {
  data[index2] = Math.trunc(epochMs % 4294967296);
  data[index2 + 1] = Math.trunc(epochMs / 4294967296);
};
var setEpochMsToMicrosecondsLong2 = (data, index2, epochMs) => {
  data[index2] = Math.trunc(epochMs * 1e3 % 4294967296);
  data[index2 + 1] = Math.trunc(epochMs * 1e3 / 4294967296);
};
var setEpochMsToNanosecondsLong2 = (data, index2, epochMs) => {
  data[index2] = Math.trunc(epochMs * 1e6 % 4294967296);
  data[index2 + 1] = Math.trunc(epochMs * 1e6 / 4294967296);
};
var setVariableWidthBytes2 = (values2, valueOffsets, index2, value) => {
  if (index2 + 1 < valueOffsets.length) {
    const { [index2]: x4, [index2 + 1]: y4 } = valueOffsets;
    values2.set(value.subarray(0, y4 - x4), x4);
  }
};
var setBool3 = ({ offset: offset2, values: values2 }, index2, val) => {
  const idx = offset2 + index2;
  val ? values2[idx >> 3] |= 1 << idx % 8 : values2[idx >> 3] &= ~(1 << idx % 8);
};
var setInt2 = ({ values: values2 }, index2, value) => {
  values2[index2] = value;
};
var setFloat2 = ({ values: values2 }, index2, value) => {
  values2[index2] = value;
};
var setFloat162 = ({ values: values2 }, index2, value) => {
  values2[index2] = float64ToUint162(value);
};
var setAnyFloat2 = (data, index2, value) => {
  switch (data.type.precision) {
    case Precision2.HALF:
      return setFloat162(data, index2, value);
    case Precision2.SINGLE:
    case Precision2.DOUBLE:
      return setFloat2(data, index2, value);
  }
};
var setDateDay2 = ({ values: values2 }, index2, value) => {
  setEpochMsToDays2(values2, index2, value.valueOf());
};
var setDateMillisecond2 = ({ values: values2 }, index2, value) => {
  setEpochMsToMillisecondsLong2(values2, index2 * 2, value.valueOf());
};
var setFixedSizeBinary2 = ({ stride, values: values2 }, index2, value) => {
  values2.set(value.subarray(0, stride), stride * index2);
};
var setBinary2 = ({ values: values2, valueOffsets }, index2, value) => setVariableWidthBytes2(values2, valueOffsets, index2, value);
var setUtf82 = ({ values: values2, valueOffsets }, index2, value) => {
  setVariableWidthBytes2(values2, valueOffsets, index2, encodeUtf82(value));
};
var setDate2 = (data, index2, value) => {
  data.type.unit === DateUnit2.DAY ? setDateDay2(data, index2, value) : setDateMillisecond2(data, index2, value);
};
var setTimestampSecond2 = ({ values: values2 }, index2, value) => setEpochMsToMillisecondsLong2(values2, index2 * 2, value / 1e3);
var setTimestampMillisecond2 = ({ values: values2 }, index2, value) => setEpochMsToMillisecondsLong2(values2, index2 * 2, value);
var setTimestampMicrosecond2 = ({ values: values2 }, index2, value) => setEpochMsToMicrosecondsLong2(values2, index2 * 2, value);
var setTimestampNanosecond2 = ({ values: values2 }, index2, value) => setEpochMsToNanosecondsLong2(values2, index2 * 2, value);
var setTimestamp2 = (data, index2, value) => {
  switch (data.type.unit) {
    case TimeUnit2.SECOND:
      return setTimestampSecond2(data, index2, value);
    case TimeUnit2.MILLISECOND:
      return setTimestampMillisecond2(data, index2, value);
    case TimeUnit2.MICROSECOND:
      return setTimestampMicrosecond2(data, index2, value);
    case TimeUnit2.NANOSECOND:
      return setTimestampNanosecond2(data, index2, value);
  }
};
var setTimeSecond2 = ({ values: values2 }, index2, value) => {
  values2[index2] = value;
};
var setTimeMillisecond2 = ({ values: values2 }, index2, value) => {
  values2[index2] = value;
};
var setTimeMicrosecond2 = ({ values: values2 }, index2, value) => {
  values2[index2] = value;
};
var setTimeNanosecond2 = ({ values: values2 }, index2, value) => {
  values2[index2] = value;
};
var setTime2 = (data, index2, value) => {
  switch (data.type.unit) {
    case TimeUnit2.SECOND:
      return setTimeSecond2(data, index2, value);
    case TimeUnit2.MILLISECOND:
      return setTimeMillisecond2(data, index2, value);
    case TimeUnit2.MICROSECOND:
      return setTimeMicrosecond2(data, index2, value);
    case TimeUnit2.NANOSECOND:
      return setTimeNanosecond2(data, index2, value);
  }
};
var setDecimal2 = ({ values: values2, stride }, index2, value) => {
  values2.set(value.subarray(0, stride), stride * index2);
};
var setList2 = (data, index2, value) => {
  const values2 = data.children[0];
  const valueOffsets = data.valueOffsets;
  const set3 = instance8.getVisitFn(values2);
  if (Array.isArray(value)) {
    for (let idx = -1, itr = valueOffsets[index2], end = valueOffsets[index2 + 1]; itr < end; ) {
      set3(values2, itr++, value[++idx]);
    }
  } else {
    for (let idx = -1, itr = valueOffsets[index2], end = valueOffsets[index2 + 1]; itr < end; ) {
      set3(values2, itr++, value.get(++idx));
    }
  }
};
var setMap2 = (data, index2, value) => {
  const values2 = data.children[0];
  const { valueOffsets } = data;
  const set3 = instance8.getVisitFn(values2);
  let { [index2]: idx, [index2 + 1]: end } = valueOffsets;
  const entries = value instanceof Map ? value.entries() : Object.entries(value);
  for (const val of entries) {
    set3(values2, idx, val);
    if (++idx >= end)
      break;
  }
};
var _setStructArrayValue2 = (o, v3) => (set3, c4, _2, i) => c4 && set3(c4, o, v3[i]);
var _setStructVectorValue2 = (o, v3) => (set3, c4, _2, i) => c4 && set3(c4, o, v3.get(i));
var _setStructMapValue2 = (o, v3) => (set3, c4, f2, _2) => c4 && set3(c4, o, v3.get(f2.name));
var _setStructObjectValue2 = (o, v3) => (set3, c4, f2, _2) => c4 && set3(c4, o, v3[f2.name]);
var setStruct2 = (data, index2, value) => {
  const childSetters = data.type.children.map((f2) => instance8.getVisitFn(f2.type));
  const set3 = value instanceof Map ? _setStructMapValue2(index2, value) : value instanceof Vector2 ? _setStructVectorValue2(index2, value) : Array.isArray(value) ? _setStructArrayValue2(index2, value) : _setStructObjectValue2(index2, value);
  data.type.children.forEach((f2, i) => set3(childSetters[i], data.children[i], f2, i));
};
var setUnion2 = (data, index2, value) => {
  data.type.mode === UnionMode2.Dense ? setDenseUnion2(data, index2, value) : setSparseUnion2(data, index2, value);
};
var setDenseUnion2 = (data, index2, value) => {
  const childIndex = data.type.typeIdToChildIndex[data.typeIds[index2]];
  const child = data.children[childIndex];
  instance8.visit(child, data.valueOffsets[index2], value);
};
var setSparseUnion2 = (data, index2, value) => {
  const childIndex = data.type.typeIdToChildIndex[data.typeIds[index2]];
  const child = data.children[childIndex];
  instance8.visit(child, index2, value);
};
var setDictionary2 = (data, index2, value) => {
  var _a9;
  (_a9 = data.dictionary) === null || _a9 === void 0 ? void 0 : _a9.set(data.values[index2], value);
};
var setIntervalValue2 = (data, index2, value) => {
  data.type.unit === IntervalUnit2.DAY_TIME ? setIntervalDayTime2(data, index2, value) : setIntervalYearMonth2(data, index2, value);
};
var setIntervalDayTime2 = ({ values: values2 }, index2, value) => {
  values2.set(value.subarray(0, 2), 2 * index2);
};
var setIntervalYearMonth2 = ({ values: values2 }, index2, value) => {
  values2[index2] = value[0] * 12 + value[1] % 12;
};
var setDurationSecond2 = ({ values: values2 }, index2, value) => {
  values2[index2] = value;
};
var setDurationMillisecond2 = ({ values: values2 }, index2, value) => {
  values2[index2] = value;
};
var setDurationMicrosecond2 = ({ values: values2 }, index2, value) => {
  values2[index2] = value;
};
var setDurationNanosecond2 = ({ values: values2 }, index2, value) => {
  values2[index2] = value;
};
var setDuration2 = (data, index2, value) => {
  switch (data.type.unit) {
    case TimeUnit2.SECOND:
      return setDurationSecond2(data, index2, value);
    case TimeUnit2.MILLISECOND:
      return setDurationMillisecond2(data, index2, value);
    case TimeUnit2.MICROSECOND:
      return setDurationMicrosecond2(data, index2, value);
    case TimeUnit2.NANOSECOND:
      return setDurationNanosecond2(data, index2, value);
  }
};
var setFixedSizeList2 = (data, index2, value) => {
  const { stride } = data;
  const child = data.children[0];
  const set3 = instance8.getVisitFn(child);
  if (Array.isArray(value)) {
    for (let idx = -1, offset2 = index2 * stride; ++idx < stride; ) {
      set3(child, offset2 + idx, value[idx]);
    }
  } else {
    for (let idx = -1, offset2 = index2 * stride; ++idx < stride; ) {
      set3(child, offset2 + idx, value.get(idx));
    }
  }
};
SetVisitor2.prototype.visitBool = wrapSet2(setBool3);
SetVisitor2.prototype.visitInt = wrapSet2(setInt2);
SetVisitor2.prototype.visitInt8 = wrapSet2(setInt2);
SetVisitor2.prototype.visitInt16 = wrapSet2(setInt2);
SetVisitor2.prototype.visitInt32 = wrapSet2(setInt2);
SetVisitor2.prototype.visitInt64 = wrapSet2(setInt2);
SetVisitor2.prototype.visitUint8 = wrapSet2(setInt2);
SetVisitor2.prototype.visitUint16 = wrapSet2(setInt2);
SetVisitor2.prototype.visitUint32 = wrapSet2(setInt2);
SetVisitor2.prototype.visitUint64 = wrapSet2(setInt2);
SetVisitor2.prototype.visitFloat = wrapSet2(setAnyFloat2);
SetVisitor2.prototype.visitFloat16 = wrapSet2(setFloat162);
SetVisitor2.prototype.visitFloat32 = wrapSet2(setFloat2);
SetVisitor2.prototype.visitFloat64 = wrapSet2(setFloat2);
SetVisitor2.prototype.visitUtf8 = wrapSet2(setUtf82);
SetVisitor2.prototype.visitBinary = wrapSet2(setBinary2);
SetVisitor2.prototype.visitFixedSizeBinary = wrapSet2(setFixedSizeBinary2);
SetVisitor2.prototype.visitDate = wrapSet2(setDate2);
SetVisitor2.prototype.visitDateDay = wrapSet2(setDateDay2);
SetVisitor2.prototype.visitDateMillisecond = wrapSet2(setDateMillisecond2);
SetVisitor2.prototype.visitTimestamp = wrapSet2(setTimestamp2);
SetVisitor2.prototype.visitTimestampSecond = wrapSet2(setTimestampSecond2);
SetVisitor2.prototype.visitTimestampMillisecond = wrapSet2(setTimestampMillisecond2);
SetVisitor2.prototype.visitTimestampMicrosecond = wrapSet2(setTimestampMicrosecond2);
SetVisitor2.prototype.visitTimestampNanosecond = wrapSet2(setTimestampNanosecond2);
SetVisitor2.prototype.visitTime = wrapSet2(setTime2);
SetVisitor2.prototype.visitTimeSecond = wrapSet2(setTimeSecond2);
SetVisitor2.prototype.visitTimeMillisecond = wrapSet2(setTimeMillisecond2);
SetVisitor2.prototype.visitTimeMicrosecond = wrapSet2(setTimeMicrosecond2);
SetVisitor2.prototype.visitTimeNanosecond = wrapSet2(setTimeNanosecond2);
SetVisitor2.prototype.visitDecimal = wrapSet2(setDecimal2);
SetVisitor2.prototype.visitList = wrapSet2(setList2);
SetVisitor2.prototype.visitStruct = wrapSet2(setStruct2);
SetVisitor2.prototype.visitUnion = wrapSet2(setUnion2);
SetVisitor2.prototype.visitDenseUnion = wrapSet2(setDenseUnion2);
SetVisitor2.prototype.visitSparseUnion = wrapSet2(setSparseUnion2);
SetVisitor2.prototype.visitDictionary = wrapSet2(setDictionary2);
SetVisitor2.prototype.visitInterval = wrapSet2(setIntervalValue2);
SetVisitor2.prototype.visitIntervalDayTime = wrapSet2(setIntervalDayTime2);
SetVisitor2.prototype.visitIntervalYearMonth = wrapSet2(setIntervalYearMonth2);
SetVisitor2.prototype.visitDuration = wrapSet2(setDuration2);
SetVisitor2.prototype.visitDurationSecond = wrapSet2(setDurationSecond2);
SetVisitor2.prototype.visitDurationMillisecond = wrapSet2(setDurationMillisecond2);
SetVisitor2.prototype.visitDurationMicrosecond = wrapSet2(setDurationMicrosecond2);
SetVisitor2.prototype.visitDurationNanosecond = wrapSet2(setDurationNanosecond2);
SetVisitor2.prototype.visitFixedSizeList = wrapSet2(setFixedSizeList2);
SetVisitor2.prototype.visitMap = wrapSet2(setMap2);
var instance8 = new SetVisitor2();

// ../../node_modules/apache-arrow/row/struct.mjs
var kParent2 = Symbol.for("parent");
var kRowIndex2 = Symbol.for("rowIndex");
var StructRow2 = class {
  constructor(parent, rowIndex) {
    this[kParent2] = parent;
    this[kRowIndex2] = rowIndex;
    return new Proxy(this, new StructRowProxyHandler2());
  }
  toArray() {
    return Object.values(this.toJSON());
  }
  toJSON() {
    const i = this[kRowIndex2];
    const parent = this[kParent2];
    const keys = parent.type.children;
    const json = {};
    for (let j2 = -1, n = keys.length; ++j2 < n; ) {
      json[keys[j2].name] = instance9.visit(parent.children[j2], i);
    }
    return json;
  }
  toString() {
    return `{${[...this].map(([key, val]) => `${valueToString2(key)}: ${valueToString2(val)}`).join(", ")}}`;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.toString();
  }
  [Symbol.iterator]() {
    return new StructRowIterator2(this[kParent2], this[kRowIndex2]);
  }
};
var StructRowIterator2 = class {
  constructor(data, rowIndex) {
    this.childIndex = 0;
    this.children = data.children;
    this.rowIndex = rowIndex;
    this.childFields = data.type.children;
    this.numChildren = this.childFields.length;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const i = this.childIndex;
    if (i < this.numChildren) {
      this.childIndex = i + 1;
      return {
        done: false,
        value: [
          this.childFields[i].name,
          instance9.visit(this.children[i], this.rowIndex)
        ]
      };
    }
    return { done: true, value: null };
  }
};
Object.defineProperties(StructRow2.prototype, {
  [Symbol.toStringTag]: { enumerable: false, configurable: false, value: "Row" },
  [kParent2]: { writable: true, enumerable: false, configurable: false, value: null },
  [kRowIndex2]: { writable: true, enumerable: false, configurable: false, value: -1 }
});
var StructRowProxyHandler2 = class {
  isExtensible() {
    return false;
  }
  deleteProperty() {
    return false;
  }
  preventExtensions() {
    return true;
  }
  ownKeys(row) {
    return row[kParent2].type.children.map((f2) => f2.name);
  }
  has(row, key) {
    return row[kParent2].type.children.findIndex((f2) => f2.name === key) !== -1;
  }
  getOwnPropertyDescriptor(row, key) {
    if (row[kParent2].type.children.findIndex((f2) => f2.name === key) !== -1) {
      return { writable: true, enumerable: true, configurable: true };
    }
    return;
  }
  get(row, key) {
    if (Reflect.has(row, key)) {
      return row[key];
    }
    const idx = row[kParent2].type.children.findIndex((f2) => f2.name === key);
    if (idx !== -1) {
      const val = instance9.visit(row[kParent2].children[idx], row[kRowIndex2]);
      Reflect.set(row, key, val);
      return val;
    }
  }
  set(row, key, val) {
    const idx = row[kParent2].type.children.findIndex((f2) => f2.name === key);
    if (idx !== -1) {
      instance8.visit(row[kParent2].children[idx], row[kRowIndex2], val);
      return Reflect.set(row, key, val);
    } else if (Reflect.has(row, key) || typeof key === "symbol") {
      return Reflect.set(row, key, val);
    }
    return false;
  }
};

// ../../node_modules/apache-arrow/visitor/get.mjs
var GetVisitor2 = class extends Visitor2 {
};
function wrapGet2(fn) {
  return (data, _1) => data.getValid(_1) ? fn(data, _1) : null;
}
var epochDaysToMs2 = (data, index2) => 864e5 * data[index2];
var epochMillisecondsLongToMs2 = (data, index2) => 4294967296 * data[index2 + 1] + (data[index2] >>> 0);
var epochMicrosecondsLongToMs2 = (data, index2) => 4294967296 * (data[index2 + 1] / 1e3) + (data[index2] >>> 0) / 1e3;
var epochNanosecondsLongToMs2 = (data, index2) => 4294967296 * (data[index2 + 1] / 1e6) + (data[index2] >>> 0) / 1e6;
var epochMillisecondsToDate2 = (epochMs) => new Date(epochMs);
var epochDaysToDate2 = (data, index2) => epochMillisecondsToDate2(epochDaysToMs2(data, index2));
var epochMillisecondsLongToDate2 = (data, index2) => epochMillisecondsToDate2(epochMillisecondsLongToMs2(data, index2));
var getNull2 = (_data, _index) => null;
var getVariableWidthBytes2 = (values2, valueOffsets, index2) => {
  if (index2 + 1 >= valueOffsets.length) {
    return null;
  }
  const x4 = valueOffsets[index2];
  const y4 = valueOffsets[index2 + 1];
  return values2.subarray(x4, y4);
};
var getBool3 = ({ offset: offset2, values: values2 }, index2) => {
  const idx = offset2 + index2;
  const byte = values2[idx >> 3];
  return (byte & 1 << idx % 8) !== 0;
};
var getDateDay2 = ({ values: values2 }, index2) => epochDaysToDate2(values2, index2);
var getDateMillisecond2 = ({ values: values2 }, index2) => epochMillisecondsLongToDate2(values2, index2 * 2);
var getNumeric2 = ({ stride, values: values2 }, index2) => values2[stride * index2];
var getFloat162 = ({ stride, values: values2 }, index2) => uint16ToFloat642(values2[stride * index2]);
var getBigInts2 = ({ values: values2 }, index2) => values2[index2];
var getFixedSizeBinary2 = ({ stride, values: values2 }, index2) => values2.subarray(stride * index2, stride * (index2 + 1));
var getBinary2 = ({ values: values2, valueOffsets }, index2) => getVariableWidthBytes2(values2, valueOffsets, index2);
var getUtf82 = ({ values: values2, valueOffsets }, index2) => {
  const bytes = getVariableWidthBytes2(values2, valueOffsets, index2);
  return bytes !== null ? decodeUtf82(bytes) : null;
};
var getInt2 = ({ values: values2 }, index2) => values2[index2];
var getFloat2 = ({ type: type2, values: values2 }, index2) => type2.precision !== Precision2.HALF ? values2[index2] : uint16ToFloat642(values2[index2]);
var getDate2 = (data, index2) => data.type.unit === DateUnit2.DAY ? getDateDay2(data, index2) : getDateMillisecond2(data, index2);
var getTimestampSecond2 = ({ values: values2 }, index2) => 1e3 * epochMillisecondsLongToMs2(values2, index2 * 2);
var getTimestampMillisecond2 = ({ values: values2 }, index2) => epochMillisecondsLongToMs2(values2, index2 * 2);
var getTimestampMicrosecond2 = ({ values: values2 }, index2) => epochMicrosecondsLongToMs2(values2, index2 * 2);
var getTimestampNanosecond2 = ({ values: values2 }, index2) => epochNanosecondsLongToMs2(values2, index2 * 2);
var getTimestamp2 = (data, index2) => {
  switch (data.type.unit) {
    case TimeUnit2.SECOND:
      return getTimestampSecond2(data, index2);
    case TimeUnit2.MILLISECOND:
      return getTimestampMillisecond2(data, index2);
    case TimeUnit2.MICROSECOND:
      return getTimestampMicrosecond2(data, index2);
    case TimeUnit2.NANOSECOND:
      return getTimestampNanosecond2(data, index2);
  }
};
var getTimeSecond2 = ({ values: values2 }, index2) => values2[index2];
var getTimeMillisecond2 = ({ values: values2 }, index2) => values2[index2];
var getTimeMicrosecond2 = ({ values: values2 }, index2) => values2[index2];
var getTimeNanosecond2 = ({ values: values2 }, index2) => values2[index2];
var getTime2 = (data, index2) => {
  switch (data.type.unit) {
    case TimeUnit2.SECOND:
      return getTimeSecond2(data, index2);
    case TimeUnit2.MILLISECOND:
      return getTimeMillisecond2(data, index2);
    case TimeUnit2.MICROSECOND:
      return getTimeMicrosecond2(data, index2);
    case TimeUnit2.NANOSECOND:
      return getTimeNanosecond2(data, index2);
  }
};
var getDecimal2 = ({ values: values2, stride }, index2) => BN2.decimal(values2.subarray(stride * index2, stride * (index2 + 1)));
var getList2 = (data, index2) => {
  const { valueOffsets, stride, children: children2 } = data;
  const { [index2 * stride]: begin, [index2 * stride + 1]: end } = valueOffsets;
  const child = children2[0];
  const slice4 = child.slice(begin, end - begin);
  return new Vector2([slice4]);
};
var getMap2 = (data, index2) => {
  const { valueOffsets, children: children2 } = data;
  const { [index2]: begin, [index2 + 1]: end } = valueOffsets;
  const child = children2[0];
  return new MapRow2(child.slice(begin, end - begin));
};
var getStruct2 = (data, index2) => {
  return new StructRow2(data, index2);
};
var getUnion2 = (data, index2) => {
  return data.type.mode === UnionMode2.Dense ? getDenseUnion2(data, index2) : getSparseUnion2(data, index2);
};
var getDenseUnion2 = (data, index2) => {
  const childIndex = data.type.typeIdToChildIndex[data.typeIds[index2]];
  const child = data.children[childIndex];
  return instance9.visit(child, data.valueOffsets[index2]);
};
var getSparseUnion2 = (data, index2) => {
  const childIndex = data.type.typeIdToChildIndex[data.typeIds[index2]];
  const child = data.children[childIndex];
  return instance9.visit(child, index2);
};
var getDictionary2 = (data, index2) => {
  var _a9;
  return (_a9 = data.dictionary) === null || _a9 === void 0 ? void 0 : _a9.get(data.values[index2]);
};
var getInterval2 = (data, index2) => data.type.unit === IntervalUnit2.DAY_TIME ? getIntervalDayTime2(data, index2) : getIntervalYearMonth2(data, index2);
var getIntervalDayTime2 = ({ values: values2 }, index2) => values2.subarray(2 * index2, 2 * (index2 + 1));
var getIntervalYearMonth2 = ({ values: values2 }, index2) => {
  const interval2 = values2[index2];
  const int32s = new Int32Array(2);
  int32s[0] = Math.trunc(interval2 / 12);
  int32s[1] = Math.trunc(interval2 % 12);
  return int32s;
};
var getDurationSecond2 = ({ values: values2 }, index2) => values2[index2];
var getDurationMillisecond2 = ({ values: values2 }, index2) => values2[index2];
var getDurationMicrosecond2 = ({ values: values2 }, index2) => values2[index2];
var getDurationNanosecond2 = ({ values: values2 }, index2) => values2[index2];
var getDuration2 = (data, index2) => {
  switch (data.type.unit) {
    case TimeUnit2.SECOND:
      return getDurationSecond2(data, index2);
    case TimeUnit2.MILLISECOND:
      return getDurationMillisecond2(data, index2);
    case TimeUnit2.MICROSECOND:
      return getDurationMicrosecond2(data, index2);
    case TimeUnit2.NANOSECOND:
      return getDurationNanosecond2(data, index2);
  }
};
var getFixedSizeList2 = (data, index2) => {
  const { stride, children: children2 } = data;
  const child = children2[0];
  const slice4 = child.slice(index2 * stride, stride);
  return new Vector2([slice4]);
};
GetVisitor2.prototype.visitNull = wrapGet2(getNull2);
GetVisitor2.prototype.visitBool = wrapGet2(getBool3);
GetVisitor2.prototype.visitInt = wrapGet2(getInt2);
GetVisitor2.prototype.visitInt8 = wrapGet2(getNumeric2);
GetVisitor2.prototype.visitInt16 = wrapGet2(getNumeric2);
GetVisitor2.prototype.visitInt32 = wrapGet2(getNumeric2);
GetVisitor2.prototype.visitInt64 = wrapGet2(getBigInts2);
GetVisitor2.prototype.visitUint8 = wrapGet2(getNumeric2);
GetVisitor2.prototype.visitUint16 = wrapGet2(getNumeric2);
GetVisitor2.prototype.visitUint32 = wrapGet2(getNumeric2);
GetVisitor2.prototype.visitUint64 = wrapGet2(getBigInts2);
GetVisitor2.prototype.visitFloat = wrapGet2(getFloat2);
GetVisitor2.prototype.visitFloat16 = wrapGet2(getFloat162);
GetVisitor2.prototype.visitFloat32 = wrapGet2(getNumeric2);
GetVisitor2.prototype.visitFloat64 = wrapGet2(getNumeric2);
GetVisitor2.prototype.visitUtf8 = wrapGet2(getUtf82);
GetVisitor2.prototype.visitBinary = wrapGet2(getBinary2);
GetVisitor2.prototype.visitFixedSizeBinary = wrapGet2(getFixedSizeBinary2);
GetVisitor2.prototype.visitDate = wrapGet2(getDate2);
GetVisitor2.prototype.visitDateDay = wrapGet2(getDateDay2);
GetVisitor2.prototype.visitDateMillisecond = wrapGet2(getDateMillisecond2);
GetVisitor2.prototype.visitTimestamp = wrapGet2(getTimestamp2);
GetVisitor2.prototype.visitTimestampSecond = wrapGet2(getTimestampSecond2);
GetVisitor2.prototype.visitTimestampMillisecond = wrapGet2(getTimestampMillisecond2);
GetVisitor2.prototype.visitTimestampMicrosecond = wrapGet2(getTimestampMicrosecond2);
GetVisitor2.prototype.visitTimestampNanosecond = wrapGet2(getTimestampNanosecond2);
GetVisitor2.prototype.visitTime = wrapGet2(getTime2);
GetVisitor2.prototype.visitTimeSecond = wrapGet2(getTimeSecond2);
GetVisitor2.prototype.visitTimeMillisecond = wrapGet2(getTimeMillisecond2);
GetVisitor2.prototype.visitTimeMicrosecond = wrapGet2(getTimeMicrosecond2);
GetVisitor2.prototype.visitTimeNanosecond = wrapGet2(getTimeNanosecond2);
GetVisitor2.prototype.visitDecimal = wrapGet2(getDecimal2);
GetVisitor2.prototype.visitList = wrapGet2(getList2);
GetVisitor2.prototype.visitStruct = wrapGet2(getStruct2);
GetVisitor2.prototype.visitUnion = wrapGet2(getUnion2);
GetVisitor2.prototype.visitDenseUnion = wrapGet2(getDenseUnion2);
GetVisitor2.prototype.visitSparseUnion = wrapGet2(getSparseUnion2);
GetVisitor2.prototype.visitDictionary = wrapGet2(getDictionary2);
GetVisitor2.prototype.visitInterval = wrapGet2(getInterval2);
GetVisitor2.prototype.visitIntervalDayTime = wrapGet2(getIntervalDayTime2);
GetVisitor2.prototype.visitIntervalYearMonth = wrapGet2(getIntervalYearMonth2);
GetVisitor2.prototype.visitDuration = wrapGet2(getDuration2);
GetVisitor2.prototype.visitDurationSecond = wrapGet2(getDurationSecond2);
GetVisitor2.prototype.visitDurationMillisecond = wrapGet2(getDurationMillisecond2);
GetVisitor2.prototype.visitDurationMicrosecond = wrapGet2(getDurationMicrosecond2);
GetVisitor2.prototype.visitDurationNanosecond = wrapGet2(getDurationNanosecond2);
GetVisitor2.prototype.visitFixedSizeList = wrapGet2(getFixedSizeList2);
GetVisitor2.prototype.visitMap = wrapGet2(getMap2);
var instance9 = new GetVisitor2();

// ../../node_modules/apache-arrow/row/map.mjs
var kKeys2 = Symbol.for("keys");
var kVals2 = Symbol.for("vals");
var MapRow2 = class {
  constructor(slice4) {
    this[kKeys2] = new Vector2([slice4.children[0]]).memoize();
    this[kVals2] = slice4.children[1];
    return new Proxy(this, new MapRowProxyHandler2());
  }
  [Symbol.iterator]() {
    return new MapRowIterator2(this[kKeys2], this[kVals2]);
  }
  get size() {
    return this[kKeys2].length;
  }
  toArray() {
    return Object.values(this.toJSON());
  }
  toJSON() {
    const keys = this[kKeys2];
    const vals = this[kVals2];
    const json = {};
    for (let i = -1, n = keys.length; ++i < n; ) {
      json[keys.get(i)] = instance9.visit(vals, i);
    }
    return json;
  }
  toString() {
    return `{${[...this].map(([key, val]) => `${valueToString2(key)}: ${valueToString2(val)}`).join(", ")}}`;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.toString();
  }
};
var MapRowIterator2 = class {
  constructor(keys, vals) {
    this.keys = keys;
    this.vals = vals;
    this.keyIndex = 0;
    this.numKeys = keys.length;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const i = this.keyIndex;
    if (i === this.numKeys) {
      return { done: true, value: null };
    }
    this.keyIndex++;
    return {
      done: false,
      value: [
        this.keys.get(i),
        instance9.visit(this.vals, i)
      ]
    };
  }
};
var MapRowProxyHandler2 = class {
  isExtensible() {
    return false;
  }
  deleteProperty() {
    return false;
  }
  preventExtensions() {
    return true;
  }
  ownKeys(row) {
    return row[kKeys2].toArray().map(String);
  }
  has(row, key) {
    return row[kKeys2].includes(key);
  }
  getOwnPropertyDescriptor(row, key) {
    const idx = row[kKeys2].indexOf(key);
    if (idx !== -1) {
      return { writable: true, enumerable: true, configurable: true };
    }
    return;
  }
  get(row, key) {
    if (Reflect.has(row, key)) {
      return row[key];
    }
    const idx = row[kKeys2].indexOf(key);
    if (idx !== -1) {
      const val = instance9.visit(Reflect.get(row, kVals2), idx);
      Reflect.set(row, key, val);
      return val;
    }
  }
  set(row, key, val) {
    const idx = row[kKeys2].indexOf(key);
    if (idx !== -1) {
      instance8.visit(Reflect.get(row, kVals2), idx, val);
      return Reflect.set(row, key, val);
    } else if (Reflect.has(row, key)) {
      return Reflect.set(row, key, val);
    }
    return false;
  }
};
Object.defineProperties(MapRow2.prototype, {
  [Symbol.toStringTag]: { enumerable: false, configurable: false, value: "Row" },
  [kKeys2]: { writable: true, enumerable: false, configurable: false, value: null },
  [kVals2]: { writable: true, enumerable: false, configurable: false, value: null }
});

// ../../node_modules/apache-arrow/util/vector.mjs
function clampIndex2(source, index2, then) {
  const length4 = source.length;
  const adjust = index2 > -1 ? index2 : length4 + index2 % length4;
  return then ? then(source, adjust) : adjust;
}
var tmp2;
function clampRange2(source, begin, end, then) {
  const { length: len = 0 } = source;
  let lhs = typeof begin !== "number" ? 0 : begin;
  let rhs = typeof end !== "number" ? len : end;
  lhs < 0 && (lhs = (lhs % len + len) % len);
  rhs < 0 && (rhs = (rhs % len + len) % len);
  rhs < lhs && (tmp2 = lhs, lhs = rhs, rhs = tmp2);
  rhs > len && (rhs = len);
  return then ? then(source, lhs, rhs) : [lhs, rhs];
}
var isNaNFast2 = (value) => value !== value;
function createElementComparator2(search3) {
  const typeofSearch = typeof search3;
  if (typeofSearch !== "object" || search3 === null) {
    if (isNaNFast2(search3)) {
      return isNaNFast2;
    }
    return (value) => value === search3;
  }
  if (search3 instanceof Date) {
    const valueOfSearch = search3.valueOf();
    return (value) => value instanceof Date ? value.valueOf() === valueOfSearch : false;
  }
  if (ArrayBuffer.isView(search3)) {
    return (value) => value ? compareArrayLike2(search3, value) : false;
  }
  if (search3 instanceof Map) {
    return createMapComparator2(search3);
  }
  if (Array.isArray(search3)) {
    return createArrayLikeComparator2(search3);
  }
  if (search3 instanceof Vector2) {
    return createVectorComparator2(search3);
  }
  return createObjectComparator2(search3, true);
}
function createArrayLikeComparator2(lhs) {
  const comparators = [];
  for (let i = -1, n = lhs.length; ++i < n; ) {
    comparators[i] = createElementComparator2(lhs[i]);
  }
  return createSubElementsComparator2(comparators);
}
function createMapComparator2(lhs) {
  let i = -1;
  const comparators = [];
  for (const v3 of lhs.values())
    comparators[++i] = createElementComparator2(v3);
  return createSubElementsComparator2(comparators);
}
function createVectorComparator2(lhs) {
  const comparators = [];
  for (let i = -1, n = lhs.length; ++i < n; ) {
    comparators[i] = createElementComparator2(lhs.get(i));
  }
  return createSubElementsComparator2(comparators);
}
function createObjectComparator2(lhs, allowEmpty = false) {
  const keys = Object.keys(lhs);
  if (!allowEmpty && keys.length === 0) {
    return () => false;
  }
  const comparators = [];
  for (let i = -1, n = keys.length; ++i < n; ) {
    comparators[i] = createElementComparator2(lhs[keys[i]]);
  }
  return createSubElementsComparator2(comparators, keys);
}
function createSubElementsComparator2(comparators, keys) {
  return (rhs) => {
    if (!rhs || typeof rhs !== "object") {
      return false;
    }
    switch (rhs.constructor) {
      case Array:
        return compareArray2(comparators, rhs);
      case Map:
        return compareObject2(comparators, rhs, rhs.keys());
      case MapRow2:
      case StructRow2:
      case Object:
      case void 0:
        return compareObject2(comparators, rhs, keys || Object.keys(rhs));
    }
    return rhs instanceof Vector2 ? compareVector2(comparators, rhs) : false;
  };
}
function compareArray2(comparators, arr) {
  const n = comparators.length;
  if (arr.length !== n) {
    return false;
  }
  for (let i = -1; ++i < n; ) {
    if (!comparators[i](arr[i])) {
      return false;
    }
  }
  return true;
}
function compareVector2(comparators, vec2) {
  const n = comparators.length;
  if (vec2.length !== n) {
    return false;
  }
  for (let i = -1; ++i < n; ) {
    if (!comparators[i](vec2.get(i))) {
      return false;
    }
  }
  return true;
}
function compareObject2(comparators, obj, keys) {
  const lKeyItr = keys[Symbol.iterator]();
  const rKeyItr = obj instanceof Map ? obj.keys() : Object.keys(obj)[Symbol.iterator]();
  const rValItr = obj instanceof Map ? obj.values() : Object.values(obj)[Symbol.iterator]();
  let i = 0;
  const n = comparators.length;
  let rVal = rValItr.next();
  let lKey = lKeyItr.next();
  let rKey = rKeyItr.next();
  for (; i < n && !lKey.done && !rKey.done && !rVal.done; ++i, lKey = lKeyItr.next(), rKey = rKeyItr.next(), rVal = rValItr.next()) {
    if (lKey.value !== rKey.value || !comparators[i](rVal.value)) {
      break;
    }
  }
  if (i === n && lKey.done && rKey.done && rVal.done) {
    return true;
  }
  lKeyItr.return && lKeyItr.return();
  rKeyItr.return && rKeyItr.return();
  rValItr.return && rValItr.return();
  return false;
}

// ../../node_modules/apache-arrow/util/bit.mjs
var bit_exports2 = {};
__export(bit_exports2, {
  BitIterator: () => BitIterator2,
  getBit: () => getBit2,
  getBool: () => getBool4,
  packBools: () => packBools2,
  popcnt_array: () => popcnt_array2,
  popcnt_bit_range: () => popcnt_bit_range2,
  popcnt_uint32: () => popcnt_uint322,
  setBool: () => setBool4,
  truncateBitmap: () => truncateBitmap2
});
function getBool4(_data, _index, byte, bit) {
  return (byte & 1 << bit) !== 0;
}
function getBit2(_data, _index, byte, bit) {
  return (byte & 1 << bit) >> bit;
}
function setBool4(bytes, index2, value) {
  return value ? !!(bytes[index2 >> 3] |= 1 << index2 % 8) || true : !(bytes[index2 >> 3] &= ~(1 << index2 % 8)) && false;
}
function truncateBitmap2(offset2, length4, bitmap) {
  const alignedSize = bitmap.byteLength + 7 & ~7;
  if (offset2 > 0 || bitmap.byteLength < alignedSize) {
    const bytes = new Uint8Array(alignedSize);
    bytes.set(offset2 % 8 === 0 ? bitmap.subarray(offset2 >> 3) : (
      // Otherwise iterate each bit from the offset and return a new one
      packBools2(new BitIterator2(bitmap, offset2, length4, null, getBool4)).subarray(0, alignedSize)
    ));
    return bytes;
  }
  return bitmap;
}
function packBools2(values2) {
  const xs = [];
  let i = 0, bit = 0, byte = 0;
  for (const value of values2) {
    value && (byte |= 1 << bit);
    if (++bit === 8) {
      xs[i++] = byte;
      byte = bit = 0;
    }
  }
  if (i === 0 || bit > 0) {
    xs[i++] = byte;
  }
  const b2 = new Uint8Array(xs.length + 7 & ~7);
  b2.set(xs);
  return b2;
}
var BitIterator2 = class {
  constructor(bytes, begin, length4, context, get3) {
    this.bytes = bytes;
    this.length = length4;
    this.context = context;
    this.get = get3;
    this.bit = begin % 8;
    this.byteIndex = begin >> 3;
    this.byte = bytes[this.byteIndex++];
    this.index = 0;
  }
  next() {
    if (this.index < this.length) {
      if (this.bit === 8) {
        this.bit = 0;
        this.byte = this.bytes[this.byteIndex++];
      }
      return {
        value: this.get(this.context, this.index++, this.byte, this.bit++)
      };
    }
    return { done: true, value: null };
  }
  [Symbol.iterator]() {
    return this;
  }
};
function popcnt_bit_range2(data, lhs, rhs) {
  if (rhs - lhs <= 0) {
    return 0;
  }
  if (rhs - lhs < 8) {
    let sum5 = 0;
    for (const bit of new BitIterator2(data, lhs, rhs - lhs, data, getBit2)) {
      sum5 += bit;
    }
    return sum5;
  }
  const rhsInside = rhs >> 3 << 3;
  const lhsInside = lhs + (lhs % 8 === 0 ? 0 : 8 - lhs % 8);
  return (
    // Get the popcnt of bits between the left hand side, and the next highest multiple of 8
    popcnt_bit_range2(data, lhs, lhsInside) + // Get the popcnt of bits between the right hand side, and the next lowest multiple of 8
    popcnt_bit_range2(data, rhsInside, rhs) + // Get the popcnt of all bits between the left and right hand sides' multiples of 8
    popcnt_array2(data, lhsInside >> 3, rhsInside - lhsInside >> 3)
  );
}
function popcnt_array2(arr, byteOffset, byteLength) {
  let cnt = 0, pos = Math.trunc(byteOffset);
  const view = new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  const len = byteLength === void 0 ? arr.byteLength : pos + byteLength;
  while (len - pos >= 4) {
    cnt += popcnt_uint322(view.getUint32(pos));
    pos += 4;
  }
  while (len - pos >= 2) {
    cnt += popcnt_uint322(view.getUint16(pos));
    pos += 2;
  }
  while (len - pos >= 1) {
    cnt += popcnt_uint322(view.getUint8(pos));
    pos += 1;
  }
  return cnt;
}
function popcnt_uint322(uint32) {
  let i = Math.trunc(uint32);
  i = i - (i >>> 1 & 1431655765);
  i = (i & 858993459) + (i >>> 2 & 858993459);
  return (i + (i >>> 4) & 252645135) * 16843009 >>> 24;
}

// ../../node_modules/apache-arrow/data.mjs
var kUnknownNullCount2 = -1;
var Data2 = class _Data {
  get typeId() {
    return this.type.typeId;
  }
  get ArrayType() {
    return this.type.ArrayType;
  }
  get buffers() {
    return [this.valueOffsets, this.values, this.nullBitmap, this.typeIds];
  }
  get nullable() {
    if (this._nullCount !== 0) {
      const { type: type2 } = this;
      if (DataType2.isSparseUnion(type2)) {
        return this.children.some((child) => child.nullable);
      } else if (DataType2.isDenseUnion(type2)) {
        return this.children.some((child) => child.nullable);
      }
      return this.nullBitmap && this.nullBitmap.byteLength > 0;
    }
    return true;
  }
  get byteLength() {
    let byteLength = 0;
    const { valueOffsets, values: values2, nullBitmap, typeIds } = this;
    valueOffsets && (byteLength += valueOffsets.byteLength);
    values2 && (byteLength += values2.byteLength);
    nullBitmap && (byteLength += nullBitmap.byteLength);
    typeIds && (byteLength += typeIds.byteLength);
    return this.children.reduce((byteLength2, child) => byteLength2 + child.byteLength, byteLength);
  }
  get nullCount() {
    if (DataType2.isUnion(this.type)) {
      return this.children.reduce((nullCount2, child) => nullCount2 + child.nullCount, 0);
    }
    let nullCount = this._nullCount;
    let nullBitmap;
    if (nullCount <= kUnknownNullCount2 && (nullBitmap = this.nullBitmap)) {
      this._nullCount = nullCount = this.length - popcnt_bit_range2(nullBitmap, this.offset, this.offset + this.length);
    }
    return nullCount;
  }
  constructor(type2, offset2, length4, nullCount, buffers, children2 = [], dictionary) {
    this.type = type2;
    this.children = children2;
    this.dictionary = dictionary;
    this.offset = Math.floor(Math.max(offset2 || 0, 0));
    this.length = Math.floor(Math.max(length4 || 0, 0));
    this._nullCount = Math.floor(Math.max(nullCount || 0, -1));
    let buffer;
    if (buffers instanceof _Data) {
      this.stride = buffers.stride;
      this.values = buffers.values;
      this.typeIds = buffers.typeIds;
      this.nullBitmap = buffers.nullBitmap;
      this.valueOffsets = buffers.valueOffsets;
    } else {
      this.stride = strideForType2(type2);
      if (buffers) {
        (buffer = buffers[0]) && (this.valueOffsets = buffer);
        (buffer = buffers[1]) && (this.values = buffer);
        (buffer = buffers[2]) && (this.nullBitmap = buffer);
        (buffer = buffers[3]) && (this.typeIds = buffer);
      }
    }
  }
  getValid(index2) {
    const { type: type2 } = this;
    if (DataType2.isUnion(type2)) {
      const union = type2;
      const child = this.children[union.typeIdToChildIndex[this.typeIds[index2]]];
      const indexInChild = union.mode === UnionMode2.Dense ? this.valueOffsets[index2] : index2;
      return child.getValid(indexInChild);
    }
    if (this.nullable && this.nullCount > 0) {
      const pos = this.offset + index2;
      const val = this.nullBitmap[pos >> 3];
      return (val & 1 << pos % 8) !== 0;
    }
    return true;
  }
  setValid(index2, value) {
    let prev;
    const { type: type2 } = this;
    if (DataType2.isUnion(type2)) {
      const union = type2;
      const child = this.children[union.typeIdToChildIndex[this.typeIds[index2]]];
      const indexInChild = union.mode === UnionMode2.Dense ? this.valueOffsets[index2] : index2;
      prev = child.getValid(indexInChild);
      child.setValid(indexInChild, value);
    } else {
      let { nullBitmap } = this;
      const { offset: offset2, length: length4 } = this;
      const idx = offset2 + index2;
      const mask = 1 << idx % 8;
      const byteOffset = idx >> 3;
      if (!nullBitmap || nullBitmap.byteLength <= byteOffset) {
        nullBitmap = new Uint8Array((offset2 + length4 + 63 & ~63) >> 3).fill(255);
        if (this.nullCount > 0) {
          nullBitmap.set(truncateBitmap2(offset2, length4, this.nullBitmap), 0);
        }
        Object.assign(this, { nullBitmap, _nullCount: -1 });
      }
      const byte = nullBitmap[byteOffset];
      prev = (byte & mask) !== 0;
      value ? nullBitmap[byteOffset] = byte | mask : nullBitmap[byteOffset] = byte & ~mask;
    }
    if (prev !== !!value) {
      this._nullCount = this.nullCount + (value ? -1 : 1);
    }
    return value;
  }
  clone(type2 = this.type, offset2 = this.offset, length4 = this.length, nullCount = this._nullCount, buffers = this, children2 = this.children) {
    return new _Data(type2, offset2, length4, nullCount, buffers, children2, this.dictionary);
  }
  slice(offset2, length4) {
    const { stride, typeId, children: children2 } = this;
    const nullCount = +(this._nullCount === 0) - 1;
    const childStride = typeId === 16 ? stride : 1;
    const buffers = this._sliceBuffers(offset2, length4, stride, typeId);
    return this.clone(
      this.type,
      this.offset + offset2,
      length4,
      nullCount,
      buffers,
      // Don't slice children if we have value offsets (the variable-width types)
      children2.length === 0 || this.valueOffsets ? children2 : this._sliceChildren(children2, childStride * offset2, childStride * length4)
    );
  }
  _changeLengthAndBackfillNullBitmap(newLength) {
    if (this.typeId === Type3.Null) {
      return this.clone(this.type, 0, newLength, 0);
    }
    const { length: length4, nullCount } = this;
    const bitmap = new Uint8Array((newLength + 63 & ~63) >> 3).fill(255, 0, length4 >> 3);
    bitmap[length4 >> 3] = (1 << length4 - (length4 & ~7)) - 1;
    if (nullCount > 0) {
      bitmap.set(truncateBitmap2(this.offset, length4, this.nullBitmap), 0);
    }
    const buffers = this.buffers;
    buffers[BufferType2.VALIDITY] = bitmap;
    return this.clone(this.type, 0, newLength, nullCount + (newLength - length4), buffers);
  }
  _sliceBuffers(offset2, length4, stride, typeId) {
    let arr;
    const { buffers } = this;
    (arr = buffers[BufferType2.TYPE]) && (buffers[BufferType2.TYPE] = arr.subarray(offset2, offset2 + length4));
    (arr = buffers[BufferType2.OFFSET]) && (buffers[BufferType2.OFFSET] = arr.subarray(offset2, offset2 + length4 + 1)) || // Otherwise if no offsets, slice the data buffer. Don't slice the data vector for Booleans, since the offset goes by bits not bytes
    (arr = buffers[BufferType2.DATA]) && (buffers[BufferType2.DATA] = typeId === 6 ? arr : arr.subarray(stride * offset2, stride * (offset2 + length4)));
    return buffers;
  }
  _sliceChildren(children2, offset2, length4) {
    return children2.map((child) => child.slice(offset2, length4));
  }
};
Data2.prototype.children = Object.freeze([]);
var MakeDataVisitor2 = class _MakeDataVisitor extends Visitor2 {
  visit(props) {
    return this.getVisitFn(props["type"]).call(this, props);
  }
  visitNull(props) {
    const { ["type"]: type2, ["offset"]: offset2 = 0, ["length"]: length4 = 0 } = props;
    return new Data2(type2, offset2, length4, length4);
  }
  visitBool(props) {
    const { ["type"]: type2, ["offset"]: offset2 = 0 } = props;
    const nullBitmap = toUint8Array2(props["nullBitmap"]);
    const data = toArrayBufferView2(type2.ArrayType, props["data"]);
    const { ["length"]: length4 = data.length >> 3, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data2(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);
  }
  visitInt(props) {
    const { ["type"]: type2, ["offset"]: offset2 = 0 } = props;
    const nullBitmap = toUint8Array2(props["nullBitmap"]);
    const data = toArrayBufferView2(type2.ArrayType, props["data"]);
    const { ["length"]: length4 = data.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data2(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);
  }
  visitFloat(props) {
    const { ["type"]: type2, ["offset"]: offset2 = 0 } = props;
    const nullBitmap = toUint8Array2(props["nullBitmap"]);
    const data = toArrayBufferView2(type2.ArrayType, props["data"]);
    const { ["length"]: length4 = data.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data2(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);
  }
  visitUtf8(props) {
    const { ["type"]: type2, ["offset"]: offset2 = 0 } = props;
    const data = toUint8Array2(props["data"]);
    const nullBitmap = toUint8Array2(props["nullBitmap"]);
    const valueOffsets = toInt32Array2(props["valueOffsets"]);
    const { ["length"]: length4 = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data2(type2, offset2, length4, nullCount, [valueOffsets, data, nullBitmap]);
  }
  visitBinary(props) {
    const { ["type"]: type2, ["offset"]: offset2 = 0 } = props;
    const data = toUint8Array2(props["data"]);
    const nullBitmap = toUint8Array2(props["nullBitmap"]);
    const valueOffsets = toInt32Array2(props["valueOffsets"]);
    const { ["length"]: length4 = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data2(type2, offset2, length4, nullCount, [valueOffsets, data, nullBitmap]);
  }
  visitFixedSizeBinary(props) {
    const { ["type"]: type2, ["offset"]: offset2 = 0 } = props;
    const nullBitmap = toUint8Array2(props["nullBitmap"]);
    const data = toArrayBufferView2(type2.ArrayType, props["data"]);
    const { ["length"]: length4 = data.length / strideForType2(type2), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data2(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);
  }
  visitDate(props) {
    const { ["type"]: type2, ["offset"]: offset2 = 0 } = props;
    const nullBitmap = toUint8Array2(props["nullBitmap"]);
    const data = toArrayBufferView2(type2.ArrayType, props["data"]);
    const { ["length"]: length4 = data.length / strideForType2(type2), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data2(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);
  }
  visitTimestamp(props) {
    const { ["type"]: type2, ["offset"]: offset2 = 0 } = props;
    const nullBitmap = toUint8Array2(props["nullBitmap"]);
    const data = toArrayBufferView2(type2.ArrayType, props["data"]);
    const { ["length"]: length4 = data.length / strideForType2(type2), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data2(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);
  }
  visitTime(props) {
    const { ["type"]: type2, ["offset"]: offset2 = 0 } = props;
    const nullBitmap = toUint8Array2(props["nullBitmap"]);
    const data = toArrayBufferView2(type2.ArrayType, props["data"]);
    const { ["length"]: length4 = data.length / strideForType2(type2), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data2(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);
  }
  visitDecimal(props) {
    const { ["type"]: type2, ["offset"]: offset2 = 0 } = props;
    const nullBitmap = toUint8Array2(props["nullBitmap"]);
    const data = toArrayBufferView2(type2.ArrayType, props["data"]);
    const { ["length"]: length4 = data.length / strideForType2(type2), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data2(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);
  }
  visitList(props) {
    const { ["type"]: type2, ["offset"]: offset2 = 0, ["child"]: child } = props;
    const nullBitmap = toUint8Array2(props["nullBitmap"]);
    const valueOffsets = toInt32Array2(props["valueOffsets"]);
    const { ["length"]: length4 = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data2(type2, offset2, length4, nullCount, [valueOffsets, void 0, nullBitmap], [child]);
  }
  visitStruct(props) {
    const { ["type"]: type2, ["offset"]: offset2 = 0, ["children"]: children2 = [] } = props;
    const nullBitmap = toUint8Array2(props["nullBitmap"]);
    const { length: length4 = children2.reduce((len, { length: length5 }) => Math.max(len, length5), 0), nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data2(type2, offset2, length4, nullCount, [void 0, void 0, nullBitmap], children2);
  }
  visitUnion(props) {
    const { ["type"]: type2, ["offset"]: offset2 = 0, ["children"]: children2 = [] } = props;
    const typeIds = toArrayBufferView2(type2.ArrayType, props["typeIds"]);
    const { ["length"]: length4 = typeIds.length, ["nullCount"]: nullCount = -1 } = props;
    if (DataType2.isSparseUnion(type2)) {
      return new Data2(type2, offset2, length4, nullCount, [void 0, void 0, void 0, typeIds], children2);
    }
    const valueOffsets = toInt32Array2(props["valueOffsets"]);
    return new Data2(type2, offset2, length4, nullCount, [valueOffsets, void 0, void 0, typeIds], children2);
  }
  visitDictionary(props) {
    const { ["type"]: type2, ["offset"]: offset2 = 0 } = props;
    const nullBitmap = toUint8Array2(props["nullBitmap"]);
    const data = toArrayBufferView2(type2.indices.ArrayType, props["data"]);
    const { ["dictionary"]: dictionary = new Vector2([new _MakeDataVisitor().visit({ type: type2.dictionary })]) } = props;
    const { ["length"]: length4 = data.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data2(type2, offset2, length4, nullCount, [void 0, data, nullBitmap], [], dictionary);
  }
  visitInterval(props) {
    const { ["type"]: type2, ["offset"]: offset2 = 0 } = props;
    const nullBitmap = toUint8Array2(props["nullBitmap"]);
    const data = toArrayBufferView2(type2.ArrayType, props["data"]);
    const { ["length"]: length4 = data.length / strideForType2(type2), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data2(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);
  }
  visitDuration(props) {
    const { ["type"]: type2, ["offset"]: offset2 = 0 } = props;
    const nullBitmap = toUint8Array2(props["nullBitmap"]);
    const data = toArrayBufferView2(type2.ArrayType, props["data"]);
    const { ["length"]: length4 = data.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data2(type2, offset2, length4, nullCount, [void 0, data, nullBitmap]);
  }
  visitFixedSizeList(props) {
    const { ["type"]: type2, ["offset"]: offset2 = 0, ["child"]: child = new _MakeDataVisitor().visit({ type: type2.valueType }) } = props;
    const nullBitmap = toUint8Array2(props["nullBitmap"]);
    const { ["length"]: length4 = child.length / strideForType2(type2), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data2(type2, offset2, length4, nullCount, [void 0, void 0, nullBitmap], [child]);
  }
  visitMap(props) {
    const { ["type"]: type2, ["offset"]: offset2 = 0, ["child"]: child = new _MakeDataVisitor().visit({ type: type2.childType }) } = props;
    const nullBitmap = toUint8Array2(props["nullBitmap"]);
    const valueOffsets = toInt32Array2(props["valueOffsets"]);
    const { ["length"]: length4 = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data2(type2, offset2, length4, nullCount, [valueOffsets, void 0, nullBitmap], [child]);
  }
};
var makeDataVisitor2 = new MakeDataVisitor2();
function makeData2(props) {
  return makeDataVisitor2.visit(props);
}

// ../../node_modules/apache-arrow/util/chunk.mjs
var ChunkedIterator2 = class {
  constructor(numChunks = 0, getChunkIterator) {
    this.numChunks = numChunks;
    this.getChunkIterator = getChunkIterator;
    this.chunkIndex = 0;
    this.chunkIterator = this.getChunkIterator(0);
  }
  next() {
    while (this.chunkIndex < this.numChunks) {
      const next = this.chunkIterator.next();
      if (!next.done) {
        return next;
      }
      if (++this.chunkIndex < this.numChunks) {
        this.chunkIterator = this.getChunkIterator(this.chunkIndex);
      }
    }
    return { done: true, value: null };
  }
  [Symbol.iterator]() {
    return this;
  }
};
function computeChunkNullCounts2(chunks) {
  return chunks.reduce((nullCount, chunk) => nullCount + chunk.nullCount, 0);
}
function computeChunkOffsets2(chunks) {
  return chunks.reduce((offsets, chunk, index2) => {
    offsets[index2 + 1] = offsets[index2] + chunk.length;
    return offsets;
  }, new Uint32Array(chunks.length + 1));
}
function sliceChunks2(chunks, offsets, begin, end) {
  const slices = [];
  for (let i = -1, n = chunks.length; ++i < n; ) {
    const chunk = chunks[i];
    const offset2 = offsets[i];
    const { length: length4 } = chunk;
    if (offset2 >= end) {
      break;
    }
    if (begin >= offset2 + length4) {
      continue;
    }
    if (offset2 >= begin && offset2 + length4 <= end) {
      slices.push(chunk);
      continue;
    }
    const from2 = Math.max(0, begin - offset2);
    const to = Math.min(end - offset2, length4);
    slices.push(chunk.slice(from2, to - from2));
  }
  if (slices.length === 0) {
    slices.push(chunks[0].slice(0, 0));
  }
  return slices;
}
function binarySearch2(chunks, offsets, idx, fn) {
  let lhs = 0, mid2 = 0, rhs = offsets.length - 1;
  do {
    if (lhs >= rhs - 1) {
      return idx < offsets[rhs] ? fn(chunks, lhs, idx - offsets[lhs]) : null;
    }
    mid2 = lhs + Math.trunc((rhs - lhs) * 0.5);
    idx < offsets[mid2] ? rhs = mid2 : lhs = mid2;
  } while (lhs < rhs);
}
function isChunkedValid2(data, index2) {
  return data.getValid(index2);
}
function wrapChunkedCall12(fn) {
  function chunkedFn(chunks, i, j2) {
    return fn(chunks[i], j2);
  }
  return function(index2) {
    const data = this.data;
    return binarySearch2(data, this._offsets, index2, chunkedFn);
  };
}
function wrapChunkedCall22(fn) {
  let _2;
  function chunkedFn(chunks, i, j2) {
    return fn(chunks[i], j2, _2);
  }
  return function(index2, value) {
    const data = this.data;
    _2 = value;
    const result = binarySearch2(data, this._offsets, index2, chunkedFn);
    _2 = void 0;
    return result;
  };
}
function wrapChunkedIndexOf2(indexOf2) {
  let _1;
  function chunkedIndexOf(data, chunkIndex, fromIndex) {
    let begin = fromIndex, index2 = 0, total = 0;
    for (let i = chunkIndex - 1, n = data.length; ++i < n; ) {
      const chunk = data[i];
      if (~(index2 = indexOf2(chunk, _1, begin))) {
        return total + index2;
      }
      begin = 0;
      total += chunk.length;
    }
    return -1;
  }
  return function(element, offset2) {
    _1 = element;
    const data = this.data;
    const result = typeof offset2 !== "number" ? chunkedIndexOf(data, 0, 0) : binarySearch2(data, this._offsets, offset2, chunkedIndexOf);
    _1 = void 0;
    return result;
  };
}

// ../../node_modules/apache-arrow/visitor/indexof.mjs
var IndexOfVisitor2 = class extends Visitor2 {
};
function nullIndexOf2(data, searchElement) {
  return searchElement === null && data.length > 0 ? 0 : -1;
}
function indexOfNull2(data, fromIndex) {
  const { nullBitmap } = data;
  if (!nullBitmap || data.nullCount <= 0) {
    return -1;
  }
  let i = 0;
  for (const isValid of new BitIterator2(nullBitmap, data.offset + (fromIndex || 0), data.length, nullBitmap, getBool4)) {
    if (!isValid) {
      return i;
    }
    ++i;
  }
  return -1;
}
function indexOfValue2(data, searchElement, fromIndex) {
  if (searchElement === void 0) {
    return -1;
  }
  if (searchElement === null) {
    switch (data.typeId) {
      case Type3.Union:
        break;
      case Type3.Dictionary:
        break;
      default:
        return indexOfNull2(data, fromIndex);
    }
  }
  const get3 = instance9.getVisitFn(data);
  const compare = createElementComparator2(searchElement);
  for (let i = (fromIndex || 0) - 1, n = data.length; ++i < n; ) {
    if (compare(get3(data, i))) {
      return i;
    }
  }
  return -1;
}
function indexOfUnion2(data, searchElement, fromIndex) {
  const get3 = instance9.getVisitFn(data);
  const compare = createElementComparator2(searchElement);
  for (let i = (fromIndex || 0) - 1, n = data.length; ++i < n; ) {
    if (compare(get3(data, i))) {
      return i;
    }
  }
  return -1;
}
IndexOfVisitor2.prototype.visitNull = nullIndexOf2;
IndexOfVisitor2.prototype.visitBool = indexOfValue2;
IndexOfVisitor2.prototype.visitInt = indexOfValue2;
IndexOfVisitor2.prototype.visitInt8 = indexOfValue2;
IndexOfVisitor2.prototype.visitInt16 = indexOfValue2;
IndexOfVisitor2.prototype.visitInt32 = indexOfValue2;
IndexOfVisitor2.prototype.visitInt64 = indexOfValue2;
IndexOfVisitor2.prototype.visitUint8 = indexOfValue2;
IndexOfVisitor2.prototype.visitUint16 = indexOfValue2;
IndexOfVisitor2.prototype.visitUint32 = indexOfValue2;
IndexOfVisitor2.prototype.visitUint64 = indexOfValue2;
IndexOfVisitor2.prototype.visitFloat = indexOfValue2;
IndexOfVisitor2.prototype.visitFloat16 = indexOfValue2;
IndexOfVisitor2.prototype.visitFloat32 = indexOfValue2;
IndexOfVisitor2.prototype.visitFloat64 = indexOfValue2;
IndexOfVisitor2.prototype.visitUtf8 = indexOfValue2;
IndexOfVisitor2.prototype.visitBinary = indexOfValue2;
IndexOfVisitor2.prototype.visitFixedSizeBinary = indexOfValue2;
IndexOfVisitor2.prototype.visitDate = indexOfValue2;
IndexOfVisitor2.prototype.visitDateDay = indexOfValue2;
IndexOfVisitor2.prototype.visitDateMillisecond = indexOfValue2;
IndexOfVisitor2.prototype.visitTimestamp = indexOfValue2;
IndexOfVisitor2.prototype.visitTimestampSecond = indexOfValue2;
IndexOfVisitor2.prototype.visitTimestampMillisecond = indexOfValue2;
IndexOfVisitor2.prototype.visitTimestampMicrosecond = indexOfValue2;
IndexOfVisitor2.prototype.visitTimestampNanosecond = indexOfValue2;
IndexOfVisitor2.prototype.visitTime = indexOfValue2;
IndexOfVisitor2.prototype.visitTimeSecond = indexOfValue2;
IndexOfVisitor2.prototype.visitTimeMillisecond = indexOfValue2;
IndexOfVisitor2.prototype.visitTimeMicrosecond = indexOfValue2;
IndexOfVisitor2.prototype.visitTimeNanosecond = indexOfValue2;
IndexOfVisitor2.prototype.visitDecimal = indexOfValue2;
IndexOfVisitor2.prototype.visitList = indexOfValue2;
IndexOfVisitor2.prototype.visitStruct = indexOfValue2;
IndexOfVisitor2.prototype.visitUnion = indexOfValue2;
IndexOfVisitor2.prototype.visitDenseUnion = indexOfUnion2;
IndexOfVisitor2.prototype.visitSparseUnion = indexOfUnion2;
IndexOfVisitor2.prototype.visitDictionary = indexOfValue2;
IndexOfVisitor2.prototype.visitInterval = indexOfValue2;
IndexOfVisitor2.prototype.visitIntervalDayTime = indexOfValue2;
IndexOfVisitor2.prototype.visitIntervalYearMonth = indexOfValue2;
IndexOfVisitor2.prototype.visitDuration = indexOfValue2;
IndexOfVisitor2.prototype.visitDurationSecond = indexOfValue2;
IndexOfVisitor2.prototype.visitDurationMillisecond = indexOfValue2;
IndexOfVisitor2.prototype.visitDurationMicrosecond = indexOfValue2;
IndexOfVisitor2.prototype.visitDurationNanosecond = indexOfValue2;
IndexOfVisitor2.prototype.visitFixedSizeList = indexOfValue2;
IndexOfVisitor2.prototype.visitMap = indexOfValue2;
var instance10 = new IndexOfVisitor2();

// ../../node_modules/apache-arrow/visitor/iterator.mjs
var IteratorVisitor2 = class extends Visitor2 {
};
function vectorIterator2(vector3) {
  const { type: type2 } = vector3;
  if (vector3.nullCount === 0 && vector3.stride === 1 && (type2.typeId === Type3.Timestamp || type2 instanceof Int_2 && type2.bitWidth !== 64 || type2 instanceof Time_2 && type2.bitWidth !== 64 || type2 instanceof Float2 && type2.precision !== Precision2.HALF)) {
    return new ChunkedIterator2(vector3.data.length, (chunkIndex) => {
      const data = vector3.data[chunkIndex];
      return data.values.subarray(0, data.length)[Symbol.iterator]();
    });
  }
  let offset2 = 0;
  return new ChunkedIterator2(vector3.data.length, (chunkIndex) => {
    const data = vector3.data[chunkIndex];
    const length4 = data.length;
    const inner = vector3.slice(offset2, offset2 + length4);
    offset2 += length4;
    return new VectorIterator2(inner);
  });
}
var VectorIterator2 = class {
  constructor(vector3) {
    this.vector = vector3;
    this.index = 0;
  }
  next() {
    if (this.index < this.vector.length) {
      return {
        value: this.vector.get(this.index++)
      };
    }
    return { done: true, value: null };
  }
  [Symbol.iterator]() {
    return this;
  }
};
IteratorVisitor2.prototype.visitNull = vectorIterator2;
IteratorVisitor2.prototype.visitBool = vectorIterator2;
IteratorVisitor2.prototype.visitInt = vectorIterator2;
IteratorVisitor2.prototype.visitInt8 = vectorIterator2;
IteratorVisitor2.prototype.visitInt16 = vectorIterator2;
IteratorVisitor2.prototype.visitInt32 = vectorIterator2;
IteratorVisitor2.prototype.visitInt64 = vectorIterator2;
IteratorVisitor2.prototype.visitUint8 = vectorIterator2;
IteratorVisitor2.prototype.visitUint16 = vectorIterator2;
IteratorVisitor2.prototype.visitUint32 = vectorIterator2;
IteratorVisitor2.prototype.visitUint64 = vectorIterator2;
IteratorVisitor2.prototype.visitFloat = vectorIterator2;
IteratorVisitor2.prototype.visitFloat16 = vectorIterator2;
IteratorVisitor2.prototype.visitFloat32 = vectorIterator2;
IteratorVisitor2.prototype.visitFloat64 = vectorIterator2;
IteratorVisitor2.prototype.visitUtf8 = vectorIterator2;
IteratorVisitor2.prototype.visitBinary = vectorIterator2;
IteratorVisitor2.prototype.visitFixedSizeBinary = vectorIterator2;
IteratorVisitor2.prototype.visitDate = vectorIterator2;
IteratorVisitor2.prototype.visitDateDay = vectorIterator2;
IteratorVisitor2.prototype.visitDateMillisecond = vectorIterator2;
IteratorVisitor2.prototype.visitTimestamp = vectorIterator2;
IteratorVisitor2.prototype.visitTimestampSecond = vectorIterator2;
IteratorVisitor2.prototype.visitTimestampMillisecond = vectorIterator2;
IteratorVisitor2.prototype.visitTimestampMicrosecond = vectorIterator2;
IteratorVisitor2.prototype.visitTimestampNanosecond = vectorIterator2;
IteratorVisitor2.prototype.visitTime = vectorIterator2;
IteratorVisitor2.prototype.visitTimeSecond = vectorIterator2;
IteratorVisitor2.prototype.visitTimeMillisecond = vectorIterator2;
IteratorVisitor2.prototype.visitTimeMicrosecond = vectorIterator2;
IteratorVisitor2.prototype.visitTimeNanosecond = vectorIterator2;
IteratorVisitor2.prototype.visitDecimal = vectorIterator2;
IteratorVisitor2.prototype.visitList = vectorIterator2;
IteratorVisitor2.prototype.visitStruct = vectorIterator2;
IteratorVisitor2.prototype.visitUnion = vectorIterator2;
IteratorVisitor2.prototype.visitDenseUnion = vectorIterator2;
IteratorVisitor2.prototype.visitSparseUnion = vectorIterator2;
IteratorVisitor2.prototype.visitDictionary = vectorIterator2;
IteratorVisitor2.prototype.visitInterval = vectorIterator2;
IteratorVisitor2.prototype.visitIntervalDayTime = vectorIterator2;
IteratorVisitor2.prototype.visitIntervalYearMonth = vectorIterator2;
IteratorVisitor2.prototype.visitDuration = vectorIterator2;
IteratorVisitor2.prototype.visitDurationSecond = vectorIterator2;
IteratorVisitor2.prototype.visitDurationMillisecond = vectorIterator2;
IteratorVisitor2.prototype.visitDurationMicrosecond = vectorIterator2;
IteratorVisitor2.prototype.visitDurationNanosecond = vectorIterator2;
IteratorVisitor2.prototype.visitFixedSizeList = vectorIterator2;
IteratorVisitor2.prototype.visitMap = vectorIterator2;
var instance11 = new IteratorVisitor2();

// ../../node_modules/apache-arrow/visitor/bytelength.mjs
var sum2 = (x4, y4) => x4 + y4;
var GetByteLengthVisitor = class extends Visitor2 {
  visitNull(____, _2) {
    return 0;
  }
  visitInt(data, _2) {
    return data.type.bitWidth / 8;
  }
  visitFloat(data, _2) {
    return data.type.ArrayType.BYTES_PER_ELEMENT;
  }
  visitBool(____, _2) {
    return 1 / 8;
  }
  visitDecimal(data, _2) {
    return data.type.bitWidth / 8;
  }
  visitDate(data, _2) {
    return (data.type.unit + 1) * 4;
  }
  visitTime(data, _2) {
    return data.type.bitWidth / 8;
  }
  visitTimestamp(data, _2) {
    return data.type.unit === TimeUnit2.SECOND ? 4 : 8;
  }
  visitInterval(data, _2) {
    return (data.type.unit + 1) * 4;
  }
  visitDuration(____, _2) {
    return 8;
  }
  visitStruct(data, i) {
    return data.children.reduce((total, child) => total + instance12.visit(child, i), 0);
  }
  visitFixedSizeBinary(data, _2) {
    return data.type.byteWidth;
  }
  visitMap(data, i) {
    return 8 + data.children.reduce((total, child) => total + instance12.visit(child, i), 0);
  }
  visitDictionary(data, i) {
    var _a9;
    return data.type.indices.bitWidth / 8 + (((_a9 = data.dictionary) === null || _a9 === void 0 ? void 0 : _a9.getByteLength(data.values[i])) || 0);
  }
};
var getUtf8ByteLength = ({ valueOffsets }, index2) => {
  return 8 + (valueOffsets[index2 + 1] - valueOffsets[index2]);
};
var getBinaryByteLength = ({ valueOffsets }, index2) => {
  return 8 + (valueOffsets[index2 + 1] - valueOffsets[index2]);
};
var getListByteLength = ({ valueOffsets, stride, children: children2 }, index2) => {
  const child = children2[0];
  const { [index2 * stride]: start2 } = valueOffsets;
  const { [index2 * stride + 1]: end } = valueOffsets;
  const visit2 = instance12.getVisitFn(child.type);
  const slice4 = child.slice(start2, end - start2);
  let size = 8;
  for (let idx = -1, len = end - start2; ++idx < len; ) {
    size += visit2(slice4, idx);
  }
  return size;
};
var getFixedSizeListByteLength = ({ stride, children: children2 }, index2) => {
  const child = children2[0];
  const slice4 = child.slice(index2 * stride, stride);
  const visit2 = instance12.getVisitFn(child.type);
  let size = 0;
  for (let idx = -1, len = slice4.length; ++idx < len; ) {
    size += visit2(slice4, idx);
  }
  return size;
};
var getUnionByteLength = (data, index2) => {
  return data.type.mode === UnionMode2.Dense ? getDenseUnionByteLength(data, index2) : getSparseUnionByteLength(data, index2);
};
var getDenseUnionByteLength = ({ type: type2, children: children2, typeIds, valueOffsets }, index2) => {
  const childIndex = type2.typeIdToChildIndex[typeIds[index2]];
  return 8 + instance12.visit(children2[childIndex], valueOffsets[index2]);
};
var getSparseUnionByteLength = ({ children: children2 }, index2) => {
  return 4 + instance12.visitMany(children2, children2.map(() => index2)).reduce(sum2, 0);
};
GetByteLengthVisitor.prototype.visitUtf8 = getUtf8ByteLength;
GetByteLengthVisitor.prototype.visitBinary = getBinaryByteLength;
GetByteLengthVisitor.prototype.visitList = getListByteLength;
GetByteLengthVisitor.prototype.visitFixedSizeList = getFixedSizeListByteLength;
GetByteLengthVisitor.prototype.visitUnion = getUnionByteLength;
GetByteLengthVisitor.prototype.visitDenseUnion = getDenseUnionByteLength;
GetByteLengthVisitor.prototype.visitSparseUnion = getSparseUnionByteLength;
var instance12 = new GetByteLengthVisitor();

// ../../node_modules/apache-arrow/vector.mjs
var _a6;
var visitorsByTypeId2 = {};
var vectorPrototypesByTypeId2 = {};
var Vector2 = class _Vector {
  constructor(input3) {
    var _b3, _c3, _d3;
    const data = input3[0] instanceof _Vector ? input3.flatMap((x4) => x4.data) : input3;
    if (data.length === 0 || data.some((x4) => !(x4 instanceof Data2))) {
      throw new TypeError("Vector constructor expects an Array of Data instances.");
    }
    const type2 = (_b3 = data[0]) === null || _b3 === void 0 ? void 0 : _b3.type;
    switch (data.length) {
      case 0:
        this._offsets = [0];
        break;
      case 1: {
        const { get: get3, set: set3, indexOf: indexOf2, byteLength } = visitorsByTypeId2[type2.typeId];
        const unchunkedData = data[0];
        this.isValid = (index2) => isChunkedValid2(unchunkedData, index2);
        this.get = (index2) => get3(unchunkedData, index2);
        this.set = (index2, value) => set3(unchunkedData, index2, value);
        this.indexOf = (index2) => indexOf2(unchunkedData, index2);
        this.getByteLength = (index2) => byteLength(unchunkedData, index2);
        this._offsets = [0, unchunkedData.length];
        break;
      }
      default:
        Object.setPrototypeOf(this, vectorPrototypesByTypeId2[type2.typeId]);
        this._offsets = computeChunkOffsets2(data);
        break;
    }
    this.data = data;
    this.type = type2;
    this.stride = strideForType2(type2);
    this.numChildren = (_d3 = (_c3 = type2.children) === null || _c3 === void 0 ? void 0 : _c3.length) !== null && _d3 !== void 0 ? _d3 : 0;
    this.length = this._offsets.at(-1);
  }
  /**
   * The aggregate size (in bytes) of this Vector's buffers and/or child Vectors.
   */
  get byteLength() {
    return this.data.reduce((byteLength, data) => byteLength + data.byteLength, 0);
  }
  /**
   * The number of null elements in this Vector.
   */
  get nullCount() {
    return computeChunkNullCounts2(this.data);
  }
  /**
   * The Array or TypedArray constructor used for the JS representation
   *  of the element's values in {@link Vector.prototype.toArray `toArray()`}.
   */
  get ArrayType() {
    return this.type.ArrayType;
  }
  /**
   * The name that should be printed when the Vector is logged in a message.
   */
  get [Symbol.toStringTag]() {
    return `${this.VectorName}<${this.type[Symbol.toStringTag]}>`;
  }
  /**
   * The name of this Vector.
   */
  get VectorName() {
    return `${Type3[this.type.typeId]}Vector`;
  }
  /**
   * Check whether an element is null.
   * @param index The index at which to read the validity bitmap.
   */
  // @ts-ignore
  isValid(index2) {
    return false;
  }
  /**
   * Get an element value by position.
   * @param index The index of the element to read.
   */
  // @ts-ignore
  get(index2) {
    return null;
  }
  /**
   * Set an element value by position.
   * @param index The index of the element to write.
   * @param value The value to set.
   */
  // @ts-ignore
  set(index2, value) {
    return;
  }
  /**
   * Retrieve the index of the first occurrence of a value in an Vector.
   * @param element The value to locate in the Vector.
   * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
   */
  // @ts-ignore
  indexOf(element, offset2) {
    return -1;
  }
  includes(element, offset2) {
    return this.indexOf(element, offset2) > -1;
  }
  /**
   * Get the size in bytes of an element by index.
   * @param index The index at which to get the byteLength.
   */
  // @ts-ignore
  getByteLength(index2) {
    return 0;
  }
  /**
   * Iterator for the Vector's elements.
   */
  [Symbol.iterator]() {
    return instance11.visit(this);
  }
  /**
   * Combines two or more Vectors of the same type.
   * @param others Additional Vectors to add to the end of this Vector.
   */
  concat(...others) {
    return new _Vector(this.data.concat(others.flatMap((x4) => x4.data).flat(Number.POSITIVE_INFINITY)));
  }
  /**
   * Return a zero-copy sub-section of this Vector.
   * @param start The beginning of the specified portion of the Vector.
   * @param end The end of the specified portion of the Vector. This is exclusive of the element at the index 'end'.
   */
  slice(begin, end) {
    return new _Vector(clampRange2(this, begin, end, ({ data, _offsets }, begin2, end2) => sliceChunks2(data, _offsets, begin2, end2)));
  }
  toJSON() {
    return [...this];
  }
  /**
   * Return a JavaScript Array or TypedArray of the Vector's elements.
   *
   * @note If this Vector contains a single Data chunk and the Vector's type is a
   *  primitive numeric type corresponding to one of the JavaScript TypedArrays, this
   *  method returns a zero-copy slice of the underlying TypedArray values. If there's
   *  more than one chunk, the resulting TypedArray will be a copy of the data from each
   *  chunk's underlying TypedArray values.
   *
   * @returns An Array or TypedArray of the Vector's elements, based on the Vector's DataType.
   */
  toArray() {
    const { type: type2, data, length: length4, stride, ArrayType } = this;
    switch (type2.typeId) {
      case Type3.Int:
      case Type3.Float:
      case Type3.Decimal:
      case Type3.Time:
      case Type3.Timestamp:
        switch (data.length) {
          case 0:
            return new ArrayType();
          case 1:
            return data[0].values.subarray(0, length4 * stride);
          default:
            return data.reduce((memo2, { values: values2, length: chunk_length }) => {
              memo2.array.set(values2.subarray(0, chunk_length * stride), memo2.offset);
              memo2.offset += chunk_length * stride;
              return memo2;
            }, { array: new ArrayType(length4 * stride), offset: 0 }).array;
        }
    }
    return [...this];
  }
  /**
   * Returns a string representation of the Vector.
   *
   * @returns A string representation of the Vector.
   */
  toString() {
    return `[${[...this].join(",")}]`;
  }
  /**
   * Returns a child Vector by name, or null if this Vector has no child with the given name.
   * @param name The name of the child to retrieve.
   */
  getChild(name2) {
    var _b3;
    return this.getChildAt((_b3 = this.type.children) === null || _b3 === void 0 ? void 0 : _b3.findIndex((f2) => f2.name === name2));
  }
  /**
   * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
   * @param index The index of the child to retrieve.
   */
  getChildAt(index2) {
    if (index2 > -1 && index2 < this.numChildren) {
      return new _Vector(this.data.map(({ children: children2 }) => children2[index2]));
    }
    return null;
  }
  get isMemoized() {
    if (DataType2.isDictionary(this.type)) {
      return this.data[0].dictionary.isMemoized;
    }
    return false;
  }
  /**
   * Adds memoization to the Vector's {@link get} method. For dictionary
   * vectors, this method return a vector that memoizes only the dictionary
   * values.
   *
   * Memoization is very useful when decoding a value is expensive such as
   * Uft8. The memoization creates a cache of the size of the Vector and
   * therfore increases memory usage.
   *
   * @returns A new vector that memoizes calls to {@link get}.
   */
  memoize() {
    if (DataType2.isDictionary(this.type)) {
      const dictionary = new MemoizedVector2(this.data[0].dictionary);
      const newData = this.data.map((data) => {
        const cloned = data.clone();
        cloned.dictionary = dictionary;
        return cloned;
      });
      return new _Vector(newData);
    }
    return new MemoizedVector2(this);
  }
  /**
   * Returns a vector without memoization of the {@link get} method. If this
   * vector is not memoized, this method returns this vector.
   *
   * @returns A a vector without memoization.
   */
  unmemoize() {
    if (DataType2.isDictionary(this.type) && this.isMemoized) {
      const dictionary = this.data[0].dictionary.unmemoize();
      const newData = this.data.map((data) => {
        const newData2 = data.clone();
        newData2.dictionary = dictionary;
        return newData2;
      });
      return new _Vector(newData);
    }
    return this;
  }
};
_a6 = Symbol.toStringTag;
Vector2[_a6] = ((proto) => {
  proto.type = DataType2.prototype;
  proto.data = [];
  proto.length = 0;
  proto.stride = 1;
  proto.numChildren = 0;
  proto._offsets = new Uint32Array([0]);
  proto[Symbol.isConcatSpreadable] = true;
  const typeIds = Object.keys(Type3).map((T) => Type3[T]).filter((T) => typeof T === "number" && T !== Type3.NONE);
  for (const typeId of typeIds) {
    const get3 = instance9.getVisitFnByTypeId(typeId);
    const set3 = instance8.getVisitFnByTypeId(typeId);
    const indexOf2 = instance10.getVisitFnByTypeId(typeId);
    const byteLength = instance12.getVisitFnByTypeId(typeId);
    visitorsByTypeId2[typeId] = { get: get3, set: set3, indexOf: indexOf2, byteLength };
    vectorPrototypesByTypeId2[typeId] = Object.create(proto, {
      ["isValid"]: { value: wrapChunkedCall12(isChunkedValid2) },
      ["get"]: { value: wrapChunkedCall12(instance9.getVisitFnByTypeId(typeId)) },
      ["set"]: { value: wrapChunkedCall22(instance8.getVisitFnByTypeId(typeId)) },
      ["indexOf"]: { value: wrapChunkedIndexOf2(instance10.getVisitFnByTypeId(typeId)) },
      ["getByteLength"]: { value: wrapChunkedCall12(instance12.getVisitFnByTypeId(typeId)) }
    });
  }
  return "Vector";
})(Vector2.prototype);
var MemoizedVector2 = class _MemoizedVector extends Vector2 {
  constructor(vector3) {
    super(vector3.data);
    const get3 = this.get;
    const set3 = this.set;
    const slice4 = this.slice;
    const cache = new Array(this.length);
    Object.defineProperty(this, "get", {
      value(index2) {
        const cachedValue = cache[index2];
        if (cachedValue !== void 0) {
          return cachedValue;
        }
        const value = get3.call(this, index2);
        cache[index2] = value;
        return value;
      }
    });
    Object.defineProperty(this, "set", {
      value(index2, value) {
        set3.call(this, index2, value);
        cache[index2] = value;
      }
    });
    Object.defineProperty(this, "slice", {
      value: (begin, end) => new _MemoizedVector(slice4.call(this, begin, end))
    });
    Object.defineProperty(this, "isMemoized", { value: true });
    Object.defineProperty(this, "unmemoize", {
      value: () => new Vector2(this.data)
    });
    Object.defineProperty(this, "memoize", {
      value: () => this
    });
  }
};

// ../../node_modules/apache-arrow/builder/valid.mjs
function createIsValidFunction2(nullValues) {
  if (!nullValues || nullValues.length <= 0) {
    return function isValid(value) {
      return true;
    };
  }
  let fnBody = "";
  const noNaNs = nullValues.filter((x4) => x4 === x4);
  if (noNaNs.length > 0) {
    fnBody = `
    switch (x) {${noNaNs.map((x4) => `
        case ${valueToCase2(x4)}:`).join("")}
            return false;
    }`;
  }
  if (nullValues.length !== noNaNs.length) {
    fnBody = `if (x !== x) return false;
${fnBody}`;
  }
  return new Function(`x`, `${fnBody}
return true;`);
}
function valueToCase2(x4) {
  if (typeof x4 !== "bigint") {
    return valueToString2(x4);
  }
  return `${valueToString2(x4)}n`;
}

// ../../node_modules/apache-arrow/builder/buffer.mjs
var roundLengthUpToNearest64Bytes2 = (len, BPE) => (Math.ceil(len) * BPE + 63 & ~63 || 64) / BPE;
var sliceOrExtendArray = (arr, len = 0) => arr.length >= len ? arr.subarray(0, len) : memcpy2(new arr.constructor(len), arr, 0);
var BufferBuilder2 = class {
  constructor(buffer, stride = 1) {
    this.buffer = buffer;
    this.stride = stride;
    this.BYTES_PER_ELEMENT = buffer.BYTES_PER_ELEMENT;
    this.ArrayType = buffer.constructor;
    this._resize(this.length = Math.ceil(buffer.length / stride));
  }
  get byteLength() {
    return Math.ceil(this.length * this.stride) * this.BYTES_PER_ELEMENT;
  }
  get reservedLength() {
    return this.buffer.length / this.stride;
  }
  get reservedByteLength() {
    return this.buffer.byteLength;
  }
  // @ts-ignore
  set(index2, value) {
    return this;
  }
  append(value) {
    return this.set(this.length, value);
  }
  reserve(extra) {
    if (extra > 0) {
      this.length += extra;
      const stride = this.stride;
      const length4 = this.length * stride;
      const reserved = this.buffer.length;
      if (length4 >= reserved) {
        this._resize(reserved === 0 ? roundLengthUpToNearest64Bytes2(length4 * 1, this.BYTES_PER_ELEMENT) : roundLengthUpToNearest64Bytes2(length4 * 2, this.BYTES_PER_ELEMENT));
      }
    }
    return this;
  }
  flush(length4 = this.length) {
    length4 = roundLengthUpToNearest64Bytes2(length4 * this.stride, this.BYTES_PER_ELEMENT);
    const array4 = sliceOrExtendArray(this.buffer, length4);
    this.clear();
    return array4;
  }
  clear() {
    this.length = 0;
    this._resize(0);
    return this;
  }
  _resize(newLength) {
    return this.buffer = memcpy2(new this.ArrayType(newLength), this.buffer);
  }
};
BufferBuilder2.prototype.offset = 0;
var DataBufferBuilder2 = class extends BufferBuilder2 {
  last() {
    return this.get(this.length - 1);
  }
  get(index2) {
    return this.buffer[index2];
  }
  set(index2, value) {
    this.reserve(index2 - this.length + 1);
    this.buffer[index2 * this.stride] = value;
    return this;
  }
};
var BitmapBufferBuilder2 = class extends DataBufferBuilder2 {
  constructor(data = new Uint8Array(0)) {
    super(data, 1 / 8);
    this.numValid = 0;
  }
  get numInvalid() {
    return this.length - this.numValid;
  }
  get(idx) {
    return this.buffer[idx >> 3] >> idx % 8 & 1;
  }
  set(idx, val) {
    const { buffer } = this.reserve(idx - this.length + 1);
    const byte = idx >> 3, bit = idx % 8, cur = buffer[byte] >> bit & 1;
    val ? cur === 0 && (buffer[byte] |= 1 << bit, ++this.numValid) : cur === 1 && (buffer[byte] &= ~(1 << bit), --this.numValid);
    return this;
  }
  clear() {
    this.numValid = 0;
    return super.clear();
  }
};
var OffsetsBufferBuilder2 = class extends DataBufferBuilder2 {
  constructor(data = new Int32Array(1)) {
    super(data, 1);
  }
  append(value) {
    return this.set(this.length - 1, value);
  }
  set(index2, value) {
    const offset2 = this.length - 1;
    const buffer = this.reserve(index2 - offset2 + 1).buffer;
    if (offset2 < index2++) {
      buffer.fill(buffer[offset2], offset2, index2);
    }
    buffer[index2] = buffer[index2 - 1] + value;
    return this;
  }
  flush(length4 = this.length - 1) {
    if (length4 > this.length) {
      this.set(length4 - 1, 0);
    }
    return super.flush(length4 + 1);
  }
};

// ../../node_modules/apache-arrow/builder.mjs
var Builder5 = class {
  /** @nocollapse */
  // @ts-ignore
  static throughNode(options) {
    throw new Error(`"throughNode" not available in this environment`);
  }
  /** @nocollapse */
  // @ts-ignore
  static throughDOM(options) {
    throw new Error(`"throughDOM" not available in this environment`);
  }
  /**
   * Construct a builder with the given Arrow DataType with optional null values,
   * which will be interpreted as "null" when set or appended to the `Builder`.
   * @param {{ type: T, nullValues?: any[] }} options A `BuilderOptions` object used to create this `Builder`.
   */
  constructor({ "type": type2, "nullValues": nulls }) {
    this.length = 0;
    this.finished = false;
    this.type = type2;
    this.children = [];
    this.nullValues = nulls;
    this.stride = strideForType2(type2);
    this._nulls = new BitmapBufferBuilder2();
    if (nulls && nulls.length > 0) {
      this._isValid = createIsValidFunction2(nulls);
    }
  }
  /**
   * Flush the `Builder` and return a `Vector<T>`.
   * @returns {Vector<T>} A `Vector<T>` of the flushed values.
   */
  toVector() {
    return new Vector2([this.flush()]);
  }
  get ArrayType() {
    return this.type.ArrayType;
  }
  get nullCount() {
    return this._nulls.numInvalid;
  }
  get numChildren() {
    return this.children.length;
  }
  /**
   * @returns The aggregate length (in bytes) of the values that have been written.
   */
  get byteLength() {
    let size = 0;
    const { _offsets, _values, _nulls, _typeIds, children: children2 } = this;
    _offsets && (size += _offsets.byteLength);
    _values && (size += _values.byteLength);
    _nulls && (size += _nulls.byteLength);
    _typeIds && (size += _typeIds.byteLength);
    return children2.reduce((size2, child) => size2 + child.byteLength, size);
  }
  /**
   * @returns The aggregate number of rows that have been reserved to write new values.
   */
  get reservedLength() {
    return this._nulls.reservedLength;
  }
  /**
   * @returns The aggregate length (in bytes) that has been reserved to write new values.
   */
  get reservedByteLength() {
    let size = 0;
    this._offsets && (size += this._offsets.reservedByteLength);
    this._values && (size += this._values.reservedByteLength);
    this._nulls && (size += this._nulls.reservedByteLength);
    this._typeIds && (size += this._typeIds.reservedByteLength);
    return this.children.reduce((size2, child) => size2 + child.reservedByteLength, size);
  }
  get valueOffsets() {
    return this._offsets ? this._offsets.buffer : null;
  }
  get values() {
    return this._values ? this._values.buffer : null;
  }
  get nullBitmap() {
    return this._nulls ? this._nulls.buffer : null;
  }
  get typeIds() {
    return this._typeIds ? this._typeIds.buffer : null;
  }
  /**
   * Appends a value (or null) to this `Builder`.
   * This is equivalent to `builder.set(builder.length, value)`.
   * @param {T['TValue'] | TNull } value The value to append.
   */
  append(value) {
    return this.set(this.length, value);
  }
  /**
   * Validates whether a value is valid (true), or null (false)
   * @param {T['TValue'] | TNull } value The value to compare against null the value representations
   */
  isValid(value) {
    return this._isValid(value);
  }
  /**
   * Write a value (or null-value sentinel) at the supplied index.
   * If the value matches one of the null-value representations, a 1-bit is
   * written to the null `BitmapBufferBuilder`. Otherwise, a 0 is written to
   * the null `BitmapBufferBuilder`, and the value is passed to
   * `Builder.prototype.setValue()`.
   * @param {number} index The index of the value to write.
   * @param {T['TValue'] | TNull } value The value to write at the supplied index.
   * @returns {this} The updated `Builder` instance.
   */
  set(index2, value) {
    if (this.setValid(index2, this.isValid(value))) {
      this.setValue(index2, value);
    }
    return this;
  }
  /**
   * Write a value to the underlying buffers at the supplied index, bypassing
   * the null-value check. This is a low-level method that
   * @param {number} index
   * @param {T['TValue'] | TNull } value
   */
  setValue(index2, value) {
    this._setValue(this, index2, value);
  }
  setValid(index2, valid2) {
    this.length = this._nulls.set(index2, +valid2).length;
    return valid2;
  }
  // @ts-ignore
  addChild(child, name2 = `${this.numChildren}`) {
    throw new Error(`Cannot append children to non-nested type "${this.type}"`);
  }
  /**
   * Retrieve the child `Builder` at the supplied `index`, or null if no child
   * exists at that index.
   * @param {number} index The index of the child `Builder` to retrieve.
   * @returns {Builder | null} The child Builder at the supplied index or null.
   */
  getChildAt(index2) {
    return this.children[index2] || null;
  }
  /**
   * Commit all the values that have been written to their underlying
   * ArrayBuffers, including any child Builders if applicable, and reset
   * the internal `Builder` state.
   * @returns A `Data<T>` of the buffers and children representing the values written.
   */
  flush() {
    let data;
    let typeIds;
    let nullBitmap;
    let valueOffsets;
    const { type: type2, length: length4, nullCount, _typeIds, _offsets, _values, _nulls } = this;
    if (typeIds = _typeIds === null || _typeIds === void 0 ? void 0 : _typeIds.flush(length4)) {
      valueOffsets = _offsets === null || _offsets === void 0 ? void 0 : _offsets.flush(length4);
    } else if (valueOffsets = _offsets === null || _offsets === void 0 ? void 0 : _offsets.flush(length4)) {
      data = _values === null || _values === void 0 ? void 0 : _values.flush(_offsets.last());
    } else {
      data = _values === null || _values === void 0 ? void 0 : _values.flush(length4);
    }
    if (nullCount > 0) {
      nullBitmap = _nulls === null || _nulls === void 0 ? void 0 : _nulls.flush(length4);
    }
    const children2 = this.children.map((child) => child.flush());
    this.clear();
    return makeData2({
      type: type2,
      length: length4,
      nullCount,
      children: children2,
      "child": children2[0],
      data,
      typeIds,
      nullBitmap,
      valueOffsets
    });
  }
  /**
   * Finalize this `Builder`, and child builders if applicable.
   * @returns {this} The finalized `Builder` instance.
   */
  finish() {
    this.finished = true;
    for (const child of this.children)
      child.finish();
    return this;
  }
  /**
   * Clear this Builder's internal state, including child Builders if applicable, and reset the length to 0.
   * @returns {this} The cleared `Builder` instance.
   */
  clear() {
    var _a9, _b3, _c3, _d3;
    this.length = 0;
    (_a9 = this._nulls) === null || _a9 === void 0 ? void 0 : _a9.clear();
    (_b3 = this._values) === null || _b3 === void 0 ? void 0 : _b3.clear();
    (_c3 = this._offsets) === null || _c3 === void 0 ? void 0 : _c3.clear();
    (_d3 = this._typeIds) === null || _d3 === void 0 ? void 0 : _d3.clear();
    for (const child of this.children)
      child.clear();
    return this;
  }
};
Builder5.prototype.length = 1;
Builder5.prototype.stride = 1;
Builder5.prototype.children = null;
Builder5.prototype.finished = false;
Builder5.prototype.nullValues = null;
Builder5.prototype._isValid = () => true;
var FixedWidthBuilder2 = class extends Builder5 {
  constructor(opts) {
    super(opts);
    this._values = new DataBufferBuilder2(new this.ArrayType(0), this.stride);
  }
  setValue(index2, value) {
    const values2 = this._values;
    values2.reserve(index2 - values2.length + 1);
    return super.setValue(index2, value);
  }
};
var VariableWidthBuilder2 = class extends Builder5 {
  constructor(opts) {
    super(opts);
    this._pendingLength = 0;
    this._offsets = new OffsetsBufferBuilder2();
  }
  setValue(index2, value) {
    const pending = this._pending || (this._pending = /* @__PURE__ */ new Map());
    const current = pending.get(index2);
    current && (this._pendingLength -= current.length);
    this._pendingLength += value instanceof MapRow2 ? value[kKeys2].length : value.length;
    pending.set(index2, value);
  }
  setValid(index2, isValid) {
    if (!super.setValid(index2, isValid)) {
      (this._pending || (this._pending = /* @__PURE__ */ new Map())).set(index2, void 0);
      return false;
    }
    return true;
  }
  clear() {
    this._pendingLength = 0;
    this._pending = void 0;
    return super.clear();
  }
  flush() {
    this._flush();
    return super.flush();
  }
  finish() {
    this._flush();
    return super.finish();
  }
  _flush() {
    const pending = this._pending;
    const pendingLength = this._pendingLength;
    this._pendingLength = 0;
    this._pending = void 0;
    if (pending && pending.size > 0) {
      this._flushPending(pending, pendingLength);
    }
    return this;
  }
};

// ../../node_modules/apache-arrow/fb/block.mjs
var Block2 = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  /**
   * Index to the start of the RecordBlock (note this is past the Message header)
   */
  offset() {
    return this.bb.readInt64(this.bb_pos);
  }
  /**
   * Length of the metadata
   */
  metaDataLength() {
    return this.bb.readInt32(this.bb_pos + 8);
  }
  /**
   * Length of the data (this is aligned so there can be a gap between this and
   * the metadata).
   */
  bodyLength() {
    return this.bb.readInt64(this.bb_pos + 16);
  }
  static sizeOf() {
    return 24;
  }
  static createBlock(builder, offset2, metaDataLength, bodyLength) {
    builder.prep(8, 24);
    builder.writeInt64(BigInt(bodyLength !== null && bodyLength !== void 0 ? bodyLength : 0));
    builder.pad(4);
    builder.writeInt32(metaDataLength);
    builder.writeInt64(BigInt(offset2 !== null && offset2 !== void 0 ? offset2 : 0));
    return builder.offset();
  }
};

// ../../node_modules/apache-arrow/fb/key-value.mjs
var KeyValue2 = class _KeyValue {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsKeyValue(bb2, obj) {
    return (obj || new _KeyValue()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsKeyValue(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _KeyValue()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  key(optionalEncoding) {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.__string(this.bb_pos + offset2, optionalEncoding) : null;
  }
  value(optionalEncoding) {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? this.bb.__string(this.bb_pos + offset2, optionalEncoding) : null;
  }
  static startKeyValue(builder) {
    builder.startObject(2);
  }
  static addKey(builder, keyOffset) {
    builder.addFieldOffset(0, keyOffset, 0);
  }
  static addValue(builder, valueOffset) {
    builder.addFieldOffset(1, valueOffset, 0);
  }
  static endKeyValue(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createKeyValue(builder, keyOffset, valueOffset) {
    _KeyValue.startKeyValue(builder);
    _KeyValue.addKey(builder, keyOffset);
    _KeyValue.addValue(builder, valueOffset);
    return _KeyValue.endKeyValue(builder);
  }
};

// ../../node_modules/apache-arrow/fb/metadata-version.mjs
var MetadataVersion3;
(function(MetadataVersion4) {
  MetadataVersion4[MetadataVersion4["V1"] = 0] = "V1";
  MetadataVersion4[MetadataVersion4["V2"] = 1] = "V2";
  MetadataVersion4[MetadataVersion4["V3"] = 2] = "V3";
  MetadataVersion4[MetadataVersion4["V4"] = 3] = "V4";
  MetadataVersion4[MetadataVersion4["V5"] = 4] = "V5";
})(MetadataVersion3 || (MetadataVersion3 = {}));

// ../../node_modules/apache-arrow/fb/endianness.mjs
var Endianness2;
(function(Endianness3) {
  Endianness3[Endianness3["Little"] = 0] = "Little";
  Endianness3[Endianness3["Big"] = 1] = "Big";
})(Endianness2 || (Endianness2 = {}));

// ../../node_modules/apache-arrow/fb/dictionary-kind.mjs
var DictionaryKind2;
(function(DictionaryKind3) {
  DictionaryKind3[DictionaryKind3["DenseArray"] = 0] = "DenseArray";
})(DictionaryKind2 || (DictionaryKind2 = {}));

// ../../node_modules/apache-arrow/fb/int.mjs
var Int2 = class _Int {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsInt(bb2, obj) {
    return (obj || new _Int()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsInt(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Int()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  bitWidth() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 0;
  }
  isSigned() {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? !!this.bb.readInt8(this.bb_pos + offset2) : false;
  }
  static startInt(builder) {
    builder.startObject(2);
  }
  static addBitWidth(builder, bitWidth) {
    builder.addFieldInt32(0, bitWidth, 0);
  }
  static addIsSigned(builder, isSigned) {
    builder.addFieldInt8(1, +isSigned, 0);
  }
  static endInt(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createInt(builder, bitWidth, isSigned) {
    _Int.startInt(builder);
    _Int.addBitWidth(builder, bitWidth);
    _Int.addIsSigned(builder, isSigned);
    return _Int.endInt(builder);
  }
};

// ../../node_modules/apache-arrow/fb/dictionary-encoding.mjs
var DictionaryEncoding2 = class _DictionaryEncoding {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsDictionaryEncoding(bb2, obj) {
    return (obj || new _DictionaryEncoding()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsDictionaryEncoding(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _DictionaryEncoding()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  /**
   * The known dictionary id in the application where this data is used. In
   * the file or streaming formats, the dictionary ids are found in the
   * DictionaryBatch messages
   */
  id() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt64(this.bb_pos + offset2) : BigInt("0");
  }
  /**
   * The dictionary indices are constrained to be non-negative integers. If
   * this field is null, the indices must be signed int32. To maximize
   * cross-language compatibility and performance, implementations are
   * recommended to prefer signed integer types over unsigned integer types
   * and to avoid uint64 indices unless they are required by an application.
   */
  indexType(obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? (obj || new Int2()).__init(this.bb.__indirect(this.bb_pos + offset2), this.bb) : null;
  }
  /**
   * By default, dictionaries are not ordered, or the order does not have
   * semantic meaning. In some statistical, applications, dictionary-encoding
   * is used to represent ordered categorical data, and we provide a way to
   * preserve that metadata here
   */
  isOrdered() {
    const offset2 = this.bb.__offset(this.bb_pos, 8);
    return offset2 ? !!this.bb.readInt8(this.bb_pos + offset2) : false;
  }
  dictionaryKind() {
    const offset2 = this.bb.__offset(this.bb_pos, 10);
    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : DictionaryKind2.DenseArray;
  }
  static startDictionaryEncoding(builder) {
    builder.startObject(4);
  }
  static addId(builder, id2) {
    builder.addFieldInt64(0, id2, BigInt("0"));
  }
  static addIndexType(builder, indexTypeOffset) {
    builder.addFieldOffset(1, indexTypeOffset, 0);
  }
  static addIsOrdered(builder, isOrdered2) {
    builder.addFieldInt8(2, +isOrdered2, 0);
  }
  static addDictionaryKind(builder, dictionaryKind) {
    builder.addFieldInt16(3, dictionaryKind, DictionaryKind2.DenseArray);
  }
  static endDictionaryEncoding(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
};

// ../../node_modules/apache-arrow/fb/binary.mjs
var Binary4 = class _Binary {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsBinary(bb2, obj) {
    return (obj || new _Binary()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsBinary(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Binary()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static startBinary(builder) {
    builder.startObject(0);
  }
  static endBinary(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createBinary(builder) {
    _Binary.startBinary(builder);
    return _Binary.endBinary(builder);
  }
};

// ../../node_modules/apache-arrow/fb/bool.mjs
var Bool4 = class _Bool {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsBool(bb2, obj) {
    return (obj || new _Bool()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsBool(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Bool()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static startBool(builder) {
    builder.startObject(0);
  }
  static endBool(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createBool(builder) {
    _Bool.startBool(builder);
    return _Bool.endBool(builder);
  }
};

// ../../node_modules/apache-arrow/fb/date-unit.mjs
var DateUnit3;
(function(DateUnit4) {
  DateUnit4[DateUnit4["DAY"] = 0] = "DAY";
  DateUnit4[DateUnit4["MILLISECOND"] = 1] = "MILLISECOND";
})(DateUnit3 || (DateUnit3 = {}));

// ../../node_modules/apache-arrow/fb/date.mjs
var Date3 = class _Date {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsDate(bb2, obj) {
    return (obj || new _Date()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsDate(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Date()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  unit() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : DateUnit3.MILLISECOND;
  }
  static startDate(builder) {
    builder.startObject(1);
  }
  static addUnit(builder, unit3) {
    builder.addFieldInt16(0, unit3, DateUnit3.MILLISECOND);
  }
  static endDate(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createDate(builder, unit3) {
    _Date.startDate(builder);
    _Date.addUnit(builder, unit3);
    return _Date.endDate(builder);
  }
};

// ../../node_modules/apache-arrow/fb/decimal.mjs
var Decimal4 = class _Decimal {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsDecimal(bb2, obj) {
    return (obj || new _Decimal()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsDecimal(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Decimal()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  /**
   * Total number of decimal digits
   */
  precision() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 0;
  }
  /**
   * Number of digits after the decimal point "."
   */
  scale() {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 0;
  }
  /**
   * Number of bits per value. The only accepted widths are 128 and 256.
   * We use bitWidth for consistency with Int::bitWidth.
   */
  bitWidth() {
    const offset2 = this.bb.__offset(this.bb_pos, 8);
    return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 128;
  }
  static startDecimal(builder) {
    builder.startObject(3);
  }
  static addPrecision(builder, precision) {
    builder.addFieldInt32(0, precision, 0);
  }
  static addScale(builder, scale3) {
    builder.addFieldInt32(1, scale3, 0);
  }
  static addBitWidth(builder, bitWidth) {
    builder.addFieldInt32(2, bitWidth, 128);
  }
  static endDecimal(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createDecimal(builder, precision, scale3, bitWidth) {
    _Decimal.startDecimal(builder);
    _Decimal.addPrecision(builder, precision);
    _Decimal.addScale(builder, scale3);
    _Decimal.addBitWidth(builder, bitWidth);
    return _Decimal.endDecimal(builder);
  }
};

// ../../node_modules/apache-arrow/fb/time-unit.mjs
var TimeUnit3;
(function(TimeUnit4) {
  TimeUnit4[TimeUnit4["SECOND"] = 0] = "SECOND";
  TimeUnit4[TimeUnit4["MILLISECOND"] = 1] = "MILLISECOND";
  TimeUnit4[TimeUnit4["MICROSECOND"] = 2] = "MICROSECOND";
  TimeUnit4[TimeUnit4["NANOSECOND"] = 3] = "NANOSECOND";
})(TimeUnit3 || (TimeUnit3 = {}));

// ../../node_modules/apache-arrow/fb/duration.mjs
var Duration4 = class _Duration {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsDuration(bb2, obj) {
    return (obj || new _Duration()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsDuration(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Duration()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  unit() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : TimeUnit3.MILLISECOND;
  }
  static startDuration(builder) {
    builder.startObject(1);
  }
  static addUnit(builder, unit3) {
    builder.addFieldInt16(0, unit3, TimeUnit3.MILLISECOND);
  }
  static endDuration(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createDuration(builder, unit3) {
    _Duration.startDuration(builder);
    _Duration.addUnit(builder, unit3);
    return _Duration.endDuration(builder);
  }
};

// ../../node_modules/apache-arrow/fb/fixed-size-binary.mjs
var FixedSizeBinary4 = class _FixedSizeBinary {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsFixedSizeBinary(bb2, obj) {
    return (obj || new _FixedSizeBinary()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsFixedSizeBinary(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _FixedSizeBinary()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  /**
   * Number of bytes per value
   */
  byteWidth() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 0;
  }
  static startFixedSizeBinary(builder) {
    builder.startObject(1);
  }
  static addByteWidth(builder, byteWidth) {
    builder.addFieldInt32(0, byteWidth, 0);
  }
  static endFixedSizeBinary(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createFixedSizeBinary(builder, byteWidth) {
    _FixedSizeBinary.startFixedSizeBinary(builder);
    _FixedSizeBinary.addByteWidth(builder, byteWidth);
    return _FixedSizeBinary.endFixedSizeBinary(builder);
  }
};

// ../../node_modules/apache-arrow/fb/fixed-size-list.mjs
var FixedSizeList4 = class _FixedSizeList {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsFixedSizeList(bb2, obj) {
    return (obj || new _FixedSizeList()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsFixedSizeList(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _FixedSizeList()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  /**
   * Number of list items per value
   */
  listSize() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 0;
  }
  static startFixedSizeList(builder) {
    builder.startObject(1);
  }
  static addListSize(builder, listSize) {
    builder.addFieldInt32(0, listSize, 0);
  }
  static endFixedSizeList(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createFixedSizeList(builder, listSize) {
    _FixedSizeList.startFixedSizeList(builder);
    _FixedSizeList.addListSize(builder, listSize);
    return _FixedSizeList.endFixedSizeList(builder);
  }
};

// ../../node_modules/apache-arrow/fb/precision.mjs
var Precision3;
(function(Precision4) {
  Precision4[Precision4["HALF"] = 0] = "HALF";
  Precision4[Precision4["SINGLE"] = 1] = "SINGLE";
  Precision4[Precision4["DOUBLE"] = 2] = "DOUBLE";
})(Precision3 || (Precision3 = {}));

// ../../node_modules/apache-arrow/fb/floating-point.mjs
var FloatingPoint2 = class _FloatingPoint {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsFloatingPoint(bb2, obj) {
    return (obj || new _FloatingPoint()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsFloatingPoint(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _FloatingPoint()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  precision() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : Precision3.HALF;
  }
  static startFloatingPoint(builder) {
    builder.startObject(1);
  }
  static addPrecision(builder, precision) {
    builder.addFieldInt16(0, precision, Precision3.HALF);
  }
  static endFloatingPoint(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createFloatingPoint(builder, precision) {
    _FloatingPoint.startFloatingPoint(builder);
    _FloatingPoint.addPrecision(builder, precision);
    return _FloatingPoint.endFloatingPoint(builder);
  }
};

// ../../node_modules/apache-arrow/fb/interval-unit.mjs
var IntervalUnit3;
(function(IntervalUnit4) {
  IntervalUnit4[IntervalUnit4["YEAR_MONTH"] = 0] = "YEAR_MONTH";
  IntervalUnit4[IntervalUnit4["DAY_TIME"] = 1] = "DAY_TIME";
  IntervalUnit4[IntervalUnit4["MONTH_DAY_NANO"] = 2] = "MONTH_DAY_NANO";
})(IntervalUnit3 || (IntervalUnit3 = {}));

// ../../node_modules/apache-arrow/fb/interval.mjs
var Interval2 = class _Interval {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsInterval(bb2, obj) {
    return (obj || new _Interval()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsInterval(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Interval()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  unit() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : IntervalUnit3.YEAR_MONTH;
  }
  static startInterval(builder) {
    builder.startObject(1);
  }
  static addUnit(builder, unit3) {
    builder.addFieldInt16(0, unit3, IntervalUnit3.YEAR_MONTH);
  }
  static endInterval(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createInterval(builder, unit3) {
    _Interval.startInterval(builder);
    _Interval.addUnit(builder, unit3);
    return _Interval.endInterval(builder);
  }
};

// ../../node_modules/apache-arrow/fb/list.mjs
var List4 = class _List {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsList(bb2, obj) {
    return (obj || new _List()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsList(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _List()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static startList(builder) {
    builder.startObject(0);
  }
  static endList(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createList(builder) {
    _List.startList(builder);
    return _List.endList(builder);
  }
};

// ../../node_modules/apache-arrow/fb/map.mjs
var Map3 = class _Map {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsMap(bb2, obj) {
    return (obj || new _Map()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsMap(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Map()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  /**
   * Set to true if the keys within each value are sorted
   */
  keysSorted() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? !!this.bb.readInt8(this.bb_pos + offset2) : false;
  }
  static startMap(builder) {
    builder.startObject(1);
  }
  static addKeysSorted(builder, keysSorted) {
    builder.addFieldInt8(0, +keysSorted, 0);
  }
  static endMap(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createMap(builder, keysSorted) {
    _Map.startMap(builder);
    _Map.addKeysSorted(builder, keysSorted);
    return _Map.endMap(builder);
  }
};

// ../../node_modules/apache-arrow/fb/null.mjs
var Null4 = class _Null {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsNull(bb2, obj) {
    return (obj || new _Null()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsNull(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Null()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static startNull(builder) {
    builder.startObject(0);
  }
  static endNull(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createNull(builder) {
    _Null.startNull(builder);
    return _Null.endNull(builder);
  }
};

// ../../node_modules/apache-arrow/fb/struct-.mjs
var Struct_2 = class _Struct_ {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsStruct_(bb2, obj) {
    return (obj || new _Struct_()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsStruct_(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Struct_()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static startStruct_(builder) {
    builder.startObject(0);
  }
  static endStruct_(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createStruct_(builder) {
    _Struct_.startStruct_(builder);
    return _Struct_.endStruct_(builder);
  }
};

// ../../node_modules/apache-arrow/fb/time.mjs
var Time2 = class _Time {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsTime(bb2, obj) {
    return (obj || new _Time()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsTime(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Time()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  unit() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : TimeUnit3.MILLISECOND;
  }
  bitWidth() {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? this.bb.readInt32(this.bb_pos + offset2) : 32;
  }
  static startTime(builder) {
    builder.startObject(2);
  }
  static addUnit(builder, unit3) {
    builder.addFieldInt16(0, unit3, TimeUnit3.MILLISECOND);
  }
  static addBitWidth(builder, bitWidth) {
    builder.addFieldInt32(1, bitWidth, 32);
  }
  static endTime(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createTime(builder, unit3, bitWidth) {
    _Time.startTime(builder);
    _Time.addUnit(builder, unit3);
    _Time.addBitWidth(builder, bitWidth);
    return _Time.endTime(builder);
  }
};

// ../../node_modules/apache-arrow/fb/timestamp.mjs
var Timestamp2 = class _Timestamp {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsTimestamp(bb2, obj) {
    return (obj || new _Timestamp()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsTimestamp(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Timestamp()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  unit() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : TimeUnit3.SECOND;
  }
  timezone(optionalEncoding) {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? this.bb.__string(this.bb_pos + offset2, optionalEncoding) : null;
  }
  static startTimestamp(builder) {
    builder.startObject(2);
  }
  static addUnit(builder, unit3) {
    builder.addFieldInt16(0, unit3, TimeUnit3.SECOND);
  }
  static addTimezone(builder, timezoneOffset) {
    builder.addFieldOffset(1, timezoneOffset, 0);
  }
  static endTimestamp(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createTimestamp(builder, unit3, timezoneOffset) {
    _Timestamp.startTimestamp(builder);
    _Timestamp.addUnit(builder, unit3);
    _Timestamp.addTimezone(builder, timezoneOffset);
    return _Timestamp.endTimestamp(builder);
  }
};

// ../../node_modules/apache-arrow/fb/union-mode.mjs
var UnionMode3;
(function(UnionMode4) {
  UnionMode4[UnionMode4["Sparse"] = 0] = "Sparse";
  UnionMode4[UnionMode4["Dense"] = 1] = "Dense";
})(UnionMode3 || (UnionMode3 = {}));

// ../../node_modules/apache-arrow/fb/union.mjs
var Union2 = class _Union {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsUnion(bb2, obj) {
    return (obj || new _Union()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsUnion(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Union()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  mode() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : UnionMode3.Sparse;
  }
  typeIds(index2) {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset2) + index2 * 4) : 0;
  }
  typeIdsLength() {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
  }
  typeIdsArray() {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset2), this.bb.__vector_len(this.bb_pos + offset2)) : null;
  }
  static startUnion(builder) {
    builder.startObject(2);
  }
  static addMode(builder, mode3) {
    builder.addFieldInt16(0, mode3, UnionMode3.Sparse);
  }
  static addTypeIds(builder, typeIdsOffset) {
    builder.addFieldOffset(1, typeIdsOffset, 0);
  }
  static createTypeIdsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt32(data[i]);
    }
    return builder.endVector();
  }
  static startTypeIdsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static endUnion(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createUnion(builder, mode3, typeIdsOffset) {
    _Union.startUnion(builder);
    _Union.addMode(builder, mode3);
    _Union.addTypeIds(builder, typeIdsOffset);
    return _Union.endUnion(builder);
  }
};

// ../../node_modules/apache-arrow/fb/utf8.mjs
var Utf84 = class _Utf8 {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsUtf8(bb2, obj) {
    return (obj || new _Utf8()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsUtf8(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Utf8()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static startUtf8(builder) {
    builder.startObject(0);
  }
  static endUtf8(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createUtf8(builder) {
    _Utf8.startUtf8(builder);
    return _Utf8.endUtf8(builder);
  }
};

// ../../node_modules/apache-arrow/fb/type.mjs
var Type4;
(function(Type5) {
  Type5[Type5["NONE"] = 0] = "NONE";
  Type5[Type5["Null"] = 1] = "Null";
  Type5[Type5["Int"] = 2] = "Int";
  Type5[Type5["FloatingPoint"] = 3] = "FloatingPoint";
  Type5[Type5["Binary"] = 4] = "Binary";
  Type5[Type5["Utf8"] = 5] = "Utf8";
  Type5[Type5["Bool"] = 6] = "Bool";
  Type5[Type5["Decimal"] = 7] = "Decimal";
  Type5[Type5["Date"] = 8] = "Date";
  Type5[Type5["Time"] = 9] = "Time";
  Type5[Type5["Timestamp"] = 10] = "Timestamp";
  Type5[Type5["Interval"] = 11] = "Interval";
  Type5[Type5["List"] = 12] = "List";
  Type5[Type5["Struct_"] = 13] = "Struct_";
  Type5[Type5["Union"] = 14] = "Union";
  Type5[Type5["FixedSizeBinary"] = 15] = "FixedSizeBinary";
  Type5[Type5["FixedSizeList"] = 16] = "FixedSizeList";
  Type5[Type5["Map"] = 17] = "Map";
  Type5[Type5["Duration"] = 18] = "Duration";
  Type5[Type5["LargeBinary"] = 19] = "LargeBinary";
  Type5[Type5["LargeUtf8"] = 20] = "LargeUtf8";
  Type5[Type5["LargeList"] = 21] = "LargeList";
  Type5[Type5["RunEndEncoded"] = 22] = "RunEndEncoded";
})(Type4 || (Type4 = {}));

// ../../node_modules/apache-arrow/fb/field.mjs
var Field3 = class _Field {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsField(bb2, obj) {
    return (obj || new _Field()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsField(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Field()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  name(optionalEncoding) {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.__string(this.bb_pos + offset2, optionalEncoding) : null;
  }
  /**
   * Whether or not this field can contain nulls. Should be true in general.
   */
  nullable() {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? !!this.bb.readInt8(this.bb_pos + offset2) : false;
  }
  typeType() {
    const offset2 = this.bb.__offset(this.bb_pos, 8);
    return offset2 ? this.bb.readUint8(this.bb_pos + offset2) : Type4.NONE;
  }
  /**
   * This is the type of the decoded value if the field is dictionary encoded.
   */
  type(obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 10);
    return offset2 ? this.bb.__union(obj, this.bb_pos + offset2) : null;
  }
  /**
   * Present only if the field is dictionary encoded.
   */
  dictionary(obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 12);
    return offset2 ? (obj || new DictionaryEncoding2()).__init(this.bb.__indirect(this.bb_pos + offset2), this.bb) : null;
  }
  /**
   * children apply only to nested data types like Struct, List and Union. For
   * primitive types children will have length 0.
   */
  children(index2, obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 14);
    return offset2 ? (obj || new _Field()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset2) + index2 * 4), this.bb) : null;
  }
  childrenLength() {
    const offset2 = this.bb.__offset(this.bb_pos, 14);
    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
  }
  /**
   * User-defined metadata
   */
  customMetadata(index2, obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 16);
    return offset2 ? (obj || new KeyValue2()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset2) + index2 * 4), this.bb) : null;
  }
  customMetadataLength() {
    const offset2 = this.bb.__offset(this.bb_pos, 16);
    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
  }
  static startField(builder) {
    builder.startObject(7);
  }
  static addName(builder, nameOffset) {
    builder.addFieldOffset(0, nameOffset, 0);
  }
  static addNullable(builder, nullable) {
    builder.addFieldInt8(1, +nullable, 0);
  }
  static addTypeType(builder, typeType) {
    builder.addFieldInt8(2, typeType, Type4.NONE);
  }
  static addType(builder, typeOffset) {
    builder.addFieldOffset(3, typeOffset, 0);
  }
  static addDictionary(builder, dictionaryOffset) {
    builder.addFieldOffset(4, dictionaryOffset, 0);
  }
  static addChildren(builder, childrenOffset) {
    builder.addFieldOffset(5, childrenOffset, 0);
  }
  static createChildrenVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startChildrenVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addCustomMetadata(builder, customMetadataOffset) {
    builder.addFieldOffset(6, customMetadataOffset, 0);
  }
  static createCustomMetadataVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startCustomMetadataVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static endField(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
};

// ../../node_modules/apache-arrow/fb/schema.mjs
var Schema3 = class _Schema {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsSchema(bb2, obj) {
    return (obj || new _Schema()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsSchema(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Schema()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  /**
   * endianness of the buffer
   * it is Little Endian by default
   * if endianness doesn't match the underlying system then the vectors need to be converted
   */
  endianness() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : Endianness2.Little;
  }
  fields(index2, obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? (obj || new Field3()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset2) + index2 * 4), this.bb) : null;
  }
  fieldsLength() {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
  }
  customMetadata(index2, obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 8);
    return offset2 ? (obj || new KeyValue2()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset2) + index2 * 4), this.bb) : null;
  }
  customMetadataLength() {
    const offset2 = this.bb.__offset(this.bb_pos, 8);
    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
  }
  /**
   * Features used in the stream/file.
   */
  features(index2) {
    const offset2 = this.bb.__offset(this.bb_pos, 10);
    return offset2 ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset2) + index2 * 8) : BigInt(0);
  }
  featuresLength() {
    const offset2 = this.bb.__offset(this.bb_pos, 10);
    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
  }
  static startSchema(builder) {
    builder.startObject(4);
  }
  static addEndianness(builder, endianness) {
    builder.addFieldInt16(0, endianness, Endianness2.Little);
  }
  static addFields(builder, fieldsOffset) {
    builder.addFieldOffset(1, fieldsOffset, 0);
  }
  static createFieldsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startFieldsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addCustomMetadata(builder, customMetadataOffset) {
    builder.addFieldOffset(2, customMetadataOffset, 0);
  }
  static createCustomMetadataVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startCustomMetadataVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addFeatures(builder, featuresOffset) {
    builder.addFieldOffset(3, featuresOffset, 0);
  }
  static createFeaturesVector(builder, data) {
    builder.startVector(8, data.length, 8);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt64(data[i]);
    }
    return builder.endVector();
  }
  static startFeaturesVector(builder, numElems) {
    builder.startVector(8, numElems, 8);
  }
  static endSchema(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static finishSchemaBuffer(builder, offset2) {
    builder.finish(offset2);
  }
  static finishSizePrefixedSchemaBuffer(builder, offset2) {
    builder.finish(offset2, void 0, true);
  }
  static createSchema(builder, endianness, fieldsOffset, customMetadataOffset, featuresOffset) {
    _Schema.startSchema(builder);
    _Schema.addEndianness(builder, endianness);
    _Schema.addFields(builder, fieldsOffset);
    _Schema.addCustomMetadata(builder, customMetadataOffset);
    _Schema.addFeatures(builder, featuresOffset);
    return _Schema.endSchema(builder);
  }
};

// ../../node_modules/apache-arrow/fb/footer.mjs
var Footer2 = class _Footer {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsFooter(bb2, obj) {
    return (obj || new _Footer()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsFooter(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Footer()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  version() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : MetadataVersion3.V1;
  }
  schema(obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? (obj || new Schema3()).__init(this.bb.__indirect(this.bb_pos + offset2), this.bb) : null;
  }
  dictionaries(index2, obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 8);
    return offset2 ? (obj || new Block2()).__init(this.bb.__vector(this.bb_pos + offset2) + index2 * 24, this.bb) : null;
  }
  dictionariesLength() {
    const offset2 = this.bb.__offset(this.bb_pos, 8);
    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
  }
  recordBatches(index2, obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 10);
    return offset2 ? (obj || new Block2()).__init(this.bb.__vector(this.bb_pos + offset2) + index2 * 24, this.bb) : null;
  }
  recordBatchesLength() {
    const offset2 = this.bb.__offset(this.bb_pos, 10);
    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
  }
  /**
   * User-defined metadata
   */
  customMetadata(index2, obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 12);
    return offset2 ? (obj || new KeyValue2()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset2) + index2 * 4), this.bb) : null;
  }
  customMetadataLength() {
    const offset2 = this.bb.__offset(this.bb_pos, 12);
    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
  }
  static startFooter(builder) {
    builder.startObject(5);
  }
  static addVersion(builder, version) {
    builder.addFieldInt16(0, version, MetadataVersion3.V1);
  }
  static addSchema(builder, schemaOffset) {
    builder.addFieldOffset(1, schemaOffset, 0);
  }
  static addDictionaries(builder, dictionariesOffset) {
    builder.addFieldOffset(2, dictionariesOffset, 0);
  }
  static startDictionariesVector(builder, numElems) {
    builder.startVector(24, numElems, 8);
  }
  static addRecordBatches(builder, recordBatchesOffset) {
    builder.addFieldOffset(3, recordBatchesOffset, 0);
  }
  static startRecordBatchesVector(builder, numElems) {
    builder.startVector(24, numElems, 8);
  }
  static addCustomMetadata(builder, customMetadataOffset) {
    builder.addFieldOffset(4, customMetadataOffset, 0);
  }
  static createCustomMetadataVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startCustomMetadataVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static endFooter(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static finishFooterBuffer(builder, offset2) {
    builder.finish(offset2);
  }
  static finishSizePrefixedFooterBuffer(builder, offset2) {
    builder.finish(offset2, void 0, true);
  }
};

// ../../node_modules/apache-arrow/schema.mjs
var Schema4 = class _Schema {
  constructor(fields = [], metadata, dictionaries, metadataVersion = MetadataVersion2.V5) {
    this.fields = fields || [];
    this.metadata = metadata || /* @__PURE__ */ new Map();
    if (!dictionaries) {
      dictionaries = generateDictionaryMap2(fields);
    }
    this.dictionaries = dictionaries;
    this.metadataVersion = metadataVersion;
  }
  get [Symbol.toStringTag]() {
    return "Schema";
  }
  get names() {
    return this.fields.map((f2) => f2.name);
  }
  toString() {
    return `Schema<{ ${this.fields.map((f2, i) => `${i}: ${f2}`).join(", ")} }>`;
  }
  /**
   * Construct a new Schema containing only specified fields.
   *
   * @param fieldNames Names of fields to keep.
   * @returns A new Schema of fields matching the specified names.
   */
  select(fieldNames) {
    const names = new Set(fieldNames);
    const fields = this.fields.filter((f2) => names.has(f2.name));
    return new _Schema(fields, this.metadata);
  }
  /**
   * Construct a new Schema containing only fields at the specified indices.
   *
   * @param fieldIndices Indices of fields to keep.
   * @returns A new Schema of fields at the specified indices.
   */
  selectAt(fieldIndices) {
    const fields = fieldIndices.map((i) => this.fields[i]).filter(Boolean);
    return new _Schema(fields, this.metadata);
  }
  assign(...args) {
    const other = args[0] instanceof _Schema ? args[0] : Array.isArray(args[0]) ? new _Schema(args[0]) : new _Schema(args);
    const curFields = [...this.fields];
    const metadata = mergeMaps2(mergeMaps2(/* @__PURE__ */ new Map(), this.metadata), other.metadata);
    const newFields = other.fields.filter((f2) => {
      const i = curFields.findIndex((f3) => f3.name === f2.name);
      return ~i ? (curFields[i] = f2.clone({
        metadata: mergeMaps2(mergeMaps2(/* @__PURE__ */ new Map(), curFields[i].metadata), f2.metadata)
      })) && false : true;
    });
    const newDictionaries = generateDictionaryMap2(newFields, /* @__PURE__ */ new Map());
    return new _Schema([...curFields, ...newFields], metadata, new Map([...this.dictionaries, ...newDictionaries]));
  }
};
Schema4.prototype.fields = null;
Schema4.prototype.metadata = null;
Schema4.prototype.dictionaries = null;
var Field4 = class _Field {
  /** @nocollapse */
  static new(...args) {
    let [name2, type2, nullable, metadata] = args;
    if (args[0] && typeof args[0] === "object") {
      ({ name: name2 } = args[0]);
      type2 === void 0 && (type2 = args[0].type);
      nullable === void 0 && (nullable = args[0].nullable);
      metadata === void 0 && (metadata = args[0].metadata);
    }
    return new _Field(`${name2}`, type2, nullable, metadata);
  }
  constructor(name2, type2, nullable = false, metadata) {
    this.name = name2;
    this.type = type2;
    this.nullable = nullable;
    this.metadata = metadata || /* @__PURE__ */ new Map();
  }
  get typeId() {
    return this.type.typeId;
  }
  get [Symbol.toStringTag]() {
    return "Field";
  }
  toString() {
    return `${this.name}: ${this.type}`;
  }
  clone(...args) {
    let [name2, type2, nullable, metadata] = args;
    !args[0] || typeof args[0] !== "object" ? [name2 = this.name, type2 = this.type, nullable = this.nullable, metadata = this.metadata] = args : { name: name2 = this.name, type: type2 = this.type, nullable = this.nullable, metadata = this.metadata } = args[0];
    return _Field.new(name2, type2, nullable, metadata);
  }
};
Field4.prototype.type = null;
Field4.prototype.name = null;
Field4.prototype.nullable = null;
Field4.prototype.metadata = null;
function mergeMaps2(m1, m2) {
  return new Map([...m1 || /* @__PURE__ */ new Map(), ...m2 || /* @__PURE__ */ new Map()]);
}
function generateDictionaryMap2(fields, dictionaries = /* @__PURE__ */ new Map()) {
  for (let i = -1, n = fields.length; ++i < n; ) {
    const field2 = fields[i];
    const type2 = field2.type;
    if (DataType2.isDictionary(type2)) {
      if (!dictionaries.has(type2.id)) {
        dictionaries.set(type2.id, type2.dictionary);
      } else if (dictionaries.get(type2.id) !== type2.dictionary) {
        throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);
      }
    }
    if (type2.children && type2.children.length > 0) {
      generateDictionaryMap2(type2.children, dictionaries);
    }
  }
  return dictionaries;
}

// ../../node_modules/apache-arrow/ipc/metadata/file.mjs
var Builder6 = Builder;
var ByteBuffer4 = ByteBuffer;
var Footer_2 = class {
  /** @nocollapse */
  static decode(buf) {
    buf = new ByteBuffer4(toUint8Array2(buf));
    const footer = Footer2.getRootAsFooter(buf);
    const schema = Schema4.decode(footer.schema(), /* @__PURE__ */ new Map(), footer.version());
    return new OffHeapFooter2(schema, footer);
  }
  /** @nocollapse */
  static encode(footer) {
    const b2 = new Builder6();
    const schemaOffset = Schema4.encode(b2, footer.schema);
    Footer2.startRecordBatchesVector(b2, footer.numRecordBatches);
    for (const rb of [...footer.recordBatches()].slice().reverse()) {
      FileBlock2.encode(b2, rb);
    }
    const recordBatchesOffset = b2.endVector();
    Footer2.startDictionariesVector(b2, footer.numDictionaries);
    for (const db of [...footer.dictionaryBatches()].slice().reverse()) {
      FileBlock2.encode(b2, db);
    }
    const dictionaryBatchesOffset = b2.endVector();
    Footer2.startFooter(b2);
    Footer2.addSchema(b2, schemaOffset);
    Footer2.addVersion(b2, MetadataVersion2.V5);
    Footer2.addRecordBatches(b2, recordBatchesOffset);
    Footer2.addDictionaries(b2, dictionaryBatchesOffset);
    Footer2.finishFooterBuffer(b2, Footer2.endFooter(b2));
    return b2.asUint8Array();
  }
  get numRecordBatches() {
    return this._recordBatches.length;
  }
  get numDictionaries() {
    return this._dictionaryBatches.length;
  }
  constructor(schema, version = MetadataVersion2.V5, recordBatches, dictionaryBatches) {
    this.schema = schema;
    this.version = version;
    recordBatches && (this._recordBatches = recordBatches);
    dictionaryBatches && (this._dictionaryBatches = dictionaryBatches);
  }
  *recordBatches() {
    for (let block, i = -1, n = this.numRecordBatches; ++i < n; ) {
      if (block = this.getRecordBatch(i)) {
        yield block;
      }
    }
  }
  *dictionaryBatches() {
    for (let block, i = -1, n = this.numDictionaries; ++i < n; ) {
      if (block = this.getDictionaryBatch(i)) {
        yield block;
      }
    }
  }
  getRecordBatch(index2) {
    return index2 >= 0 && index2 < this.numRecordBatches && this._recordBatches[index2] || null;
  }
  getDictionaryBatch(index2) {
    return index2 >= 0 && index2 < this.numDictionaries && this._dictionaryBatches[index2] || null;
  }
};
var OffHeapFooter2 = class extends Footer_2 {
  get numRecordBatches() {
    return this._footer.recordBatchesLength();
  }
  get numDictionaries() {
    return this._footer.dictionariesLength();
  }
  constructor(schema, _footer) {
    super(schema, _footer.version());
    this._footer = _footer;
  }
  getRecordBatch(index2) {
    if (index2 >= 0 && index2 < this.numRecordBatches) {
      const fileBlock = this._footer.recordBatches(index2);
      if (fileBlock) {
        return FileBlock2.decode(fileBlock);
      }
    }
    return null;
  }
  getDictionaryBatch(index2) {
    if (index2 >= 0 && index2 < this.numDictionaries) {
      const fileBlock = this._footer.dictionaries(index2);
      if (fileBlock) {
        return FileBlock2.decode(fileBlock);
      }
    }
    return null;
  }
};
var FileBlock2 = class _FileBlock {
  /** @nocollapse */
  static decode(block) {
    return new _FileBlock(block.metaDataLength(), block.bodyLength(), block.offset());
  }
  /** @nocollapse */
  static encode(b2, fileBlock) {
    const { metaDataLength } = fileBlock;
    const offset2 = BigInt(fileBlock.offset);
    const bodyLength = BigInt(fileBlock.bodyLength);
    return Block2.createBlock(b2, offset2, metaDataLength, bodyLength);
  }
  constructor(metaDataLength, bodyLength, offset2) {
    this.metaDataLength = metaDataLength;
    this.offset = bigIntToNumber2(offset2);
    this.bodyLength = bigIntToNumber2(bodyLength);
  }
};

// ../../node_modules/apache-arrow/io/interfaces.mjs
var ITERATOR_DONE2 = Object.freeze({ done: true, value: void 0 });
var ArrowJSON2 = class {
  constructor(_json) {
    this._json = _json;
  }
  get schema() {
    return this._json["schema"];
  }
  get batches() {
    return this._json["batches"] || [];
  }
  get dictionaries() {
    return this._json["dictionaries"] || [];
  }
};
var ReadableInterop2 = class {
  tee() {
    return this._getDOMStream().tee();
  }
  pipe(writable, options) {
    return this._getNodeStream().pipe(writable, options);
  }
  pipeTo(writable, options) {
    return this._getDOMStream().pipeTo(writable, options);
  }
  pipeThrough(duplex, options) {
    return this._getDOMStream().pipeThrough(duplex, options);
  }
  _getDOMStream() {
    return this._DOMStream || (this._DOMStream = this.toDOMStream());
  }
  _getNodeStream() {
    return this._nodeStream || (this._nodeStream = this.toNodeStream());
  }
};
var AsyncQueue2 = class extends ReadableInterop2 {
  constructor() {
    super();
    this._values = [];
    this.resolvers = [];
    this._closedPromise = new Promise((r) => this._closedPromiseResolve = r);
  }
  get closed() {
    return this._closedPromise;
  }
  cancel(reason) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.return(reason);
    });
  }
  write(value) {
    if (this._ensureOpen()) {
      this.resolvers.length <= 0 ? this._values.push(value) : this.resolvers.shift().resolve({ done: false, value });
    }
  }
  abort(value) {
    if (this._closedPromiseResolve) {
      this.resolvers.length <= 0 ? this._error = { error: value } : this.resolvers.shift().reject({ done: true, value });
    }
  }
  close() {
    if (this._closedPromiseResolve) {
      const { resolvers } = this;
      while (resolvers.length > 0) {
        resolvers.shift().resolve(ITERATOR_DONE2);
      }
      this._closedPromiseResolve();
      this._closedPromiseResolve = void 0;
    }
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  toDOMStream(options) {
    return adapters_default2.toDOMStream(this._closedPromiseResolve || this._error ? this : this._values, options);
  }
  toNodeStream(options) {
    return adapters_default2.toNodeStream(this._closedPromiseResolve || this._error ? this : this._values, options);
  }
  throw(_2) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.abort(_2);
      return ITERATOR_DONE2;
    });
  }
  return(_2) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.close();
      return ITERATOR_DONE2;
    });
  }
  read(size) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.next(size, "read")).value;
    });
  }
  peek(size) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.next(size, "peek")).value;
    });
  }
  next(..._args) {
    if (this._values.length > 0) {
      return Promise.resolve({ done: false, value: this._values.shift() });
    } else if (this._error) {
      return Promise.reject({ done: true, value: this._error.error });
    } else if (!this._closedPromiseResolve) {
      return Promise.resolve(ITERATOR_DONE2);
    } else {
      return new Promise((resolve, reject) => {
        this.resolvers.push({ resolve, reject });
      });
    }
  }
  _ensureOpen() {
    if (this._closedPromiseResolve) {
      return true;
    }
    throw new Error(`AsyncQueue is closed`);
  }
};

// ../../node_modules/apache-arrow/io/stream.mjs
var AsyncByteQueue2 = class extends AsyncQueue2 {
  write(value) {
    if ((value = toUint8Array2(value)).byteLength > 0) {
      return super.write(value);
    }
  }
  toString(sync = false) {
    return sync ? decodeUtf82(this.toUint8Array(true)) : this.toUint8Array(false).then(decodeUtf82);
  }
  toUint8Array(sync = false) {
    return sync ? joinUint8Arrays2(this._values)[0] : (() => __awaiter(this, void 0, void 0, function* () {
      var _a9, e_1, _b3, _c3;
      const buffers = [];
      let byteLength = 0;
      try {
        for (var _d3 = true, _e3 = __asyncValues(this), _f3; _f3 = yield _e3.next(), _a9 = _f3.done, !_a9; _d3 = true) {
          _c3 = _f3.value;
          _d3 = false;
          const chunk = _c3;
          buffers.push(chunk);
          byteLength += chunk.byteLength;
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (!_d3 && !_a9 && (_b3 = _e3.return))
            yield _b3.call(_e3);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return joinUint8Arrays2(buffers, byteLength)[0];
    }))();
  }
};
var ByteStream2 = class {
  constructor(source) {
    if (source) {
      this.source = new ByteStreamSource2(adapters_default2.fromIterable(source));
    }
  }
  [Symbol.iterator]() {
    return this;
  }
  next(value) {
    return this.source.next(value);
  }
  throw(value) {
    return this.source.throw(value);
  }
  return(value) {
    return this.source.return(value);
  }
  peek(size) {
    return this.source.peek(size);
  }
  read(size) {
    return this.source.read(size);
  }
};
var AsyncByteStream2 = class _AsyncByteStream {
  constructor(source) {
    if (source instanceof _AsyncByteStream) {
      this.source = source.source;
    } else if (source instanceof AsyncByteQueue2) {
      this.source = new AsyncByteStreamSource2(adapters_default2.fromAsyncIterable(source));
    } else if (isReadableNodeStream2(source)) {
      this.source = new AsyncByteStreamSource2(adapters_default2.fromNodeStream(source));
    } else if (isReadableDOMStream2(source)) {
      this.source = new AsyncByteStreamSource2(adapters_default2.fromDOMStream(source));
    } else if (isFetchResponse2(source)) {
      this.source = new AsyncByteStreamSource2(adapters_default2.fromDOMStream(source.body));
    } else if (isIterable2(source)) {
      this.source = new AsyncByteStreamSource2(adapters_default2.fromIterable(source));
    } else if (isPromise2(source)) {
      this.source = new AsyncByteStreamSource2(adapters_default2.fromAsyncIterable(source));
    } else if (isAsyncIterable2(source)) {
      this.source = new AsyncByteStreamSource2(adapters_default2.fromAsyncIterable(source));
    }
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  next(value) {
    return this.source.next(value);
  }
  throw(value) {
    return this.source.throw(value);
  }
  return(value) {
    return this.source.return(value);
  }
  get closed() {
    return this.source.closed;
  }
  cancel(reason) {
    return this.source.cancel(reason);
  }
  peek(size) {
    return this.source.peek(size);
  }
  read(size) {
    return this.source.read(size);
  }
};
var ByteStreamSource2 = class {
  constructor(source) {
    this.source = source;
  }
  cancel(reason) {
    this.return(reason);
  }
  peek(size) {
    return this.next(size, "peek").value;
  }
  read(size) {
    return this.next(size, "read").value;
  }
  next(size, cmd = "read") {
    return this.source.next({ cmd, size });
  }
  throw(value) {
    return Object.create(this.source.throw && this.source.throw(value) || ITERATOR_DONE2);
  }
  return(value) {
    return Object.create(this.source.return && this.source.return(value) || ITERATOR_DONE2);
  }
};
var AsyncByteStreamSource2 = class {
  constructor(source) {
    this.source = source;
    this._closedPromise = new Promise((r) => this._closedPromiseResolve = r);
  }
  cancel(reason) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.return(reason);
    });
  }
  get closed() {
    return this._closedPromise;
  }
  read(size) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.next(size, "read")).value;
    });
  }
  peek(size) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.next(size, "peek")).value;
    });
  }
  next(size, cmd = "read") {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this.source.next({ cmd, size });
    });
  }
  throw(value) {
    return __awaiter(this, void 0, void 0, function* () {
      const result = this.source.throw && (yield this.source.throw(value)) || ITERATOR_DONE2;
      this._closedPromiseResolve && this._closedPromiseResolve();
      this._closedPromiseResolve = void 0;
      return Object.create(result);
    });
  }
  return(value) {
    return __awaiter(this, void 0, void 0, function* () {
      const result = this.source.return && (yield this.source.return(value)) || ITERATOR_DONE2;
      this._closedPromiseResolve && this._closedPromiseResolve();
      this._closedPromiseResolve = void 0;
      return Object.create(result);
    });
  }
};

// ../../node_modules/apache-arrow/io/file.mjs
var RandomAccessFile2 = class extends ByteStream2 {
  constructor(buffer, byteLength) {
    super();
    this.position = 0;
    this.buffer = toUint8Array2(buffer);
    this.size = byteLength === void 0 ? this.buffer.byteLength : byteLength;
  }
  readInt32(position3) {
    const { buffer, byteOffset } = this.readAt(position3, 4);
    return new DataView(buffer, byteOffset).getInt32(0, true);
  }
  seek(position3) {
    this.position = Math.min(position3, this.size);
    return position3 < this.size;
  }
  read(nBytes) {
    const { buffer, size, position: position3 } = this;
    if (buffer && position3 < size) {
      if (typeof nBytes !== "number") {
        nBytes = Number.POSITIVE_INFINITY;
      }
      this.position = Math.min(size, position3 + Math.min(size - position3, nBytes));
      return buffer.subarray(position3, this.position);
    }
    return null;
  }
  readAt(position3, nBytes) {
    const buf = this.buffer;
    const end = Math.min(this.size, position3 + nBytes);
    return buf ? buf.subarray(position3, end) : new Uint8Array(nBytes);
  }
  close() {
    this.buffer && (this.buffer = null);
  }
  throw(value) {
    this.close();
    return { done: true, value };
  }
  return(value) {
    this.close();
    return { done: true, value };
  }
};
var AsyncRandomAccessFile2 = class extends AsyncByteStream2 {
  constructor(file, byteLength) {
    super();
    this.position = 0;
    this._handle = file;
    if (typeof byteLength === "number") {
      this.size = byteLength;
    } else {
      this._pending = (() => __awaiter(this, void 0, void 0, function* () {
        this.size = (yield file.stat()).size;
        delete this._pending;
      }))();
    }
  }
  readInt32(position3) {
    return __awaiter(this, void 0, void 0, function* () {
      const { buffer, byteOffset } = yield this.readAt(position3, 4);
      return new DataView(buffer, byteOffset).getInt32(0, true);
    });
  }
  seek(position3) {
    return __awaiter(this, void 0, void 0, function* () {
      this._pending && (yield this._pending);
      this.position = Math.min(position3, this.size);
      return position3 < this.size;
    });
  }
  read(nBytes) {
    return __awaiter(this, void 0, void 0, function* () {
      this._pending && (yield this._pending);
      const { _handle: file, size, position: position3 } = this;
      if (file && position3 < size) {
        if (typeof nBytes !== "number") {
          nBytes = Number.POSITIVE_INFINITY;
        }
        let pos = position3, offset2 = 0, bytesRead = 0;
        const end = Math.min(size, pos + Math.min(size - pos, nBytes));
        const buffer = new Uint8Array(Math.max(0, (this.position = end) - pos));
        while ((pos += bytesRead) < end && (offset2 += bytesRead) < buffer.byteLength) {
          ({ bytesRead } = yield file.read(buffer, offset2, buffer.byteLength - offset2, pos));
        }
        return buffer;
      }
      return null;
    });
  }
  readAt(position3, nBytes) {
    return __awaiter(this, void 0, void 0, function* () {
      this._pending && (yield this._pending);
      const { _handle: file, size } = this;
      if (file && position3 + nBytes < size) {
        const end = Math.min(size, position3 + nBytes);
        const buffer = new Uint8Array(end - position3);
        return (yield file.read(buffer, 0, nBytes, position3)).buffer;
      }
      return new Uint8Array(nBytes);
    });
  }
  close() {
    return __awaiter(this, void 0, void 0, function* () {
      const f2 = this._handle;
      this._handle = null;
      f2 && (yield f2.close());
    });
  }
  throw(value) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.close();
      return { done: true, value };
    });
  }
  return(value) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.close();
      return { done: true, value };
    });
  }
};

// ../../node_modules/apache-arrow/util/int.mjs
var int_exports2 = {};
__export(int_exports2, {
  BaseInt64: () => BaseInt642,
  Int128: () => Int1282,
  Int64: () => Int644,
  Uint64: () => Uint644
});
var carryBit162 = 1 << 16;
function intAsHex2(value) {
  if (value < 0) {
    value = 4294967295 + value + 1;
  }
  return `0x${value.toString(16)}`;
}
var kInt32DecimalDigits2 = 8;
var kPowersOfTen2 = [
  1,
  10,
  100,
  1e3,
  1e4,
  1e5,
  1e6,
  1e7,
  1e8
];
var BaseInt642 = class {
  constructor(buffer) {
    this.buffer = buffer;
  }
  high() {
    return this.buffer[1];
  }
  low() {
    return this.buffer[0];
  }
  _times(other) {
    const L2 = new Uint32Array([
      this.buffer[1] >>> 16,
      this.buffer[1] & 65535,
      this.buffer[0] >>> 16,
      this.buffer[0] & 65535
    ]);
    const R2 = new Uint32Array([
      other.buffer[1] >>> 16,
      other.buffer[1] & 65535,
      other.buffer[0] >>> 16,
      other.buffer[0] & 65535
    ]);
    let product2 = L2[3] * R2[3];
    this.buffer[0] = product2 & 65535;
    let sum5 = product2 >>> 16;
    product2 = L2[2] * R2[3];
    sum5 += product2;
    product2 = L2[3] * R2[2] >>> 0;
    sum5 += product2;
    this.buffer[0] += sum5 << 16;
    this.buffer[1] = sum5 >>> 0 < product2 ? carryBit162 : 0;
    this.buffer[1] += sum5 >>> 16;
    this.buffer[1] += L2[1] * R2[3] + L2[2] * R2[2] + L2[3] * R2[1];
    this.buffer[1] += L2[0] * R2[3] + L2[1] * R2[2] + L2[2] * R2[1] + L2[3] * R2[0] << 16;
    return this;
  }
  _plus(other) {
    const sum5 = this.buffer[0] + other.buffer[0] >>> 0;
    this.buffer[1] += other.buffer[1];
    if (sum5 < this.buffer[0] >>> 0) {
      ++this.buffer[1];
    }
    this.buffer[0] = sum5;
  }
  lessThan(other) {
    return this.buffer[1] < other.buffer[1] || this.buffer[1] === other.buffer[1] && this.buffer[0] < other.buffer[0];
  }
  equals(other) {
    return this.buffer[1] === other.buffer[1] && this.buffer[0] == other.buffer[0];
  }
  greaterThan(other) {
    return other.lessThan(this);
  }
  hex() {
    return `${intAsHex2(this.buffer[1])} ${intAsHex2(this.buffer[0])}`;
  }
};
var Uint644 = class _Uint64 extends BaseInt642 {
  times(other) {
    this._times(other);
    return this;
  }
  plus(other) {
    this._plus(other);
    return this;
  }
  /** @nocollapse */
  static from(val, out_buffer = new Uint32Array(2)) {
    return _Uint64.fromString(typeof val === "string" ? val : val.toString(), out_buffer);
  }
  /** @nocollapse */
  static fromNumber(num, out_buffer = new Uint32Array(2)) {
    return _Uint64.fromString(num.toString(), out_buffer);
  }
  /** @nocollapse */
  static fromString(str, out_buffer = new Uint32Array(2)) {
    const length4 = str.length;
    const out = new _Uint64(out_buffer);
    for (let posn = 0; posn < length4; ) {
      const group3 = kInt32DecimalDigits2 < length4 - posn ? kInt32DecimalDigits2 : length4 - posn;
      const chunk = new _Uint64(new Uint32Array([Number.parseInt(str.slice(posn, posn + group3), 10), 0]));
      const multiple = new _Uint64(new Uint32Array([kPowersOfTen2[group3], 0]));
      out.times(multiple);
      out.plus(chunk);
      posn += group3;
    }
    return out;
  }
  /** @nocollapse */
  static convertArray(values2) {
    const data = new Uint32Array(values2.length * 2);
    for (let i = -1, n = values2.length; ++i < n; ) {
      _Uint64.from(values2[i], new Uint32Array(data.buffer, data.byteOffset + 2 * i * 4, 2));
    }
    return data;
  }
  /** @nocollapse */
  static multiply(left2, right2) {
    const rtrn = new _Uint64(new Uint32Array(left2.buffer));
    return rtrn.times(right2);
  }
  /** @nocollapse */
  static add(left2, right2) {
    const rtrn = new _Uint64(new Uint32Array(left2.buffer));
    return rtrn.plus(right2);
  }
};
var Int644 = class _Int64 extends BaseInt642 {
  negate() {
    this.buffer[0] = ~this.buffer[0] + 1;
    this.buffer[1] = ~this.buffer[1];
    if (this.buffer[0] == 0) {
      ++this.buffer[1];
    }
    return this;
  }
  times(other) {
    this._times(other);
    return this;
  }
  plus(other) {
    this._plus(other);
    return this;
  }
  lessThan(other) {
    const this_high = this.buffer[1] << 0;
    const other_high = other.buffer[1] << 0;
    return this_high < other_high || this_high === other_high && this.buffer[0] < other.buffer[0];
  }
  /** @nocollapse */
  static from(val, out_buffer = new Uint32Array(2)) {
    return _Int64.fromString(typeof val === "string" ? val : val.toString(), out_buffer);
  }
  /** @nocollapse */
  static fromNumber(num, out_buffer = new Uint32Array(2)) {
    return _Int64.fromString(num.toString(), out_buffer);
  }
  /** @nocollapse */
  static fromString(str, out_buffer = new Uint32Array(2)) {
    const negate2 = str.startsWith("-");
    const length4 = str.length;
    const out = new _Int64(out_buffer);
    for (let posn = negate2 ? 1 : 0; posn < length4; ) {
      const group3 = kInt32DecimalDigits2 < length4 - posn ? kInt32DecimalDigits2 : length4 - posn;
      const chunk = new _Int64(new Uint32Array([Number.parseInt(str.slice(posn, posn + group3), 10), 0]));
      const multiple = new _Int64(new Uint32Array([kPowersOfTen2[group3], 0]));
      out.times(multiple);
      out.plus(chunk);
      posn += group3;
    }
    return negate2 ? out.negate() : out;
  }
  /** @nocollapse */
  static convertArray(values2) {
    const data = new Uint32Array(values2.length * 2);
    for (let i = -1, n = values2.length; ++i < n; ) {
      _Int64.from(values2[i], new Uint32Array(data.buffer, data.byteOffset + 2 * i * 4, 2));
    }
    return data;
  }
  /** @nocollapse */
  static multiply(left2, right2) {
    const rtrn = new _Int64(new Uint32Array(left2.buffer));
    return rtrn.times(right2);
  }
  /** @nocollapse */
  static add(left2, right2) {
    const rtrn = new _Int64(new Uint32Array(left2.buffer));
    return rtrn.plus(right2);
  }
};
var Int1282 = class _Int128 {
  constructor(buffer) {
    this.buffer = buffer;
  }
  high() {
    return new Int644(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));
  }
  low() {
    return new Int644(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset, 2));
  }
  negate() {
    this.buffer[0] = ~this.buffer[0] + 1;
    this.buffer[1] = ~this.buffer[1];
    this.buffer[2] = ~this.buffer[2];
    this.buffer[3] = ~this.buffer[3];
    if (this.buffer[0] == 0) {
      ++this.buffer[1];
    }
    if (this.buffer[1] == 0) {
      ++this.buffer[2];
    }
    if (this.buffer[2] == 0) {
      ++this.buffer[3];
    }
    return this;
  }
  times(other) {
    const L0 = new Uint644(new Uint32Array([this.buffer[3], 0]));
    const L1 = new Uint644(new Uint32Array([this.buffer[2], 0]));
    const L2 = new Uint644(new Uint32Array([this.buffer[1], 0]));
    const L3 = new Uint644(new Uint32Array([this.buffer[0], 0]));
    const R0 = new Uint644(new Uint32Array([other.buffer[3], 0]));
    const R1 = new Uint644(new Uint32Array([other.buffer[2], 0]));
    const R2 = new Uint644(new Uint32Array([other.buffer[1], 0]));
    const R3 = new Uint644(new Uint32Array([other.buffer[0], 0]));
    let product2 = Uint644.multiply(L3, R3);
    this.buffer[0] = product2.low();
    const sum5 = new Uint644(new Uint32Array([product2.high(), 0]));
    product2 = Uint644.multiply(L2, R3);
    sum5.plus(product2);
    product2 = Uint644.multiply(L3, R2);
    sum5.plus(product2);
    this.buffer[1] = sum5.low();
    this.buffer[3] = sum5.lessThan(product2) ? 1 : 0;
    this.buffer[2] = sum5.high();
    const high = new Uint644(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));
    high.plus(Uint644.multiply(L1, R3)).plus(Uint644.multiply(L2, R2)).plus(Uint644.multiply(L3, R1));
    this.buffer[3] += Uint644.multiply(L0, R3).plus(Uint644.multiply(L1, R2)).plus(Uint644.multiply(L2, R1)).plus(Uint644.multiply(L3, R0)).low();
    return this;
  }
  plus(other) {
    const sums = new Uint32Array(4);
    sums[3] = this.buffer[3] + other.buffer[3] >>> 0;
    sums[2] = this.buffer[2] + other.buffer[2] >>> 0;
    sums[1] = this.buffer[1] + other.buffer[1] >>> 0;
    sums[0] = this.buffer[0] + other.buffer[0] >>> 0;
    if (sums[0] < this.buffer[0] >>> 0) {
      ++sums[1];
    }
    if (sums[1] < this.buffer[1] >>> 0) {
      ++sums[2];
    }
    if (sums[2] < this.buffer[2] >>> 0) {
      ++sums[3];
    }
    this.buffer[3] = sums[3];
    this.buffer[2] = sums[2];
    this.buffer[1] = sums[1];
    this.buffer[0] = sums[0];
    return this;
  }
  hex() {
    return `${intAsHex2(this.buffer[3])} ${intAsHex2(this.buffer[2])} ${intAsHex2(this.buffer[1])} ${intAsHex2(this.buffer[0])}`;
  }
  /** @nocollapse */
  static multiply(left2, right2) {
    const rtrn = new _Int128(new Uint32Array(left2.buffer));
    return rtrn.times(right2);
  }
  /** @nocollapse */
  static add(left2, right2) {
    const rtrn = new _Int128(new Uint32Array(left2.buffer));
    return rtrn.plus(right2);
  }
  /** @nocollapse */
  static from(val, out_buffer = new Uint32Array(4)) {
    return _Int128.fromString(typeof val === "string" ? val : val.toString(), out_buffer);
  }
  /** @nocollapse */
  static fromNumber(num, out_buffer = new Uint32Array(4)) {
    return _Int128.fromString(num.toString(), out_buffer);
  }
  /** @nocollapse */
  static fromString(str, out_buffer = new Uint32Array(4)) {
    const negate2 = str.startsWith("-");
    const length4 = str.length;
    const out = new _Int128(out_buffer);
    for (let posn = negate2 ? 1 : 0; posn < length4; ) {
      const group3 = kInt32DecimalDigits2 < length4 - posn ? kInt32DecimalDigits2 : length4 - posn;
      const chunk = new _Int128(new Uint32Array([Number.parseInt(str.slice(posn, posn + group3), 10), 0, 0, 0]));
      const multiple = new _Int128(new Uint32Array([kPowersOfTen2[group3], 0, 0, 0]));
      out.times(multiple);
      out.plus(chunk);
      posn += group3;
    }
    return negate2 ? out.negate() : out;
  }
  /** @nocollapse */
  static convertArray(values2) {
    const data = new Uint32Array(values2.length * 4);
    for (let i = -1, n = values2.length; ++i < n; ) {
      _Int128.from(values2[i], new Uint32Array(data.buffer, data.byteOffset + 4 * 4 * i, 4));
    }
    return data;
  }
};

// ../../node_modules/apache-arrow/visitor/vectorloader.mjs
var VectorLoader2 = class extends Visitor2 {
  constructor(bytes, nodes, buffers, dictionaries, metadataVersion = MetadataVersion2.V5) {
    super();
    this.nodesIndex = -1;
    this.buffersIndex = -1;
    this.bytes = bytes;
    this.nodes = nodes;
    this.buffers = buffers;
    this.dictionaries = dictionaries;
    this.metadataVersion = metadataVersion;
  }
  visit(node) {
    return super.visit(node instanceof Field4 ? node.type : node);
  }
  visitNull(type2, { length: length4 } = this.nextFieldNode()) {
    return makeData2({ type: type2, length: length4 });
  }
  visitBool(type2, { length: length4, nullCount } = this.nextFieldNode()) {
    return makeData2({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });
  }
  visitInt(type2, { length: length4, nullCount } = this.nextFieldNode()) {
    return makeData2({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });
  }
  visitFloat(type2, { length: length4, nullCount } = this.nextFieldNode()) {
    return makeData2({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });
  }
  visitUtf8(type2, { length: length4, nullCount } = this.nextFieldNode()) {
    return makeData2({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), valueOffsets: this.readOffsets(type2), data: this.readData(type2) });
  }
  visitBinary(type2, { length: length4, nullCount } = this.nextFieldNode()) {
    return makeData2({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), valueOffsets: this.readOffsets(type2), data: this.readData(type2) });
  }
  visitFixedSizeBinary(type2, { length: length4, nullCount } = this.nextFieldNode()) {
    return makeData2({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });
  }
  visitDate(type2, { length: length4, nullCount } = this.nextFieldNode()) {
    return makeData2({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });
  }
  visitTimestamp(type2, { length: length4, nullCount } = this.nextFieldNode()) {
    return makeData2({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });
  }
  visitTime(type2, { length: length4, nullCount } = this.nextFieldNode()) {
    return makeData2({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });
  }
  visitDecimal(type2, { length: length4, nullCount } = this.nextFieldNode()) {
    return makeData2({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });
  }
  visitList(type2, { length: length4, nullCount } = this.nextFieldNode()) {
    return makeData2({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), valueOffsets: this.readOffsets(type2), "child": this.visit(type2.children[0]) });
  }
  visitStruct(type2, { length: length4, nullCount } = this.nextFieldNode()) {
    return makeData2({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), children: this.visitMany(type2.children) });
  }
  visitUnion(type2, { length: length4, nullCount } = this.nextFieldNode()) {
    if (this.metadataVersion < MetadataVersion2.V5) {
      this.readNullBitmap(type2, nullCount);
    }
    return type2.mode === UnionMode2.Sparse ? this.visitSparseUnion(type2, { length: length4, nullCount }) : this.visitDenseUnion(type2, { length: length4, nullCount });
  }
  visitDenseUnion(type2, { length: length4, nullCount } = this.nextFieldNode()) {
    return makeData2({ type: type2, length: length4, nullCount, typeIds: this.readTypeIds(type2), valueOffsets: this.readOffsets(type2), children: this.visitMany(type2.children) });
  }
  visitSparseUnion(type2, { length: length4, nullCount } = this.nextFieldNode()) {
    return makeData2({ type: type2, length: length4, nullCount, typeIds: this.readTypeIds(type2), children: this.visitMany(type2.children) });
  }
  visitDictionary(type2, { length: length4, nullCount } = this.nextFieldNode()) {
    return makeData2({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2.indices), dictionary: this.readDictionary(type2) });
  }
  visitInterval(type2, { length: length4, nullCount } = this.nextFieldNode()) {
    return makeData2({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });
  }
  visitDuration(type2, { length: length4, nullCount } = this.nextFieldNode()) {
    return makeData2({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), data: this.readData(type2) });
  }
  visitFixedSizeList(type2, { length: length4, nullCount } = this.nextFieldNode()) {
    return makeData2({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), "child": this.visit(type2.children[0]) });
  }
  visitMap(type2, { length: length4, nullCount } = this.nextFieldNode()) {
    return makeData2({ type: type2, length: length4, nullCount, nullBitmap: this.readNullBitmap(type2, nullCount), valueOffsets: this.readOffsets(type2), "child": this.visit(type2.children[0]) });
  }
  nextFieldNode() {
    return this.nodes[++this.nodesIndex];
  }
  nextBufferRange() {
    return this.buffers[++this.buffersIndex];
  }
  readNullBitmap(type2, nullCount, buffer = this.nextBufferRange()) {
    return nullCount > 0 && this.readData(type2, buffer) || new Uint8Array(0);
  }
  readOffsets(type2, buffer) {
    return this.readData(type2, buffer);
  }
  readTypeIds(type2, buffer) {
    return this.readData(type2, buffer);
  }
  readData(_type, { length: length4, offset: offset2 } = this.nextBufferRange()) {
    return this.bytes.subarray(offset2, offset2 + length4);
  }
  readDictionary(type2) {
    return this.dictionaries.get(type2.id);
  }
};
var JSONVectorLoader2 = class extends VectorLoader2 {
  constructor(sources, nodes, buffers, dictionaries, metadataVersion) {
    super(new Uint8Array(0), nodes, buffers, dictionaries, metadataVersion);
    this.sources = sources;
  }
  readNullBitmap(_type, nullCount, { offset: offset2 } = this.nextBufferRange()) {
    return nullCount <= 0 ? new Uint8Array(0) : packBools2(this.sources[offset2]);
  }
  readOffsets(_type, { offset: offset2 } = this.nextBufferRange()) {
    return toArrayBufferView2(Uint8Array, toArrayBufferView2(Int32Array, this.sources[offset2]));
  }
  readTypeIds(type2, { offset: offset2 } = this.nextBufferRange()) {
    return toArrayBufferView2(Uint8Array, toArrayBufferView2(type2.ArrayType, this.sources[offset2]));
  }
  readData(type2, { offset: offset2 } = this.nextBufferRange()) {
    const { sources } = this;
    if (DataType2.isTimestamp(type2)) {
      return toArrayBufferView2(Uint8Array, Int644.convertArray(sources[offset2]));
    } else if ((DataType2.isInt(type2) || DataType2.isTime(type2)) && type2.bitWidth === 64 || DataType2.isDuration(type2)) {
      return toArrayBufferView2(Uint8Array, Int644.convertArray(sources[offset2]));
    } else if (DataType2.isDate(type2) && type2.unit === DateUnit2.MILLISECOND) {
      return toArrayBufferView2(Uint8Array, Int644.convertArray(sources[offset2]));
    } else if (DataType2.isDecimal(type2)) {
      return toArrayBufferView2(Uint8Array, Int1282.convertArray(sources[offset2]));
    } else if (DataType2.isBinary(type2) || DataType2.isFixedSizeBinary(type2)) {
      return binaryDataFromJSON2(sources[offset2]);
    } else if (DataType2.isBool(type2)) {
      return packBools2(sources[offset2]);
    } else if (DataType2.isUtf8(type2)) {
      return encodeUtf82(sources[offset2].join(""));
    }
    return toArrayBufferView2(Uint8Array, toArrayBufferView2(type2.ArrayType, sources[offset2].map((x4) => +x4)));
  }
};
function binaryDataFromJSON2(values2) {
  const joined = values2.join("");
  const data = new Uint8Array(joined.length / 2);
  for (let i = 0; i < joined.length; i += 2) {
    data[i >> 1] = Number.parseInt(joined.slice(i, i + 2), 16);
  }
  return data;
}

// ../../node_modules/apache-arrow/builder/binary.mjs
var BinaryBuilder2 = class extends VariableWidthBuilder2 {
  constructor(opts) {
    super(opts);
    this._values = new BufferBuilder2(new Uint8Array(0));
  }
  get byteLength() {
    let size = this._pendingLength + this.length * 4;
    this._offsets && (size += this._offsets.byteLength);
    this._values && (size += this._values.byteLength);
    this._nulls && (size += this._nulls.byteLength);
    return size;
  }
  setValue(index2, value) {
    return super.setValue(index2, toUint8Array2(value));
  }
  _flushPending(pending, pendingLength) {
    const offsets = this._offsets;
    const data = this._values.reserve(pendingLength).buffer;
    let offset2 = 0;
    for (const [index2, value] of pending) {
      if (value === void 0) {
        offsets.set(index2, 0);
      } else {
        const length4 = value.length;
        data.set(value, offset2);
        offsets.set(index2, length4);
        offset2 += length4;
      }
    }
  }
};

// ../../node_modules/apache-arrow/builder/bool.mjs
var BoolBuilder2 = class extends Builder5 {
  constructor(options) {
    super(options);
    this._values = new BitmapBufferBuilder2();
  }
  setValue(index2, value) {
    this._values.set(index2, +value);
  }
};

// ../../node_modules/apache-arrow/builder/date.mjs
var DateBuilder2 = class extends FixedWidthBuilder2 {
};
DateBuilder2.prototype._setValue = setDate2;
var DateDayBuilder2 = class extends DateBuilder2 {
};
DateDayBuilder2.prototype._setValue = setDateDay2;
var DateMillisecondBuilder2 = class extends DateBuilder2 {
};
DateMillisecondBuilder2.prototype._setValue = setDateMillisecond2;

// ../../node_modules/apache-arrow/builder/decimal.mjs
var DecimalBuilder2 = class extends FixedWidthBuilder2 {
};
DecimalBuilder2.prototype._setValue = setDecimal2;

// ../../node_modules/apache-arrow/builder/dictionary.mjs
var DictionaryBuilder2 = class extends Builder5 {
  constructor({ "type": type2, "nullValues": nulls, "dictionaryHashFunction": hashFn }) {
    super({ type: new Dictionary2(type2.dictionary, type2.indices, type2.id, type2.isOrdered) });
    this._nulls = null;
    this._dictionaryOffset = 0;
    this._keysToIndices = /* @__PURE__ */ Object.create(null);
    this.indices = makeBuilder2({ "type": this.type.indices, "nullValues": nulls });
    this.dictionary = makeBuilder2({ "type": this.type.dictionary, "nullValues": null });
    if (typeof hashFn === "function") {
      this.valueToKey = hashFn;
    }
  }
  get values() {
    return this.indices.values;
  }
  get nullCount() {
    return this.indices.nullCount;
  }
  get nullBitmap() {
    return this.indices.nullBitmap;
  }
  get byteLength() {
    return this.indices.byteLength + this.dictionary.byteLength;
  }
  get reservedLength() {
    return this.indices.reservedLength + this.dictionary.reservedLength;
  }
  get reservedByteLength() {
    return this.indices.reservedByteLength + this.dictionary.reservedByteLength;
  }
  isValid(value) {
    return this.indices.isValid(value);
  }
  setValid(index2, valid2) {
    const indices = this.indices;
    valid2 = indices.setValid(index2, valid2);
    this.length = indices.length;
    return valid2;
  }
  setValue(index2, value) {
    const keysToIndices = this._keysToIndices;
    const key = this.valueToKey(value);
    let idx = keysToIndices[key];
    if (idx === void 0) {
      keysToIndices[key] = idx = this._dictionaryOffset + this.dictionary.append(value).length - 1;
    }
    return this.indices.setValue(index2, idx);
  }
  flush() {
    const type2 = this.type;
    const prev = this._dictionary;
    const curr = this.dictionary.toVector();
    const data = this.indices.flush().clone(type2);
    data.dictionary = prev ? prev.concat(curr) : curr;
    this.finished || (this._dictionaryOffset += curr.length);
    this._dictionary = data.dictionary;
    this.clear();
    return data;
  }
  finish() {
    this.indices.finish();
    this.dictionary.finish();
    this._dictionaryOffset = 0;
    this._keysToIndices = /* @__PURE__ */ Object.create(null);
    return super.finish();
  }
  clear() {
    this.indices.clear();
    this.dictionary.clear();
    return super.clear();
  }
  valueToKey(val) {
    return typeof val === "string" ? val : `${val}`;
  }
};

// ../../node_modules/apache-arrow/builder/fixedsizebinary.mjs
var FixedSizeBinaryBuilder2 = class extends FixedWidthBuilder2 {
};
FixedSizeBinaryBuilder2.prototype._setValue = setFixedSizeBinary2;

// ../../node_modules/apache-arrow/builder/fixedsizelist.mjs
var FixedSizeListBuilder2 = class extends Builder5 {
  setValue(index2, value) {
    const [child] = this.children;
    const start2 = index2 * this.stride;
    for (let i = -1, n = value.length; ++i < n; ) {
      child.set(start2 + i, value[i]);
    }
  }
  addChild(child, name2 = "0") {
    if (this.numChildren > 0) {
      throw new Error("FixedSizeListBuilder can only have one child.");
    }
    const childIndex = this.children.push(child);
    this.type = new FixedSizeList3(this.type.listSize, new Field4(name2, child.type, true));
    return childIndex;
  }
};

// ../../node_modules/apache-arrow/builder/float.mjs
var FloatBuilder2 = class extends FixedWidthBuilder2 {
  setValue(index2, value) {
    this._values.set(index2, value);
  }
};
var Float16Builder2 = class extends FloatBuilder2 {
  setValue(index2, value) {
    super.setValue(index2, float64ToUint162(value));
  }
};
var Float32Builder2 = class extends FloatBuilder2 {
};
var Float64Builder2 = class extends FloatBuilder2 {
};

// ../../node_modules/apache-arrow/builder/interval.mjs
var IntervalBuilder2 = class extends FixedWidthBuilder2 {
};
IntervalBuilder2.prototype._setValue = setIntervalValue2;
var IntervalDayTimeBuilder2 = class extends IntervalBuilder2 {
};
IntervalDayTimeBuilder2.prototype._setValue = setIntervalDayTime2;
var IntervalYearMonthBuilder2 = class extends IntervalBuilder2 {
};
IntervalYearMonthBuilder2.prototype._setValue = setIntervalYearMonth2;

// ../../node_modules/apache-arrow/builder/duration.mjs
var DurationBuilder2 = class extends FixedWidthBuilder2 {
};
DurationBuilder2.prototype._setValue = setDuration2;
var DurationSecondBuilder2 = class extends DurationBuilder2 {
};
DurationSecondBuilder2.prototype._setValue = setDurationSecond2;
var DurationMillisecondBuilder2 = class extends DurationBuilder2 {
};
DurationMillisecondBuilder2.prototype._setValue = setDurationMillisecond2;
var DurationMicrosecondBuilder2 = class extends DurationBuilder2 {
};
DurationMicrosecondBuilder2.prototype._setValue = setDurationMicrosecond2;
var DurationNanosecondBuilder2 = class extends DurationBuilder2 {
};
DurationNanosecondBuilder2.prototype._setValue = setDurationNanosecond2;

// ../../node_modules/apache-arrow/builder/int.mjs
var IntBuilder2 = class extends FixedWidthBuilder2 {
  setValue(index2, value) {
    this._values.set(index2, value);
  }
};
var Int8Builder2 = class extends IntBuilder2 {
};
var Int16Builder2 = class extends IntBuilder2 {
};
var Int32Builder2 = class extends IntBuilder2 {
};
var Int64Builder2 = class extends IntBuilder2 {
};
var Uint8Builder2 = class extends IntBuilder2 {
};
var Uint16Builder2 = class extends IntBuilder2 {
};
var Uint32Builder2 = class extends IntBuilder2 {
};
var Uint64Builder2 = class extends IntBuilder2 {
};

// ../../node_modules/apache-arrow/builder/list.mjs
var ListBuilder2 = class extends VariableWidthBuilder2 {
  constructor(opts) {
    super(opts);
    this._offsets = new OffsetsBufferBuilder2();
  }
  addChild(child, name2 = "0") {
    if (this.numChildren > 0) {
      throw new Error("ListBuilder can only have one child.");
    }
    this.children[this.numChildren] = child;
    this.type = new List3(new Field4(name2, child.type, true));
    return this.numChildren - 1;
  }
  _flushPending(pending) {
    const offsets = this._offsets;
    const [child] = this.children;
    for (const [index2, value] of pending) {
      if (typeof value === "undefined") {
        offsets.set(index2, 0);
      } else {
        const v3 = value;
        const n = v3.length;
        const start2 = offsets.set(index2, n).buffer[index2];
        for (let i = -1; ++i < n; ) {
          child.set(start2 + i, v3[i]);
        }
      }
    }
  }
};

// ../../node_modules/apache-arrow/builder/map.mjs
var MapBuilder2 = class extends VariableWidthBuilder2 {
  set(index2, value) {
    return super.set(index2, value);
  }
  setValue(index2, value) {
    const row = value instanceof Map ? value : new Map(Object.entries(value));
    const pending = this._pending || (this._pending = /* @__PURE__ */ new Map());
    const current = pending.get(index2);
    current && (this._pendingLength -= current.size);
    this._pendingLength += row.size;
    pending.set(index2, row);
  }
  addChild(child, name2 = `${this.numChildren}`) {
    if (this.numChildren > 0) {
      throw new Error("ListBuilder can only have one child.");
    }
    this.children[this.numChildren] = child;
    this.type = new Map_2(new Field4(name2, child.type, true), this.type.keysSorted);
    return this.numChildren - 1;
  }
  _flushPending(pending) {
    const offsets = this._offsets;
    const [child] = this.children;
    for (const [index2, value] of pending) {
      if (value === void 0) {
        offsets.set(index2, 0);
      } else {
        let { [index2]: idx, [index2 + 1]: end } = offsets.set(index2, value.size).buffer;
        for (const val of value.entries()) {
          child.set(idx, val);
          if (++idx >= end)
            break;
        }
      }
    }
  }
};

// ../../node_modules/apache-arrow/builder/null.mjs
var NullBuilder2 = class extends Builder5 {
  // @ts-ignore
  setValue(index2, value) {
  }
  setValid(index2, valid2) {
    this.length = Math.max(index2 + 1, this.length);
    return valid2;
  }
};

// ../../node_modules/apache-arrow/builder/struct.mjs
var StructBuilder2 = class extends Builder5 {
  setValue(index2, value) {
    const { children: children2, type: type2 } = this;
    switch (Array.isArray(value) || value.constructor) {
      case true:
        return type2.children.forEach((_2, i) => children2[i].set(index2, value[i]));
      case Map:
        return type2.children.forEach((f2, i) => children2[i].set(index2, value.get(f2.name)));
      default:
        return type2.children.forEach((f2, i) => children2[i].set(index2, value[f2.name]));
    }
  }
  /** @inheritdoc */
  setValid(index2, valid2) {
    if (!super.setValid(index2, valid2)) {
      this.children.forEach((child) => child.setValid(index2, valid2));
    }
    return valid2;
  }
  addChild(child, name2 = `${this.numChildren}`) {
    const childIndex = this.children.push(child);
    this.type = new Struct2([...this.type.children, new Field4(name2, child.type, true)]);
    return childIndex;
  }
};

// ../../node_modules/apache-arrow/builder/timestamp.mjs
var TimestampBuilder2 = class extends FixedWidthBuilder2 {
};
TimestampBuilder2.prototype._setValue = setTimestamp2;
var TimestampSecondBuilder2 = class extends TimestampBuilder2 {
};
TimestampSecondBuilder2.prototype._setValue = setTimestampSecond2;
var TimestampMillisecondBuilder2 = class extends TimestampBuilder2 {
};
TimestampMillisecondBuilder2.prototype._setValue = setTimestampMillisecond2;
var TimestampMicrosecondBuilder2 = class extends TimestampBuilder2 {
};
TimestampMicrosecondBuilder2.prototype._setValue = setTimestampMicrosecond2;
var TimestampNanosecondBuilder2 = class extends TimestampBuilder2 {
};
TimestampNanosecondBuilder2.prototype._setValue = setTimestampNanosecond2;

// ../../node_modules/apache-arrow/builder/time.mjs
var TimeBuilder2 = class extends FixedWidthBuilder2 {
};
TimeBuilder2.prototype._setValue = setTime2;
var TimeSecondBuilder2 = class extends TimeBuilder2 {
};
TimeSecondBuilder2.prototype._setValue = setTimeSecond2;
var TimeMillisecondBuilder2 = class extends TimeBuilder2 {
};
TimeMillisecondBuilder2.prototype._setValue = setTimeMillisecond2;
var TimeMicrosecondBuilder2 = class extends TimeBuilder2 {
};
TimeMicrosecondBuilder2.prototype._setValue = setTimeMicrosecond2;
var TimeNanosecondBuilder2 = class extends TimeBuilder2 {
};
TimeNanosecondBuilder2.prototype._setValue = setTimeNanosecond2;

// ../../node_modules/apache-arrow/builder/union.mjs
var UnionBuilder2 = class extends Builder5 {
  constructor(options) {
    super(options);
    this._typeIds = new DataBufferBuilder2(new Int8Array(0), 1);
    if (typeof options["valueToChildTypeId"] === "function") {
      this._valueToChildTypeId = options["valueToChildTypeId"];
    }
  }
  get typeIdToChildIndex() {
    return this.type.typeIdToChildIndex;
  }
  append(value, childTypeId) {
    return this.set(this.length, value, childTypeId);
  }
  set(index2, value, childTypeId) {
    if (childTypeId === void 0) {
      childTypeId = this._valueToChildTypeId(this, value, index2);
    }
    this.setValue(index2, value, childTypeId);
    return this;
  }
  setValue(index2, value, childTypeId) {
    this._typeIds.set(index2, childTypeId);
    const childIndex = this.type.typeIdToChildIndex[childTypeId];
    const child = this.children[childIndex];
    child === null || child === void 0 ? void 0 : child.set(index2, value);
  }
  addChild(child, name2 = `${this.children.length}`) {
    const childTypeId = this.children.push(child);
    const { type: { children: children2, mode: mode3, typeIds } } = this;
    const fields = [...children2, new Field4(name2, child.type)];
    this.type = new Union_2(mode3, [...typeIds, childTypeId], fields);
    return childTypeId;
  }
  /** @ignore */
  // @ts-ignore
  _valueToChildTypeId(builder, value, offset2) {
    throw new Error(`Cannot map UnionBuilder value to child typeId. Pass the \`childTypeId\` as the second argument to unionBuilder.append(), or supply a \`valueToChildTypeId\` function as part of the UnionBuilder constructor options.`);
  }
};
var SparseUnionBuilder2 = class extends UnionBuilder2 {
};
var DenseUnionBuilder2 = class extends UnionBuilder2 {
  constructor(options) {
    super(options);
    this._offsets = new DataBufferBuilder2(new Int32Array(0));
  }
  /** @ignore */
  setValue(index2, value, childTypeId) {
    const id2 = this._typeIds.set(index2, childTypeId).buffer[index2];
    const child = this.getChildAt(this.type.typeIdToChildIndex[id2]);
    const denseIndex = this._offsets.set(index2, child.length).buffer[index2];
    child === null || child === void 0 ? void 0 : child.set(denseIndex, value);
  }
};

// ../../node_modules/apache-arrow/builder/utf8.mjs
var Utf8Builder2 = class extends VariableWidthBuilder2 {
  constructor(opts) {
    super(opts);
    this._values = new BufferBuilder2(new Uint8Array(0));
  }
  get byteLength() {
    let size = this._pendingLength + this.length * 4;
    this._offsets && (size += this._offsets.byteLength);
    this._values && (size += this._values.byteLength);
    this._nulls && (size += this._nulls.byteLength);
    return size;
  }
  setValue(index2, value) {
    return super.setValue(index2, encodeUtf82(value));
  }
  // @ts-ignore
  _flushPending(pending, pendingLength) {
  }
};
Utf8Builder2.prototype._flushPending = BinaryBuilder2.prototype._flushPending;

// ../../node_modules/apache-arrow/visitor/builderctor.mjs
var GetBuilderCtor2 = class extends Visitor2 {
  visitNull() {
    return NullBuilder2;
  }
  visitBool() {
    return BoolBuilder2;
  }
  visitInt() {
    return IntBuilder2;
  }
  visitInt8() {
    return Int8Builder2;
  }
  visitInt16() {
    return Int16Builder2;
  }
  visitInt32() {
    return Int32Builder2;
  }
  visitInt64() {
    return Int64Builder2;
  }
  visitUint8() {
    return Uint8Builder2;
  }
  visitUint16() {
    return Uint16Builder2;
  }
  visitUint32() {
    return Uint32Builder2;
  }
  visitUint64() {
    return Uint64Builder2;
  }
  visitFloat() {
    return FloatBuilder2;
  }
  visitFloat16() {
    return Float16Builder2;
  }
  visitFloat32() {
    return Float32Builder2;
  }
  visitFloat64() {
    return Float64Builder2;
  }
  visitUtf8() {
    return Utf8Builder2;
  }
  visitBinary() {
    return BinaryBuilder2;
  }
  visitFixedSizeBinary() {
    return FixedSizeBinaryBuilder2;
  }
  visitDate() {
    return DateBuilder2;
  }
  visitDateDay() {
    return DateDayBuilder2;
  }
  visitDateMillisecond() {
    return DateMillisecondBuilder2;
  }
  visitTimestamp() {
    return TimestampBuilder2;
  }
  visitTimestampSecond() {
    return TimestampSecondBuilder2;
  }
  visitTimestampMillisecond() {
    return TimestampMillisecondBuilder2;
  }
  visitTimestampMicrosecond() {
    return TimestampMicrosecondBuilder2;
  }
  visitTimestampNanosecond() {
    return TimestampNanosecondBuilder2;
  }
  visitTime() {
    return TimeBuilder2;
  }
  visitTimeSecond() {
    return TimeSecondBuilder2;
  }
  visitTimeMillisecond() {
    return TimeMillisecondBuilder2;
  }
  visitTimeMicrosecond() {
    return TimeMicrosecondBuilder2;
  }
  visitTimeNanosecond() {
    return TimeNanosecondBuilder2;
  }
  visitDecimal() {
    return DecimalBuilder2;
  }
  visitList() {
    return ListBuilder2;
  }
  visitStruct() {
    return StructBuilder2;
  }
  visitUnion() {
    return UnionBuilder2;
  }
  visitDenseUnion() {
    return DenseUnionBuilder2;
  }
  visitSparseUnion() {
    return SparseUnionBuilder2;
  }
  visitDictionary() {
    return DictionaryBuilder2;
  }
  visitInterval() {
    return IntervalBuilder2;
  }
  visitIntervalDayTime() {
    return IntervalDayTimeBuilder2;
  }
  visitIntervalYearMonth() {
    return IntervalYearMonthBuilder2;
  }
  visitDuration() {
    return DurationBuilder2;
  }
  visitDurationSecond() {
    return DurationSecondBuilder2;
  }
  visitDurationMillisecond() {
    return DurationMillisecondBuilder2;
  }
  visitDurationMicrosecond() {
    return DurationMicrosecondBuilder2;
  }
  visistDurationNanosecond() {
    return DurationNanosecondBuilder2;
  }
  visitFixedSizeList() {
    return FixedSizeListBuilder2;
  }
  visitMap() {
    return MapBuilder2;
  }
};
var instance13 = new GetBuilderCtor2();

// ../../node_modules/apache-arrow/visitor/typecomparator.mjs
var TypeComparator2 = class extends Visitor2 {
  compareSchemas(schema, other) {
    return schema === other || other instanceof schema.constructor && this.compareManyFields(schema.fields, other.fields);
  }
  compareManyFields(fields, others) {
    return fields === others || Array.isArray(fields) && Array.isArray(others) && fields.length === others.length && fields.every((f2, i) => this.compareFields(f2, others[i]));
  }
  compareFields(field2, other) {
    return field2 === other || other instanceof field2.constructor && field2.name === other.name && field2.nullable === other.nullable && this.visit(field2.type, other.type);
  }
};
function compareConstructor2(type2, other) {
  return other instanceof type2.constructor;
}
function compareAny2(type2, other) {
  return type2 === other || compareConstructor2(type2, other);
}
function compareInt2(type2, other) {
  return type2 === other || compareConstructor2(type2, other) && type2.bitWidth === other.bitWidth && type2.isSigned === other.isSigned;
}
function compareFloat2(type2, other) {
  return type2 === other || compareConstructor2(type2, other) && type2.precision === other.precision;
}
function compareFixedSizeBinary2(type2, other) {
  return type2 === other || compareConstructor2(type2, other) && type2.byteWidth === other.byteWidth;
}
function compareDate2(type2, other) {
  return type2 === other || compareConstructor2(type2, other) && type2.unit === other.unit;
}
function compareTimestamp2(type2, other) {
  return type2 === other || compareConstructor2(type2, other) && type2.unit === other.unit && type2.timezone === other.timezone;
}
function compareTime2(type2, other) {
  return type2 === other || compareConstructor2(type2, other) && type2.unit === other.unit && type2.bitWidth === other.bitWidth;
}
function compareList2(type2, other) {
  return type2 === other || compareConstructor2(type2, other) && type2.children.length === other.children.length && instance14.compareManyFields(type2.children, other.children);
}
function compareStruct2(type2, other) {
  return type2 === other || compareConstructor2(type2, other) && type2.children.length === other.children.length && instance14.compareManyFields(type2.children, other.children);
}
function compareUnion2(type2, other) {
  return type2 === other || compareConstructor2(type2, other) && type2.mode === other.mode && type2.typeIds.every((x4, i) => x4 === other.typeIds[i]) && instance14.compareManyFields(type2.children, other.children);
}
function compareDictionary2(type2, other) {
  return type2 === other || compareConstructor2(type2, other) && type2.id === other.id && type2.isOrdered === other.isOrdered && instance14.visit(type2.indices, other.indices) && instance14.visit(type2.dictionary, other.dictionary);
}
function compareInterval2(type2, other) {
  return type2 === other || compareConstructor2(type2, other) && type2.unit === other.unit;
}
function compareDuration2(type2, other) {
  return type2 === other || compareConstructor2(type2, other) && type2.unit === other.unit;
}
function compareFixedSizeList2(type2, other) {
  return type2 === other || compareConstructor2(type2, other) && type2.listSize === other.listSize && type2.children.length === other.children.length && instance14.compareManyFields(type2.children, other.children);
}
function compareMap2(type2, other) {
  return type2 === other || compareConstructor2(type2, other) && type2.keysSorted === other.keysSorted && type2.children.length === other.children.length && instance14.compareManyFields(type2.children, other.children);
}
TypeComparator2.prototype.visitNull = compareAny2;
TypeComparator2.prototype.visitBool = compareAny2;
TypeComparator2.prototype.visitInt = compareInt2;
TypeComparator2.prototype.visitInt8 = compareInt2;
TypeComparator2.prototype.visitInt16 = compareInt2;
TypeComparator2.prototype.visitInt32 = compareInt2;
TypeComparator2.prototype.visitInt64 = compareInt2;
TypeComparator2.prototype.visitUint8 = compareInt2;
TypeComparator2.prototype.visitUint16 = compareInt2;
TypeComparator2.prototype.visitUint32 = compareInt2;
TypeComparator2.prototype.visitUint64 = compareInt2;
TypeComparator2.prototype.visitFloat = compareFloat2;
TypeComparator2.prototype.visitFloat16 = compareFloat2;
TypeComparator2.prototype.visitFloat32 = compareFloat2;
TypeComparator2.prototype.visitFloat64 = compareFloat2;
TypeComparator2.prototype.visitUtf8 = compareAny2;
TypeComparator2.prototype.visitBinary = compareAny2;
TypeComparator2.prototype.visitFixedSizeBinary = compareFixedSizeBinary2;
TypeComparator2.prototype.visitDate = compareDate2;
TypeComparator2.prototype.visitDateDay = compareDate2;
TypeComparator2.prototype.visitDateMillisecond = compareDate2;
TypeComparator2.prototype.visitTimestamp = compareTimestamp2;
TypeComparator2.prototype.visitTimestampSecond = compareTimestamp2;
TypeComparator2.prototype.visitTimestampMillisecond = compareTimestamp2;
TypeComparator2.prototype.visitTimestampMicrosecond = compareTimestamp2;
TypeComparator2.prototype.visitTimestampNanosecond = compareTimestamp2;
TypeComparator2.prototype.visitTime = compareTime2;
TypeComparator2.prototype.visitTimeSecond = compareTime2;
TypeComparator2.prototype.visitTimeMillisecond = compareTime2;
TypeComparator2.prototype.visitTimeMicrosecond = compareTime2;
TypeComparator2.prototype.visitTimeNanosecond = compareTime2;
TypeComparator2.prototype.visitDecimal = compareAny2;
TypeComparator2.prototype.visitList = compareList2;
TypeComparator2.prototype.visitStruct = compareStruct2;
TypeComparator2.prototype.visitUnion = compareUnion2;
TypeComparator2.prototype.visitDenseUnion = compareUnion2;
TypeComparator2.prototype.visitSparseUnion = compareUnion2;
TypeComparator2.prototype.visitDictionary = compareDictionary2;
TypeComparator2.prototype.visitInterval = compareInterval2;
TypeComparator2.prototype.visitIntervalDayTime = compareInterval2;
TypeComparator2.prototype.visitIntervalYearMonth = compareInterval2;
TypeComparator2.prototype.visitDuration = compareDuration2;
TypeComparator2.prototype.visitDurationSecond = compareDuration2;
TypeComparator2.prototype.visitDurationMillisecond = compareDuration2;
TypeComparator2.prototype.visitDurationMicrosecond = compareDuration2;
TypeComparator2.prototype.visitDurationNanosecond = compareDuration2;
TypeComparator2.prototype.visitFixedSizeList = compareFixedSizeList2;
TypeComparator2.prototype.visitMap = compareMap2;
var instance14 = new TypeComparator2();
function compareSchemas2(schema, other) {
  return instance14.compareSchemas(schema, other);
}
function compareFields2(field2, other) {
  return instance14.compareFields(field2, other);
}
function compareTypes2(type2, other) {
  return instance14.visit(type2, other);
}

// ../../node_modules/apache-arrow/factories.mjs
function makeBuilder2(options) {
  const type2 = options.type;
  const builder = new (instance13.getVisitFn(type2)())(options);
  if (type2.children && type2.children.length > 0) {
    const children2 = options["children"] || [];
    const defaultOptions = { "nullValues": options["nullValues"] };
    const getChildOptions = Array.isArray(children2) ? (_2, i) => children2[i] || defaultOptions : ({ name: name2 }) => children2[name2] || defaultOptions;
    for (const [index2, field2] of type2.children.entries()) {
      const { type: type3 } = field2;
      const opts = getChildOptions(field2, index2);
      builder.children.push(makeBuilder2(Object.assign(Object.assign({}, opts), { type: type3 })));
    }
  }
  return builder;
}

// ../../node_modules/apache-arrow/util/recordbatch.mjs
function distributeVectorsIntoRecordBatches2(schema, vecs) {
  return uniformlyDistributeChunksAcrossRecordBatches2(schema, vecs.map((v3) => v3.data.concat()));
}
function uniformlyDistributeChunksAcrossRecordBatches2(schema, cols) {
  const fields = [...schema.fields];
  const batches = [];
  const memo2 = { numBatches: cols.reduce((n, c4) => Math.max(n, c4.length), 0) };
  let numBatches = 0, batchLength = 0;
  let i = -1;
  const numColumns = cols.length;
  let child, children2 = [];
  while (memo2.numBatches-- > 0) {
    for (batchLength = Number.POSITIVE_INFINITY, i = -1; ++i < numColumns; ) {
      children2[i] = child = cols[i].shift();
      batchLength = Math.min(batchLength, child ? child.length : batchLength);
    }
    if (Number.isFinite(batchLength)) {
      children2 = distributeChildren2(fields, batchLength, children2, cols, memo2);
      if (batchLength > 0) {
        batches[numBatches++] = makeData2({
          type: new Struct2(fields),
          length: batchLength,
          nullCount: 0,
          children: children2.slice()
        });
      }
    }
  }
  return [
    schema = schema.assign(fields),
    batches.map((data) => new RecordBatch4(schema, data))
  ];
}
function distributeChildren2(fields, batchLength, children2, columns, memo2) {
  var _a9;
  const nullBitmapSize = (batchLength + 63 & ~63) >> 3;
  for (let i = -1, n = columns.length; ++i < n; ) {
    const child = children2[i];
    const length4 = child === null || child === void 0 ? void 0 : child.length;
    if (length4 >= batchLength) {
      if (length4 === batchLength) {
        children2[i] = child;
      } else {
        children2[i] = child.slice(0, batchLength);
        memo2.numBatches = Math.max(memo2.numBatches, columns[i].unshift(child.slice(batchLength, length4 - batchLength)));
      }
    } else {
      const field2 = fields[i];
      fields[i] = field2.clone({ nullable: true });
      children2[i] = (_a9 = child === null || child === void 0 ? void 0 : child._changeLengthAndBackfillNullBitmap(batchLength)) !== null && _a9 !== void 0 ? _a9 : makeData2({
        type: field2.type,
        length: batchLength,
        nullCount: batchLength,
        nullBitmap: new Uint8Array(nullBitmapSize)
      });
    }
  }
  return children2;
}

// ../../node_modules/apache-arrow/table.mjs
var _a7;
var Table2 = class _Table {
  constructor(...args) {
    var _b3, _c3;
    if (args.length === 0) {
      this.batches = [];
      this.schema = new Schema4([]);
      this._offsets = [0];
      return this;
    }
    let schema;
    let offsets;
    if (args[0] instanceof Schema4) {
      schema = args.shift();
    }
    if (args.at(-1) instanceof Uint32Array) {
      offsets = args.pop();
    }
    const unwrap = (x4) => {
      if (x4) {
        if (x4 instanceof RecordBatch4) {
          return [x4];
        } else if (x4 instanceof _Table) {
          return x4.batches;
        } else if (x4 instanceof Data2) {
          if (x4.type instanceof Struct2) {
            return [new RecordBatch4(new Schema4(x4.type.children), x4)];
          }
        } else if (Array.isArray(x4)) {
          return x4.flatMap((v3) => unwrap(v3));
        } else if (typeof x4[Symbol.iterator] === "function") {
          return [...x4].flatMap((v3) => unwrap(v3));
        } else if (typeof x4 === "object") {
          const keys = Object.keys(x4);
          const vecs = keys.map((k3) => new Vector2([x4[k3]]));
          const schema2 = new Schema4(keys.map((k3, i) => new Field4(String(k3), vecs[i].type)));
          const [, batches2] = distributeVectorsIntoRecordBatches2(schema2, vecs);
          return batches2.length === 0 ? [new RecordBatch4(x4)] : batches2;
        }
      }
      return [];
    };
    const batches = args.flatMap((v3) => unwrap(v3));
    schema = (_c3 = schema !== null && schema !== void 0 ? schema : (_b3 = batches[0]) === null || _b3 === void 0 ? void 0 : _b3.schema) !== null && _c3 !== void 0 ? _c3 : new Schema4([]);
    if (!(schema instanceof Schema4)) {
      throw new TypeError("Table constructor expects a [Schema, RecordBatch[]] pair.");
    }
    for (const batch of batches) {
      if (!(batch instanceof RecordBatch4)) {
        throw new TypeError("Table constructor expects a [Schema, RecordBatch[]] pair.");
      }
      if (!compareSchemas2(schema, batch.schema)) {
        throw new TypeError("Table and inner RecordBatch schemas must be equivalent.");
      }
    }
    this.schema = schema;
    this.batches = batches;
    this._offsets = offsets !== null && offsets !== void 0 ? offsets : computeChunkOffsets2(this.data);
  }
  /**
   * The contiguous {@link RecordBatch `RecordBatch`} chunks of the Table rows.
   */
  get data() {
    return this.batches.map(({ data }) => data);
  }
  /**
   * The number of columns in this Table.
   */
  get numCols() {
    return this.schema.fields.length;
  }
  /**
   * The number of rows in this Table.
   */
  get numRows() {
    return this.data.reduce((numRows, data) => numRows + data.length, 0);
  }
  /**
   * The number of null rows in this Table.
   */
  get nullCount() {
    if (this._nullCount === -1) {
      this._nullCount = computeChunkNullCounts2(this.data);
    }
    return this._nullCount;
  }
  /**
   * Check whether an element is null.
   *
   * @param index The index at which to read the validity bitmap.
   */
  // @ts-ignore
  isValid(index2) {
    return false;
  }
  /**
   * Get an element value by position.
   *
   * @param index The index of the element to read.
   */
  // @ts-ignore
  get(index2) {
    return null;
  }
  /**
   * Set an element value by position.
   *
   * @param index The index of the element to write.
   * @param value The value to set.
   */
  // @ts-ignore
  set(index2, value) {
    return;
  }
  /**
   * Retrieve the index of the first occurrence of a value in an Vector.
   *
   * @param element The value to locate in the Vector.
   * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
   */
  // @ts-ignore
  indexOf(element, offset2) {
    return -1;
  }
  /**
   * Get the size in bytes of an element by index.
   * @param index The index at which to get the byteLength.
   */
  // @ts-ignore
  getByteLength(index2) {
    return 0;
  }
  /**
   * Iterator for rows in this Table.
   */
  [Symbol.iterator]() {
    if (this.batches.length > 0) {
      return instance11.visit(new Vector2(this.data));
    }
    return new Array(0)[Symbol.iterator]();
  }
  /**
   * Return a JavaScript Array of the Table rows.
   *
   * @returns An Array of Table rows.
   */
  toArray() {
    return [...this];
  }
  /**
   * Returns a string representation of the Table rows.
   *
   * @returns A string representation of the Table rows.
   */
  toString() {
    return `[
  ${this.toArray().join(",\n  ")}
]`;
  }
  /**
   * Combines two or more Tables of the same schema.
   *
   * @param others Additional Tables to add to the end of this Tables.
   */
  concat(...others) {
    const schema = this.schema;
    const data = this.data.concat(others.flatMap(({ data: data2 }) => data2));
    return new _Table(schema, data.map((data2) => new RecordBatch4(schema, data2)));
  }
  /**
   * Return a zero-copy sub-section of this Table.
   *
   * @param begin The beginning of the specified portion of the Table.
   * @param end The end of the specified portion of the Table. This is exclusive of the element at the index 'end'.
   */
  slice(begin, end) {
    const schema = this.schema;
    [begin, end] = clampRange2({ length: this.numRows }, begin, end);
    const data = sliceChunks2(this.data, this._offsets, begin, end);
    return new _Table(schema, data.map((chunk) => new RecordBatch4(schema, chunk)));
  }
  /**
   * Returns a child Vector by name, or null if this Vector has no child with the given name.
   *
   * @param name The name of the child to retrieve.
   */
  getChild(name2) {
    return this.getChildAt(this.schema.fields.findIndex((f2) => f2.name === name2));
  }
  /**
   * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
   *
   * @param index The index of the child to retrieve.
   */
  getChildAt(index2) {
    if (index2 > -1 && index2 < this.schema.fields.length) {
      const data = this.data.map((data2) => data2.children[index2]);
      if (data.length === 0) {
        const { type: type2 } = this.schema.fields[index2];
        const empty4 = makeData2({ type: type2, length: 0, nullCount: 0 });
        data.push(empty4._changeLengthAndBackfillNullBitmap(this.numRows));
      }
      return new Vector2(data);
    }
    return null;
  }
  /**
   * Sets a child Vector by name.
   *
   * @param name The name of the child to overwrite.
   * @returns A new Table with the supplied child for the specified name.
   */
  setChild(name2, child) {
    var _b3;
    return this.setChildAt((_b3 = this.schema.fields) === null || _b3 === void 0 ? void 0 : _b3.findIndex((f2) => f2.name === name2), child);
  }
  setChildAt(index2, child) {
    let schema = this.schema;
    let batches = [...this.batches];
    if (index2 > -1 && index2 < this.numCols) {
      if (!child) {
        child = new Vector2([makeData2({ type: new Null3(), length: this.numRows })]);
      }
      const fields = schema.fields.slice();
      const field2 = fields[index2].clone({ type: child.type });
      const children2 = this.schema.fields.map((_2, i) => this.getChildAt(i));
      [fields[index2], children2[index2]] = [field2, child];
      [schema, batches] = distributeVectorsIntoRecordBatches2(schema, children2);
    }
    return new _Table(schema, batches);
  }
  /**
   * Construct a new Table containing only specified columns.
   *
   * @param columnNames Names of columns to keep.
   * @returns A new Table of columns matching the specified names.
   */
  select(columnNames) {
    const nameToIndex = this.schema.fields.reduce((m2, f2, i) => m2.set(f2.name, i), /* @__PURE__ */ new Map());
    return this.selectAt(columnNames.map((columnName) => nameToIndex.get(columnName)).filter((x4) => x4 > -1));
  }
  /**
   * Construct a new Table containing only columns at the specified indices.
   *
   * @param columnIndices Indices of columns to keep.
   * @returns A new Table of columns at the specified indices.
   */
  selectAt(columnIndices) {
    const schema = this.schema.selectAt(columnIndices);
    const data = this.batches.map((batch) => batch.selectAt(columnIndices));
    return new _Table(schema, data);
  }
  assign(other) {
    const fields = this.schema.fields;
    const [indices, oldToNew] = other.schema.fields.reduce((memo2, f2, newIdx) => {
      const [indices2, oldToNew2] = memo2;
      const i = fields.findIndex((f3) => f3.name === f2.name);
      ~i ? oldToNew2[i] = newIdx : indices2.push(newIdx);
      return memo2;
    }, [[], []]);
    const schema = this.schema.assign(other.schema);
    const columns = [
      ...fields.map((_2, i) => [i, oldToNew[i]]).map(([i, j2]) => j2 === void 0 ? this.getChildAt(i) : other.getChildAt(j2)),
      ...indices.map((i) => other.getChildAt(i))
    ].filter(Boolean);
    return new _Table(...distributeVectorsIntoRecordBatches2(schema, columns));
  }
};
_a7 = Symbol.toStringTag;
Table2[_a7] = ((proto) => {
  proto.schema = null;
  proto.batches = [];
  proto._offsets = new Uint32Array([0]);
  proto._nullCount = -1;
  proto[Symbol.isConcatSpreadable] = true;
  proto["isValid"] = wrapChunkedCall12(isChunkedValid2);
  proto["get"] = wrapChunkedCall12(instance9.getVisitFn(Type3.Struct));
  proto["set"] = wrapChunkedCall22(instance8.getVisitFn(Type3.Struct));
  proto["indexOf"] = wrapChunkedIndexOf2(instance10.getVisitFn(Type3.Struct));
  proto["getByteLength"] = wrapChunkedCall12(instance12.getVisitFn(Type3.Struct));
  return "Table";
})(Table2.prototype);

// ../../node_modules/apache-arrow/recordbatch.mjs
var _a8;
var RecordBatch4 = class _RecordBatch {
  constructor(...args) {
    switch (args.length) {
      case 2: {
        [this.schema] = args;
        if (!(this.schema instanceof Schema4)) {
          throw new TypeError("RecordBatch constructor expects a [Schema, Data] pair.");
        }
        [
          ,
          this.data = makeData2({
            nullCount: 0,
            type: new Struct2(this.schema.fields),
            children: this.schema.fields.map((f2) => makeData2({ type: f2.type, nullCount: 0 }))
          })
        ] = args;
        if (!(this.data instanceof Data2)) {
          throw new TypeError("RecordBatch constructor expects a [Schema, Data] pair.");
        }
        [this.schema, this.data] = ensureSameLengthData2(this.schema, this.data.children);
        break;
      }
      case 1: {
        const [obj] = args;
        const { fields, children: children2, length: length4 } = Object.keys(obj).reduce((memo2, name2, i) => {
          memo2.children[i] = obj[name2];
          memo2.length = Math.max(memo2.length, obj[name2].length);
          memo2.fields[i] = Field4.new({ name: name2, type: obj[name2].type, nullable: true });
          return memo2;
        }, {
          length: 0,
          fields: new Array(),
          children: new Array()
        });
        const schema = new Schema4(fields);
        const data = makeData2({ type: new Struct2(fields), length: length4, children: children2, nullCount: 0 });
        [this.schema, this.data] = ensureSameLengthData2(schema, data.children, length4);
        break;
      }
      default:
        throw new TypeError("RecordBatch constructor expects an Object mapping names to child Data, or a [Schema, Data] pair.");
    }
  }
  get dictionaries() {
    return this._dictionaries || (this._dictionaries = collectDictionaries2(this.schema.fields, this.data.children));
  }
  /**
   * The number of columns in this RecordBatch.
   */
  get numCols() {
    return this.schema.fields.length;
  }
  /**
   * The number of rows in this RecordBatch.
   */
  get numRows() {
    return this.data.length;
  }
  /**
   * The number of null rows in this RecordBatch.
   */
  get nullCount() {
    return this.data.nullCount;
  }
  /**
   * Check whether an element is null.
   * @param index The index at which to read the validity bitmap.
   */
  isValid(index2) {
    return this.data.getValid(index2);
  }
  /**
   * Get a row by position.
   * @param index The index of the element to read.
   */
  get(index2) {
    return instance9.visit(this.data, index2);
  }
  /**
   * Set a row by position.
   * @param index The index of the element to write.
   * @param value The value to set.
   */
  set(index2, value) {
    return instance8.visit(this.data, index2, value);
  }
  /**
   * Retrieve the index of the first occurrence of a row in an RecordBatch.
   * @param element The row to locate in the RecordBatch.
   * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
   */
  indexOf(element, offset2) {
    return instance10.visit(this.data, element, offset2);
  }
  /**
   * Get the size (in bytes) of a row by index.
   * @param index The row index for which to compute the byteLength.
   */
  getByteLength(index2) {
    return instance12.visit(this.data, index2);
  }
  /**
   * Iterator for rows in this RecordBatch.
   */
  [Symbol.iterator]() {
    return instance11.visit(new Vector2([this.data]));
  }
  /**
   * Return a JavaScript Array of the RecordBatch rows.
   * @returns An Array of RecordBatch rows.
   */
  toArray() {
    return [...this];
  }
  /**
   * Combines two or more RecordBatch of the same schema.
   * @param others Additional RecordBatch to add to the end of this RecordBatch.
   */
  concat(...others) {
    return new Table2(this.schema, [this, ...others]);
  }
  /**
   * Return a zero-copy sub-section of this RecordBatch.
   * @param start The beginning of the specified portion of the RecordBatch.
   * @param end The end of the specified portion of the RecordBatch. This is exclusive of the element at the index 'end'.
   */
  slice(begin, end) {
    const [slice4] = new Vector2([this.data]).slice(begin, end).data;
    return new _RecordBatch(this.schema, slice4);
  }
  /**
   * Returns a child Vector by name, or null if this Vector has no child with the given name.
   * @param name The name of the child to retrieve.
   */
  getChild(name2) {
    var _b3;
    return this.getChildAt((_b3 = this.schema.fields) === null || _b3 === void 0 ? void 0 : _b3.findIndex((f2) => f2.name === name2));
  }
  /**
   * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
   * @param index The index of the child to retrieve.
   */
  getChildAt(index2) {
    if (index2 > -1 && index2 < this.schema.fields.length) {
      return new Vector2([this.data.children[index2]]);
    }
    return null;
  }
  /**
   * Sets a child Vector by name.
   * @param name The name of the child to overwrite.
   * @returns A new RecordBatch with the new child for the specified name.
   */
  setChild(name2, child) {
    var _b3;
    return this.setChildAt((_b3 = this.schema.fields) === null || _b3 === void 0 ? void 0 : _b3.findIndex((f2) => f2.name === name2), child);
  }
  setChildAt(index2, child) {
    let schema = this.schema;
    let data = this.data;
    if (index2 > -1 && index2 < this.numCols) {
      if (!child) {
        child = new Vector2([makeData2({ type: new Null3(), length: this.numRows })]);
      }
      const fields = schema.fields.slice();
      const children2 = data.children.slice();
      const field2 = fields[index2].clone({ type: child.type });
      [fields[index2], children2[index2]] = [field2, child.data[0]];
      schema = new Schema4(fields, new Map(this.schema.metadata));
      data = makeData2({ type: new Struct2(fields), children: children2 });
    }
    return new _RecordBatch(schema, data);
  }
  /**
   * Construct a new RecordBatch containing only specified columns.
   *
   * @param columnNames Names of columns to keep.
   * @returns A new RecordBatch of columns matching the specified names.
   */
  select(columnNames) {
    const schema = this.schema.select(columnNames);
    const type2 = new Struct2(schema.fields);
    const children2 = [];
    for (const name2 of columnNames) {
      const index2 = this.schema.fields.findIndex((f2) => f2.name === name2);
      if (~index2) {
        children2[index2] = this.data.children[index2];
      }
    }
    return new _RecordBatch(schema, makeData2({ type: type2, length: this.numRows, children: children2 }));
  }
  /**
   * Construct a new RecordBatch containing only columns at the specified indices.
   *
   * @param columnIndices Indices of columns to keep.
   * @returns A new RecordBatch of columns matching at the specified indices.
   */
  selectAt(columnIndices) {
    const schema = this.schema.selectAt(columnIndices);
    const children2 = columnIndices.map((i) => this.data.children[i]).filter(Boolean);
    const subset = makeData2({ type: new Struct2(schema.fields), length: this.numRows, children: children2 });
    return new _RecordBatch(schema, subset);
  }
};
_a8 = Symbol.toStringTag;
RecordBatch4[_a8] = ((proto) => {
  proto._nullCount = -1;
  proto[Symbol.isConcatSpreadable] = true;
  return "RecordBatch";
})(RecordBatch4.prototype);
function ensureSameLengthData2(schema, chunks, maxLength = chunks.reduce((max4, col) => Math.max(max4, col.length), 0)) {
  var _b3;
  const fields = [...schema.fields];
  const children2 = [...chunks];
  const nullBitmapSize = (maxLength + 63 & ~63) >> 3;
  for (const [idx, field2] of schema.fields.entries()) {
    const chunk = chunks[idx];
    if (!chunk || chunk.length !== maxLength) {
      fields[idx] = field2.clone({ nullable: true });
      children2[idx] = (_b3 = chunk === null || chunk === void 0 ? void 0 : chunk._changeLengthAndBackfillNullBitmap(maxLength)) !== null && _b3 !== void 0 ? _b3 : makeData2({
        type: field2.type,
        length: maxLength,
        nullCount: maxLength,
        nullBitmap: new Uint8Array(nullBitmapSize)
      });
    }
  }
  return [
    schema.assign(fields),
    makeData2({ type: new Struct2(fields), length: maxLength, children: children2 })
  ];
}
function collectDictionaries2(fields, children2, dictionaries = /* @__PURE__ */ new Map()) {
  var _b3, _c3;
  if (((_b3 = fields === null || fields === void 0 ? void 0 : fields.length) !== null && _b3 !== void 0 ? _b3 : 0) > 0 && (fields === null || fields === void 0 ? void 0 : fields.length) === (children2 === null || children2 === void 0 ? void 0 : children2.length)) {
    for (let i = -1, n = fields.length; ++i < n; ) {
      const { type: type2 } = fields[i];
      const data = children2[i];
      for (const next of [data, ...((_c3 = data === null || data === void 0 ? void 0 : data.dictionary) === null || _c3 === void 0 ? void 0 : _c3.data) || []]) {
        collectDictionaries2(type2.children, next === null || next === void 0 ? void 0 : next.children, dictionaries);
      }
      if (DataType2.isDictionary(type2)) {
        const { id: id2 } = type2;
        if (!dictionaries.has(id2)) {
          if (data === null || data === void 0 ? void 0 : data.dictionary) {
            dictionaries.set(id2, data.dictionary);
          }
        } else if (dictionaries.get(id2) !== data.dictionary) {
          throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);
        }
      }
    }
  }
  return dictionaries;
}
var _InternalEmptyPlaceholderRecordBatch2 = class extends RecordBatch4 {
  constructor(schema) {
    const children2 = schema.fields.map((f2) => makeData2({ type: f2.type }));
    const data = makeData2({ type: new Struct2(schema.fields), nullCount: 0, children: children2 });
    super(schema, data);
  }
};

// ../../node_modules/apache-arrow/fb/body-compression-method.mjs
var BodyCompressionMethod2;
(function(BodyCompressionMethod3) {
  BodyCompressionMethod3[BodyCompressionMethod3["BUFFER"] = 0] = "BUFFER";
})(BodyCompressionMethod2 || (BodyCompressionMethod2 = {}));

// ../../node_modules/apache-arrow/fb/compression-type.mjs
var CompressionType2;
(function(CompressionType3) {
  CompressionType3[CompressionType3["LZ4_FRAME"] = 0] = "LZ4_FRAME";
  CompressionType3[CompressionType3["ZSTD"] = 1] = "ZSTD";
})(CompressionType2 || (CompressionType2 = {}));

// ../../node_modules/apache-arrow/fb/body-compression.mjs
var BodyCompression2 = class _BodyCompression {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsBodyCompression(bb2, obj) {
    return (obj || new _BodyCompression()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsBodyCompression(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _BodyCompression()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  /**
   * Compressor library.
   * For LZ4_FRAME, each compressed buffer must consist of a single frame.
   */
  codec() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt8(this.bb_pos + offset2) : CompressionType2.LZ4_FRAME;
  }
  /**
   * Indicates the way the record batch body was compressed
   */
  method() {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? this.bb.readInt8(this.bb_pos + offset2) : BodyCompressionMethod2.BUFFER;
  }
  static startBodyCompression(builder) {
    builder.startObject(2);
  }
  static addCodec(builder, codec) {
    builder.addFieldInt8(0, codec, CompressionType2.LZ4_FRAME);
  }
  static addMethod(builder, method) {
    builder.addFieldInt8(1, method, BodyCompressionMethod2.BUFFER);
  }
  static endBodyCompression(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static createBodyCompression(builder, codec, method) {
    _BodyCompression.startBodyCompression(builder);
    _BodyCompression.addCodec(builder, codec);
    _BodyCompression.addMethod(builder, method);
    return _BodyCompression.endBodyCompression(builder);
  }
};

// ../../node_modules/apache-arrow/fb/buffer.mjs
var Buffer3 = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  /**
   * The relative offset into the shared memory page where the bytes for this
   * buffer starts
   */
  offset() {
    return this.bb.readInt64(this.bb_pos);
  }
  /**
   * The absolute length (in bytes) of the memory buffer. The memory is found
   * from offset (inclusive) to offset + length (non-inclusive). When building
   * messages using the encapsulated IPC message, padding bytes may be written
   * after a buffer, but such padding bytes do not need to be accounted for in
   * the size here.
   */
  length() {
    return this.bb.readInt64(this.bb_pos + 8);
  }
  static sizeOf() {
    return 16;
  }
  static createBuffer(builder, offset2, length4) {
    builder.prep(8, 16);
    builder.writeInt64(BigInt(length4 !== null && length4 !== void 0 ? length4 : 0));
    builder.writeInt64(BigInt(offset2 !== null && offset2 !== void 0 ? offset2 : 0));
    return builder.offset();
  }
};

// ../../node_modules/apache-arrow/fb/field-node.mjs
var FieldNode3 = class {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  /**
   * The number of value slots in the Arrow array at this level of a nested
   * tree
   */
  length() {
    return this.bb.readInt64(this.bb_pos);
  }
  /**
   * The number of observed nulls. Fields with null_count == 0 may choose not
   * to write their physical validity bitmap out as a materialized buffer,
   * instead setting the length of the bitmap buffer to 0.
   */
  nullCount() {
    return this.bb.readInt64(this.bb_pos + 8);
  }
  static sizeOf() {
    return 16;
  }
  static createFieldNode(builder, length4, null_count) {
    builder.prep(8, 16);
    builder.writeInt64(BigInt(null_count !== null && null_count !== void 0 ? null_count : 0));
    builder.writeInt64(BigInt(length4 !== null && length4 !== void 0 ? length4 : 0));
    return builder.offset();
  }
};

// ../../node_modules/apache-arrow/fb/record-batch.mjs
var RecordBatch5 = class _RecordBatch {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsRecordBatch(bb2, obj) {
    return (obj || new _RecordBatch()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsRecordBatch(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _RecordBatch()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  /**
   * number of records / rows. The arrays in the batch should all have this
   * length
   */
  length() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt64(this.bb_pos + offset2) : BigInt("0");
  }
  /**
   * Nodes correspond to the pre-ordered flattened logical schema
   */
  nodes(index2, obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? (obj || new FieldNode3()).__init(this.bb.__vector(this.bb_pos + offset2) + index2 * 16, this.bb) : null;
  }
  nodesLength() {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
  }
  /**
   * Buffers correspond to the pre-ordered flattened buffer tree
   *
   * The number of buffers appended to this list depends on the schema. For
   * example, most primitive arrays will have 2 buffers, 1 for the validity
   * bitmap and 1 for the values. For struct arrays, there will only be a
   * single buffer for the validity (nulls) bitmap
   */
  buffers(index2, obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 8);
    return offset2 ? (obj || new Buffer3()).__init(this.bb.__vector(this.bb_pos + offset2) + index2 * 16, this.bb) : null;
  }
  buffersLength() {
    const offset2 = this.bb.__offset(this.bb_pos, 8);
    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
  }
  /**
   * Optional compression of the message body
   */
  compression(obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 10);
    return offset2 ? (obj || new BodyCompression2()).__init(this.bb.__indirect(this.bb_pos + offset2), this.bb) : null;
  }
  static startRecordBatch(builder) {
    builder.startObject(4);
  }
  static addLength(builder, length4) {
    builder.addFieldInt64(0, length4, BigInt("0"));
  }
  static addNodes(builder, nodesOffset) {
    builder.addFieldOffset(1, nodesOffset, 0);
  }
  static startNodesVector(builder, numElems) {
    builder.startVector(16, numElems, 8);
  }
  static addBuffers(builder, buffersOffset) {
    builder.addFieldOffset(2, buffersOffset, 0);
  }
  static startBuffersVector(builder, numElems) {
    builder.startVector(16, numElems, 8);
  }
  static addCompression(builder, compressionOffset) {
    builder.addFieldOffset(3, compressionOffset, 0);
  }
  static endRecordBatch(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
};

// ../../node_modules/apache-arrow/fb/dictionary-batch.mjs
var DictionaryBatch3 = class _DictionaryBatch {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsDictionaryBatch(bb2, obj) {
    return (obj || new _DictionaryBatch()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsDictionaryBatch(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _DictionaryBatch()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  id() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt64(this.bb_pos + offset2) : BigInt("0");
  }
  data(obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? (obj || new RecordBatch5()).__init(this.bb.__indirect(this.bb_pos + offset2), this.bb) : null;
  }
  /**
   * If isDelta is true the values in the dictionary are to be appended to a
   * dictionary with the indicated id. If isDelta is false this dictionary
   * should replace the existing dictionary.
   */
  isDelta() {
    const offset2 = this.bb.__offset(this.bb_pos, 8);
    return offset2 ? !!this.bb.readInt8(this.bb_pos + offset2) : false;
  }
  static startDictionaryBatch(builder) {
    builder.startObject(3);
  }
  static addId(builder, id2) {
    builder.addFieldInt64(0, id2, BigInt("0"));
  }
  static addData(builder, dataOffset) {
    builder.addFieldOffset(1, dataOffset, 0);
  }
  static addIsDelta(builder, isDelta) {
    builder.addFieldInt8(2, +isDelta, 0);
  }
  static endDictionaryBatch(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
};

// ../../node_modules/apache-arrow/fb/message-header.mjs
var MessageHeader3;
(function(MessageHeader4) {
  MessageHeader4[MessageHeader4["NONE"] = 0] = "NONE";
  MessageHeader4[MessageHeader4["Schema"] = 1] = "Schema";
  MessageHeader4[MessageHeader4["DictionaryBatch"] = 2] = "DictionaryBatch";
  MessageHeader4[MessageHeader4["RecordBatch"] = 3] = "RecordBatch";
  MessageHeader4[MessageHeader4["Tensor"] = 4] = "Tensor";
  MessageHeader4[MessageHeader4["SparseTensor"] = 5] = "SparseTensor";
})(MessageHeader3 || (MessageHeader3 = {}));

// ../../node_modules/apache-arrow/fb/message.mjs
var Message3 = class _Message {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb2) {
    this.bb_pos = i;
    this.bb = bb2;
    return this;
  }
  static getRootAsMessage(bb2, obj) {
    return (obj || new _Message()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  static getSizePrefixedRootAsMessage(bb2, obj) {
    bb2.setPosition(bb2.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Message()).__init(bb2.readInt32(bb2.position()) + bb2.position(), bb2);
  }
  version() {
    const offset2 = this.bb.__offset(this.bb_pos, 4);
    return offset2 ? this.bb.readInt16(this.bb_pos + offset2) : MetadataVersion3.V1;
  }
  headerType() {
    const offset2 = this.bb.__offset(this.bb_pos, 6);
    return offset2 ? this.bb.readUint8(this.bb_pos + offset2) : MessageHeader3.NONE;
  }
  header(obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 8);
    return offset2 ? this.bb.__union(obj, this.bb_pos + offset2) : null;
  }
  bodyLength() {
    const offset2 = this.bb.__offset(this.bb_pos, 10);
    return offset2 ? this.bb.readInt64(this.bb_pos + offset2) : BigInt("0");
  }
  customMetadata(index2, obj) {
    const offset2 = this.bb.__offset(this.bb_pos, 12);
    return offset2 ? (obj || new KeyValue2()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset2) + index2 * 4), this.bb) : null;
  }
  customMetadataLength() {
    const offset2 = this.bb.__offset(this.bb_pos, 12);
    return offset2 ? this.bb.__vector_len(this.bb_pos + offset2) : 0;
  }
  static startMessage(builder) {
    builder.startObject(5);
  }
  static addVersion(builder, version) {
    builder.addFieldInt16(0, version, MetadataVersion3.V1);
  }
  static addHeaderType(builder, headerType) {
    builder.addFieldInt8(1, headerType, MessageHeader3.NONE);
  }
  static addHeader(builder, headerOffset) {
    builder.addFieldOffset(2, headerOffset, 0);
  }
  static addBodyLength(builder, bodyLength) {
    builder.addFieldInt64(3, bodyLength, BigInt("0"));
  }
  static addCustomMetadata(builder, customMetadataOffset) {
    builder.addFieldOffset(4, customMetadataOffset, 0);
  }
  static createCustomMetadataVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startCustomMetadataVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static endMessage(builder) {
    const offset2 = builder.endObject();
    return offset2;
  }
  static finishMessageBuffer(builder, offset2) {
    builder.finish(offset2);
  }
  static finishSizePrefixedMessageBuffer(builder, offset2) {
    builder.finish(offset2, void 0, true);
  }
  static createMessage(builder, version, headerType, headerOffset, bodyLength, customMetadataOffset) {
    _Message.startMessage(builder);
    _Message.addVersion(builder, version);
    _Message.addHeaderType(builder, headerType);
    _Message.addHeader(builder, headerOffset);
    _Message.addBodyLength(builder, bodyLength);
    _Message.addCustomMetadata(builder, customMetadataOffset);
    return _Message.endMessage(builder);
  }
};

// ../../node_modules/apache-arrow/visitor/typeassembler.mjs
var TypeAssembler2 = class extends Visitor2 {
  visit(node, builder) {
    return node == null || builder == null ? void 0 : super.visit(node, builder);
  }
  visitNull(_node, b2) {
    Null4.startNull(b2);
    return Null4.endNull(b2);
  }
  visitInt(node, b2) {
    Int2.startInt(b2);
    Int2.addBitWidth(b2, node.bitWidth);
    Int2.addIsSigned(b2, node.isSigned);
    return Int2.endInt(b2);
  }
  visitFloat(node, b2) {
    FloatingPoint2.startFloatingPoint(b2);
    FloatingPoint2.addPrecision(b2, node.precision);
    return FloatingPoint2.endFloatingPoint(b2);
  }
  visitBinary(_node, b2) {
    Binary4.startBinary(b2);
    return Binary4.endBinary(b2);
  }
  visitBool(_node, b2) {
    Bool4.startBool(b2);
    return Bool4.endBool(b2);
  }
  visitUtf8(_node, b2) {
    Utf84.startUtf8(b2);
    return Utf84.endUtf8(b2);
  }
  visitDecimal(node, b2) {
    Decimal4.startDecimal(b2);
    Decimal4.addScale(b2, node.scale);
    Decimal4.addPrecision(b2, node.precision);
    Decimal4.addBitWidth(b2, node.bitWidth);
    return Decimal4.endDecimal(b2);
  }
  visitDate(node, b2) {
    Date3.startDate(b2);
    Date3.addUnit(b2, node.unit);
    return Date3.endDate(b2);
  }
  visitTime(node, b2) {
    Time2.startTime(b2);
    Time2.addUnit(b2, node.unit);
    Time2.addBitWidth(b2, node.bitWidth);
    return Time2.endTime(b2);
  }
  visitTimestamp(node, b2) {
    const timezone = node.timezone && b2.createString(node.timezone) || void 0;
    Timestamp2.startTimestamp(b2);
    Timestamp2.addUnit(b2, node.unit);
    if (timezone !== void 0) {
      Timestamp2.addTimezone(b2, timezone);
    }
    return Timestamp2.endTimestamp(b2);
  }
  visitInterval(node, b2) {
    Interval2.startInterval(b2);
    Interval2.addUnit(b2, node.unit);
    return Interval2.endInterval(b2);
  }
  visitDuration(node, b2) {
    Duration4.startDuration(b2);
    Duration4.addUnit(b2, node.unit);
    return Duration4.endDuration(b2);
  }
  visitList(_node, b2) {
    List4.startList(b2);
    return List4.endList(b2);
  }
  visitStruct(_node, b2) {
    Struct_2.startStruct_(b2);
    return Struct_2.endStruct_(b2);
  }
  visitUnion(node, b2) {
    Union2.startTypeIdsVector(b2, node.typeIds.length);
    const typeIds = Union2.createTypeIdsVector(b2, node.typeIds);
    Union2.startUnion(b2);
    Union2.addMode(b2, node.mode);
    Union2.addTypeIds(b2, typeIds);
    return Union2.endUnion(b2);
  }
  visitDictionary(node, b2) {
    const indexType = this.visit(node.indices, b2);
    DictionaryEncoding2.startDictionaryEncoding(b2);
    DictionaryEncoding2.addId(b2, BigInt(node.id));
    DictionaryEncoding2.addIsOrdered(b2, node.isOrdered);
    if (indexType !== void 0) {
      DictionaryEncoding2.addIndexType(b2, indexType);
    }
    return DictionaryEncoding2.endDictionaryEncoding(b2);
  }
  visitFixedSizeBinary(node, b2) {
    FixedSizeBinary4.startFixedSizeBinary(b2);
    FixedSizeBinary4.addByteWidth(b2, node.byteWidth);
    return FixedSizeBinary4.endFixedSizeBinary(b2);
  }
  visitFixedSizeList(node, b2) {
    FixedSizeList4.startFixedSizeList(b2);
    FixedSizeList4.addListSize(b2, node.listSize);
    return FixedSizeList4.endFixedSizeList(b2);
  }
  visitMap(node, b2) {
    Map3.startMap(b2);
    Map3.addKeysSorted(b2, node.keysSorted);
    return Map3.endMap(b2);
  }
};
var instance15 = new TypeAssembler2();

// ../../node_modules/apache-arrow/ipc/metadata/json.mjs
function schemaFromJSON2(_schema, dictionaries = /* @__PURE__ */ new Map()) {
  return new Schema4(schemaFieldsFromJSON2(_schema, dictionaries), customMetadataFromJSON2(_schema["metadata"]), dictionaries);
}
function recordBatchFromJSON2(b2) {
  return new RecordBatch6(b2["count"], fieldNodesFromJSON2(b2["columns"]), buffersFromJSON2(b2["columns"]));
}
function dictionaryBatchFromJSON2(b2) {
  return new DictionaryBatch4(recordBatchFromJSON2(b2["data"]), b2["id"], b2["isDelta"]);
}
function schemaFieldsFromJSON2(_schema, dictionaries) {
  return (_schema["fields"] || []).filter(Boolean).map((f2) => Field4.fromJSON(f2, dictionaries));
}
function fieldChildrenFromJSON2(_field, dictionaries) {
  return (_field["children"] || []).filter(Boolean).map((f2) => Field4.fromJSON(f2, dictionaries));
}
function fieldNodesFromJSON2(xs) {
  return (xs || []).reduce((fieldNodes, column3) => [
    ...fieldNodes,
    new FieldNode4(column3["count"], nullCountFromJSON2(column3["VALIDITY"])),
    ...fieldNodesFromJSON2(column3["children"])
  ], []);
}
function buffersFromJSON2(xs, buffers = []) {
  for (let i = -1, n = (xs || []).length; ++i < n; ) {
    const column3 = xs[i];
    column3["VALIDITY"] && buffers.push(new BufferRegion2(buffers.length, column3["VALIDITY"].length));
    column3["TYPE_ID"] && buffers.push(new BufferRegion2(buffers.length, column3["TYPE_ID"].length));
    column3["OFFSET"] && buffers.push(new BufferRegion2(buffers.length, column3["OFFSET"].length));
    column3["DATA"] && buffers.push(new BufferRegion2(buffers.length, column3["DATA"].length));
    buffers = buffersFromJSON2(column3["children"], buffers);
  }
  return buffers;
}
function nullCountFromJSON2(validity) {
  return (validity || []).reduce((sum5, val) => sum5 + +(val === 0), 0);
}
function fieldFromJSON2(_field, dictionaries) {
  let id2;
  let keys;
  let field2;
  let dictMeta;
  let type2;
  let dictType;
  if (!dictionaries || !(dictMeta = _field["dictionary"])) {
    type2 = typeFromJSON2(_field, fieldChildrenFromJSON2(_field, dictionaries));
    field2 = new Field4(_field["name"], type2, _field["nullable"], customMetadataFromJSON2(_field["metadata"]));
  } else if (!dictionaries.has(id2 = dictMeta["id"])) {
    keys = (keys = dictMeta["indexType"]) ? indexTypeFromJSON2(keys) : new Int322();
    dictionaries.set(id2, type2 = typeFromJSON2(_field, fieldChildrenFromJSON2(_field, dictionaries)));
    dictType = new Dictionary2(type2, keys, id2, dictMeta["isOrdered"]);
    field2 = new Field4(_field["name"], dictType, _field["nullable"], customMetadataFromJSON2(_field["metadata"]));
  } else {
    keys = (keys = dictMeta["indexType"]) ? indexTypeFromJSON2(keys) : new Int322();
    dictType = new Dictionary2(dictionaries.get(id2), keys, id2, dictMeta["isOrdered"]);
    field2 = new Field4(_field["name"], dictType, _field["nullable"], customMetadataFromJSON2(_field["metadata"]));
  }
  return field2 || null;
}
function customMetadataFromJSON2(metadata = []) {
  return new Map(metadata.map(({ key, value }) => [key, value]));
}
function indexTypeFromJSON2(_type) {
  return new Int_2(_type["isSigned"], _type["bitWidth"]);
}
function typeFromJSON2(f2, children2) {
  const typeId = f2["type"]["name"];
  switch (typeId) {
    case "NONE":
      return new Null3();
    case "null":
      return new Null3();
    case "binary":
      return new Binary3();
    case "utf8":
      return new Utf83();
    case "bool":
      return new Bool3();
    case "list":
      return new List3((children2 || [])[0]);
    case "struct":
      return new Struct2(children2 || []);
    case "struct_":
      return new Struct2(children2 || []);
  }
  switch (typeId) {
    case "int": {
      const t = f2["type"];
      return new Int_2(t["isSigned"], t["bitWidth"]);
    }
    case "floatingpoint": {
      const t = f2["type"];
      return new Float2(Precision2[t["precision"]]);
    }
    case "decimal": {
      const t = f2["type"];
      return new Decimal3(t["scale"], t["precision"], t["bitWidth"]);
    }
    case "date": {
      const t = f2["type"];
      return new Date_2(DateUnit2[t["unit"]]);
    }
    case "time": {
      const t = f2["type"];
      return new Time_2(TimeUnit2[t["unit"]], t["bitWidth"]);
    }
    case "timestamp": {
      const t = f2["type"];
      return new Timestamp_2(TimeUnit2[t["unit"]], t["timezone"]);
    }
    case "interval": {
      const t = f2["type"];
      return new Interval_2(IntervalUnit2[t["unit"]]);
    }
    case "duration": {
      const t = f2["type"];
      return new Duration3(TimeUnit2[t["unit"]]);
    }
    case "union": {
      const t = f2["type"];
      const [m2, ...ms] = (t["mode"] + "").toLowerCase();
      const mode3 = m2.toUpperCase() + ms.join("");
      return new Union_2(UnionMode2[mode3], t["typeIds"] || [], children2 || []);
    }
    case "fixedsizebinary": {
      const t = f2["type"];
      return new FixedSizeBinary3(t["byteWidth"]);
    }
    case "fixedsizelist": {
      const t = f2["type"];
      return new FixedSizeList3(t["listSize"], (children2 || [])[0]);
    }
    case "map": {
      const t = f2["type"];
      return new Map_2((children2 || [])[0], t["keysSorted"]);
    }
  }
  throw new Error(`Unrecognized type: "${typeId}"`);
}

// ../../node_modules/apache-arrow/ipc/metadata/message.mjs
var Builder7 = Builder;
var ByteBuffer5 = ByteBuffer;
var Message4 = class _Message {
  /** @nocollapse */
  static fromJSON(msg, headerType) {
    const message = new _Message(0, MetadataVersion2.V5, headerType);
    message._createHeader = messageHeaderFromJSON2(msg, headerType);
    return message;
  }
  /** @nocollapse */
  static decode(buf) {
    buf = new ByteBuffer5(toUint8Array2(buf));
    const _message = Message3.getRootAsMessage(buf);
    const bodyLength = _message.bodyLength();
    const version = _message.version();
    const headerType = _message.headerType();
    const message = new _Message(bodyLength, version, headerType);
    message._createHeader = decodeMessageHeader2(_message, headerType);
    return message;
  }
  /** @nocollapse */
  static encode(message) {
    const b2 = new Builder7();
    let headerOffset = -1;
    if (message.isSchema()) {
      headerOffset = Schema4.encode(b2, message.header());
    } else if (message.isRecordBatch()) {
      headerOffset = RecordBatch6.encode(b2, message.header());
    } else if (message.isDictionaryBatch()) {
      headerOffset = DictionaryBatch4.encode(b2, message.header());
    }
    Message3.startMessage(b2);
    Message3.addVersion(b2, MetadataVersion2.V5);
    Message3.addHeader(b2, headerOffset);
    Message3.addHeaderType(b2, message.headerType);
    Message3.addBodyLength(b2, BigInt(message.bodyLength));
    Message3.finishMessageBuffer(b2, Message3.endMessage(b2));
    return b2.asUint8Array();
  }
  /** @nocollapse */
  static from(header, bodyLength = 0) {
    if (header instanceof Schema4) {
      return new _Message(0, MetadataVersion2.V5, MessageHeader2.Schema, header);
    }
    if (header instanceof RecordBatch6) {
      return new _Message(bodyLength, MetadataVersion2.V5, MessageHeader2.RecordBatch, header);
    }
    if (header instanceof DictionaryBatch4) {
      return new _Message(bodyLength, MetadataVersion2.V5, MessageHeader2.DictionaryBatch, header);
    }
    throw new Error(`Unrecognized Message header: ${header}`);
  }
  get type() {
    return this.headerType;
  }
  get version() {
    return this._version;
  }
  get headerType() {
    return this._headerType;
  }
  get bodyLength() {
    return this._bodyLength;
  }
  header() {
    return this._createHeader();
  }
  isSchema() {
    return this.headerType === MessageHeader2.Schema;
  }
  isRecordBatch() {
    return this.headerType === MessageHeader2.RecordBatch;
  }
  isDictionaryBatch() {
    return this.headerType === MessageHeader2.DictionaryBatch;
  }
  constructor(bodyLength, version, headerType, header) {
    this._version = version;
    this._headerType = headerType;
    this.body = new Uint8Array(0);
    header && (this._createHeader = () => header);
    this._bodyLength = bigIntToNumber2(bodyLength);
  }
};
var RecordBatch6 = class {
  get nodes() {
    return this._nodes;
  }
  get length() {
    return this._length;
  }
  get buffers() {
    return this._buffers;
  }
  constructor(length4, nodes, buffers) {
    this._nodes = nodes;
    this._buffers = buffers;
    this._length = bigIntToNumber2(length4);
  }
};
var DictionaryBatch4 = class {
  get id() {
    return this._id;
  }
  get data() {
    return this._data;
  }
  get isDelta() {
    return this._isDelta;
  }
  get length() {
    return this.data.length;
  }
  get nodes() {
    return this.data.nodes;
  }
  get buffers() {
    return this.data.buffers;
  }
  constructor(data, id2, isDelta = false) {
    this._data = data;
    this._isDelta = isDelta;
    this._id = bigIntToNumber2(id2);
  }
};
var BufferRegion2 = class {
  constructor(offset2, length4) {
    this.offset = bigIntToNumber2(offset2);
    this.length = bigIntToNumber2(length4);
  }
};
var FieldNode4 = class {
  constructor(length4, nullCount) {
    this.length = bigIntToNumber2(length4);
    this.nullCount = bigIntToNumber2(nullCount);
  }
};
function messageHeaderFromJSON2(message, type2) {
  return () => {
    switch (type2) {
      case MessageHeader2.Schema:
        return Schema4.fromJSON(message);
      case MessageHeader2.RecordBatch:
        return RecordBatch6.fromJSON(message);
      case MessageHeader2.DictionaryBatch:
        return DictionaryBatch4.fromJSON(message);
    }
    throw new Error(`Unrecognized Message type: { name: ${MessageHeader2[type2]}, type: ${type2} }`);
  };
}
function decodeMessageHeader2(message, type2) {
  return () => {
    switch (type2) {
      case MessageHeader2.Schema:
        return Schema4.decode(message.header(new Schema3()), /* @__PURE__ */ new Map(), message.version());
      case MessageHeader2.RecordBatch:
        return RecordBatch6.decode(message.header(new RecordBatch5()), message.version());
      case MessageHeader2.DictionaryBatch:
        return DictionaryBatch4.decode(message.header(new DictionaryBatch3()), message.version());
    }
    throw new Error(`Unrecognized Message type: { name: ${MessageHeader2[type2]}, type: ${type2} }`);
  };
}
Field4["encode"] = encodeField2;
Field4["decode"] = decodeField2;
Field4["fromJSON"] = fieldFromJSON2;
Schema4["encode"] = encodeSchema2;
Schema4["decode"] = decodeSchema2;
Schema4["fromJSON"] = schemaFromJSON2;
RecordBatch6["encode"] = encodeRecordBatch2;
RecordBatch6["decode"] = decodeRecordBatch2;
RecordBatch6["fromJSON"] = recordBatchFromJSON2;
DictionaryBatch4["encode"] = encodeDictionaryBatch2;
DictionaryBatch4["decode"] = decodeDictionaryBatch2;
DictionaryBatch4["fromJSON"] = dictionaryBatchFromJSON2;
FieldNode4["encode"] = encodeFieldNode2;
FieldNode4["decode"] = decodeFieldNode2;
BufferRegion2["encode"] = encodeBufferRegion2;
BufferRegion2["decode"] = decodeBufferRegion2;
function decodeSchema2(_schema, dictionaries = /* @__PURE__ */ new Map(), version = MetadataVersion2.V5) {
  const fields = decodeSchemaFields2(_schema, dictionaries);
  return new Schema4(fields, decodeCustomMetadata2(_schema), dictionaries, version);
}
function decodeRecordBatch2(batch, version = MetadataVersion2.V5) {
  if (batch.compression() !== null) {
    throw new Error("Record batch compression not implemented");
  }
  return new RecordBatch6(batch.length(), decodeFieldNodes2(batch), decodeBuffers2(batch, version));
}
function decodeDictionaryBatch2(batch, version = MetadataVersion2.V5) {
  return new DictionaryBatch4(RecordBatch6.decode(batch.data(), version), batch.id(), batch.isDelta());
}
function decodeBufferRegion2(b2) {
  return new BufferRegion2(b2.offset(), b2.length());
}
function decodeFieldNode2(f2) {
  return new FieldNode4(f2.length(), f2.nullCount());
}
function decodeFieldNodes2(batch) {
  const nodes = [];
  for (let f2, i = -1, j2 = -1, n = batch.nodesLength(); ++i < n; ) {
    if (f2 = batch.nodes(i)) {
      nodes[++j2] = FieldNode4.decode(f2);
    }
  }
  return nodes;
}
function decodeBuffers2(batch, version) {
  const bufferRegions = [];
  for (let b2, i = -1, j2 = -1, n = batch.buffersLength(); ++i < n; ) {
    if (b2 = batch.buffers(i)) {
      if (version < MetadataVersion2.V4) {
        b2.bb_pos += 8 * (i + 1);
      }
      bufferRegions[++j2] = BufferRegion2.decode(b2);
    }
  }
  return bufferRegions;
}
function decodeSchemaFields2(schema, dictionaries) {
  const fields = [];
  for (let f2, i = -1, j2 = -1, n = schema.fieldsLength(); ++i < n; ) {
    if (f2 = schema.fields(i)) {
      fields[++j2] = Field4.decode(f2, dictionaries);
    }
  }
  return fields;
}
function decodeFieldChildren2(field2, dictionaries) {
  const children2 = [];
  for (let f2, i = -1, j2 = -1, n = field2.childrenLength(); ++i < n; ) {
    if (f2 = field2.children(i)) {
      children2[++j2] = Field4.decode(f2, dictionaries);
    }
  }
  return children2;
}
function decodeField2(f2, dictionaries) {
  let id2;
  let field2;
  let type2;
  let keys;
  let dictType;
  let dictMeta;
  if (!dictionaries || !(dictMeta = f2.dictionary())) {
    type2 = decodeFieldType2(f2, decodeFieldChildren2(f2, dictionaries));
    field2 = new Field4(f2.name(), type2, f2.nullable(), decodeCustomMetadata2(f2));
  } else if (!dictionaries.has(id2 = bigIntToNumber2(dictMeta.id()))) {
    keys = (keys = dictMeta.indexType()) ? decodeIndexType2(keys) : new Int322();
    dictionaries.set(id2, type2 = decodeFieldType2(f2, decodeFieldChildren2(f2, dictionaries)));
    dictType = new Dictionary2(type2, keys, id2, dictMeta.isOrdered());
    field2 = new Field4(f2.name(), dictType, f2.nullable(), decodeCustomMetadata2(f2));
  } else {
    keys = (keys = dictMeta.indexType()) ? decodeIndexType2(keys) : new Int322();
    dictType = new Dictionary2(dictionaries.get(id2), keys, id2, dictMeta.isOrdered());
    field2 = new Field4(f2.name(), dictType, f2.nullable(), decodeCustomMetadata2(f2));
  }
  return field2 || null;
}
function decodeCustomMetadata2(parent) {
  const data = /* @__PURE__ */ new Map();
  if (parent) {
    for (let entry, key, i = -1, n = Math.trunc(parent.customMetadataLength()); ++i < n; ) {
      if ((entry = parent.customMetadata(i)) && (key = entry.key()) != null) {
        data.set(key, entry.value());
      }
    }
  }
  return data;
}
function decodeIndexType2(_type) {
  return new Int_2(_type.isSigned(), _type.bitWidth());
}
function decodeFieldType2(f2, children2) {
  const typeId = f2.typeType();
  switch (typeId) {
    case Type4["NONE"]:
      return new Null3();
    case Type4["Null"]:
      return new Null3();
    case Type4["Binary"]:
      return new Binary3();
    case Type4["Utf8"]:
      return new Utf83();
    case Type4["Bool"]:
      return new Bool3();
    case Type4["List"]:
      return new List3((children2 || [])[0]);
    case Type4["Struct_"]:
      return new Struct2(children2 || []);
  }
  switch (typeId) {
    case Type4["Int"]: {
      const t = f2.type(new Int2());
      return new Int_2(t.isSigned(), t.bitWidth());
    }
    case Type4["FloatingPoint"]: {
      const t = f2.type(new FloatingPoint2());
      return new Float2(t.precision());
    }
    case Type4["Decimal"]: {
      const t = f2.type(new Decimal4());
      return new Decimal3(t.scale(), t.precision(), t.bitWidth());
    }
    case Type4["Date"]: {
      const t = f2.type(new Date3());
      return new Date_2(t.unit());
    }
    case Type4["Time"]: {
      const t = f2.type(new Time2());
      return new Time_2(t.unit(), t.bitWidth());
    }
    case Type4["Timestamp"]: {
      const t = f2.type(new Timestamp2());
      return new Timestamp_2(t.unit(), t.timezone());
    }
    case Type4["Interval"]: {
      const t = f2.type(new Interval2());
      return new Interval_2(t.unit());
    }
    case Type4["Duration"]: {
      const t = f2.type(new Duration4());
      return new Duration3(t.unit());
    }
    case Type4["Union"]: {
      const t = f2.type(new Union2());
      return new Union_2(t.mode(), t.typeIdsArray() || [], children2 || []);
    }
    case Type4["FixedSizeBinary"]: {
      const t = f2.type(new FixedSizeBinary4());
      return new FixedSizeBinary3(t.byteWidth());
    }
    case Type4["FixedSizeList"]: {
      const t = f2.type(new FixedSizeList4());
      return new FixedSizeList3(t.listSize(), (children2 || [])[0]);
    }
    case Type4["Map"]: {
      const t = f2.type(new Map3());
      return new Map_2((children2 || [])[0], t.keysSorted());
    }
  }
  throw new Error(`Unrecognized type: "${Type4[typeId]}" (${typeId})`);
}
function encodeSchema2(b2, schema) {
  const fieldOffsets = schema.fields.map((f2) => Field4.encode(b2, f2));
  Schema3.startFieldsVector(b2, fieldOffsets.length);
  const fieldsVectorOffset = Schema3.createFieldsVector(b2, fieldOffsets);
  const metadataOffset = !(schema.metadata && schema.metadata.size > 0) ? -1 : Schema3.createCustomMetadataVector(b2, [...schema.metadata].map(([k3, v3]) => {
    const key = b2.createString(`${k3}`);
    const val = b2.createString(`${v3}`);
    KeyValue2.startKeyValue(b2);
    KeyValue2.addKey(b2, key);
    KeyValue2.addValue(b2, val);
    return KeyValue2.endKeyValue(b2);
  }));
  Schema3.startSchema(b2);
  Schema3.addFields(b2, fieldsVectorOffset);
  Schema3.addEndianness(b2, platformIsLittleEndian2 ? Endianness2.Little : Endianness2.Big);
  if (metadataOffset !== -1) {
    Schema3.addCustomMetadata(b2, metadataOffset);
  }
  return Schema3.endSchema(b2);
}
function encodeField2(b2, field2) {
  let nameOffset = -1;
  let typeOffset = -1;
  let dictionaryOffset = -1;
  const type2 = field2.type;
  let typeId = field2.typeId;
  if (!DataType2.isDictionary(type2)) {
    typeOffset = instance15.visit(type2, b2);
  } else {
    typeId = type2.dictionary.typeId;
    dictionaryOffset = instance15.visit(type2, b2);
    typeOffset = instance15.visit(type2.dictionary, b2);
  }
  const childOffsets = (type2.children || []).map((f2) => Field4.encode(b2, f2));
  const childrenVectorOffset = Field3.createChildrenVector(b2, childOffsets);
  const metadataOffset = !(field2.metadata && field2.metadata.size > 0) ? -1 : Field3.createCustomMetadataVector(b2, [...field2.metadata].map(([k3, v3]) => {
    const key = b2.createString(`${k3}`);
    const val = b2.createString(`${v3}`);
    KeyValue2.startKeyValue(b2);
    KeyValue2.addKey(b2, key);
    KeyValue2.addValue(b2, val);
    return KeyValue2.endKeyValue(b2);
  }));
  if (field2.name) {
    nameOffset = b2.createString(field2.name);
  }
  Field3.startField(b2);
  Field3.addType(b2, typeOffset);
  Field3.addTypeType(b2, typeId);
  Field3.addChildren(b2, childrenVectorOffset);
  Field3.addNullable(b2, !!field2.nullable);
  if (nameOffset !== -1) {
    Field3.addName(b2, nameOffset);
  }
  if (dictionaryOffset !== -1) {
    Field3.addDictionary(b2, dictionaryOffset);
  }
  if (metadataOffset !== -1) {
    Field3.addCustomMetadata(b2, metadataOffset);
  }
  return Field3.endField(b2);
}
function encodeRecordBatch2(b2, recordBatch) {
  const nodes = recordBatch.nodes || [];
  const buffers = recordBatch.buffers || [];
  RecordBatch5.startNodesVector(b2, nodes.length);
  for (const n of nodes.slice().reverse())
    FieldNode4.encode(b2, n);
  const nodesVectorOffset = b2.endVector();
  RecordBatch5.startBuffersVector(b2, buffers.length);
  for (const b_ of buffers.slice().reverse())
    BufferRegion2.encode(b2, b_);
  const buffersVectorOffset = b2.endVector();
  RecordBatch5.startRecordBatch(b2);
  RecordBatch5.addLength(b2, BigInt(recordBatch.length));
  RecordBatch5.addNodes(b2, nodesVectorOffset);
  RecordBatch5.addBuffers(b2, buffersVectorOffset);
  return RecordBatch5.endRecordBatch(b2);
}
function encodeDictionaryBatch2(b2, dictionaryBatch) {
  const dataOffset = RecordBatch6.encode(b2, dictionaryBatch.data);
  DictionaryBatch3.startDictionaryBatch(b2);
  DictionaryBatch3.addId(b2, BigInt(dictionaryBatch.id));
  DictionaryBatch3.addIsDelta(b2, dictionaryBatch.isDelta);
  DictionaryBatch3.addData(b2, dataOffset);
  return DictionaryBatch3.endDictionaryBatch(b2);
}
function encodeFieldNode2(b2, node) {
  return FieldNode3.createFieldNode(b2, BigInt(node.length), BigInt(node.nullCount));
}
function encodeBufferRegion2(b2, node) {
  return Buffer3.createBuffer(b2, BigInt(node.offset), BigInt(node.length));
}
var platformIsLittleEndian2 = (() => {
  const buffer = new ArrayBuffer(2);
  new DataView(buffer).setInt16(
    0,
    256,
    true
    /* littleEndian */
  );
  return new Int16Array(buffer)[0] === 256;
})();

// ../../node_modules/apache-arrow/ipc/message.mjs
var invalidMessageType2 = (type2) => `Expected ${MessageHeader2[type2]} Message in stream, but was null or length 0.`;
var nullMessage2 = (type2) => `Header pointer of flatbuffer-encoded ${MessageHeader2[type2]} Message is null or length 0.`;
var invalidMessageMetadata2 = (expected, actual) => `Expected to read ${expected} metadata bytes, but only read ${actual}.`;
var invalidMessageBodyLength2 = (expected, actual) => `Expected to read ${expected} bytes for message body, but only read ${actual}.`;
var MessageReader2 = class {
  constructor(source) {
    this.source = source instanceof ByteStream2 ? source : new ByteStream2(source);
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    let r;
    if ((r = this.readMetadataLength()).done) {
      return ITERATOR_DONE2;
    }
    if (r.value === -1 && (r = this.readMetadataLength()).done) {
      return ITERATOR_DONE2;
    }
    if ((r = this.readMetadata(r.value)).done) {
      return ITERATOR_DONE2;
    }
    return r;
  }
  throw(value) {
    return this.source.throw(value);
  }
  return(value) {
    return this.source.return(value);
  }
  readMessage(type2) {
    let r;
    if ((r = this.next()).done) {
      return null;
    }
    if (type2 != null && r.value.headerType !== type2) {
      throw new Error(invalidMessageType2(type2));
    }
    return r.value;
  }
  readMessageBody(bodyLength) {
    if (bodyLength <= 0) {
      return new Uint8Array(0);
    }
    const buf = toUint8Array2(this.source.read(bodyLength));
    if (buf.byteLength < bodyLength) {
      throw new Error(invalidMessageBodyLength2(bodyLength, buf.byteLength));
    }
    return (
      /* 1. */
      buf.byteOffset % 8 === 0 && /* 2. */
      buf.byteOffset + buf.byteLength <= buf.buffer.byteLength ? buf : buf.slice()
    );
  }
  readSchema(throwIfNull = false) {
    const type2 = MessageHeader2.Schema;
    const message = this.readMessage(type2);
    const schema = message === null || message === void 0 ? void 0 : message.header();
    if (throwIfNull && !schema) {
      throw new Error(nullMessage2(type2));
    }
    return schema;
  }
  readMetadataLength() {
    const buf = this.source.read(PADDING2);
    const bb2 = buf && new ByteBuffer(buf);
    const len = (bb2 === null || bb2 === void 0 ? void 0 : bb2.readInt32(0)) || 0;
    return { done: len === 0, value: len };
  }
  readMetadata(metadataLength) {
    const buf = this.source.read(metadataLength);
    if (!buf) {
      return ITERATOR_DONE2;
    }
    if (buf.byteLength < metadataLength) {
      throw new Error(invalidMessageMetadata2(metadataLength, buf.byteLength));
    }
    return { done: false, value: Message4.decode(buf) };
  }
};
var AsyncMessageReader2 = class {
  constructor(source, byteLength) {
    this.source = source instanceof AsyncByteStream2 ? source : isFileHandle2(source) ? new AsyncRandomAccessFile2(source, byteLength) : new AsyncByteStream2(source);
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  next() {
    return __awaiter(this, void 0, void 0, function* () {
      let r;
      if ((r = yield this.readMetadataLength()).done) {
        return ITERATOR_DONE2;
      }
      if (r.value === -1 && (r = yield this.readMetadataLength()).done) {
        return ITERATOR_DONE2;
      }
      if ((r = yield this.readMetadata(r.value)).done) {
        return ITERATOR_DONE2;
      }
      return r;
    });
  }
  throw(value) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this.source.throw(value);
    });
  }
  return(value) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this.source.return(value);
    });
  }
  readMessage(type2) {
    return __awaiter(this, void 0, void 0, function* () {
      let r;
      if ((r = yield this.next()).done) {
        return null;
      }
      if (type2 != null && r.value.headerType !== type2) {
        throw new Error(invalidMessageType2(type2));
      }
      return r.value;
    });
  }
  readMessageBody(bodyLength) {
    return __awaiter(this, void 0, void 0, function* () {
      if (bodyLength <= 0) {
        return new Uint8Array(0);
      }
      const buf = toUint8Array2(yield this.source.read(bodyLength));
      if (buf.byteLength < bodyLength) {
        throw new Error(invalidMessageBodyLength2(bodyLength, buf.byteLength));
      }
      return (
        /* 1. */
        buf.byteOffset % 8 === 0 && /* 2. */
        buf.byteOffset + buf.byteLength <= buf.buffer.byteLength ? buf : buf.slice()
      );
    });
  }
  readSchema(throwIfNull = false) {
    return __awaiter(this, void 0, void 0, function* () {
      const type2 = MessageHeader2.Schema;
      const message = yield this.readMessage(type2);
      const schema = message === null || message === void 0 ? void 0 : message.header();
      if (throwIfNull && !schema) {
        throw new Error(nullMessage2(type2));
      }
      return schema;
    });
  }
  readMetadataLength() {
    return __awaiter(this, void 0, void 0, function* () {
      const buf = yield this.source.read(PADDING2);
      const bb2 = buf && new ByteBuffer(buf);
      const len = (bb2 === null || bb2 === void 0 ? void 0 : bb2.readInt32(0)) || 0;
      return { done: len === 0, value: len };
    });
  }
  readMetadata(metadataLength) {
    return __awaiter(this, void 0, void 0, function* () {
      const buf = yield this.source.read(metadataLength);
      if (!buf) {
        return ITERATOR_DONE2;
      }
      if (buf.byteLength < metadataLength) {
        throw new Error(invalidMessageMetadata2(metadataLength, buf.byteLength));
      }
      return { done: false, value: Message4.decode(buf) };
    });
  }
};
var JSONMessageReader2 = class extends MessageReader2 {
  constructor(source) {
    super(new Uint8Array(0));
    this._schema = false;
    this._body = [];
    this._batchIndex = 0;
    this._dictionaryIndex = 0;
    this._json = source instanceof ArrowJSON2 ? source : new ArrowJSON2(source);
  }
  next() {
    const { _json } = this;
    if (!this._schema) {
      this._schema = true;
      const message = Message4.fromJSON(_json.schema, MessageHeader2.Schema);
      return { done: false, value: message };
    }
    if (this._dictionaryIndex < _json.dictionaries.length) {
      const batch = _json.dictionaries[this._dictionaryIndex++];
      this._body = batch["data"]["columns"];
      const message = Message4.fromJSON(batch, MessageHeader2.DictionaryBatch);
      return { done: false, value: message };
    }
    if (this._batchIndex < _json.batches.length) {
      const batch = _json.batches[this._batchIndex++];
      this._body = batch["columns"];
      const message = Message4.fromJSON(batch, MessageHeader2.RecordBatch);
      return { done: false, value: message };
    }
    this._body = [];
    return ITERATOR_DONE2;
  }
  readMessageBody(_bodyLength) {
    return flattenDataSources(this._body);
    function flattenDataSources(xs) {
      return (xs || []).reduce((buffers, column3) => [
        ...buffers,
        ...column3["VALIDITY"] && [column3["VALIDITY"]] || [],
        ...column3["TYPE_ID"] && [column3["TYPE_ID"]] || [],
        ...column3["OFFSET"] && [column3["OFFSET"]] || [],
        ...column3["DATA"] && [column3["DATA"]] || [],
        ...flattenDataSources(column3["children"])
      ], []);
    }
  }
  readMessage(type2) {
    let r;
    if ((r = this.next()).done) {
      return null;
    }
    if (type2 != null && r.value.headerType !== type2) {
      throw new Error(invalidMessageType2(type2));
    }
    return r.value;
  }
  readSchema() {
    const type2 = MessageHeader2.Schema;
    const message = this.readMessage(type2);
    const schema = message === null || message === void 0 ? void 0 : message.header();
    if (!message || !schema) {
      throw new Error(nullMessage2(type2));
    }
    return schema;
  }
};
var PADDING2 = 4;
var MAGIC_STR2 = "ARROW1";
var MAGIC2 = new Uint8Array(MAGIC_STR2.length);
for (let i = 0; i < MAGIC_STR2.length; i += 1) {
  MAGIC2[i] = MAGIC_STR2.codePointAt(i);
}
function checkForMagicArrowString2(buffer, index2 = 0) {
  for (let i = -1, n = MAGIC2.length; ++i < n; ) {
    if (MAGIC2[i] !== buffer[index2 + i]) {
      return false;
    }
  }
  return true;
}
var magicLength2 = MAGIC2.length;
var magicAndPadding2 = magicLength2 + PADDING2;
var magicX2AndPadding2 = magicLength2 * 2 + PADDING2;

// ../../node_modules/apache-arrow/ipc/reader.mjs
var RecordBatchReader2 = class _RecordBatchReader extends ReadableInterop2 {
  constructor(impl) {
    super();
    this._impl = impl;
  }
  get closed() {
    return this._impl.closed;
  }
  get schema() {
    return this._impl.schema;
  }
  get autoDestroy() {
    return this._impl.autoDestroy;
  }
  get dictionaries() {
    return this._impl.dictionaries;
  }
  get numDictionaries() {
    return this._impl.numDictionaries;
  }
  get numRecordBatches() {
    return this._impl.numRecordBatches;
  }
  get footer() {
    return this._impl.isFile() ? this._impl.footer : null;
  }
  isSync() {
    return this._impl.isSync();
  }
  isAsync() {
    return this._impl.isAsync();
  }
  isFile() {
    return this._impl.isFile();
  }
  isStream() {
    return this._impl.isStream();
  }
  next() {
    return this._impl.next();
  }
  throw(value) {
    return this._impl.throw(value);
  }
  return(value) {
    return this._impl.return(value);
  }
  cancel() {
    return this._impl.cancel();
  }
  reset(schema) {
    this._impl.reset(schema);
    this._DOMStream = void 0;
    this._nodeStream = void 0;
    return this;
  }
  open(options) {
    const opening = this._impl.open(options);
    return isPromise2(opening) ? opening.then(() => this) : this;
  }
  readRecordBatch(index2) {
    return this._impl.isFile() ? this._impl.readRecordBatch(index2) : null;
  }
  [Symbol.iterator]() {
    return this._impl[Symbol.iterator]();
  }
  [Symbol.asyncIterator]() {
    return this._impl[Symbol.asyncIterator]();
  }
  toDOMStream() {
    return adapters_default2.toDOMStream(this.isSync() ? { [Symbol.iterator]: () => this } : { [Symbol.asyncIterator]: () => this });
  }
  toNodeStream() {
    return adapters_default2.toNodeStream(this.isSync() ? { [Symbol.iterator]: () => this } : { [Symbol.asyncIterator]: () => this }, { objectMode: true });
  }
  /** @nocollapse */
  // @ts-ignore
  static throughNode(options) {
    throw new Error(`"throughNode" not available in this environment`);
  }
  /** @nocollapse */
  static throughDOM(writableStrategy, readableStrategy) {
    throw new Error(`"throughDOM" not available in this environment`);
  }
  /** @nocollapse */
  static from(source) {
    if (source instanceof _RecordBatchReader) {
      return source;
    } else if (isArrowJSON2(source)) {
      return fromArrowJSON2(source);
    } else if (isFileHandle2(source)) {
      return fromFileHandle2(source);
    } else if (isPromise2(source)) {
      return (() => __awaiter(this, void 0, void 0, function* () {
        return yield _RecordBatchReader.from(yield source);
      }))();
    } else if (isFetchResponse2(source) || isReadableDOMStream2(source) || isReadableNodeStream2(source) || isAsyncIterable2(source)) {
      return fromAsyncByteStream2(new AsyncByteStream2(source));
    }
    return fromByteStream2(new ByteStream2(source));
  }
  /** @nocollapse */
  static readAll(source) {
    if (source instanceof _RecordBatchReader) {
      return source.isSync() ? readAllSync2(source) : readAllAsync2(source);
    } else if (isArrowJSON2(source) || ArrayBuffer.isView(source) || isIterable2(source) || isIteratorResult2(source)) {
      return readAllSync2(source);
    }
    return readAllAsync2(source);
  }
};
var RecordBatchStreamReader2 = class extends RecordBatchReader2 {
  constructor(_impl) {
    super(_impl);
    this._impl = _impl;
  }
  readAll() {
    return [...this];
  }
  [Symbol.iterator]() {
    return this._impl[Symbol.iterator]();
  }
  [Symbol.asyncIterator]() {
    return __asyncGenerator(this, arguments, function* _a9() {
      yield __await(yield* __asyncDelegator(__asyncValues(this[Symbol.iterator]())));
    });
  }
};
var AsyncRecordBatchStreamReader2 = class extends RecordBatchReader2 {
  constructor(_impl) {
    super(_impl);
    this._impl = _impl;
  }
  readAll() {
    var _a9, e_1, _b3, _c3;
    return __awaiter(this, void 0, void 0, function* () {
      const batches = new Array();
      try {
        for (var _d3 = true, _e3 = __asyncValues(this), _f3; _f3 = yield _e3.next(), _a9 = _f3.done, !_a9; _d3 = true) {
          _c3 = _f3.value;
          _d3 = false;
          const batch = _c3;
          batches.push(batch);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (!_d3 && !_a9 && (_b3 = _e3.return))
            yield _b3.call(_e3);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return batches;
    });
  }
  [Symbol.iterator]() {
    throw new Error(`AsyncRecordBatchStreamReader is not Iterable`);
  }
  [Symbol.asyncIterator]() {
    return this._impl[Symbol.asyncIterator]();
  }
};
var RecordBatchFileReader2 = class extends RecordBatchStreamReader2 {
  constructor(_impl) {
    super(_impl);
    this._impl = _impl;
  }
};
var AsyncRecordBatchFileReader2 = class extends AsyncRecordBatchStreamReader2 {
  constructor(_impl) {
    super(_impl);
    this._impl = _impl;
  }
};
var RecordBatchReaderImpl2 = class {
  get numDictionaries() {
    return this._dictionaryIndex;
  }
  get numRecordBatches() {
    return this._recordBatchIndex;
  }
  constructor(dictionaries = /* @__PURE__ */ new Map()) {
    this.closed = false;
    this.autoDestroy = true;
    this._dictionaryIndex = 0;
    this._recordBatchIndex = 0;
    this.dictionaries = dictionaries;
  }
  isSync() {
    return false;
  }
  isAsync() {
    return false;
  }
  isFile() {
    return false;
  }
  isStream() {
    return false;
  }
  reset(schema) {
    this._dictionaryIndex = 0;
    this._recordBatchIndex = 0;
    this.schema = schema;
    this.dictionaries = /* @__PURE__ */ new Map();
    return this;
  }
  _loadRecordBatch(header, body) {
    const children2 = this._loadVectors(header, body, this.schema.fields);
    const data = makeData2({ type: new Struct2(this.schema.fields), length: header.length, children: children2 });
    return new RecordBatch4(this.schema, data);
  }
  _loadDictionaryBatch(header, body) {
    const { id: id2, isDelta } = header;
    const { dictionaries, schema } = this;
    const dictionary = dictionaries.get(id2);
    if (isDelta || !dictionary) {
      const type2 = schema.dictionaries.get(id2);
      const data = this._loadVectors(header.data, body, [type2]);
      return (dictionary && isDelta ? dictionary.concat(new Vector2(data)) : new Vector2(data)).memoize();
    }
    return dictionary.memoize();
  }
  _loadVectors(header, body, types) {
    return new VectorLoader2(body, header.nodes, header.buffers, this.dictionaries, this.schema.metadataVersion).visitMany(types);
  }
};
var RecordBatchStreamReaderImpl2 = class extends RecordBatchReaderImpl2 {
  constructor(source, dictionaries) {
    super(dictionaries);
    this._reader = !isArrowJSON2(source) ? new MessageReader2(this._handle = source) : new JSONMessageReader2(this._handle = source);
  }
  isSync() {
    return true;
  }
  isStream() {
    return true;
  }
  [Symbol.iterator]() {
    return this;
  }
  cancel() {
    if (!this.closed && (this.closed = true)) {
      this.reset()._reader.return();
      this._reader = null;
      this.dictionaries = null;
    }
  }
  open(options) {
    if (!this.closed) {
      this.autoDestroy = shouldAutoDestroy2(this, options);
      if (!(this.schema || (this.schema = this._reader.readSchema()))) {
        this.cancel();
      }
    }
    return this;
  }
  throw(value) {
    if (!this.closed && this.autoDestroy && (this.closed = true)) {
      return this.reset()._reader.throw(value);
    }
    return ITERATOR_DONE2;
  }
  return(value) {
    if (!this.closed && this.autoDestroy && (this.closed = true)) {
      return this.reset()._reader.return(value);
    }
    return ITERATOR_DONE2;
  }
  next() {
    if (this.closed) {
      return ITERATOR_DONE2;
    }
    let message;
    const { _reader: reader } = this;
    while (message = this._readNextMessageAndValidate()) {
      if (message.isSchema()) {
        this.reset(message.header());
      } else if (message.isRecordBatch()) {
        this._recordBatchIndex++;
        const header = message.header();
        const buffer = reader.readMessageBody(message.bodyLength);
        const recordBatch = this._loadRecordBatch(header, buffer);
        return { done: false, value: recordBatch };
      } else if (message.isDictionaryBatch()) {
        this._dictionaryIndex++;
        const header = message.header();
        const buffer = reader.readMessageBody(message.bodyLength);
        const vector3 = this._loadDictionaryBatch(header, buffer);
        this.dictionaries.set(header.id, vector3);
      }
    }
    if (this.schema && this._recordBatchIndex === 0) {
      this._recordBatchIndex++;
      return { done: false, value: new _InternalEmptyPlaceholderRecordBatch2(this.schema) };
    }
    return this.return();
  }
  _readNextMessageAndValidate(type2) {
    return this._reader.readMessage(type2);
  }
};
var AsyncRecordBatchStreamReaderImpl2 = class extends RecordBatchReaderImpl2 {
  constructor(source, dictionaries) {
    super(dictionaries);
    this._reader = new AsyncMessageReader2(this._handle = source);
  }
  isAsync() {
    return true;
  }
  isStream() {
    return true;
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  cancel() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.closed && (this.closed = true)) {
        yield this.reset()._reader.return();
        this._reader = null;
        this.dictionaries = null;
      }
    });
  }
  open(options) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.closed) {
        this.autoDestroy = shouldAutoDestroy2(this, options);
        if (!(this.schema || (this.schema = yield this._reader.readSchema()))) {
          yield this.cancel();
        }
      }
      return this;
    });
  }
  throw(value) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.closed && this.autoDestroy && (this.closed = true)) {
        return yield this.reset()._reader.throw(value);
      }
      return ITERATOR_DONE2;
    });
  }
  return(value) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.closed && this.autoDestroy && (this.closed = true)) {
        return yield this.reset()._reader.return(value);
      }
      return ITERATOR_DONE2;
    });
  }
  next() {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.closed) {
        return ITERATOR_DONE2;
      }
      let message;
      const { _reader: reader } = this;
      while (message = yield this._readNextMessageAndValidate()) {
        if (message.isSchema()) {
          yield this.reset(message.header());
        } else if (message.isRecordBatch()) {
          this._recordBatchIndex++;
          const header = message.header();
          const buffer = yield reader.readMessageBody(message.bodyLength);
          const recordBatch = this._loadRecordBatch(header, buffer);
          return { done: false, value: recordBatch };
        } else if (message.isDictionaryBatch()) {
          this._dictionaryIndex++;
          const header = message.header();
          const buffer = yield reader.readMessageBody(message.bodyLength);
          const vector3 = this._loadDictionaryBatch(header, buffer);
          this.dictionaries.set(header.id, vector3);
        }
      }
      if (this.schema && this._recordBatchIndex === 0) {
        this._recordBatchIndex++;
        return { done: false, value: new _InternalEmptyPlaceholderRecordBatch2(this.schema) };
      }
      return yield this.return();
    });
  }
  _readNextMessageAndValidate(type2) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this._reader.readMessage(type2);
    });
  }
};
var RecordBatchFileReaderImpl2 = class extends RecordBatchStreamReaderImpl2 {
  get footer() {
    return this._footer;
  }
  get numDictionaries() {
    return this._footer ? this._footer.numDictionaries : 0;
  }
  get numRecordBatches() {
    return this._footer ? this._footer.numRecordBatches : 0;
  }
  constructor(source, dictionaries) {
    super(source instanceof RandomAccessFile2 ? source : new RandomAccessFile2(source), dictionaries);
  }
  isSync() {
    return true;
  }
  isFile() {
    return true;
  }
  open(options) {
    if (!this.closed && !this._footer) {
      this.schema = (this._footer = this._readFooter()).schema;
      for (const block of this._footer.dictionaryBatches()) {
        block && this._readDictionaryBatch(this._dictionaryIndex++);
      }
    }
    return super.open(options);
  }
  readRecordBatch(index2) {
    var _a9;
    if (this.closed) {
      return null;
    }
    if (!this._footer) {
      this.open();
    }
    const block = (_a9 = this._footer) === null || _a9 === void 0 ? void 0 : _a9.getRecordBatch(index2);
    if (block && this._handle.seek(block.offset)) {
      const message = this._reader.readMessage(MessageHeader2.RecordBatch);
      if (message === null || message === void 0 ? void 0 : message.isRecordBatch()) {
        const header = message.header();
        const buffer = this._reader.readMessageBody(message.bodyLength);
        const recordBatch = this._loadRecordBatch(header, buffer);
        return recordBatch;
      }
    }
    return null;
  }
  _readDictionaryBatch(index2) {
    var _a9;
    const block = (_a9 = this._footer) === null || _a9 === void 0 ? void 0 : _a9.getDictionaryBatch(index2);
    if (block && this._handle.seek(block.offset)) {
      const message = this._reader.readMessage(MessageHeader2.DictionaryBatch);
      if (message === null || message === void 0 ? void 0 : message.isDictionaryBatch()) {
        const header = message.header();
        const buffer = this._reader.readMessageBody(message.bodyLength);
        const vector3 = this._loadDictionaryBatch(header, buffer);
        this.dictionaries.set(header.id, vector3);
      }
    }
  }
  _readFooter() {
    const { _handle } = this;
    const offset2 = _handle.size - magicAndPadding2;
    const length4 = _handle.readInt32(offset2);
    const buffer = _handle.readAt(offset2 - length4, length4);
    return Footer_2.decode(buffer);
  }
  _readNextMessageAndValidate(type2) {
    var _a9;
    if (!this._footer) {
      this.open();
    }
    if (this._footer && this._recordBatchIndex < this.numRecordBatches) {
      const block = (_a9 = this._footer) === null || _a9 === void 0 ? void 0 : _a9.getRecordBatch(this._recordBatchIndex);
      if (block && this._handle.seek(block.offset)) {
        return this._reader.readMessage(type2);
      }
    }
    return null;
  }
};
var AsyncRecordBatchFileReaderImpl2 = class extends AsyncRecordBatchStreamReaderImpl2 {
  get footer() {
    return this._footer;
  }
  get numDictionaries() {
    return this._footer ? this._footer.numDictionaries : 0;
  }
  get numRecordBatches() {
    return this._footer ? this._footer.numRecordBatches : 0;
  }
  constructor(source, ...rest) {
    const byteLength = typeof rest[0] !== "number" ? rest.shift() : void 0;
    const dictionaries = rest[0] instanceof Map ? rest.shift() : void 0;
    super(source instanceof AsyncRandomAccessFile2 ? source : new AsyncRandomAccessFile2(source, byteLength), dictionaries);
  }
  isFile() {
    return true;
  }
  isAsync() {
    return true;
  }
  open(options) {
    const _super = Object.create(null, {
      open: { get: () => super.open }
    });
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.closed && !this._footer) {
        this.schema = (this._footer = yield this._readFooter()).schema;
        for (const block of this._footer.dictionaryBatches()) {
          block && (yield this._readDictionaryBatch(this._dictionaryIndex++));
        }
      }
      return yield _super.open.call(this, options);
    });
  }
  readRecordBatch(index2) {
    var _a9;
    return __awaiter(this, void 0, void 0, function* () {
      if (this.closed) {
        return null;
      }
      if (!this._footer) {
        yield this.open();
      }
      const block = (_a9 = this._footer) === null || _a9 === void 0 ? void 0 : _a9.getRecordBatch(index2);
      if (block && (yield this._handle.seek(block.offset))) {
        const message = yield this._reader.readMessage(MessageHeader2.RecordBatch);
        if (message === null || message === void 0 ? void 0 : message.isRecordBatch()) {
          const header = message.header();
          const buffer = yield this._reader.readMessageBody(message.bodyLength);
          const recordBatch = this._loadRecordBatch(header, buffer);
          return recordBatch;
        }
      }
      return null;
    });
  }
  _readDictionaryBatch(index2) {
    var _a9;
    return __awaiter(this, void 0, void 0, function* () {
      const block = (_a9 = this._footer) === null || _a9 === void 0 ? void 0 : _a9.getDictionaryBatch(index2);
      if (block && (yield this._handle.seek(block.offset))) {
        const message = yield this._reader.readMessage(MessageHeader2.DictionaryBatch);
        if (message === null || message === void 0 ? void 0 : message.isDictionaryBatch()) {
          const header = message.header();
          const buffer = yield this._reader.readMessageBody(message.bodyLength);
          const vector3 = this._loadDictionaryBatch(header, buffer);
          this.dictionaries.set(header.id, vector3);
        }
      }
    });
  }
  _readFooter() {
    return __awaiter(this, void 0, void 0, function* () {
      const { _handle } = this;
      _handle._pending && (yield _handle._pending);
      const offset2 = _handle.size - magicAndPadding2;
      const length4 = yield _handle.readInt32(offset2);
      const buffer = yield _handle.readAt(offset2 - length4, length4);
      return Footer_2.decode(buffer);
    });
  }
  _readNextMessageAndValidate(type2) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this._footer) {
        yield this.open();
      }
      if (this._footer && this._recordBatchIndex < this.numRecordBatches) {
        const block = this._footer.getRecordBatch(this._recordBatchIndex);
        if (block && (yield this._handle.seek(block.offset))) {
          return yield this._reader.readMessage(type2);
        }
      }
      return null;
    });
  }
};
var RecordBatchJSONReaderImpl2 = class extends RecordBatchStreamReaderImpl2 {
  constructor(source, dictionaries) {
    super(source, dictionaries);
  }
  _loadVectors(header, body, types) {
    return new JSONVectorLoader2(body, header.nodes, header.buffers, this.dictionaries, this.schema.metadataVersion).visitMany(types);
  }
};
function shouldAutoDestroy2(self, options) {
  return options && typeof options["autoDestroy"] === "boolean" ? options["autoDestroy"] : self["autoDestroy"];
}
function* readAllSync2(source) {
  const reader = RecordBatchReader2.from(source);
  try {
    if (!reader.open({ autoDestroy: false }).closed) {
      do {
        yield reader;
      } while (!reader.reset().open().closed);
    }
  } finally {
    reader.cancel();
  }
}
function readAllAsync2(source) {
  return __asyncGenerator(this, arguments, function* readAllAsync_1() {
    const reader = yield __await(RecordBatchReader2.from(source));
    try {
      if (!(yield __await(reader.open({ autoDestroy: false }))).closed) {
        do {
          yield yield __await(reader);
        } while (!(yield __await(reader.reset().open())).closed);
      }
    } finally {
      yield __await(reader.cancel());
    }
  });
}
function fromArrowJSON2(source) {
  return new RecordBatchStreamReader2(new RecordBatchJSONReaderImpl2(source));
}
function fromByteStream2(source) {
  const bytes = source.peek(magicLength2 + 7 & ~7);
  return bytes && bytes.byteLength >= 4 ? !checkForMagicArrowString2(bytes) ? new RecordBatchStreamReader2(new RecordBatchStreamReaderImpl2(source)) : new RecordBatchFileReader2(new RecordBatchFileReaderImpl2(source.read())) : new RecordBatchStreamReader2(new RecordBatchStreamReaderImpl2(function* () {
  }()));
}
function fromAsyncByteStream2(source) {
  return __awaiter(this, void 0, void 0, function* () {
    const bytes = yield source.peek(magicLength2 + 7 & ~7);
    return bytes && bytes.byteLength >= 4 ? !checkForMagicArrowString2(bytes) ? new AsyncRecordBatchStreamReader2(new AsyncRecordBatchStreamReaderImpl2(source)) : new RecordBatchFileReader2(new RecordBatchFileReaderImpl2(yield source.read())) : new AsyncRecordBatchStreamReader2(new AsyncRecordBatchStreamReaderImpl2(function() {
      return __asyncGenerator(this, arguments, function* () {
      });
    }()));
  });
}
function fromFileHandle2(source) {
  return __awaiter(this, void 0, void 0, function* () {
    const { size } = yield source.stat();
    const file = new AsyncRandomAccessFile2(source, size);
    if (size >= magicX2AndPadding2 && checkForMagicArrowString2(yield file.readAt(0, magicLength2 + 7 & ~7))) {
      return new AsyncRecordBatchFileReader2(new AsyncRecordBatchFileReaderImpl2(file));
    }
    return new AsyncRecordBatchStreamReader2(new AsyncRecordBatchStreamReaderImpl2(file));
  });
}

// ../../node_modules/apache-arrow/visitor/vectorassembler.mjs
var VectorAssembler2 = class _VectorAssembler extends Visitor2 {
  /** @nocollapse */
  static assemble(...args) {
    const unwrap = (nodes) => nodes.flatMap((node) => Array.isArray(node) ? unwrap(node) : node instanceof RecordBatch4 ? node.data.children : node.data);
    const assembler = new _VectorAssembler();
    assembler.visitMany(unwrap(args));
    return assembler;
  }
  constructor() {
    super();
    this._byteLength = 0;
    this._nodes = [];
    this._buffers = [];
    this._bufferRegions = [];
  }
  visit(data) {
    if (data instanceof Vector2) {
      this.visitMany(data.data);
      return this;
    }
    const { type: type2 } = data;
    if (!DataType2.isDictionary(type2)) {
      const { length: length4 } = data;
      if (length4 > 2147483647) {
        throw new RangeError("Cannot write arrays larger than 2^31 - 1 in length");
      }
      if (DataType2.isUnion(type2)) {
        this.nodes.push(new FieldNode4(length4, 0));
      } else {
        const { nullCount } = data;
        if (!DataType2.isNull(type2)) {
          addBuffer2.call(this, nullCount <= 0 ? new Uint8Array(0) : truncateBitmap2(data.offset, length4, data.nullBitmap));
        }
        this.nodes.push(new FieldNode4(length4, nullCount));
      }
    }
    return super.visit(data);
  }
  visitNull(_null) {
    return this;
  }
  visitDictionary(data) {
    return this.visit(data.clone(data.type.indices));
  }
  get nodes() {
    return this._nodes;
  }
  get buffers() {
    return this._buffers;
  }
  get byteLength() {
    return this._byteLength;
  }
  get bufferRegions() {
    return this._bufferRegions;
  }
};
function addBuffer2(values2) {
  const byteLength = values2.byteLength + 7 & ~7;
  this.buffers.push(values2);
  this.bufferRegions.push(new BufferRegion2(this._byteLength, byteLength));
  this._byteLength += byteLength;
  return this;
}
function assembleUnion2(data) {
  var _a9;
  const { type: type2, length: length4, typeIds, valueOffsets } = data;
  addBuffer2.call(this, typeIds);
  if (type2.mode === UnionMode2.Sparse) {
    return assembleNestedVector2.call(this, data);
  } else if (type2.mode === UnionMode2.Dense) {
    if (data.offset <= 0) {
      addBuffer2.call(this, valueOffsets);
      return assembleNestedVector2.call(this, data);
    } else {
      const shiftedOffsets = new Int32Array(length4);
      const childOffsets = /* @__PURE__ */ Object.create(null);
      const childLengths = /* @__PURE__ */ Object.create(null);
      for (let typeId, shift, index2 = -1; ++index2 < length4; ) {
        if ((typeId = typeIds[index2]) === void 0) {
          continue;
        }
        if ((shift = childOffsets[typeId]) === void 0) {
          shift = childOffsets[typeId] = valueOffsets[index2];
        }
        shiftedOffsets[index2] = valueOffsets[index2] - shift;
        childLengths[typeId] = ((_a9 = childLengths[typeId]) !== null && _a9 !== void 0 ? _a9 : 0) + 1;
      }
      addBuffer2.call(this, shiftedOffsets);
      this.visitMany(data.children.map((child, childIndex) => {
        const typeId = type2.typeIds[childIndex];
        const childOffset = childOffsets[typeId];
        const childLength = childLengths[typeId];
        return child.slice(childOffset, Math.min(length4, childLength));
      }));
    }
  }
  return this;
}
function assembleBoolVector2(data) {
  let values2;
  if (data.nullCount >= data.length) {
    return addBuffer2.call(this, new Uint8Array(0));
  } else if ((values2 = data.values) instanceof Uint8Array) {
    return addBuffer2.call(this, truncateBitmap2(data.offset, data.length, values2));
  }
  return addBuffer2.call(this, packBools2(data.values));
}
function assembleFlatVector2(data) {
  return addBuffer2.call(this, data.values.subarray(0, data.length * data.stride));
}
function assembleFlatListVector2(data) {
  const { length: length4, values: values2, valueOffsets } = data;
  const { [0]: begin, [length4]: end } = valueOffsets;
  const byteLength = Math.min(end - begin, values2.byteLength - begin);
  addBuffer2.call(this, rebaseValueOffsets2(-begin, length4 + 1, valueOffsets));
  addBuffer2.call(this, values2.subarray(begin, begin + byteLength));
  return this;
}
function assembleListVector2(data) {
  const { length: length4, valueOffsets } = data;
  if (valueOffsets) {
    const { [0]: begin, [length4]: end } = valueOffsets;
    addBuffer2.call(this, rebaseValueOffsets2(-begin, length4 + 1, valueOffsets));
    return this.visit(data.children[0].slice(begin, end - begin));
  }
  return this.visit(data.children[0]);
}
function assembleNestedVector2(data) {
  return this.visitMany(data.type.children.map((_2, i) => data.children[i]).filter(Boolean))[0];
}
VectorAssembler2.prototype.visitBool = assembleBoolVector2;
VectorAssembler2.prototype.visitInt = assembleFlatVector2;
VectorAssembler2.prototype.visitFloat = assembleFlatVector2;
VectorAssembler2.prototype.visitUtf8 = assembleFlatListVector2;
VectorAssembler2.prototype.visitBinary = assembleFlatListVector2;
VectorAssembler2.prototype.visitFixedSizeBinary = assembleFlatVector2;
VectorAssembler2.prototype.visitDate = assembleFlatVector2;
VectorAssembler2.prototype.visitTimestamp = assembleFlatVector2;
VectorAssembler2.prototype.visitTime = assembleFlatVector2;
VectorAssembler2.prototype.visitDecimal = assembleFlatVector2;
VectorAssembler2.prototype.visitList = assembleListVector2;
VectorAssembler2.prototype.visitStruct = assembleNestedVector2;
VectorAssembler2.prototype.visitUnion = assembleUnion2;
VectorAssembler2.prototype.visitInterval = assembleFlatVector2;
VectorAssembler2.prototype.visitDuration = assembleFlatVector2;
VectorAssembler2.prototype.visitFixedSizeList = assembleListVector2;
VectorAssembler2.prototype.visitMap = assembleListVector2;

// ../../node_modules/apache-arrow/ipc/writer.mjs
var RecordBatchWriter2 = class extends ReadableInterop2 {
  /** @nocollapse */
  // @ts-ignore
  static throughNode(options) {
    throw new Error(`"throughNode" not available in this environment`);
  }
  /** @nocollapse */
  static throughDOM(writableStrategy, readableStrategy) {
    throw new Error(`"throughDOM" not available in this environment`);
  }
  constructor(options) {
    super();
    this._position = 0;
    this._started = false;
    this._sink = new AsyncByteQueue2();
    this._schema = null;
    this._dictionaryBlocks = [];
    this._recordBatchBlocks = [];
    this._dictionaryDeltaOffsets = /* @__PURE__ */ new Map();
    isObject2(options) || (options = { autoDestroy: true, writeLegacyIpcFormat: false });
    this._autoDestroy = typeof options.autoDestroy === "boolean" ? options.autoDestroy : true;
    this._writeLegacyIpcFormat = typeof options.writeLegacyIpcFormat === "boolean" ? options.writeLegacyIpcFormat : false;
  }
  toString(sync = false) {
    return this._sink.toString(sync);
  }
  toUint8Array(sync = false) {
    return this._sink.toUint8Array(sync);
  }
  writeAll(input3) {
    if (isPromise2(input3)) {
      return input3.then((x4) => this.writeAll(x4));
    } else if (isAsyncIterable2(input3)) {
      return writeAllAsync2(this, input3);
    }
    return writeAll2(this, input3);
  }
  get closed() {
    return this._sink.closed;
  }
  [Symbol.asyncIterator]() {
    return this._sink[Symbol.asyncIterator]();
  }
  toDOMStream(options) {
    return this._sink.toDOMStream(options);
  }
  toNodeStream(options) {
    return this._sink.toNodeStream(options);
  }
  close() {
    return this.reset()._sink.close();
  }
  abort(reason) {
    return this.reset()._sink.abort(reason);
  }
  finish() {
    this._autoDestroy ? this.close() : this.reset(this._sink, this._schema);
    return this;
  }
  reset(sink = this._sink, schema = null) {
    if (sink === this._sink || sink instanceof AsyncByteQueue2) {
      this._sink = sink;
    } else {
      this._sink = new AsyncByteQueue2();
      if (sink && isWritableDOMStream2(sink)) {
        this.toDOMStream({ type: "bytes" }).pipeTo(sink);
      } else if (sink && isWritableNodeStream2(sink)) {
        this.toNodeStream({ objectMode: false }).pipe(sink);
      }
    }
    if (this._started && this._schema) {
      this._writeFooter(this._schema);
    }
    this._started = false;
    this._dictionaryBlocks = [];
    this._recordBatchBlocks = [];
    this._dictionaryDeltaOffsets = /* @__PURE__ */ new Map();
    if (!schema || !compareSchemas2(schema, this._schema)) {
      if (schema == null) {
        this._position = 0;
        this._schema = null;
      } else {
        this._started = true;
        this._schema = schema;
        this._writeSchema(schema);
      }
    }
    return this;
  }
  write(payload) {
    let schema = null;
    if (!this._sink) {
      throw new Error(`RecordBatchWriter is closed`);
    } else if (payload == null) {
      return this.finish() && void 0;
    } else if (payload instanceof Table2 && !(schema = payload.schema)) {
      return this.finish() && void 0;
    } else if (payload instanceof RecordBatch4 && !(schema = payload.schema)) {
      return this.finish() && void 0;
    }
    if (schema && !compareSchemas2(schema, this._schema)) {
      if (this._started && this._autoDestroy) {
        return this.close();
      }
      this.reset(this._sink, schema);
    }
    if (payload instanceof RecordBatch4) {
      if (!(payload instanceof _InternalEmptyPlaceholderRecordBatch2)) {
        this._writeRecordBatch(payload);
      }
    } else if (payload instanceof Table2) {
      this.writeAll(payload.batches);
    } else if (isIterable2(payload)) {
      this.writeAll(payload);
    }
  }
  _writeMessage(message, alignment = 8) {
    const a3 = alignment - 1;
    const buffer = Message4.encode(message);
    const flatbufferSize = buffer.byteLength;
    const prefixSize = !this._writeLegacyIpcFormat ? 8 : 4;
    const alignedSize = flatbufferSize + prefixSize + a3 & ~a3;
    const nPaddingBytes = alignedSize - flatbufferSize - prefixSize;
    if (message.headerType === MessageHeader2.RecordBatch) {
      this._recordBatchBlocks.push(new FileBlock2(alignedSize, message.bodyLength, this._position));
    } else if (message.headerType === MessageHeader2.DictionaryBatch) {
      this._dictionaryBlocks.push(new FileBlock2(alignedSize, message.bodyLength, this._position));
    }
    if (!this._writeLegacyIpcFormat) {
      this._write(Int32Array.of(-1));
    }
    this._write(Int32Array.of(alignedSize - prefixSize));
    if (flatbufferSize > 0) {
      this._write(buffer);
    }
    return this._writePadding(nPaddingBytes);
  }
  _write(chunk) {
    if (this._started) {
      const buffer = toUint8Array2(chunk);
      if (buffer && buffer.byteLength > 0) {
        this._sink.write(buffer);
        this._position += buffer.byteLength;
      }
    }
    return this;
  }
  _writeSchema(schema) {
    return this._writeMessage(Message4.from(schema));
  }
  // @ts-ignore
  _writeFooter(schema) {
    return this._writeLegacyIpcFormat ? this._write(Int32Array.of(0)) : this._write(Int32Array.of(-1, 0));
  }
  _writeMagic() {
    return this._write(MAGIC2);
  }
  _writePadding(nBytes) {
    return nBytes > 0 ? this._write(new Uint8Array(nBytes)) : this;
  }
  _writeRecordBatch(batch) {
    const { byteLength, nodes, bufferRegions, buffers } = VectorAssembler2.assemble(batch);
    const recordBatch = new RecordBatch6(batch.numRows, nodes, bufferRegions);
    const message = Message4.from(recordBatch, byteLength);
    return this._writeDictionaries(batch)._writeMessage(message)._writeBodyBuffers(buffers);
  }
  _writeDictionaryBatch(dictionary, id2, isDelta = false) {
    this._dictionaryDeltaOffsets.set(id2, dictionary.length + (this._dictionaryDeltaOffsets.get(id2) || 0));
    const { byteLength, nodes, bufferRegions, buffers } = VectorAssembler2.assemble(new Vector2([dictionary]));
    const recordBatch = new RecordBatch6(dictionary.length, nodes, bufferRegions);
    const dictionaryBatch = new DictionaryBatch4(recordBatch, id2, isDelta);
    const message = Message4.from(dictionaryBatch, byteLength);
    return this._writeMessage(message)._writeBodyBuffers(buffers);
  }
  _writeBodyBuffers(buffers) {
    let buffer;
    let size, padding2;
    for (let i = -1, n = buffers.length; ++i < n; ) {
      if ((buffer = buffers[i]) && (size = buffer.byteLength) > 0) {
        this._write(buffer);
        if ((padding2 = (size + 7 & ~7) - size) > 0) {
          this._writePadding(padding2);
        }
      }
    }
    return this;
  }
  _writeDictionaries(batch) {
    for (let [id2, dictionary] of batch.dictionaries) {
      let offset2 = this._dictionaryDeltaOffsets.get(id2) || 0;
      if (offset2 === 0 || (dictionary = dictionary === null || dictionary === void 0 ? void 0 : dictionary.slice(offset2)).length > 0) {
        for (const data of dictionary.data) {
          this._writeDictionaryBatch(data, id2, offset2 > 0);
          offset2 += data.length;
        }
      }
    }
    return this;
  }
};
var RecordBatchStreamWriter2 = class _RecordBatchStreamWriter extends RecordBatchWriter2 {
  /** @nocollapse */
  static writeAll(input3, options) {
    const writer = new _RecordBatchStreamWriter(options);
    if (isPromise2(input3)) {
      return input3.then((x4) => writer.writeAll(x4));
    } else if (isAsyncIterable2(input3)) {
      return writeAllAsync2(writer, input3);
    }
    return writeAll2(writer, input3);
  }
};
var RecordBatchFileWriter2 = class _RecordBatchFileWriter extends RecordBatchWriter2 {
  /** @nocollapse */
  static writeAll(input3) {
    const writer = new _RecordBatchFileWriter();
    if (isPromise2(input3)) {
      return input3.then((x4) => writer.writeAll(x4));
    } else if (isAsyncIterable2(input3)) {
      return writeAllAsync2(writer, input3);
    }
    return writeAll2(writer, input3);
  }
  constructor() {
    super();
    this._autoDestroy = true;
  }
  // @ts-ignore
  _writeSchema(schema) {
    return this._writeMagic()._writePadding(2);
  }
  _writeFooter(schema) {
    const buffer = Footer_2.encode(new Footer_2(schema, MetadataVersion2.V5, this._recordBatchBlocks, this._dictionaryBlocks));
    return super._writeFooter(schema)._write(buffer)._write(Int32Array.of(buffer.byteLength))._writeMagic();
  }
};
function writeAll2(writer, input3) {
  let chunks = input3;
  if (input3 instanceof Table2) {
    chunks = input3.batches;
    writer.reset(void 0, input3.schema);
  }
  for (const batch of chunks) {
    writer.write(batch);
  }
  return writer.finish();
}
function writeAllAsync2(writer, batches) {
  var _a9, batches_1, batches_1_1;
  var _b3, e_1, _c3, _d3;
  return __awaiter(this, void 0, void 0, function* () {
    try {
      for (_a9 = true, batches_1 = __asyncValues(batches); batches_1_1 = yield batches_1.next(), _b3 = batches_1_1.done, !_b3; _a9 = true) {
        _d3 = batches_1_1.value;
        _a9 = false;
        const batch = _d3;
        writer.write(batch);
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (!_a9 && !_b3 && (_c3 = batches_1.return))
          yield _c3.call(batches_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    return writer.finish();
  });
}

// ../../node_modules/apache-arrow/io/whatwg/iterable.mjs
function toDOMStream2(source, options) {
  if (isAsyncIterable2(source)) {
    return asyncIterableAsReadableDOMStream2(source, options);
  }
  if (isIterable2(source)) {
    return iterableAsReadableDOMStream2(source, options);
  }
  throw new Error(`toDOMStream() must be called with an Iterable or AsyncIterable`);
}
function iterableAsReadableDOMStream2(source, options) {
  let it2 = null;
  const bm = (options === null || options === void 0 ? void 0 : options.type) === "bytes" || false;
  const hwm = (options === null || options === void 0 ? void 0 : options.highWaterMark) || Math.pow(2, 24);
  return new ReadableStream(Object.assign(Object.assign({}, options), {
    start(controller) {
      next(controller, it2 || (it2 = source[Symbol.iterator]()));
    },
    pull(controller) {
      it2 ? next(controller, it2) : controller.close();
    },
    cancel() {
      ((it2 === null || it2 === void 0 ? void 0 : it2.return) && it2.return() || true) && (it2 = null);
    }
  }), Object.assign({ highWaterMark: bm ? hwm : void 0 }, options));
  function next(controller, it3) {
    let buf;
    let r = null;
    let size = controller.desiredSize || null;
    while (!(r = it3.next(bm ? size : null)).done) {
      if (ArrayBuffer.isView(r.value) && (buf = toUint8Array2(r.value))) {
        size != null && bm && (size = size - buf.byteLength + 1);
        r.value = buf;
      }
      controller.enqueue(r.value);
      if (size != null && --size <= 0) {
        return;
      }
    }
    controller.close();
  }
}
function asyncIterableAsReadableDOMStream2(source, options) {
  let it2 = null;
  const bm = (options === null || options === void 0 ? void 0 : options.type) === "bytes" || false;
  const hwm = (options === null || options === void 0 ? void 0 : options.highWaterMark) || Math.pow(2, 24);
  return new ReadableStream(Object.assign(Object.assign({}, options), {
    start(controller) {
      return __awaiter(this, void 0, void 0, function* () {
        yield next(controller, it2 || (it2 = source[Symbol.asyncIterator]()));
      });
    },
    pull(controller) {
      return __awaiter(this, void 0, void 0, function* () {
        it2 ? yield next(controller, it2) : controller.close();
      });
    },
    cancel() {
      return __awaiter(this, void 0, void 0, function* () {
        ((it2 === null || it2 === void 0 ? void 0 : it2.return) && (yield it2.return()) || true) && (it2 = null);
      });
    }
  }), Object.assign({ highWaterMark: bm ? hwm : void 0 }, options));
  function next(controller, it3) {
    return __awaiter(this, void 0, void 0, function* () {
      let buf;
      let r = null;
      let size = controller.desiredSize || null;
      while (!(r = yield it3.next(bm ? size : null)).done) {
        if (ArrayBuffer.isView(r.value) && (buf = toUint8Array2(r.value))) {
          size != null && bm && (size = size - buf.byteLength + 1);
          r.value = buf;
        }
        controller.enqueue(r.value);
        if (size != null && --size <= 0) {
          return;
        }
      }
      controller.close();
    });
  }
}

// ../../node_modules/apache-arrow/io/whatwg/builder.mjs
function builderThroughDOMStream2(options) {
  return new BuilderTransform2(options);
}
var BuilderTransform2 = class {
  constructor(options) {
    this._numChunks = 0;
    this._finished = false;
    this._bufferedSize = 0;
    const { ["readableStrategy"]: readableStrategy, ["writableStrategy"]: writableStrategy, ["queueingStrategy"]: queueingStrategy = "count" } = options, builderOptions = __rest(options, ["readableStrategy", "writableStrategy", "queueingStrategy"]);
    this._controller = null;
    this._builder = makeBuilder2(builderOptions);
    this._getSize = queueingStrategy !== "bytes" ? chunkLength2 : chunkByteLength2;
    const { ["highWaterMark"]: readableHighWaterMark = queueingStrategy === "bytes" ? Math.pow(2, 14) : 1e3 } = Object.assign({}, readableStrategy);
    const { ["highWaterMark"]: writableHighWaterMark = queueingStrategy === "bytes" ? Math.pow(2, 14) : 1e3 } = Object.assign({}, writableStrategy);
    this["readable"] = new ReadableStream({
      ["cancel"]: () => {
        this._builder.clear();
      },
      ["pull"]: (c4) => {
        this._maybeFlush(this._builder, this._controller = c4);
      },
      ["start"]: (c4) => {
        this._maybeFlush(this._builder, this._controller = c4);
      }
    }, {
      "highWaterMark": readableHighWaterMark,
      "size": queueingStrategy !== "bytes" ? chunkLength2 : chunkByteLength2
    });
    this["writable"] = new WritableStream({
      ["abort"]: () => {
        this._builder.clear();
      },
      ["write"]: () => {
        this._maybeFlush(this._builder, this._controller);
      },
      ["close"]: () => {
        this._maybeFlush(this._builder.finish(), this._controller);
      }
    }, {
      "highWaterMark": writableHighWaterMark,
      "size": (value) => this._writeValueAndReturnChunkSize(value)
    });
  }
  _writeValueAndReturnChunkSize(value) {
    const bufferedSize = this._bufferedSize;
    this._bufferedSize = this._getSize(this._builder.append(value));
    return this._bufferedSize - bufferedSize;
  }
  _maybeFlush(builder, controller) {
    if (controller == null) {
      return;
    }
    if (this._bufferedSize >= controller.desiredSize) {
      ++this._numChunks && this._enqueue(controller, builder.toVector());
    }
    if (builder.finished) {
      if (builder.length > 0 || this._numChunks === 0) {
        ++this._numChunks && this._enqueue(controller, builder.toVector());
      }
      if (!this._finished && (this._finished = true)) {
        this._enqueue(controller, null);
      }
    }
  }
  _enqueue(controller, chunk) {
    this._bufferedSize = 0;
    this._controller = null;
    chunk == null ? controller.close() : controller.enqueue(chunk);
  }
};
var chunkLength2 = (chunk) => {
  var _a9;
  return (_a9 = chunk === null || chunk === void 0 ? void 0 : chunk.length) !== null && _a9 !== void 0 ? _a9 : 0;
};
var chunkByteLength2 = (chunk) => {
  var _a9;
  return (_a9 = chunk === null || chunk === void 0 ? void 0 : chunk.byteLength) !== null && _a9 !== void 0 ? _a9 : 0;
};

// ../../node_modules/apache-arrow/io/whatwg/reader.mjs
function recordBatchReaderThroughDOMStream2(writableStrategy, readableStrategy) {
  const queue = new AsyncByteQueue2();
  let reader = null;
  const readable = new ReadableStream({
    cancel() {
      return __awaiter(this, void 0, void 0, function* () {
        yield queue.close();
      });
    },
    start(controller) {
      return __awaiter(this, void 0, void 0, function* () {
        yield next(controller, reader || (reader = yield open()));
      });
    },
    pull(controller) {
      return __awaiter(this, void 0, void 0, function* () {
        reader ? yield next(controller, reader) : controller.close();
      });
    }
  });
  return { writable: new WritableStream(queue, Object.assign({ "highWaterMark": Math.pow(2, 14) }, writableStrategy)), readable };
  function open() {
    return __awaiter(this, void 0, void 0, function* () {
      return yield (yield RecordBatchReader2.from(queue)).open(readableStrategy);
    });
  }
  function next(controller, reader2) {
    return __awaiter(this, void 0, void 0, function* () {
      let size = controller.desiredSize;
      let r = null;
      while (!(r = yield reader2.next()).done) {
        controller.enqueue(r.value);
        if (size != null && --size <= 0) {
          return;
        }
      }
      controller.close();
    });
  }
}

// ../../node_modules/apache-arrow/io/whatwg/writer.mjs
function recordBatchWriterThroughDOMStream2(writableStrategy, readableStrategy) {
  const writer = new this(writableStrategy);
  const reader = new AsyncByteStream2(writer);
  const readable = new ReadableStream({
    // type: 'bytes',
    cancel() {
      return __awaiter(this, void 0, void 0, function* () {
        yield reader.cancel();
      });
    },
    pull(controller) {
      return __awaiter(this, void 0, void 0, function* () {
        yield next(controller);
      });
    },
    start(controller) {
      return __awaiter(this, void 0, void 0, function* () {
        yield next(controller);
      });
    }
  }, Object.assign({ "highWaterMark": Math.pow(2, 14) }, readableStrategy));
  return { writable: new WritableStream(writer, writableStrategy), readable };
  function next(controller) {
    return __awaiter(this, void 0, void 0, function* () {
      let buf = null;
      let size = controller.desiredSize;
      while (buf = yield reader.read(size || null)) {
        controller.enqueue(buf);
        if (size != null && (size -= buf.byteLength) <= 0) {
          return;
        }
      }
      controller.close();
    });
  }
}

// ../../node_modules/apache-arrow/ipc/serialization.mjs
function tableToIPC2(table3, type2 = "stream") {
  return (type2 === "stream" ? RecordBatchStreamWriter2 : RecordBatchFileWriter2).writeAll(table3).toUint8Array(true);
}

// ../../node_modules/apache-arrow/Arrow.mjs
var util2 = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, bn_exports2), int_exports2), bit_exports2), math_exports2), buffer_exports2), vector_exports2), pretty_exports2), {
  compareSchemas: compareSchemas2,
  compareFields: compareFields2,
  compareTypes: compareTypes2
});

// ../../node_modules/apache-arrow/Arrow.dom.mjs
adapters_default2.toDOMStream = toDOMStream2;
Builder5["throughDOM"] = builderThroughDOMStream2;
RecordBatchReader2["throughDOM"] = recordBatchReaderThroughDOMStream2;
RecordBatchFileReader2["throughDOM"] = recordBatchReaderThroughDOMStream2;
RecordBatchStreamReader2["throughDOM"] = recordBatchReaderThroughDOMStream2;
RecordBatchWriter2["throughDOM"] = recordBatchWriterThroughDOMStream2;
RecordBatchFileWriter2["throughDOM"] = recordBatchWriterThroughDOMStream2;
RecordBatchStreamWriter2["throughDOM"] = recordBatchWriterThroughDOMStream2;

// ../../node_modules/@duckdb/duckdb-wasm/dist/duckdb-browser.mjs
var Y = Object.create;
var N = Object.defineProperty;
var H = Object.getOwnPropertyDescriptor;
var j = Object.getOwnPropertyNames;
var K = Object.getPrototypeOf;
var V = Object.prototype.hasOwnProperty;
var z = (s2, e) => () => (e || s2((e = { exports: {} }).exports, e), e.exports);
var J = (s2, e, r, t) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let o of j(e))
      !V.call(s2, o) && o !== r && N(s2, o, { get: () => e[o], enumerable: !(t = H(e, o)) || t.enumerable });
  return s2;
};
var $ = (s2, e, r) => (r = s2 != null ? Y(K(s2)) : {}, J(e || !s2 || !s2.__esModule ? N(r, "default", { value: s2, enumerable: true }) : r, s2));
var x2 = z((qe, G) => {
  G.exports = Worker;
});
var Z = ((o) => (o[o.UNDEFINED = 0] = "UNDEFINED", o[o.AUTOMATIC = 1] = "AUTOMATIC", o[o.READ_ONLY = 2] = "READ_ONLY", o[o.READ_WRITE = 3] = "READ_WRITE", o))(Z || {});
var X = ((n) => (n[n.IDENTIFIER = 0] = "IDENTIFIER", n[n.NUMERIC_CONSTANT = 1] = "NUMERIC_CONSTANT", n[n.STRING_CONSTANT = 2] = "STRING_CONSTANT", n[n.OPERATOR = 3] = "OPERATOR", n[n.KEYWORD = 4] = "KEYWORD", n[n.COMMENT = 5] = "COMMENT", n))(X || {});
var ee = ((i) => (i[i.NONE = 0] = "NONE", i[i.DEBUG = 1] = "DEBUG", i[i.INFO = 2] = "INFO", i[i.WARNING = 3] = "WARNING", i[i.ERROR = 4] = "ERROR", i))(ee || {});
var re = ((n) => (n[n.NONE = 0] = "NONE", n[n.CONNECT = 1] = "CONNECT", n[n.DISCONNECT = 2] = "DISCONNECT", n[n.OPEN = 3] = "OPEN", n[n.QUERY = 4] = "QUERY", n[n.INSTANTIATE = 5] = "INSTANTIATE", n))(re || {});
var te = ((n) => (n[n.NONE = 0] = "NONE", n[n.OK = 1] = "OK", n[n.ERROR = 2] = "ERROR", n[n.START = 3] = "START", n[n.RUN = 4] = "RUN", n[n.CAPTURE = 5] = "CAPTURE", n))(te || {});
var se = ((i) => (i[i.NONE = 0] = "NONE", i[i.WEB_WORKER = 1] = "WEB_WORKER", i[i.NODE_WORKER = 2] = "NODE_WORKER", i[i.BINDINGS = 3] = "BINDINGS", i[i.ASYNC_DUCKDB = 4] = "ASYNC_DUCKDB", i))(se || {});
var A = class {
  log(e) {
  }
};
var P = class {
  constructor(e = 2) {
    this.level = e;
  }
  log(e) {
    e.level >= this.level && console.log(e);
  }
};
var ne = ((e) => (e[e.SUCCESS = 0] = "SUCCESS", e))(ne || {});
var E = class {
  constructor(e, r) {
    this._bindings = e, this._conn = r;
  }
  get bindings() {
    return this._bindings;
  }
  async close() {
    return this._bindings.disconnect(this._conn);
  }
  useUnsafe(e) {
    return e(this._bindings, this._conn);
  }
  async query(e) {
    this._bindings.logger.log({ timestamp: /* @__PURE__ */ new Date(), level: 2, origin: 4, topic: 4, event: 4, value: e });
    let r = await this._bindings.runQuery(this._conn, e), t = RecordBatchReader2.from(r);
    return console.assert(t.isSync(), "Reader is not sync"), console.assert(t.isFile(), "Reader is not file"), new Table2(t);
  }
  async send(e) {
    this._bindings.logger.log({ timestamp: /* @__PURE__ */ new Date(), level: 2, origin: 4, topic: 4, event: 4, value: e });
    let r = await this._bindings.startPendingQuery(this._conn, e);
    for (; r == null; )
      r = await this._bindings.pollPendingQuery(this._conn);
    let t = new p(this._bindings, this._conn, r), o = await RecordBatchReader2.from(t);
    return console.assert(o.isAsync()), console.assert(o.isStream()), o;
  }
  async cancelSent() {
    return await this._bindings.cancelPendingQuery(this._conn);
  }
  async getTableNames(e) {
    return await this._bindings.getTableNames(this._conn, e);
  }
  async prepare(e) {
    let r = await this._bindings.createPrepared(this._conn, e);
    return new b(this._bindings, this._conn, r);
  }
  async insertArrowTable(e, r) {
    let t = tableToIPC2(e, "stream");
    await this.insertArrowFromIPCStream(t, r);
  }
  async insertArrowFromIPCStream(e, r) {
    await this._bindings.insertArrowFromIPCStream(this._conn, e, r);
  }
  async insertCSVFromPath(e, r) {
    await this._bindings.insertCSVFromPath(this._conn, e, r);
  }
  async insertJSONFromPath(e, r) {
    await this._bindings.insertJSONFromPath(this._conn, e, r);
  }
};
var p = class {
  constructor(e, r, t) {
    this.db = e;
    this.conn = r;
    this.header = t;
    this._first = true, this._depleted = false, this._inFlight = null;
  }
  async next() {
    if (this._first)
      return this._first = false, { done: false, value: this.header };
    if (this._depleted)
      return { done: true, value: null };
    let e;
    return this._inFlight != null ? (e = await this._inFlight, this._inFlight = null) : e = await this.db.fetchQueryResults(this.conn), this._depleted = e.length == 0, this._depleted || (this._inFlight = this.db.fetchQueryResults(this.conn)), { done: this._depleted, value: e };
  }
  [Symbol.asyncIterator]() {
    return this;
  }
};
var b = class {
  constructor(e, r, t) {
    this.bindings = e, this.connectionId = r, this.statementId = t;
  }
  async close() {
    await this.bindings.closePrepared(this.connectionId, this.statementId);
  }
  async query(...e) {
    let r = await this.bindings.runPrepared(this.connectionId, this.statementId, e), t = RecordBatchReader2.from(r);
    return console.assert(t.isSync()), console.assert(t.isFile()), new Table2(t);
  }
  async send(...e) {
    let r = await this.bindings.sendPrepared(this.connectionId, this.statementId, e), t = new p(this.bindings, this.connectionId, r), o = await RecordBatchReader2.from(t);
    return console.assert(o.isAsync()), console.assert(o.isStream()), o;
  }
};
var L = ((c4) => (c4.CANCEL_PENDING_QUERY = "CANCEL_PENDING_QUERY", c4.CLOSE_PREPARED = "CLOSE_PREPARED", c4.COLLECT_FILE_STATISTICS = "COLLECT_FILE_STATISTICS", c4.CONNECT = "CONNECT", c4.COPY_FILE_TO_BUFFER = "COPY_FILE_TO_BUFFER", c4.COPY_FILE_TO_PATH = "COPY_FILE_TO_PATH", c4.CREATE_PREPARED = "CREATE_PREPARED", c4.DISCONNECT = "DISCONNECT", c4.DROP_FILE = "DROP_FILE", c4.DROP_FILES = "DROP_FILES", c4.EXPORT_FILE_STATISTICS = "EXPORT_FILE_STATISTICS", c4.FETCH_QUERY_RESULTS = "FETCH_QUERY_RESULTS", c4.FLUSH_FILES = "FLUSH_FILES", c4.GET_FEATURE_FLAGS = "GET_FEATURE_FLAGS", c4.GET_TABLE_NAMES = "GET_TABLE_NAMES", c4.GET_VERSION = "GET_VERSION", c4.GLOB_FILE_INFOS = "GLOB_FILE_INFOS", c4.INSERT_ARROW_FROM_IPC_STREAM = "INSERT_ARROW_FROM_IPC_STREAM", c4.INSERT_CSV_FROM_PATH = "IMPORT_CSV_FROM_PATH", c4.INSERT_JSON_FROM_PATH = "IMPORT_JSON_FROM_PATH", c4.INSTANTIATE = "INSTANTIATE", c4.OPEN = "OPEN", c4.PING = "PING", c4.POLL_PENDING_QUERY = "POLL_PENDING_QUERY", c4.REGISTER_FILE_BUFFER = "REGISTER_FILE_BUFFER", c4.REGISTER_FILE_HANDLE = "REGISTER_FILE_HANDLE", c4.REGISTER_FILE_URL = "REGISTER_FILE_URL", c4.RESET = "RESET", c4.RUN_PREPARED = "RUN_PREPARED", c4.RUN_QUERY = "RUN_QUERY", c4.SEND_PREPARED = "SEND_PREPARED", c4.START_PENDING_QUERY = "START_PENDING_QUERY", c4.TOKENIZE = "TOKENIZE", c4))(L || {});
var D = ((u4) => (u4.CONNECTION_INFO = "CONNECTION_INFO", u4.ERROR = "ERROR", u4.FEATURE_FLAGS = "FEATURE_FLAGS", u4.FILE_BUFFER = "FILE_BUFFER", u4.FILE_INFOS = "FILE_INFOS", u4.FILE_SIZE = "FILE_SIZE", u4.FILE_STATISTICS = "FILE_STATISTICS", u4.INSTANTIATE_PROGRESS = "INSTANTIATE_PROGRESS", u4.LOG = "LOG", u4.OK = "OK", u4.PREPARED_STATEMENT_ID = "PREPARED_STATEMENT_ID", u4.QUERY_PLAN = "QUERY_PLAN", u4.QUERY_RESULT = "QUERY_RESULT", u4.QUERY_RESULT_CHUNK = "QUERY_RESULT_CHUNK", u4.QUERY_RESULT_HEADER = "QUERY_RESULT_HEADER", u4.QUERY_RESULT_HEADER_OR_NULL = "QUERY_RESULT_HEADER_OR_NULL", u4.REGISTERED_FILE = "REGISTERED_FILE", u4.SCRIPT_TOKENS = "SCRIPT_TOKENS", u4.SUCCESS = "SUCCESS", u4.TABLE_NAMES = "TABLE_NAMES", u4.VERSION_STRING = "VERSION_STRING", u4))(D || {});
var a = class {
  constructor(e, r) {
    this.promiseResolver = () => {
    };
    this.promiseRejecter = () => {
    };
    this.type = e, this.data = r, this.promise = new Promise((t, o) => {
      this.promiseResolver = t, this.promiseRejecter = o;
    });
  }
};
function m(s2) {
  switch (s2.typeId) {
    case Type3.Binary:
      return { sqlType: "binary" };
    case Type3.Bool:
      return { sqlType: "bool" };
    case Type3.Date:
      return { sqlType: "date" };
    case Type3.DateDay:
      return { sqlType: "date32[d]" };
    case Type3.DateMillisecond:
      return { sqlType: "date64[ms]" };
    case Type3.Decimal: {
      let e = s2;
      return { sqlType: "decimal", precision: e.precision, scale: e.scale };
    }
    case Type3.Float:
      return { sqlType: "float" };
    case Type3.Float16:
      return { sqlType: "float16" };
    case Type3.Float32:
      return { sqlType: "float32" };
    case Type3.Float64:
      return { sqlType: "float64" };
    case Type3.Int:
      return { sqlType: "int32" };
    case Type3.Int16:
      return { sqlType: "int16" };
    case Type3.Int32:
      return { sqlType: "int32" };
    case Type3.Int64:
      return { sqlType: "int64" };
    case Type3.Uint16:
      return { sqlType: "uint16" };
    case Type3.Uint32:
      return { sqlType: "uint32" };
    case Type3.Uint64:
      return { sqlType: "uint64" };
    case Type3.Uint8:
      return { sqlType: "uint8" };
    case Type3.IntervalDayTime:
      return { sqlType: "interval[dt]" };
    case Type3.IntervalYearMonth:
      return { sqlType: "interval[m]" };
    case Type3.List:
      return { sqlType: "list", valueType: m(s2.valueType) };
    case Type3.FixedSizeBinary:
      return { sqlType: "fixedsizebinary", byteWidth: s2.byteWidth };
    case Type3.Null:
      return { sqlType: "null" };
    case Type3.Utf8:
      return { sqlType: "utf8" };
    case Type3.Struct:
      return { sqlType: "struct", fields: s2.children.map((r) => R(r.name, r.type)) };
    case Type3.Map: {
      let e = s2;
      return { sqlType: "map", keyType: m(e.keyType), valueType: m(e.valueType) };
    }
    case Type3.Time:
      return { sqlType: "time[s]" };
    case Type3.TimeMicrosecond:
      return { sqlType: "time[us]" };
    case Type3.TimeMillisecond:
      return { sqlType: "time[ms]" };
    case Type3.TimeNanosecond:
      return { sqlType: "time[ns]" };
    case Type3.TimeSecond:
      return { sqlType: "time[s]" };
    case Type3.Timestamp:
      return { sqlType: "timestamp", timezone: s2.timezone || void 0 };
    case Type3.TimestampSecond:
      return { sqlType: "timestamp[s]", timezone: s2.timezone || void 0 };
    case Type3.TimestampMicrosecond:
      return { sqlType: "timestamp[us]", timezone: s2.timezone || void 0 };
    case Type3.TimestampNanosecond:
      return { sqlType: "timestamp[ns]", timezone: s2.timezone || void 0 };
    case Type3.TimestampMillisecond:
      return { sqlType: "timestamp[ms]", timezone: s2.timezone || void 0 };
  }
  throw new Error("unsupported arrow type: ".concat(s2.toString()));
}
function R(s2, e) {
  let r = m(e);
  return r.name = s2, r;
}
var oe = new TextEncoder();
var O = class {
  constructor(e, r = null) {
    this._onInstantiationProgress = [];
    this._worker = null;
    this._workerShutdownPromise = null;
    this._workerShutdownResolver = () => {
    };
    this._nextMessageId = 0;
    this._pendingRequests = /* @__PURE__ */ new Map();
    this._logger = e, this._onMessageHandler = this.onMessage.bind(this), this._onErrorHandler = this.onError.bind(this), this._onCloseHandler = this.onClose.bind(this), r != null && this.attach(r);
  }
  get logger() {
    return this._logger;
  }
  attach(e) {
    this._worker = e, this._worker.addEventListener("message", this._onMessageHandler), this._worker.addEventListener("error", this._onErrorHandler), this._worker.addEventListener("close", this._onCloseHandler), this._workerShutdownPromise = new Promise((r, t) => {
      this._workerShutdownResolver = r;
    });
  }
  detach() {
    this._worker && (this._worker.removeEventListener("message", this._onMessageHandler), this._worker.removeEventListener("error", this._onErrorHandler), this._worker.removeEventListener("close", this._onCloseHandler), this._worker = null, this._workerShutdownResolver(null), this._workerShutdownPromise = null, this._workerShutdownResolver = () => {
    });
  }
  async terminate() {
    this._worker && (this._worker.terminate(), this._worker = null, this._workerShutdownPromise = null, this._workerShutdownResolver = () => {
    });
  }
  async postTask(e, r = []) {
    if (!this._worker) {
      console.error("cannot send a message since the worker is not set!");
      return;
    }
    let t = this._nextMessageId++;
    return this._pendingRequests.set(t, e), this._worker.postMessage({ messageId: t, type: e.type, data: e.data }, r), await e.promise;
  }
  onMessage(e) {
    var o;
    let r = e.data;
    switch (r.type) {
      case "LOG": {
        this._logger.log(r.data);
        return;
      }
      case "INSTANTIATE_PROGRESS": {
        for (let i of this._onInstantiationProgress)
          i(r.data);
        return;
      }
    }
    let t = this._pendingRequests.get(r.requestId);
    if (!t) {
      console.warn("unassociated response: [".concat(r.requestId, ", ").concat(r.type.toString(), "]"));
      return;
    }
    if (this._pendingRequests.delete(r.requestId), r.type == "ERROR") {
      let i = new Error(r.data.message);
      i.name = r.data.name, (o = Object.getOwnPropertyDescriptor(i, "stack")) != null && o.writable && (i.stack = r.data.stack), t.promiseRejecter(i);
      return;
    }
    switch (t.type) {
      case "CLOSE_PREPARED":
      case "COLLECT_FILE_STATISTICS":
      case "COPY_FILE_TO_PATH":
      case "DISCONNECT":
      case "DROP_FILE":
      case "DROP_FILES":
      case "FLUSH_FILES":
      case "INSERT_ARROW_FROM_IPC_STREAM":
      case "IMPORT_CSV_FROM_PATH":
      case "IMPORT_JSON_FROM_PATH":
      case "OPEN":
      case "PING":
      case "REGISTER_FILE_BUFFER":
      case "REGISTER_FILE_HANDLE":
      case "REGISTER_FILE_URL":
      case "RESET":
        if (r.type == "OK") {
          t.promiseResolver(r.data);
          return;
        }
        break;
      case "INSTANTIATE":
        if (this._onInstantiationProgress = [], r.type == "OK") {
          t.promiseResolver(r.data);
          return;
        }
        break;
      case "GLOB_FILE_INFOS":
        if (r.type == "FILE_INFOS") {
          t.promiseResolver(r.data);
          return;
        }
        break;
      case "GET_VERSION":
        if (r.type == "VERSION_STRING") {
          t.promiseResolver(r.data);
          return;
        }
        break;
      case "GET_FEATURE_FLAGS":
        if (r.type == "FEATURE_FLAGS") {
          t.promiseResolver(r.data);
          return;
        }
        break;
      case "GET_TABLE_NAMES":
        if (r.type == "TABLE_NAMES") {
          t.promiseResolver(r.data);
          return;
        }
        break;
      case "TOKENIZE":
        if (r.type == "SCRIPT_TOKENS") {
          t.promiseResolver(r.data);
          return;
        }
        break;
      case "COPY_FILE_TO_BUFFER":
        if (r.type == "FILE_BUFFER") {
          t.promiseResolver(r.data);
          return;
        }
        break;
      case "EXPORT_FILE_STATISTICS":
        if (r.type == "FILE_STATISTICS") {
          t.promiseResolver(r.data);
          return;
        }
        break;
      case "CONNECT":
        if (r.type == "CONNECTION_INFO") {
          t.promiseResolver(r.data);
          return;
        }
        break;
      case "RUN_PREPARED":
      case "RUN_QUERY":
        if (r.type == "QUERY_RESULT") {
          t.promiseResolver(r.data);
          return;
        }
        break;
      case "SEND_PREPARED":
        if (r.type == "QUERY_RESULT_HEADER") {
          t.promiseResolver(r.data);
          return;
        }
        break;
      case "START_PENDING_QUERY":
        if (r.type == "QUERY_RESULT_HEADER_OR_NULL") {
          t.promiseResolver(r.data);
          return;
        }
        break;
      case "POLL_PENDING_QUERY":
        if (r.type == "QUERY_RESULT_HEADER_OR_NULL") {
          t.promiseResolver(r.data);
          return;
        }
        break;
      case "CANCEL_PENDING_QUERY":
        if (this._onInstantiationProgress = [], r.type == "SUCCESS") {
          t.promiseResolver(r.data);
          return;
        }
        break;
      case "FETCH_QUERY_RESULTS":
        if (r.type == "QUERY_RESULT_CHUNK") {
          t.promiseResolver(r.data);
          return;
        }
        break;
      case "CREATE_PREPARED":
        if (r.type == "PREPARED_STATEMENT_ID") {
          t.promiseResolver(r.data);
          return;
        }
        break;
    }
    t.promiseRejecter(new Error("unexpected response type: ".concat(r.type.toString())));
  }
  onError(e) {
    console.error(e), console.error("error in duckdb worker: ".concat(e.message)), this._pendingRequests.clear();
  }
  onClose() {
    if (this._workerShutdownResolver(null), this._pendingRequests.size != 0) {
      console.warn("worker terminated with ".concat(this._pendingRequests.size, " pending requests"));
      return;
    }
    this._pendingRequests.clear();
  }
  async reset() {
    let e = new a("RESET", null);
    return await this.postTask(e);
  }
  async ping() {
    let e = new a("PING", null);
    await this.postTask(e);
  }
  async dropFile(e) {
    let r = new a("DROP_FILE", e);
    return await this.postTask(r);
  }
  async dropFiles() {
    let e = new a("DROP_FILES", null);
    return await this.postTask(e);
  }
  async flushFiles() {
    let e = new a("FLUSH_FILES", null);
    return await this.postTask(e);
  }
  async instantiate(e, r = null, t = (o) => {
  }) {
    this._onInstantiationProgress.push(t);
    let o = new a("INSTANTIATE", [e, r]);
    return await this.postTask(o);
  }
  async getVersion() {
    let e = new a("GET_VERSION", null);
    return await this.postTask(e);
  }
  async getFeatureFlags() {
    let e = new a("GET_FEATURE_FLAGS", null);
    return await this.postTask(e);
  }
  async open(e) {
    let r = new a("OPEN", e);
    await this.postTask(r);
  }
  async tokenize(e) {
    let r = new a("TOKENIZE", e);
    return await this.postTask(r);
  }
  async connectInternal() {
    let e = new a("CONNECT", null);
    return await this.postTask(e);
  }
  async connect() {
    let e = await this.connectInternal();
    return new E(this, e);
  }
  async disconnect(e) {
    let r = new a("DISCONNECT", e);
    await this.postTask(r);
  }
  async runQuery(e, r) {
    let t = new a("RUN_QUERY", [e, r]);
    return await this.postTask(t);
  }
  async startPendingQuery(e, r) {
    let t = new a("START_PENDING_QUERY", [e, r]);
    return await this.postTask(t);
  }
  async pollPendingQuery(e) {
    let r = new a("POLL_PENDING_QUERY", e);
    return await this.postTask(r);
  }
  async cancelPendingQuery(e) {
    let r = new a("CANCEL_PENDING_QUERY", e);
    return await this.postTask(r);
  }
  async fetchQueryResults(e) {
    let r = new a("FETCH_QUERY_RESULTS", e);
    return await this.postTask(r);
  }
  async getTableNames(e, r) {
    let t = new a("GET_TABLE_NAMES", [e, r]);
    return await this.postTask(t);
  }
  async createPrepared(e, r) {
    let t = new a("CREATE_PREPARED", [e, r]);
    return await this.postTask(t);
  }
  async closePrepared(e, r) {
    let t = new a("CLOSE_PREPARED", [e, r]);
    await this.postTask(t);
  }
  async runPrepared(e, r, t) {
    let o = new a("RUN_PREPARED", [e, r, t]);
    return await this.postTask(o);
  }
  async sendPrepared(e, r, t) {
    let o = new a("SEND_PREPARED", [e, r, t]);
    return await this.postTask(o);
  }
  async globFiles(e) {
    let r = new a("GLOB_FILE_INFOS", e);
    return await this.postTask(r);
  }
  async registerFileText(e, r) {
    let t = oe.encode(r);
    await this.registerFileBuffer(e, t);
  }
  async registerFileURL(e, r, t, o) {
    r === void 0 && (r = e);
    let i = new a("REGISTER_FILE_URL", [e, r, t, o]);
    await this.postTask(i);
  }
  async registerEmptyFileBuffer(e) {
    let r = new a("REGISTER_FILE_BUFFER", [e, new Uint8Array()]);
    await this.postTask(r);
  }
  async registerFileBuffer(e, r) {
    let t = new a("REGISTER_FILE_BUFFER", [e, r]);
    await this.postTask(t, [r.buffer]);
  }
  async registerFileHandle(e, r, t, o) {
    let i = new a("REGISTER_FILE_HANDLE", [e, r, t, o]);
    await this.postTask(i, []);
  }
  async collectFileStatistics(e, r) {
    let t = new a("COLLECT_FILE_STATISTICS", [e, r]);
    await this.postTask(t, []);
  }
  async exportFileStatistics(e) {
    let r = new a("EXPORT_FILE_STATISTICS", e);
    return await this.postTask(r, []);
  }
  async copyFileToBuffer(e) {
    let r = new a("COPY_FILE_TO_BUFFER", e);
    return await this.postTask(r);
  }
  async copyFileToPath(e, r) {
    let t = new a("COPY_FILE_TO_PATH", [e, r]);
    await this.postTask(t);
  }
  async insertArrowFromIPCStream(e, r, t) {
    if (r.length == 0)
      return;
    let o = new a("INSERT_ARROW_FROM_IPC_STREAM", [e, r, t]);
    await this.postTask(o, [r.buffer]);
  }
  async insertCSVFromPath(e, r, t) {
    if (t.columns !== void 0) {
      let i = [];
      for (let n in t.columns) {
        let T = t.columns[n];
        i.push(R(n, T));
      }
      t.columnsFlat = i, delete t.columns;
    }
    let o = new a("IMPORT_CSV_FROM_PATH", [e, r, t]);
    await this.postTask(o);
  }
  async insertJSONFromPath(e, r, t) {
    if (t.columns !== void 0) {
      let i = [];
      for (let n in t.columns) {
        let T = t.columns[n];
        i.push(R(n, T));
      }
      t.columnsFlat = i, delete t.columns;
    }
    let o = new a("IMPORT_JSON_FROM_PATH", [e, r, t]);
    await this.postTask(o);
  }
};
var F = async () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 3, 1, 0, 1, 10, 14, 1, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11]));
var f = async () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 8, 1, 6, 0, 6, 64, 25, 11, 11]));
var U = async () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 10, 1, 8, 0, 65, 0, 253, 15, 253, 98, 11]));
var C = () => (async (s2) => {
  try {
    return typeof MessageChannel < "u" && new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(s2);
  } catch (e) {
    return false;
  }
})(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2, 0, 26, 11]));
var _ = { name: "@duckdb/duckdb-wasm", version: "1.28.1-dev99.0", description: "DuckDB powered by WebAssembly", license: "MIT", repository: { type: "git", url: "https://github.com/duckdb/duckdb-wasm.git" }, keywords: ["sql", "duckdb", "relational", "database", "data", "query", "wasm", "analytics", "olap", "arrow", "parquet", "json", "csv"], dependencies: { "apache-arrow": "^14.0.1" }, devDependencies: { "@types/emscripten": "^1.39.10", "@types/jasmine": "^5.1.4", "@typescript-eslint/eslint-plugin": "^6.18.0", "@typescript-eslint/parser": "^6.18.0", esbuild: "^0.19.10", eslint: "^8.56.0", "eslint-plugin-jasmine": "^4.1.3", "eslint-plugin-react": "^7.33.2", "fast-glob": "^3.3.2", jasmine: "^5.1.0", "jasmine-core": "^5.1.1", "jasmine-spec-reporter": "^7.0.0", "js-sha256": "^0.10.1", karma: "^6.4.2", "karma-chrome-launcher": "^3.2.0", "karma-coverage": "^2.2.1", "karma-firefox-launcher": "^2.1.2", "karma-jasmine": "^5.1.0", "karma-jasmine-html-reporter": "^2.1.0", "karma-sourcemap-loader": "^0.4.0", "karma-spec-reporter": "^0.0.36", "make-dir": "^4.0.0", nyc: "^15.1.0", prettier: "^3.2.2", puppeteer: "^21.7.0", rimraf: "^5.0.5", s3rver: "^3.7.1", typedoc: "^0.25.7", typescript: "^5.3.3", "wasm-feature-detect": "^1.6.1", "web-worker": "^1.2.0" }, scripts: { "build:debug": "node bundle.mjs debug && tsc --emitDeclarationOnly", "build:release": "node bundle.mjs release && tsc --emitDeclarationOnly", docs: "typedoc", report: "node ./coverage.mjs", "test:node": "node --enable-source-maps ../../node_modules/jasmine/bin/jasmine ./dist/tests-node.cjs", "test:node:debug": "node --inspect-brk --enable-source-maps ../../node_modules/jasmine/bin/jasmine ./dist/tests-node.cjs", "test:node:coverage": "nyc -r json --report-dir ./coverage/node node ../../node_modules/jasmine/bin/jasmine ./dist/tests-node.cjs", "test:firefox": "karma start ./karma/tests-firefox.cjs", "test:chrome": "karma start ./karma/tests-chrome.cjs", "test:chrome:eh": "karma start ./karma/tests-chrome-eh.cjs", "test:chrome:coverage": "karma start ./karma/tests-chrome-coverage.cjs", "test:browser": "karma start ./karma/tests-all.cjs", "test:browser:debug": "karma start ./karma/tests-debug.cjs", test: "npm run test:chrome && npm run test:node", "test:coverage": "npm run test:chrome:coverage && npm run test:node:coverage && npm run report", lint: "eslint src test" }, files: ["dist", "!dist/types/test"], main: "dist/duckdb-browser.cjs", module: "dist/duckdb-browser.mjs", types: "dist/duckdb-browser.d.ts", jsdelivr: "dist/duckdb-browser.cjs", unpkg: "dist/duckdb-browser.mjs", sideEffects: false, browser: { fs: false, path: false, perf_hooks: false, os: false, worker_threads: false }, exports: { "./dist/duckdb-mvp.wasm": "./dist/duckdb-mvp.wasm", "./dist/duckdb-eh.wasm": "./dist/duckdb-eh.wasm", "./dist/duckdb-coi.wasm": "./dist/duckdb-coi.wasm", "./dist/duckdb-browser": "./dist/duckdb-browser.mjs", "./dist/duckdb-browser.cjs": "./dist/duckdb-browser.cjs", "./dist/duckdb-browser.mjs": "./dist/duckdb-browser.mjs", "./dist/duckdb-browser-blocking": "./dist/duckdb-browser-blocking.mjs", "./dist/duckdb-browser-blocking.mjs": "./dist/duckdb-browser-blocking.mjs", "./dist/duckdb-browser-blocking.cjs": "./dist/duckdb-browser-blocking.cjs", "./dist/duckdb-browser-coi.pthread.worker.js": "./dist/duckdb-browser-coi.pthread.worker.js", "./dist/duckdb-browser-coi.worker.js": "./dist/duckdb-browser-coi.worker.js", "./dist/duckdb-browser-eh.worker.js": "./dist/duckdb-browser-eh.worker.js", "./dist/duckdb-browser-mvp.worker.js": "./dist/duckdb-browser-mvp.worker.js", "./dist/duckdb-node": "./dist/duckdb-node.cjs", "./dist/duckdb-node.cjs": "./dist/duckdb-node.cjs", "./dist/duckdb-node-blocking": "./dist/duckdb-node-blocking.cjs", "./dist/duckdb-node-blocking.cjs": "./dist/duckdb-node-blocking.cjs", "./dist/duckdb-node-eh.worker.cjs": "./dist/duckdb-node-eh.worker.cjs", "./dist/duckdb-node-mvp.worker.cjs": "./dist/duckdb-node-mvp.worker.cjs", "./blocking": { browser: { types: "./dist/duckdb-browser-blocking.d.ts", import: "./dist/duckdb-browser-blocking.mjs", require: "./dist/duckdb-browser-blocking.cjs" }, node: { types: "./dist/duckdb-node-blocking.d.ts", require: "./dist/duckdb-node-blocking.cjs", import: "./dist/duckdb-node-blocking.cjs" }, types: "./dist/duckdb-browser-blocking.d.ts", import: "./dist/duckdb-browser-blocking.mjs", require: "./dist/duckdb-browser-blocking.cjs" }, ".": { browser: { types: "./dist/duckdb-browser.d.ts", import: "./dist/duckdb-browser.mjs", require: "./dist/duckdb-browser.cjs" }, node: { types: "./dist/duckdb-node.d.ts", import: "./dist/duckdb-node.cjs", require: "./dist/duckdb-node.cjs" }, types: "./dist/duckdb-browser.d.ts", import: "./dist/duckdb-browser.mjs", require: "./dist/duckdb-browser.cjs" } } };
var W = _.name;
var v = _.version;
var I = _.version.split(".");
var fe = I[0];
var Ue = I[1];
var Ce = I[2];
var M = () => typeof navigator > "u";
function Ge() {
  let s2 = "https://cdn.jsdelivr.net/npm/".concat(W, "@").concat(v, "/dist/");
  return { mvp: { mainModule: "".concat(s2, "duckdb-mvp.wasm"), mainWorker: "".concat(s2, "duckdb-browser-mvp.worker.js") }, eh: { mainModule: "".concat(s2, "duckdb-eh.wasm"), mainWorker: "".concat(s2, "duckdb-browser-eh.worker.js") } };
}
var k = null;
var y2 = null;
var g = null;
var S = null;
var h = null;
async function de() {
  return k == null && (k = typeof BigInt64Array < "u"), y2 == null && (y2 = await f()), g == null && (g = await C()), S == null && (S = await U()), h == null && (h = await F()), { bigInt64Array: k, crossOriginIsolated: M() || globalThis.crossOriginIsolated || false, wasmExceptions: y2, wasmSIMD: S, wasmThreads: g, wasmBulkMemory: h };
}
async function xe(s2) {
  let e = await de();
  if (e.wasmExceptions) {
    if (e.wasmSIMD && e.wasmThreads && e.crossOriginIsolated && s2.coi)
      return { mainModule: s2.coi.mainModule, mainWorker: s2.coi.mainWorker, pthreadWorker: s2.coi.pthreadWorker };
    if (s2.eh)
      return { mainModule: s2.eh.mainModule, mainWorker: s2.eh.mainWorker, pthreadWorker: null };
  }
  return { mainModule: s2.mvp.mainModule, mainWorker: s2.mvp.mainWorker, pthreadWorker: null };
}
var Q = $(x2());
function ce() {
  let s2 = new TextDecoder();
  return (e) => (typeof SharedArrayBuffer < "u" && e.buffer instanceof SharedArrayBuffer && (e = new Uint8Array(e)), s2.decode(e));
}
var je = ce();
var q = ((n) => (n[n.BUFFER = 0] = "BUFFER", n[n.NODE_FS = 1] = "NODE_FS", n[n.BROWSER_FILEREADER = 2] = "BROWSER_FILEREADER", n[n.BROWSER_FSACCESS = 3] = "BROWSER_FSACCESS", n[n.HTTP = 4] = "HTTP", n[n.S3 = 5] = "S3", n))(q || {});

// ../core/src/connectors/wasm.js
function wasmConnector(options = {}) {
  const { duckdb, connection, ...opts } = options;
  let db = duckdb;
  let con = connection;
  let loadPromise;
  function load2() {
    if (!loadPromise) {
      loadPromise = (db ? Promise.resolve(db) : initDatabase(opts).then((result) => db = result)).then((db2) => db2.connect()).then((result) => con = result);
    }
    return loadPromise;
  }
  async function getDuckDB() {
    if (!db)
      await load2();
    return db;
  }
  async function getConnection() {
    if (!con)
      await load2();
    return con;
  }
  return {
    getDuckDB,
    getConnection,
    /**
     * Query the DuckDB-WASM instance.
     * @param {object} query
     * @param {string} [query.type] The query type: 'exec', 'arrow', or 'json'.
     * @param {string} query.sql A SQL query string.
     * @returns the query result
     */
    query: async (query) => {
      const { type: type2, sql: sql2 } = query;
      const con2 = await getConnection();
      const result = await con2.query(sql2);
      return type2 === "exec" ? void 0 : type2 === "arrow" ? result : Array.from(result);
    }
  };
}
async function initDatabase({
  log: log3 = false
} = {}) {
  const JSDELIVR_BUNDLES = Ge();
  const bundle = await xe(JSDELIVR_BUNDLES);
  const worker_url = URL.createObjectURL(
    new Blob([`importScripts("${bundle.mainWorker}");`], { type: "text/javascript" })
  );
  const worker = new Worker(worker_url);
  const logger = log3 ? new P() : new A();
  const db = new O(logger, worker);
  await db.instantiate(bundle.mainModule, bundle.pthreadWorker);
  URL.revokeObjectURL(worker_url);
  return db;
}

// ../core/src/util/synchronizer.js
function synchronizer() {
  const set3 = /* @__PURE__ */ new Set();
  let done;
  let promise = new Promise((resolve) => done = resolve);
  return {
    /**
     * Mark an item as pending.
     * @param {*} item An item to synchronize on.
     */
    pending(item) {
      set3.add(item);
    },
    /**
     * Mark a pending item as ready, indicating it is
     * ready for a synchronized update.
     * @param {*} item An item to synchronize on.
     * @returns {boolean} True if the synchronizer is ready to
     *  resolve, false otherwise.
     */
    ready(item) {
      set3.delete(item);
      return set3.size === 0;
    },
    /**
     * Resolve the current synchronization cycle, causing the synchronize
     * promise to resolve and thereby trigger downstream updates.
     */
    resolve() {
      promise = new Promise((resolve) => {
        done();
        done = resolve;
      });
    },
    /**
     * The promise for the current synchronization cycle.
     * @return {Promise} The synchronization promise.
     */
    get promise() {
      return promise;
    }
  };
}

// src/api.js
var api_exports = {};
__export(api_exports, {
  Fixed: () => Fixed,
  Param: () => Param,
  Query: () => Query,
  Selection: () => Selection,
  agg: () => agg,
  align: () => align,
  and: () => and,
  area: () => area2,
  areaX: () => areaX2,
  areaY: () => areaY2,
  argmax: () => argmax,
  argmin: () => argmin,
  arrayAgg: () => arrayAgg,
  arrow: () => arrow2,
  aspectRatio: () => aspectRatio,
  avg: () => avg,
  axis: () => axis2,
  axisFx: () => axisFx2,
  axisFy: () => axisFy2,
  axisX: () => axisX2,
  axisY: () => axisY2,
  barX: () => barX2,
  barY: () => barY2,
  bin: () => bin2,
  cast: () => cast,
  castDouble: () => castDouble,
  castInteger: () => castInteger,
  cell: () => cell2,
  cellX: () => cellX2,
  cellY: () => cellY2,
  centroid: () => centroid,
  centroidX: () => centroidX,
  centroidY: () => centroidY,
  circle: () => circle2,
  colorBase: () => colorBase,
  colorClamp: () => colorClamp,
  colorConstant: () => colorConstant2,
  colorDomain: () => colorDomain,
  colorExponent: () => colorExponent,
  colorInterpolate: () => colorInterpolate,
  colorLabel: () => colorLabel,
  colorLegend: () => colorLegend,
  colorN: () => colorN,
  colorNice: () => colorNice,
  colorPivot: () => colorPivot,
  colorRange: () => colorRange,
  colorReverse: () => colorReverse,
  colorScale: () => colorScale2,
  colorScheme: () => colorScheme2,
  colorSymmetric: () => colorSymmetric,
  colorTickFormat: () => colorTickFormat,
  colorZero: () => colorZero,
  column: () => column,
  contour: () => contour2,
  coordinator: () => coordinator,
  corr: () => corr,
  count: () => count,
  covarPop: () => covarPop,
  create: () => create,
  cume_dist: () => cume_dist,
  dateDay: () => dateDay,
  dateMonth: () => dateMonth,
  dateMonthDay: () => dateMonthDay,
  delaunayLink: () => delaunayLink2,
  delaunayMesh: () => delaunayMesh2,
  denseLine: () => denseLine,
  dense_rank: () => dense_rank,
  density: () => density2,
  densityX: () => densityX,
  densityY: () => densityY,
  dot: () => dot2,
  dotX: () => dotX2,
  dotY: () => dotY2,
  entropy: () => entropy,
  eq: () => eq,
  facetGrid: () => facetGrid,
  facetLabel: () => facetLabel,
  facetMargin: () => facetMargin,
  facetMarginBottom: () => facetMarginBottom,
  facetMarginLeft: () => facetMarginLeft,
  facetMarginRight: () => facetMarginRight,
  facetMarginTop: () => facetMarginTop,
  first: () => first,
  first_value: () => first_value,
  frame: () => frame3,
  from: () => from,
  fxAlign: () => fxAlign,
  fxAriaDescription: () => fxAriaDescription,
  fxAriaLabel: () => fxAriaLabel,
  fxAxis: () => fxAxis,
  fxDomain: () => fxDomain,
  fxFontVariant: () => fxFontVariant,
  fxGrid: () => fxGrid,
  fxInset: () => fxInset,
  fxInsetLeft: () => fxInsetLeft,
  fxInsetRight: () => fxInsetRight,
  fxLabel: () => fxLabel,
  fxLabelAnchor: () => fxLabelAnchor,
  fxLabelOffset: () => fxLabelOffset,
  fxLine: () => fxLine,
  fxNice: () => fxNice,
  fxPadding: () => fxPadding,
  fxPaddingInner: () => fxPaddingInner,
  fxPaddingOuter: () => fxPaddingOuter,
  fxRange: () => fxRange,
  fxReverse: () => fxReverse,
  fxRound: () => fxRound,
  fxTickFormat: () => fxTickFormat,
  fxTickPadding: () => fxTickPadding,
  fxTickRotate: () => fxTickRotate,
  fxTickSize: () => fxTickSize,
  fxTickSpacing: () => fxTickSpacing,
  fxTicks: () => fxTicks,
  fyAlign: () => fyAlign,
  fyAriaDescription: () => fyAriaDescription,
  fyAriaLabel: () => fyAriaLabel,
  fyAxis: () => fyAxis,
  fyDomain: () => fyDomain,
  fyFontVariant: () => fyFontVariant,
  fyGrid: () => fyGrid,
  fyInset: () => fyInset,
  fyInsetBottom: () => fyInsetBottom,
  fyInsetTop: () => fyInsetTop,
  fyLabel: () => fyLabel,
  fyLabelAnchor: () => fyLabelAnchor,
  fyLabelOffset: () => fyLabelOffset,
  fyLine: () => fyLine,
  fyNice: () => fyNice,
  fyPadding: () => fyPadding,
  fyPaddingInner: () => fyPaddingInner,
  fyPaddingOuter: () => fyPaddingOuter,
  fyRange: () => fyRange,
  fyReverse: () => fyReverse,
  fyRound: () => fyRound,
  fyTickFormat: () => fyTickFormat,
  fyTickPadding: () => fyTickPadding,
  fyTickRotate: () => fyTickRotate,
  fyTickSize: () => fyTickSize,
  fyTickSpacing: () => fyTickSpacing,
  fyTicks: () => fyTicks,
  geo: () => geo2,
  geojson: () => geojson,
  graticule: () => graticule3,
  grid: () => grid,
  gridFx: () => gridFx2,
  gridFy: () => gridFy2,
  gridX: () => gridX2,
  gridY: () => gridY2,
  gt: () => gt,
  gte: () => gte,
  hconcat: () => hconcat,
  heatmap: () => heatmap,
  height: () => height,
  hexagon: () => hexagon2,
  hexbin: () => hexbin2,
  hexgrid: () => hexgrid2,
  highlight: () => highlight,
  hspace: () => hspace,
  hull: () => hull2,
  image: () => image2,
  inset: () => inset,
  intervalX: () => intervalX,
  intervalXY: () => intervalXY,
  intervalY: () => intervalY,
  isBetween: () => isBetween,
  isDistinct: () => isDistinct,
  isNotBetween: () => isNotBetween,
  isNotDistinct: () => isNotDistinct,
  isNotNull: () => isNotNull,
  isNull: () => isNull,
  kurtosis: () => kurtosis,
  label: () => label,
  lag: () => lag,
  last: () => last,
  last_value: () => last_value,
  lead: () => lead,
  lengthBase: () => lengthBase,
  lengthClamp: () => lengthClamp,
  lengthConstant: () => lengthConstant,
  lengthDomain: () => lengthDomain,
  lengthExponent: () => lengthExponent,
  lengthNice: () => lengthNice,
  lengthRange: () => lengthRange,
  lengthScale: () => lengthScale,
  lengthZero: () => lengthZero,
  line: () => line2,
  lineX: () => lineX2,
  lineY: () => lineY2,
  link: () => link3,
  literal: () => literal,
  loadCSV: () => loadCSV,
  loadExtension: () => loadExtension,
  loadJSON: () => loadJSON,
  loadObjects: () => loadObjects,
  loadParquet: () => loadParquet,
  loadSpatial: () => loadSpatial,
  lt: () => lt,
  lte: () => lte,
  mad: () => mad,
  margin: () => margin,
  marginBottom: () => marginBottom,
  marginLeft: () => marginLeft,
  marginRight: () => marginRight,
  marginTop: () => marginTop,
  margins: () => margins,
  max: () => max,
  median: () => median,
  menu: () => menu2,
  min: () => min,
  mode: () => mode,
  name: () => name,
  nearestX: () => nearestX,
  nearestY: () => nearestY,
  neq: () => neq,
  not: () => not,
  nth_value: () => nth_value,
  ntile: () => ntile,
  opacityBase: () => opacityBase,
  opacityClamp: () => opacityClamp,
  opacityConstant: () => opacityConstant,
  opacityDomain: () => opacityDomain,
  opacityExponent: () => opacityExponent,
  opacityLabel: () => opacityLabel,
  opacityLegend: () => opacityLegend,
  opacityNice: () => opacityNice,
  opacityRange: () => opacityRange,
  opacityReverse: () => opacityReverse,
  opacityScale: () => opacityScale,
  opacityTickFormat: () => opacityTickFormat,
  opacityZero: () => opacityZero,
  or: () => or,
  padding: () => padding,
  pan: () => pan,
  panX: () => panX,
  panY: () => panY,
  panZoom: () => panZoom,
  panZoomX: () => panZoomX,
  panZoomY: () => panZoomY,
  percent_rank: () => percent_rank,
  plot: () => plot2,
  product: () => product,
  projectionClip: () => projectionClip,
  projectionDomain: () => projectionDomain,
  projectionInset: () => projectionInset,
  projectionInsetBottom: () => projectionInsetBottom,
  projectionInsetLeft: () => projectionInsetLeft,
  projectionInsetRight: () => projectionInsetRight,
  projectionInsetTop: () => projectionInsetTop,
  projectionParallels: () => projectionParallels,
  projectionPrecision: () => projectionPrecision,
  projectionRotate: () => projectionRotate,
  projectionType: () => projectionType,
  quantile: () => quantile,
  rBase: () => rBase,
  rClamp: () => rClamp,
  rConstant: () => rConstant,
  rDomain: () => rDomain,
  rExponent: () => rExponent,
  rNice: () => rNice,
  rRange: () => rRange,
  rScale: () => rScale,
  rZero: () => rZero,
  rank: () => rank,
  raster: () => raster2,
  rasterTile: () => rasterTile,
  rect: () => rect2,
  rectX: () => rectX2,
  rectY: () => rectY2,
  regressionY: () => regressionY,
  row_number: () => row_number,
  ruleX: () => ruleX2,
  ruleY: () => ruleY2,
  search: () => search2,
  skewness: () => skewness,
  slider: () => slider2,
  sphere: () => sphere2,
  spike: () => spike2,
  sql: () => sql,
  stddev: () => stddev,
  stddevPop: () => stddevPop,
  stringAgg: () => stringAgg,
  style: () => style,
  sum: () => sum,
  symbolDomain: () => symbolDomain,
  symbolLegend: () => symbolLegend,
  symbolRange: () => symbolRange,
  symbolScale: () => symbolScale,
  table: () => table2,
  text: () => text2,
  textX: () => textX2,
  textY: () => textY2,
  tickX: () => tickX2,
  tickY: () => tickY2,
  toggle: () => toggle,
  toggleColor: () => toggleColor,
  toggleX: () => toggleX,
  toggleY: () => toggleY,
  varPop: () => varPop,
  variance: () => variance,
  vconcat: () => vconcat,
  vector: () => vector2,
  vectorX: () => vectorX2,
  vectorY: () => vectorY2,
  voronoi: () => voronoi2,
  voronoiMesh: () => voronoiMesh2,
  vspace: () => vspace,
  width: () => width,
  xAlign: () => xAlign,
  xAriaDescription: () => xAriaDescription,
  xAriaLabel: () => xAriaLabel,
  xAxis: () => xAxis,
  xBase: () => xBase,
  xClamp: () => xClamp,
  xConstant: () => xConstant,
  xDomain: () => xDomain,
  xExponent: () => xExponent,
  xFontVariant: () => xFontVariant,
  xGrid: () => xGrid,
  xInset: () => xInset,
  xInsetLeft: () => xInsetLeft,
  xInsetRight: () => xInsetRight,
  xLabel: () => xLabel,
  xLabelAnchor: () => xLabelAnchor,
  xLabelOffset: () => xLabelOffset,
  xLine: () => xLine,
  xNice: () => xNice,
  xPadding: () => xPadding,
  xPaddingInner: () => xPaddingInner,
  xPaddingOuter: () => xPaddingOuter,
  xRange: () => xRange,
  xReverse: () => xReverse,
  xRound: () => xRound,
  xScale: () => xScale,
  xTickFormat: () => xTickFormat,
  xTickPadding: () => xTickPadding,
  xTickRotate: () => xTickRotate,
  xTickSize: () => xTickSize,
  xTickSpacing: () => xTickSpacing,
  xTicks: () => xTicks,
  xZero: () => xZero,
  xyDomain: () => xyDomain,
  yAlign: () => yAlign,
  yAriaDescription: () => yAriaDescription,
  yAriaLabel: () => yAriaLabel,
  yAxis: () => yAxis,
  yBase: () => yBase,
  yClamp: () => yClamp,
  yConstant: () => yConstant,
  yDomain: () => yDomain,
  yExponent: () => yExponent,
  yFontVariant: () => yFontVariant,
  yGrid: () => yGrid,
  yInset: () => yInset,
  yInsetBottom: () => yInsetBottom,
  yInsetTop: () => yInsetTop,
  yLabel: () => yLabel,
  yLabelAnchor: () => yLabelAnchor,
  yLabelOffset: () => yLabelOffset,
  yLine: () => yLine,
  yNice: () => yNice,
  yPadding: () => yPadding,
  yPaddingInner: () => yPaddingInner,
  yPaddingOuter: () => yPaddingOuter,
  yRange: () => yRange,
  yReverse: () => yReverse,
  yRound: () => yRound,
  yScale: () => yScale,
  yTickFormat: () => yTickFormat,
  yTickPadding: () => yTickPadding,
  yTickRotate: () => yTickRotate,
  yTickSize: () => yTickSize,
  yTickSpacing: () => yTickSpacing,
  yTicks: () => yTicks,
  yZero: () => yZero
});

// ../plot/src/symbols.js
var Fixed = Symbol("Fixed");
var Transient = Symbol("Transient");
var Transform = Symbol("Transform");

// ../../node_modules/@observablehq/plot/src/index.js
var src_exports = {};
__export(src_exports, {
  Area: () => Area,
  Arrow: () => Arrow,
  BarX: () => BarX,
  BarY: () => BarY,
  Cell: () => Cell,
  Contour: () => Contour,
  Density: () => Density,
  Dot: () => Dot,
  Frame: () => Frame,
  Geo: () => Geo,
  Hexgrid: () => Hexgrid,
  Image: () => Image,
  Line: () => Line,
  Link: () => Link,
  Mark: () => Mark,
  Raster: () => Raster,
  Rect: () => Rect,
  RuleX: () => RuleX,
  RuleY: () => RuleY,
  Text: () => Text,
  TickX: () => TickX,
  TickY: () => TickY,
  Tip: () => Tip,
  Vector: () => Vector3,
  area: () => area,
  areaX: () => areaX,
  areaY: () => areaY,
  arrow: () => arrow,
  auto: () => auto,
  autoSpec: () => autoSpec,
  axisFx: () => axisFx,
  axisFy: () => axisFy,
  axisX: () => axisX,
  axisY: () => axisY,
  barX: () => barX,
  barY: () => barY,
  bin: () => bin,
  binX: () => binX,
  binY: () => binY,
  bollinger: () => bollinger,
  bollingerX: () => bollingerX,
  bollingerY: () => bollingerY,
  boxX: () => boxX,
  boxY: () => boxY,
  cell: () => cell,
  cellX: () => cellX,
  cellY: () => cellY,
  centroid: () => centroid2,
  circle: () => circle,
  cluster: () => cluster,
  column: () => column2,
  contour: () => contour,
  crosshair: () => crosshair,
  crosshairX: () => crosshairX,
  crosshairY: () => crosshairY,
  delaunayLink: () => delaunayLink,
  delaunayMesh: () => delaunayMesh,
  density: () => density,
  differenceY: () => differenceY,
  dodgeX: () => dodgeX,
  dodgeY: () => dodgeY,
  dot: () => dot,
  dotX: () => dotX,
  dotY: () => dotY,
  filter: () => filter2,
  find: () => find2,
  formatIsoDate: () => formatIsoDate,
  formatMonth: () => formatMonth,
  formatWeekday: () => formatWeekday,
  frame: () => frame2,
  geo: () => geo,
  geoCentroid: () => geoCentroid,
  graticule: () => graticule2,
  gridFx: () => gridFx,
  gridFy: () => gridFy,
  gridX: () => gridX,
  gridY: () => gridY,
  group: () => group2,
  groupX: () => groupX,
  groupY: () => groupY,
  groupZ: () => groupZ,
  hexagon: () => hexagon,
  hexbin: () => hexbin,
  hexgrid: () => hexgrid,
  hull: () => hull,
  identity: () => identity7,
  image: () => image,
  indexOf: () => indexOf,
  initializer: () => initializer,
  interpolateNearest: () => interpolateNearest,
  interpolateNone: () => interpolateNone,
  interpolatorBarycentric: () => interpolatorBarycentric,
  interpolatorRandomWalk: () => interpolatorRandomWalk,
  legend: () => legend,
  line: () => line,
  lineX: () => lineX,
  lineY: () => lineY,
  linearRegressionX: () => linearRegressionX,
  linearRegressionY: () => linearRegressionY,
  link: () => link2,
  map: () => map3,
  mapX: () => mapX,
  mapY: () => mapY,
  marks: () => marks,
  normalize: () => normalize3,
  normalizeX: () => normalizeX,
  normalizeY: () => normalizeY,
  plot: () => plot,
  pointer: () => pointer,
  pointerX: () => pointerX,
  pointerY: () => pointerY,
  raster: () => raster,
  rect: () => rect,
  rectX: () => rectX,
  rectY: () => rectY,
  reverse: () => reverse2,
  ruleX: () => ruleX,
  ruleY: () => ruleY,
  scale: () => scale2,
  select: () => select,
  selectFirst: () => selectFirst,
  selectLast: () => selectLast,
  selectMaxX: () => selectMaxX,
  selectMaxY: () => selectMaxY,
  selectMinX: () => selectMinX,
  selectMinY: () => selectMinY,
  shiftX: () => shiftX,
  shuffle: () => shuffle,
  sort: () => sort2,
  sphere: () => sphere,
  spike: () => spike,
  stackX: () => stackX,
  stackX1: () => stackX1,
  stackX2: () => stackX2,
  stackY: () => stackY,
  stackY1: () => stackY1,
  stackY2: () => stackY2,
  text: () => text,
  textX: () => textX,
  textY: () => textY,
  tickX: () => tickX,
  tickY: () => tickY,
  tip: () => tip,
  transform: () => basic,
  tree: () => tree,
  treeLink: () => treeLink,
  treeNode: () => treeNode,
  valueof: () => valueof,
  vector: () => vector,
  vectorX: () => vectorX,
  vectorY: () => vectorY,
  voronoi: () => voronoi,
  voronoiMesh: () => voronoiMesh,
  window: () => window2,
  windowX: () => windowX,
  windowY: () => windowY
});

// ../../node_modules/d3-array/src/ascending.js
function ascending(a3, b2) {
  return a3 == null || b2 == null ? NaN : a3 < b2 ? -1 : a3 > b2 ? 1 : a3 >= b2 ? 0 : NaN;
}

// ../../node_modules/d3-array/src/descending.js
function descending(a3, b2) {
  return a3 == null || b2 == null ? NaN : b2 < a3 ? -1 : b2 > a3 ? 1 : b2 >= a3 ? 0 : NaN;
}

// ../../node_modules/d3-array/src/bisector.js
function bisector(f2) {
  let compare1, compare2, delta;
  if (f2.length !== 2) {
    compare1 = ascending;
    compare2 = (d, x4) => ascending(f2(d), x4);
    delta = (d, x4) => f2(d) - x4;
  } else {
    compare1 = f2 === ascending || f2 === descending ? f2 : zero;
    compare2 = f2;
    delta = f2;
  }
  function left2(a3, x4, lo = 0, hi = a3.length) {
    if (lo < hi) {
      if (compare1(x4, x4) !== 0)
        return hi;
      do {
        const mid2 = lo + hi >>> 1;
        if (compare2(a3[mid2], x4) < 0)
          lo = mid2 + 1;
        else
          hi = mid2;
      } while (lo < hi);
    }
    return lo;
  }
  function right2(a3, x4, lo = 0, hi = a3.length) {
    if (lo < hi) {
      if (compare1(x4, x4) !== 0)
        return hi;
      do {
        const mid2 = lo + hi >>> 1;
        if (compare2(a3[mid2], x4) <= 0)
          lo = mid2 + 1;
        else
          hi = mid2;
      } while (lo < hi);
    }
    return lo;
  }
  function center2(a3, x4, lo = 0, hi = a3.length) {
    const i = left2(a3, x4, lo, hi - 1);
    return i > lo && delta(a3[i - 1], x4) > -delta(a3[i], x4) ? i - 1 : i;
  }
  return { left: left2, center: center2, right: right2 };
}
function zero() {
  return 0;
}

// ../../node_modules/d3-array/src/number.js
function number(x4) {
  return x4 === null ? NaN : +x4;
}
function* numbers(values2, valueof2) {
  if (valueof2 === void 0) {
    for (let value of values2) {
      if (value != null && (value = +value) >= value) {
        yield value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values2) {
      if ((value = valueof2(value, ++index2, values2)) != null && (value = +value) >= value) {
        yield value;
      }
    }
  }
}

// ../../node_modules/d3-array/src/bisect.js
var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
var bisectCenter = bisector(number).center;
var bisect_default = bisectRight;

// ../../node_modules/d3-array/src/blur.js
var blur2 = Blur2(blurf);
var blurImage = Blur2(blurfImage);
function Blur2(blur3) {
  return function(data, rx, ry = rx) {
    if (!((rx = +rx) >= 0))
      throw new RangeError("invalid rx");
    if (!((ry = +ry) >= 0))
      throw new RangeError("invalid ry");
    let { data: values2, width: width2, height: height2 } = data;
    if (!((width2 = Math.floor(width2)) >= 0))
      throw new RangeError("invalid width");
    if (!((height2 = Math.floor(height2 !== void 0 ? height2 : values2.length / width2)) >= 0))
      throw new RangeError("invalid height");
    if (!width2 || !height2 || !rx && !ry)
      return data;
    const blurx = rx && blur3(rx);
    const blury = ry && blur3(ry);
    const temp = values2.slice();
    if (blurx && blury) {
      blurh(blurx, temp, values2, width2, height2);
      blurh(blurx, values2, temp, width2, height2);
      blurh(blurx, temp, values2, width2, height2);
      blurv(blury, values2, temp, width2, height2);
      blurv(blury, temp, values2, width2, height2);
      blurv(blury, values2, temp, width2, height2);
    } else if (blurx) {
      blurh(blurx, values2, temp, width2, height2);
      blurh(blurx, temp, values2, width2, height2);
      blurh(blurx, values2, temp, width2, height2);
    } else if (blury) {
      blurv(blury, values2, temp, width2, height2);
      blurv(blury, temp, values2, width2, height2);
      blurv(blury, values2, temp, width2, height2);
    }
    return data;
  };
}
function blurh(blur3, T, S2, w, h2) {
  for (let y4 = 0, n = w * h2; y4 < n; ) {
    blur3(T, S2, y4, y4 += w, 1);
  }
}
function blurv(blur3, T, S2, w, h2) {
  for (let x4 = 0, n = w * h2; x4 < w; ++x4) {
    blur3(T, S2, x4, x4 + n, w);
  }
}
function blurfImage(radius2) {
  const blur3 = blurf(radius2);
  return (T, S2, start2, stop, step) => {
    start2 <<= 2, stop <<= 2, step <<= 2;
    blur3(T, S2, start2 + 0, stop + 0, step);
    blur3(T, S2, start2 + 1, stop + 1, step);
    blur3(T, S2, start2 + 2, stop + 2, step);
    blur3(T, S2, start2 + 3, stop + 3, step);
  };
}
function blurf(radius2) {
  const radius0 = Math.floor(radius2);
  if (radius0 === radius2)
    return bluri(radius2);
  const t = radius2 - radius0;
  const w = 2 * radius2 + 1;
  return (T, S2, start2, stop, step) => {
    if (!((stop -= step) >= start2))
      return;
    let sum5 = radius0 * S2[start2];
    const s0 = step * radius0;
    const s1 = s0 + step;
    for (let i = start2, j2 = start2 + s0; i < j2; i += step) {
      sum5 += S2[Math.min(stop, i)];
    }
    for (let i = start2, j2 = stop; i <= j2; i += step) {
      sum5 += S2[Math.min(stop, i + s0)];
      T[i] = (sum5 + t * (S2[Math.max(start2, i - s1)] + S2[Math.min(stop, i + s1)])) / w;
      sum5 -= S2[Math.max(start2, i - s0)];
    }
  };
}
function bluri(radius2) {
  const w = 2 * radius2 + 1;
  return (T, S2, start2, stop, step) => {
    if (!((stop -= step) >= start2))
      return;
    let sum5 = radius2 * S2[start2];
    const s2 = step * radius2;
    for (let i = start2, j2 = start2 + s2; i < j2; i += step) {
      sum5 += S2[Math.min(stop, i)];
    }
    for (let i = start2, j2 = stop; i <= j2; i += step) {
      sum5 += S2[Math.min(stop, i + s2)];
      T[i] = sum5 / w;
      sum5 -= S2[Math.max(start2, i - s2)];
    }
  };
}

// ../../node_modules/d3-array/src/count.js
function count2(values2, valueof2) {
  let count4 = 0;
  if (valueof2 === void 0) {
    for (let value of values2) {
      if (value != null && (value = +value) >= value) {
        ++count4;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values2) {
      if ((value = valueof2(value, ++index2, values2)) != null && (value = +value) >= value) {
        ++count4;
      }
    }
  }
  return count4;
}

// ../../node_modules/d3-array/src/cross.js
function length2(array4) {
  return array4.length | 0;
}
function empty(length4) {
  return !(length4 > 0);
}
function arrayify(values2) {
  return typeof values2 !== "object" || "length" in values2 ? values2 : Array.from(values2);
}
function reducer(reduce) {
  return (values2) => reduce(...values2);
}
function cross(...values2) {
  const reduce = typeof values2[values2.length - 1] === "function" && reducer(values2.pop());
  values2 = values2.map(arrayify);
  const lengths = values2.map(length2);
  const j2 = values2.length - 1;
  const index2 = new Array(j2 + 1).fill(0);
  const product2 = [];
  if (j2 < 0 || lengths.some(empty))
    return product2;
  while (true) {
    product2.push(index2.map((j3, i2) => values2[i2][j3]));
    let i = j2;
    while (++index2[i] === lengths[i]) {
      if (i === 0)
        return reduce ? product2.map(reduce) : product2;
      index2[i--] = 0;
    }
  }
}

// ../../node_modules/d3-array/src/cumsum.js
function cumsum(values2, valueof2) {
  var sum5 = 0, index2 = 0;
  return Float64Array.from(values2, valueof2 === void 0 ? (v3) => sum5 += +v3 || 0 : (v3) => sum5 += +valueof2(v3, index2++, values2) || 0);
}

// ../../node_modules/d3-array/src/variance.js
function variance2(values2, valueof2) {
  let count4 = 0;
  let delta;
  let mean3 = 0;
  let sum5 = 0;
  if (valueof2 === void 0) {
    for (let value of values2) {
      if (value != null && (value = +value) >= value) {
        delta = value - mean3;
        mean3 += delta / ++count4;
        sum5 += delta * (value - mean3);
      }
    }
  } else {
    let index2 = -1;
    for (let value of values2) {
      if ((value = valueof2(value, ++index2, values2)) != null && (value = +value) >= value) {
        delta = value - mean3;
        mean3 += delta / ++count4;
        sum5 += delta * (value - mean3);
      }
    }
  }
  if (count4 > 1)
    return sum5 / (count4 - 1);
}

// ../../node_modules/d3-array/src/deviation.js
function deviation(values2, valueof2) {
  const v3 = variance2(values2, valueof2);
  return v3 ? Math.sqrt(v3) : v3;
}

// ../../node_modules/d3-array/src/extent.js
function extent(values2, valueof2) {
  let min5;
  let max4;
  if (valueof2 === void 0) {
    for (const value of values2) {
      if (value != null) {
        if (min5 === void 0) {
          if (value >= value)
            min5 = max4 = value;
        } else {
          if (min5 > value)
            min5 = value;
          if (max4 < value)
            max4 = value;
        }
      }
    }
  } else {
    let index2 = -1;
    for (let value of values2) {
      if ((value = valueof2(value, ++index2, values2)) != null) {
        if (min5 === void 0) {
          if (value >= value)
            min5 = max4 = value;
        } else {
          if (min5 > value)
            min5 = value;
          if (max4 < value)
            max4 = value;
        }
      }
    }
  }
  return [min5, max4];
}

// ../../node_modules/d3-array/src/fsum.js
var Adder = class {
  constructor() {
    this._partials = new Float64Array(32);
    this._n = 0;
  }
  add(x4) {
    const p2 = this._partials;
    let i = 0;
    for (let j2 = 0; j2 < this._n && j2 < 32; j2++) {
      const y4 = p2[j2], hi = x4 + y4, lo = Math.abs(x4) < Math.abs(y4) ? x4 - (hi - y4) : y4 - (hi - x4);
      if (lo)
        p2[i++] = lo;
      x4 = hi;
    }
    p2[i] = x4;
    this._n = i + 1;
    return this;
  }
  valueOf() {
    const p2 = this._partials;
    let n = this._n, x4, y4, lo, hi = 0;
    if (n > 0) {
      hi = p2[--n];
      while (n > 0) {
        x4 = hi;
        y4 = p2[--n];
        hi = x4 + y4;
        lo = y4 - (hi - x4);
        if (lo)
          break;
      }
      if (n > 0 && (lo < 0 && p2[n - 1] < 0 || lo > 0 && p2[n - 1] > 0)) {
        y4 = lo * 2;
        x4 = hi + y4;
        if (y4 == x4 - hi)
          hi = x4;
      }
    }
    return hi;
  }
};

// ../../node_modules/internmap/src/index.js
var InternMap = class extends Map {
  constructor(entries, key = keyof) {
    super();
    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
    if (entries != null)
      for (const [key2, value] of entries)
        this.set(key2, value);
  }
  get(key) {
    return super.get(intern_get(this, key));
  }
  has(key) {
    return super.has(intern_get(this, key));
  }
  set(key, value) {
    return super.set(intern_set(this, key), value);
  }
  delete(key) {
    return super.delete(intern_delete(this, key));
  }
};
var InternSet = class extends Set {
  constructor(values2, key = keyof) {
    super();
    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
    if (values2 != null)
      for (const value of values2)
        this.add(value);
  }
  has(value) {
    return super.has(intern_get(this, value));
  }
  add(value) {
    return super.add(intern_set(this, value));
  }
  delete(value) {
    return super.delete(intern_delete(this, value));
  }
};
function intern_get({ _intern, _key }, value) {
  const key = _key(value);
  return _intern.has(key) ? _intern.get(key) : value;
}
function intern_set({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key))
    return _intern.get(key);
  _intern.set(key, value);
  return value;
}
function intern_delete({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key)) {
    value = _intern.get(key);
    _intern.delete(key);
  }
  return value;
}
function keyof(value) {
  return value !== null && typeof value === "object" ? value.valueOf() : value;
}

// ../../node_modules/d3-array/src/identity.js
function identity2(x4) {
  return x4;
}

// ../../node_modules/d3-array/src/group.js
function group(values2, ...keys) {
  return nest(values2, identity2, identity2, keys);
}
function rollup(values2, reduce, ...keys) {
  return nest(values2, identity2, reduce, keys);
}
function rollups(values2, reduce, ...keys) {
  return nest(values2, Array.from, reduce, keys);
}
function nest(values2, map4, reduce, keys) {
  return function regroup(values3, i) {
    if (i >= keys.length)
      return reduce(values3);
    const groups2 = new InternMap();
    const keyof3 = keys[i++];
    let index2 = -1;
    for (const value of values3) {
      const key = keyof3(value, ++index2, values3);
      const group3 = groups2.get(key);
      if (group3)
        group3.push(value);
      else
        groups2.set(key, [value]);
    }
    for (const [key, values4] of groups2) {
      groups2.set(key, regroup(values4, i));
    }
    return map4(groups2);
  }(values2, 0);
}

// ../../node_modules/d3-array/src/permute.js
function permute(source, keys) {
  return Array.from(keys, (key) => source[key]);
}

// ../../node_modules/d3-array/src/sort.js
function sort(values2, ...F2) {
  if (typeof values2[Symbol.iterator] !== "function")
    throw new TypeError("values is not iterable");
  values2 = Array.from(values2);
  let [f2] = F2;
  if (f2 && f2.length !== 2 || F2.length > 1) {
    const index2 = Uint32Array.from(values2, (d, i) => i);
    if (F2.length > 1) {
      F2 = F2.map((f3) => values2.map(f3));
      index2.sort((i, j2) => {
        for (const f3 of F2) {
          const c4 = ascendingDefined(f3[i], f3[j2]);
          if (c4)
            return c4;
        }
      });
    } else {
      f2 = values2.map(f2);
      index2.sort((i, j2) => ascendingDefined(f2[i], f2[j2]));
    }
    return permute(values2, index2);
  }
  return values2.sort(compareDefined(f2));
}
function compareDefined(compare = ascending) {
  if (compare === ascending)
    return ascendingDefined;
  if (typeof compare !== "function")
    throw new TypeError("compare is not a function");
  return (a3, b2) => {
    const x4 = compare(a3, b2);
    if (x4 || x4 === 0)
      return x4;
    return (compare(b2, b2) === 0) - (compare(a3, a3) === 0);
  };
}
function ascendingDefined(a3, b2) {
  return (a3 == null || !(a3 >= a3)) - (b2 == null || !(b2 >= b2)) || (a3 < b2 ? -1 : a3 > b2 ? 1 : 0);
}

// ../../node_modules/d3-array/src/groupSort.js
function groupSort(values2, reduce, key) {
  return (reduce.length !== 2 ? sort(rollup(values2, reduce, key), ([ak, av], [bk, bv]) => ascending(av, bv) || ascending(ak, bk)) : sort(group(values2, key), ([ak, av], [bk, bv]) => reduce(av, bv) || ascending(ak, bk))).map(([key2]) => key2);
}

// ../../node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);
function tickSpec(start2, stop, count4) {
  const step = (stop - start2) / Math.max(0, count4), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
  let i1, i2, inc2;
  if (power < 0) {
    inc2 = Math.pow(10, -power) / factor;
    i1 = Math.round(start2 * inc2);
    i2 = Math.round(stop * inc2);
    if (i1 / inc2 < start2)
      ++i1;
    if (i2 / inc2 > stop)
      --i2;
    inc2 = -inc2;
  } else {
    inc2 = Math.pow(10, power) * factor;
    i1 = Math.round(start2 / inc2);
    i2 = Math.round(stop / inc2);
    if (i1 * inc2 < start2)
      ++i1;
    if (i2 * inc2 > stop)
      --i2;
  }
  if (i2 < i1 && 0.5 <= count4 && count4 < 2)
    return tickSpec(start2, stop, count4 * 2);
  return [i1, i2, inc2];
}
function ticks(start2, stop, count4) {
  stop = +stop, start2 = +start2, count4 = +count4;
  if (!(count4 > 0))
    return [];
  if (start2 === stop)
    return [start2];
  const reverse3 = stop < start2, [i1, i2, inc2] = reverse3 ? tickSpec(stop, start2, count4) : tickSpec(start2, stop, count4);
  if (!(i2 >= i1))
    return [];
  const n = i2 - i1 + 1, ticks2 = new Array(n);
  if (reverse3) {
    if (inc2 < 0)
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i2 - i) / -inc2;
    else
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i2 - i) * inc2;
  } else {
    if (inc2 < 0)
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i1 + i) / -inc2;
    else
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i1 + i) * inc2;
  }
  return ticks2;
}
function tickIncrement(start2, stop, count4) {
  stop = +stop, start2 = +start2, count4 = +count4;
  return tickSpec(start2, stop, count4)[2];
}
function tickStep(start2, stop, count4) {
  stop = +stop, start2 = +start2, count4 = +count4;
  const reverse3 = stop < start2, inc2 = reverse3 ? tickIncrement(stop, start2, count4) : tickIncrement(start2, stop, count4);
  return (reverse3 ? -1 : 1) * (inc2 < 0 ? 1 / -inc2 : inc2);
}

// ../../node_modules/d3-array/src/nice.js
function nice(start2, stop, count4) {
  let prestep;
  while (true) {
    const step = tickIncrement(start2, stop, count4);
    if (step === prestep || step === 0 || !isFinite(step)) {
      return [start2, stop];
    } else if (step > 0) {
      start2 = Math.floor(start2 / step) * step;
      stop = Math.ceil(stop / step) * step;
    } else if (step < 0) {
      start2 = Math.ceil(start2 * step) / step;
      stop = Math.floor(stop * step) / step;
    }
    prestep = step;
  }
}

// ../../node_modules/d3-array/src/threshold/sturges.js
function thresholdSturges(values2) {
  return Math.max(1, Math.ceil(Math.log(count2(values2)) / Math.LN2) + 1);
}

// ../../node_modules/d3-array/src/max.js
function max2(values2, valueof2) {
  let max4;
  if (valueof2 === void 0) {
    for (const value of values2) {
      if (value != null && (max4 < value || max4 === void 0 && value >= value)) {
        max4 = value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values2) {
      if ((value = valueof2(value, ++index2, values2)) != null && (max4 < value || max4 === void 0 && value >= value)) {
        max4 = value;
      }
    }
  }
  return max4;
}

// ../../node_modules/d3-array/src/maxIndex.js
function maxIndex(values2, valueof2) {
  let max4;
  let maxIndex2 = -1;
  let index2 = -1;
  if (valueof2 === void 0) {
    for (const value of values2) {
      ++index2;
      if (value != null && (max4 < value || max4 === void 0 && value >= value)) {
        max4 = value, maxIndex2 = index2;
      }
    }
  } else {
    for (let value of values2) {
      if ((value = valueof2(value, ++index2, values2)) != null && (max4 < value || max4 === void 0 && value >= value)) {
        max4 = value, maxIndex2 = index2;
      }
    }
  }
  return maxIndex2;
}

// ../../node_modules/d3-array/src/min.js
function min2(values2, valueof2) {
  let min5;
  if (valueof2 === void 0) {
    for (const value of values2) {
      if (value != null && (min5 > value || min5 === void 0 && value >= value)) {
        min5 = value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values2) {
      if ((value = valueof2(value, ++index2, values2)) != null && (min5 > value || min5 === void 0 && value >= value)) {
        min5 = value;
      }
    }
  }
  return min5;
}

// ../../node_modules/d3-array/src/minIndex.js
function minIndex(values2, valueof2) {
  let min5;
  let minIndex2 = -1;
  let index2 = -1;
  if (valueof2 === void 0) {
    for (const value of values2) {
      ++index2;
      if (value != null && (min5 > value || min5 === void 0 && value >= value)) {
        min5 = value, minIndex2 = index2;
      }
    }
  } else {
    for (let value of values2) {
      if ((value = valueof2(value, ++index2, values2)) != null && (min5 > value || min5 === void 0 && value >= value)) {
        min5 = value, minIndex2 = index2;
      }
    }
  }
  return minIndex2;
}

// ../../node_modules/d3-array/src/quickselect.js
function quickselect(array4, k3, left2 = 0, right2 = Infinity, compare) {
  k3 = Math.floor(k3);
  left2 = Math.floor(Math.max(0, left2));
  right2 = Math.floor(Math.min(array4.length - 1, right2));
  if (!(left2 <= k3 && k3 <= right2))
    return array4;
  compare = compare === void 0 ? ascendingDefined : compareDefined(compare);
  while (right2 > left2) {
    if (right2 - left2 > 600) {
      const n = right2 - left2 + 1;
      const m2 = k3 - left2 + 1;
      const z2 = Math.log(n);
      const s2 = 0.5 * Math.exp(2 * z2 / 3);
      const sd = 0.5 * Math.sqrt(z2 * s2 * (n - s2) / n) * (m2 - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left2, Math.floor(k3 - m2 * s2 / n + sd));
      const newRight = Math.min(right2, Math.floor(k3 + (n - m2) * s2 / n + sd));
      quickselect(array4, k3, newLeft, newRight, compare);
    }
    const t = array4[k3];
    let i = left2;
    let j2 = right2;
    swap(array4, left2, k3);
    if (compare(array4[right2], t) > 0)
      swap(array4, left2, right2);
    while (i < j2) {
      swap(array4, i, j2), ++i, --j2;
      while (compare(array4[i], t) < 0)
        ++i;
      while (compare(array4[j2], t) > 0)
        --j2;
    }
    if (compare(array4[left2], t) === 0)
      swap(array4, left2, j2);
    else
      ++j2, swap(array4, j2, right2);
    if (j2 <= k3)
      left2 = j2 + 1;
    if (k3 <= j2)
      right2 = j2 - 1;
  }
  return array4;
}
function swap(array4, i, j2) {
  const t = array4[i];
  array4[i] = array4[j2];
  array4[j2] = t;
}

// ../../node_modules/d3-array/src/greatest.js
function greatest(values2, compare = ascending) {
  let max4;
  let defined2 = false;
  if (compare.length === 1) {
    let maxValue;
    for (const element of values2) {
      const value = compare(element);
      if (defined2 ? ascending(value, maxValue) > 0 : ascending(value, value) === 0) {
        max4 = element;
        maxValue = value;
        defined2 = true;
      }
    }
  } else {
    for (const value of values2) {
      if (defined2 ? compare(value, max4) > 0 : compare(value, value) === 0) {
        max4 = value;
        defined2 = true;
      }
    }
  }
  return max4;
}

// ../../node_modules/d3-array/src/quantile.js
function quantile2(values2, p2, valueof2) {
  values2 = Float64Array.from(numbers(values2, valueof2));
  if (!(n = values2.length) || isNaN(p2 = +p2))
    return;
  if (p2 <= 0 || n < 2)
    return min2(values2);
  if (p2 >= 1)
    return max2(values2);
  var n, i = (n - 1) * p2, i0 = Math.floor(i), value0 = max2(quickselect(values2, i0).subarray(0, i0 + 1)), value1 = min2(values2.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i - i0);
}
function quantileSorted(values2, p2, valueof2 = number) {
  if (!(n = values2.length) || isNaN(p2 = +p2))
    return;
  if (p2 <= 0 || n < 2)
    return +valueof2(values2[0], 0, values2);
  if (p2 >= 1)
    return +valueof2(values2[n - 1], n - 1, values2);
  var n, i = (n - 1) * p2, i0 = Math.floor(i), value0 = +valueof2(values2[i0], i0, values2), value1 = +valueof2(values2[i0 + 1], i0 + 1, values2);
  return value0 + (value1 - value0) * (i - i0);
}

// ../../node_modules/d3-array/src/threshold/freedmanDiaconis.js
function thresholdFreedmanDiaconis(values2, min5, max4) {
  const c4 = count2(values2), d = quantile2(values2, 0.75) - quantile2(values2, 0.25);
  return c4 && d ? Math.ceil((max4 - min5) / (2 * d * Math.pow(c4, -1 / 3))) : 1;
}

// ../../node_modules/d3-array/src/threshold/scott.js
function thresholdScott(values2, min5, max4) {
  const c4 = count2(values2), d = deviation(values2);
  return c4 && d ? Math.ceil((max4 - min5) * Math.cbrt(c4) / (3.49 * d)) : 1;
}

// ../../node_modules/d3-array/src/mean.js
function mean2(values2, valueof2) {
  let count4 = 0;
  let sum5 = 0;
  if (valueof2 === void 0) {
    for (let value of values2) {
      if (value != null && (value = +value) >= value) {
        ++count4, sum5 += value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values2) {
      if ((value = valueof2(value, ++index2, values2)) != null && (value = +value) >= value) {
        ++count4, sum5 += value;
      }
    }
  }
  if (count4)
    return sum5 / count4;
}

// ../../node_modules/d3-array/src/median.js
function median2(values2, valueof2) {
  return quantile2(values2, 0.5, valueof2);
}

// ../../node_modules/d3-array/src/merge.js
function* flatten(arrays) {
  for (const array4 of arrays) {
    yield* array4;
  }
}
function merge(arrays) {
  return Array.from(flatten(arrays));
}

// ../../node_modules/d3-array/src/mode.js
function mode2(values2, valueof2) {
  const counts = new InternMap();
  if (valueof2 === void 0) {
    for (let value of values2) {
      if (value != null && value >= value) {
        counts.set(value, (counts.get(value) || 0) + 1);
      }
    }
  } else {
    let index2 = -1;
    for (let value of values2) {
      if ((value = valueof2(value, ++index2, values2)) != null && value >= value) {
        counts.set(value, (counts.get(value) || 0) + 1);
      }
    }
  }
  let modeValue;
  let modeCount = 0;
  for (const [value, count4] of counts) {
    if (count4 > modeCount) {
      modeCount = count4;
      modeValue = value;
    }
  }
  return modeValue;
}

// ../../node_modules/d3-array/src/pairs.js
function pairs(values2, pairof = pair) {
  const pairs2 = [];
  let previous;
  let first3 = false;
  for (const value of values2) {
    if (first3)
      pairs2.push(pairof(previous, value));
    previous = value;
    first3 = true;
  }
  return pairs2;
}
function pair(a3, b2) {
  return [a3, b2];
}

// ../../node_modules/d3-array/src/range.js
function range(start2, stop, step) {
  start2 = +start2, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start2, start2 = 0, 1) : n < 3 ? 1 : +step;
  var i = -1, n = Math.max(0, Math.ceil((stop - start2) / step)) | 0, range3 = new Array(n);
  while (++i < n) {
    range3[i] = start2 + i * step;
  }
  return range3;
}

// ../../node_modules/d3-array/src/rank.js
function rank2(values2, valueof2 = ascending) {
  if (typeof values2[Symbol.iterator] !== "function")
    throw new TypeError("values is not iterable");
  let V2 = Array.from(values2);
  const R2 = new Float64Array(V2.length);
  if (valueof2.length !== 2)
    V2 = V2.map(valueof2), valueof2 = ascending;
  const compareIndex = (i, j2) => valueof2(V2[i], V2[j2]);
  let k3, r;
  values2 = Uint32Array.from(V2, (_2, i) => i);
  values2.sort(valueof2 === ascending ? (i, j2) => ascendingDefined(V2[i], V2[j2]) : compareDefined(compareIndex));
  values2.forEach((j2, i) => {
    const c4 = compareIndex(j2, k3 === void 0 ? j2 : k3);
    if (c4 >= 0) {
      if (k3 === void 0 || c4 > 0)
        k3 = j2, r = i;
      R2[j2] = r;
    } else {
      R2[j2] = NaN;
    }
  });
  return R2;
}

// ../../node_modules/d3-array/src/least.js
function least(values2, compare = ascending) {
  let min5;
  let defined2 = false;
  if (compare.length === 1) {
    let minValue;
    for (const element of values2) {
      const value = compare(element);
      if (defined2 ? ascending(value, minValue) < 0 : ascending(value, value) === 0) {
        min5 = element;
        minValue = value;
        defined2 = true;
      }
    }
  } else {
    for (const value of values2) {
      if (defined2 ? compare(value, min5) < 0 : compare(value, value) === 0) {
        min5 = value;
        defined2 = true;
      }
    }
  }
  return min5;
}

// ../../node_modules/d3-array/src/sum.js
function sum3(values2, valueof2) {
  let sum5 = 0;
  if (valueof2 === void 0) {
    for (let value of values2) {
      if (value = +value) {
        sum5 += value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values2) {
      if (value = +valueof2(value, ++index2, values2)) {
        sum5 += value;
      }
    }
  }
  return sum5;
}

// ../../node_modules/d3-array/src/reverse.js
function reverse(values2) {
  if (typeof values2[Symbol.iterator] !== "function")
    throw new TypeError("values is not iterable");
  return Array.from(values2).reverse();
}

// ../../node_modules/d3-axis/src/identity.js
function identity_default(x4) {
  return x4;
}

// ../../node_modules/d3-axis/src/axis.js
var top = 1;
var right = 2;
var bottom = 3;
var left = 4;
var epsilon = 1e-6;
function translateX(x4) {
  return "translate(" + x4 + ",0)";
}
function translateY(y4) {
  return "translate(0," + y4 + ")";
}
function number2(scale3) {
  return (d) => +scale3(d);
}
function center(scale3, offset2) {
  offset2 = Math.max(0, scale3.bandwidth() - offset2 * 2) / 2;
  if (scale3.round())
    offset2 = Math.round(offset2);
  return (d) => +scale3(d) + offset2;
}
function entering() {
  return !this.__axis;
}
function axis(orient, scale3) {
  var tickArguments = [], tickValues = null, tickFormat2 = null, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, offset2 = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5, k3 = orient === top || orient === left ? -1 : 1, x4 = orient === left || orient === right ? "x" : "y", transform3 = orient === top || orient === bottom ? translateX : translateY;
  function axis3(context) {
    var values2 = tickValues == null ? scale3.ticks ? scale3.ticks.apply(scale3, tickArguments) : scale3.domain() : tickValues, format3 = tickFormat2 == null ? scale3.tickFormat ? scale3.tickFormat.apply(scale3, tickArguments) : identity_default : tickFormat2, spacing = Math.max(tickSizeInner, 0) + tickPadding, range3 = scale3.range(), range0 = +range3[0] + offset2, range1 = +range3[range3.length - 1] + offset2, position3 = (scale3.bandwidth ? center : number2)(scale3.copy(), offset2), selection2 = context.selection ? context.selection() : context, path2 = selection2.selectAll(".domain").data([null]), tick = selection2.selectAll(".tick").data(values2, scale3).order(), tickExit = tick.exit(), tickEnter = tick.enter().append("g").attr("class", "tick"), line3 = tick.select("line"), text3 = tick.select("text");
    path2 = path2.merge(path2.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor"));
    tick = tick.merge(tickEnter);
    line3 = line3.merge(tickEnter.append("line").attr("stroke", "currentColor").attr(x4 + "2", k3 * tickSizeInner));
    text3 = text3.merge(tickEnter.append("text").attr("fill", "currentColor").attr(x4, k3 * spacing).attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));
    if (context !== selection2) {
      path2 = path2.transition(context);
      tick = tick.transition(context);
      line3 = line3.transition(context);
      text3 = text3.transition(context);
      tickExit = tickExit.transition(context).attr("opacity", epsilon).attr("transform", function(d) {
        return isFinite(d = position3(d)) ? transform3(d + offset2) : this.getAttribute("transform");
      });
      tickEnter.attr("opacity", epsilon).attr("transform", function(d) {
        var p2 = this.parentNode.__axis;
        return transform3((p2 && isFinite(p2 = p2(d)) ? p2 : position3(d)) + offset2);
      });
    }
    tickExit.remove();
    path2.attr("d", orient === left || orient === right ? tickSizeOuter ? "M" + k3 * tickSizeOuter + "," + range0 + "H" + offset2 + "V" + range1 + "H" + k3 * tickSizeOuter : "M" + offset2 + "," + range0 + "V" + range1 : tickSizeOuter ? "M" + range0 + "," + k3 * tickSizeOuter + "V" + offset2 + "H" + range1 + "V" + k3 * tickSizeOuter : "M" + range0 + "," + offset2 + "H" + range1);
    tick.attr("opacity", 1).attr("transform", function(d) {
      return transform3(position3(d) + offset2);
    });
    line3.attr(x4 + "2", k3 * tickSizeInner);
    text3.attr(x4, k3 * spacing).text(format3);
    selection2.filter(entering).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");
    selection2.each(function() {
      this.__axis = position3;
    });
  }
  axis3.scale = function(_2) {
    return arguments.length ? (scale3 = _2, axis3) : scale3;
  };
  axis3.ticks = function() {
    return tickArguments = Array.from(arguments), axis3;
  };
  axis3.tickArguments = function(_2) {
    return arguments.length ? (tickArguments = _2 == null ? [] : Array.from(_2), axis3) : tickArguments.slice();
  };
  axis3.tickValues = function(_2) {
    return arguments.length ? (tickValues = _2 == null ? null : Array.from(_2), axis3) : tickValues && tickValues.slice();
  };
  axis3.tickFormat = function(_2) {
    return arguments.length ? (tickFormat2 = _2, axis3) : tickFormat2;
  };
  axis3.tickSize = function(_2) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_2, axis3) : tickSizeInner;
  };
  axis3.tickSizeInner = function(_2) {
    return arguments.length ? (tickSizeInner = +_2, axis3) : tickSizeInner;
  };
  axis3.tickSizeOuter = function(_2) {
    return arguments.length ? (tickSizeOuter = +_2, axis3) : tickSizeOuter;
  };
  axis3.tickPadding = function(_2) {
    return arguments.length ? (tickPadding = +_2, axis3) : tickPadding;
  };
  axis3.offset = function(_2) {
    return arguments.length ? (offset2 = +_2, axis3) : offset2;
  };
  return axis3;
}
function axisBottom(scale3) {
  return axis(bottom, scale3);
}

// ../../node_modules/d3-dispatch/src/dispatch.js
var noop = { value: () => {
} };
function dispatch() {
  for (var i = 0, n = arguments.length, _2 = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _2 || /[\s.]/.test(t))
      throw new Error("illegal type: " + t);
    _2[t] = [];
  }
  return new Dispatch(_2);
}
function Dispatch(_2) {
  this._ = _2;
}
function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name2 = "", i = t.indexOf(".");
    if (i >= 0)
      name2 = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t))
      throw new Error("unknown type: " + t);
    return { type: t, name: name2 };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _2 = this._, T = parseTypenames(typename + "", _2), t, i = -1, n = T.length;
    if (arguments.length < 2) {
      while (++i < n)
        if ((t = (typename = T[i]).type) && (t = get(_2[t], typename.name)))
          return t;
      return;
    }
    if (callback != null && typeof callback !== "function")
      throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type)
        _2[t] = set(_2[t], typename.name, callback);
      else if (callback == null)
        for (t in _2)
          _2[t] = set(_2[t], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy4 = {}, _2 = this._;
    for (var t in _2)
      copy4[t] = _2[t].slice();
    return new Dispatch(copy4);
  },
  call: function(type2, that) {
    if ((n = arguments.length - 2) > 0)
      for (var args = new Array(n), i = 0, n, t; i < n; ++i)
        args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type2))
      throw new Error("unknown type: " + type2);
    for (t = this._[type2], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  },
  apply: function(type2, that, args) {
    if (!this._.hasOwnProperty(type2))
      throw new Error("unknown type: " + type2);
    for (var t = this._[type2], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  }
};
function get(type2, name2) {
  for (var i = 0, n = type2.length, c4; i < n; ++i) {
    if ((c4 = type2[i]).name === name2) {
      return c4.value;
    }
  }
}
function set(type2, name2, callback) {
  for (var i = 0, n = type2.length; i < n; ++i) {
    if (type2[i].name === name2) {
      type2[i] = noop, type2 = type2.slice(0, i).concat(type2.slice(i + 1));
      break;
    }
  }
  if (callback != null)
    type2.push({ name: name2, value: callback });
  return type2;
}
var dispatch_default = dispatch;

// ../../node_modules/d3-selection/src/namespaces.js
var xhtml = "http://www.w3.org/1999/xhtml";
var namespaces_default = {
  svg: "http://www.w3.org/2000/svg",
  xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

// ../../node_modules/d3-selection/src/namespace.js
function namespace_default(name2) {
  var prefix2 = name2 += "", i = prefix2.indexOf(":");
  if (i >= 0 && (prefix2 = name2.slice(0, i)) !== "xmlns")
    name2 = name2.slice(i + 1);
  return namespaces_default.hasOwnProperty(prefix2) ? { space: namespaces_default[prefix2], local: name2 } : name2;
}

// ../../node_modules/d3-selection/src/creator.js
function creatorInherit(name2) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name2) : document2.createElementNS(uri, name2);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator_default(name2) {
  var fullname = namespace_default(name2);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}

// ../../node_modules/d3-selection/src/selector.js
function none() {
}
function selector_default(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}

// ../../node_modules/d3-selection/src/selection/select.js
function select_default(select2) {
  if (typeof select2 !== "function")
    select2 = selector_default(select2);
  for (var groups2 = this._groups, m2 = groups2.length, subgroups = new Array(m2), j2 = 0; j2 < m2; ++j2) {
    for (var group3 = groups2[j2], n = group3.length, subgroup = subgroups[j2] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group3[i]) && (subnode = select2.call(node, node.__data__, i, group3))) {
        if ("__data__" in node)
          subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }
  return new Selection2(subgroups, this._parents);
}

// ../../node_modules/d3-selection/src/array.js
function array(x4) {
  return x4 == null ? [] : Array.isArray(x4) ? x4 : Array.from(x4);
}

// ../../node_modules/d3-selection/src/selectorAll.js
function empty2() {
  return [];
}
function selectorAll_default(selector) {
  return selector == null ? empty2 : function() {
    return this.querySelectorAll(selector);
  };
}

// ../../node_modules/d3-selection/src/selection/selectAll.js
function arrayAll(select2) {
  return function() {
    return array(select2.apply(this, arguments));
  };
}
function selectAll_default(select2) {
  if (typeof select2 === "function")
    select2 = arrayAll(select2);
  else
    select2 = selectorAll_default(select2);
  for (var groups2 = this._groups, m2 = groups2.length, subgroups = [], parents = [], j2 = 0; j2 < m2; ++j2) {
    for (var group3 = groups2[j2], n = group3.length, node, i = 0; i < n; ++i) {
      if (node = group3[i]) {
        subgroups.push(select2.call(node, node.__data__, i, group3));
        parents.push(node);
      }
    }
  }
  return new Selection2(subgroups, parents);
}

// ../../node_modules/d3-selection/src/matcher.js
function matcher_default(selector) {
  return function() {
    return this.matches(selector);
  };
}
function childMatcher(selector) {
  return function(node) {
    return node.matches(selector);
  };
}

// ../../node_modules/d3-selection/src/selection/selectChild.js
var find = Array.prototype.find;
function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function selectChild_default(match) {
  return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));
}

// ../../node_modules/d3-selection/src/selection/selectChildren.js
var filter = Array.prototype.filter;
function children() {
  return Array.from(this.children);
}
function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}
function selectChildren_default(match) {
  return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
}

// ../../node_modules/d3-selection/src/selection/filter.js
function filter_default(match) {
  if (typeof match !== "function")
    match = matcher_default(match);
  for (var groups2 = this._groups, m2 = groups2.length, subgroups = new Array(m2), j2 = 0; j2 < m2; ++j2) {
    for (var group3 = groups2[j2], n = group3.length, subgroup = subgroups[j2] = [], node, i = 0; i < n; ++i) {
      if ((node = group3[i]) && match.call(node, node.__data__, i, group3)) {
        subgroup.push(node);
      }
    }
  }
  return new Selection2(subgroups, this._parents);
}

// ../../node_modules/d3-selection/src/selection/sparse.js
function sparse_default(update2) {
  return new Array(update2.length);
}

// ../../node_modules/d3-selection/src/selection/enter.js
function enter_default() {
  return new Selection2(this._enter || this._groups.map(sparse_default), this._parents);
}
function EnterNode(parent, datum2) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum2;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function(selector) {
    return this._parent.querySelector(selector);
  },
  querySelectorAll: function(selector) {
    return this._parent.querySelectorAll(selector);
  }
};

// ../../node_modules/d3-selection/src/constant.js
function constant_default(x4) {
  return function() {
    return x4;
  };
}

// ../../node_modules/d3-selection/src/selection/data.js
function bindIndex(parent, group3, enter, update2, exit, data) {
  var i = 0, node, groupLength = group3.length, dataLength = data.length;
  for (; i < dataLength; ++i) {
    if (node = group3[i]) {
      node.__data__ = data[i];
      update2[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (; i < groupLength; ++i) {
    if (node = group3[i]) {
      exit[i] = node;
    }
  }
}
function bindKey(parent, group3, enter, update2, exit, data, key) {
  var i, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group3.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
  for (i = 0; i < groupLength; ++i) {
    if (node = group3[i]) {
      keyValues[i] = keyValue = key.call(node, node.__data__, i, group3) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent, data[i], i, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update2[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (i = 0; i < groupLength; ++i) {
    if ((node = group3[i]) && nodeByKeyValue.get(keyValues[i]) === node) {
      exit[i] = node;
    }
  }
}
function datum(node) {
  return node.__data__;
}
function data_default(value, key) {
  if (!arguments.length)
    return Array.from(this, datum);
  var bind = key ? bindKey : bindIndex, parents = this._parents, groups2 = this._groups;
  if (typeof value !== "function")
    value = constant_default(value);
  for (var m2 = groups2.length, update2 = new Array(m2), enter = new Array(m2), exit = new Array(m2), j2 = 0; j2 < m2; ++j2) {
    var parent = parents[j2], group3 = groups2[j2], groupLength = group3.length, data = arraylike(value.call(parent, parent && parent.__data__, j2, parents)), dataLength = data.length, enterGroup = enter[j2] = new Array(dataLength), updateGroup = update2[j2] = new Array(dataLength), exitGroup = exit[j2] = new Array(groupLength);
    bind(parent, group3, enterGroup, updateGroup, exitGroup, data, key);
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1)
          i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength)
          ;
        previous._next = next || null;
      }
    }
  }
  update2 = new Selection2(update2, parents);
  update2._enter = enter;
  update2._exit = exit;
  return update2;
}
function arraylike(data) {
  return typeof data === "object" && "length" in data ? data : Array.from(data);
}

// ../../node_modules/d3-selection/src/selection/exit.js
function exit_default() {
  return new Selection2(this._exit || this._groups.map(sparse_default), this._parents);
}

// ../../node_modules/d3-selection/src/selection/join.js
function join_default(onenter, onupdate, onexit) {
  var enter = this.enter(), update2 = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter)
      enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update2 = onupdate(update2);
    if (update2)
      update2 = update2.selection();
  }
  if (onexit == null)
    exit.remove();
  else
    onexit(exit);
  return enter && update2 ? enter.merge(update2).order() : update2;
}

// ../../node_modules/d3-selection/src/selection/merge.js
function merge_default(context) {
  var selection2 = context.selection ? context.selection() : context;
  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m2 = Math.min(m0, m1), merges = new Array(m0), j2 = 0; j2 < m2; ++j2) {
    for (var group0 = groups0[j2], group1 = groups1[j2], n = group0.length, merge2 = merges[j2] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge2[i] = node;
      }
    }
  }
  for (; j2 < m0; ++j2) {
    merges[j2] = groups0[j2];
  }
  return new Selection2(merges, this._parents);
}

// ../../node_modules/d3-selection/src/selection/order.js
function order_default() {
  for (var groups2 = this._groups, j2 = -1, m2 = groups2.length; ++j2 < m2; ) {
    for (var group3 = groups2[j2], i = group3.length - 1, next = group3[i], node; --i >= 0; ) {
      if (node = group3[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4)
          next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }
  return this;
}

// ../../node_modules/d3-selection/src/selection/sort.js
function sort_default(compare) {
  if (!compare)
    compare = ascending2;
  function compareNode(a3, b2) {
    return a3 && b2 ? compare(a3.__data__, b2.__data__) : !a3 - !b2;
  }
  for (var groups2 = this._groups, m2 = groups2.length, sortgroups = new Array(m2), j2 = 0; j2 < m2; ++j2) {
    for (var group3 = groups2[j2], n = group3.length, sortgroup = sortgroups[j2] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group3[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection2(sortgroups, this._parents).order();
}
function ascending2(a3, b2) {
  return a3 < b2 ? -1 : a3 > b2 ? 1 : a3 >= b2 ? 0 : NaN;
}

// ../../node_modules/d3-selection/src/selection/call.js
function call_default() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

// ../../node_modules/d3-selection/src/selection/nodes.js
function nodes_default() {
  return Array.from(this);
}

// ../../node_modules/d3-selection/src/selection/node.js
function node_default() {
  for (var groups2 = this._groups, j2 = 0, m2 = groups2.length; j2 < m2; ++j2) {
    for (var group3 = groups2[j2], i = 0, n = group3.length; i < n; ++i) {
      var node = group3[i];
      if (node)
        return node;
    }
  }
  return null;
}

// ../../node_modules/d3-selection/src/selection/size.js
function size_default() {
  let size = 0;
  for (const node of this)
    ++size;
  return size;
}

// ../../node_modules/d3-selection/src/selection/empty.js
function empty_default() {
  return !this.node();
}

// ../../node_modules/d3-selection/src/selection/each.js
function each_default(callback) {
  for (var groups2 = this._groups, j2 = 0, m2 = groups2.length; j2 < m2; ++j2) {
    for (var group3 = groups2[j2], i = 0, n = group3.length, node; i < n; ++i) {
      if (node = group3[i])
        callback.call(node, node.__data__, i, group3);
    }
  }
  return this;
}

// ../../node_modules/d3-selection/src/selection/attr.js
function attrRemove(name2) {
  return function() {
    this.removeAttribute(name2);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name2, value) {
  return function() {
    this.setAttribute(name2, value);
  };
}
function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}
function attrFunction(name2, value) {
  return function() {
    var v3 = value.apply(this, arguments);
    if (v3 == null)
      this.removeAttribute(name2);
    else
      this.setAttribute(name2, v3);
  };
}
function attrFunctionNS(fullname, value) {
  return function() {
    var v3 = value.apply(this, arguments);
    if (v3 == null)
      this.removeAttributeNS(fullname.space, fullname.local);
    else
      this.setAttributeNS(fullname.space, fullname.local, v3);
  };
}
function attr_default(name2, value) {
  var fullname = namespace_default(name2);
  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }
  return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
}

// ../../node_modules/d3-selection/src/window.js
function window_default(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
}

// ../../node_modules/d3-selection/src/selection/style.js
function styleRemove(name2) {
  return function() {
    this.style.removeProperty(name2);
  };
}
function styleConstant(name2, value, priority) {
  return function() {
    this.style.setProperty(name2, value, priority);
  };
}
function styleFunction(name2, value, priority) {
  return function() {
    var v3 = value.apply(this, arguments);
    if (v3 == null)
      this.style.removeProperty(name2);
    else
      this.style.setProperty(name2, v3, priority);
  };
}
function style_default(name2, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name2, value, priority == null ? "" : priority)) : styleValue(this.node(), name2);
}
function styleValue(node, name2) {
  return node.style.getPropertyValue(name2) || window_default(node).getComputedStyle(node, null).getPropertyValue(name2);
}

// ../../node_modules/d3-selection/src/selection/property.js
function propertyRemove(name2) {
  return function() {
    delete this[name2];
  };
}
function propertyConstant(name2, value) {
  return function() {
    this[name2] = value;
  };
}
function propertyFunction(name2, value) {
  return function() {
    var v3 = value.apply(this, arguments);
    if (v3 == null)
      delete this[name2];
    else
      this[name2] = v3;
  };
}
function property_default(name2, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name2, value)) : this.node()[name2];
}

// ../../node_modules/d3-selection/src/selection/classed.js
function classArray(string2) {
  return string2.trim().split(/^|\s+/);
}
function classList(node) {
  return node.classList || new ClassList(node);
}
function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function(name2) {
    var i = this._names.indexOf(name2);
    if (i < 0) {
      this._names.push(name2);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name2) {
    var i = this._names.indexOf(name2);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name2) {
    return this._names.indexOf(name2) >= 0;
  }
};
function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n)
    list.add(names[i]);
}
function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n)
    list.remove(names[i]);
}
function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}
function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function classed_default(name2, value) {
  var names = classArray(name2 + "");
  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n)
      if (!list.contains(names[i]))
        return false;
    return true;
  }
  return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
}

// ../../node_modules/d3-selection/src/selection/text.js
function textRemove() {
  this.textContent = "";
}
function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction(value) {
  return function() {
    var v3 = value.apply(this, arguments);
    this.textContent = v3 == null ? "" : v3;
  };
}
function text_default(value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
}

// ../../node_modules/d3-selection/src/selection/html.js
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}
function htmlFunction(value) {
  return function() {
    var v3 = value.apply(this, arguments);
    this.innerHTML = v3 == null ? "" : v3;
  };
}
function html_default(value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
}

// ../../node_modules/d3-selection/src/selection/raise.js
function raise() {
  if (this.nextSibling)
    this.parentNode.appendChild(this);
}
function raise_default() {
  return this.each(raise);
}

// ../../node_modules/d3-selection/src/selection/lower.js
function lower2() {
  if (this.previousSibling)
    this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function lower_default() {
  return this.each(lower2);
}

// ../../node_modules/d3-selection/src/selection/append.js
function append_default(name2) {
  var create4 = typeof name2 === "function" ? name2 : creator_default(name2);
  return this.select(function() {
    return this.appendChild(create4.apply(this, arguments));
  });
}

// ../../node_modules/d3-selection/src/selection/insert.js
function constantNull() {
  return null;
}
function insert_default(name2, before) {
  var create4 = typeof name2 === "function" ? name2 : creator_default(name2), select2 = before == null ? constantNull : typeof before === "function" ? before : selector_default(before);
  return this.select(function() {
    return this.insertBefore(create4.apply(this, arguments), select2.apply(this, arguments) || null);
  });
}

// ../../node_modules/d3-selection/src/selection/remove.js
function remove() {
  var parent = this.parentNode;
  if (parent)
    parent.removeChild(this);
}
function remove_default() {
  return this.each(remove);
}

// ../../node_modules/d3-selection/src/selection/clone.js
function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function clone_default(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

// ../../node_modules/d3-selection/src/selection/datum.js
function datum_default(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}

// ../../node_modules/d3-selection/src/selection/on.js
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}
function parseTypenames2(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name2 = "", i = t.indexOf(".");
    if (i >= 0)
      name2 = t.slice(i + 1), t = t.slice(0, i);
    return { type: t, name: name2 };
  });
}
function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on)
      return;
    for (var j2 = 0, i = -1, m2 = on.length, o; j2 < m2; ++j2) {
      if (o = on[j2], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i] = o;
      }
    }
    if (++i)
      on.length = i;
    else
      delete this.__on;
  };
}
function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o, listener = contextListener(value);
    if (on)
      for (var j2 = 0, m2 = on.length; j2 < m2; ++j2) {
        if ((o = on[j2]).type === typename.type && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.options);
          this.addEventListener(o.type, o.listener = listener, o.options = options);
          o.value = value;
          return;
        }
      }
    this.addEventListener(typename.type, listener, options);
    o = { type: typename.type, name: typename.name, value, listener, options };
    if (!on)
      this.__on = [o];
    else
      on.push(o);
  };
}
function on_default(typename, value, options) {
  var typenames = parseTypenames2(typename + ""), i, n = typenames.length, t;
  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on)
      for (var j2 = 0, m2 = on.length, o; j2 < m2; ++j2) {
        for (i = 0, o = on[j2]; i < n; ++i) {
          if ((t = typenames[i]).type === o.type && t.name === o.name) {
            return o.value;
          }
        }
      }
    return;
  }
  on = value ? onAdd : onRemove;
  for (i = 0; i < n; ++i)
    this.each(on(typenames[i], value, options));
  return this;
}

// ../../node_modules/d3-selection/src/selection/dispatch.js
function dispatchEvent(node, type2, params) {
  var window3 = window_default(node), event = window3.CustomEvent;
  if (typeof event === "function") {
    event = new event(type2, params);
  } else {
    event = window3.document.createEvent("Event");
    if (params)
      event.initEvent(type2, params.bubbles, params.cancelable), event.detail = params.detail;
    else
      event.initEvent(type2, false, false);
  }
  node.dispatchEvent(event);
}
function dispatchConstant(type2, params) {
  return function() {
    return dispatchEvent(this, type2, params);
  };
}
function dispatchFunction(type2, params) {
  return function() {
    return dispatchEvent(this, type2, params.apply(this, arguments));
  };
}
function dispatch_default2(type2, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type2, params));
}

// ../../node_modules/d3-selection/src/selection/iterator.js
function* iterator_default() {
  for (var groups2 = this._groups, j2 = 0, m2 = groups2.length; j2 < m2; ++j2) {
    for (var group3 = groups2[j2], i = 0, n = group3.length, node; i < n; ++i) {
      if (node = group3[i])
        yield node;
    }
  }
}

// ../../node_modules/d3-selection/src/selection/index.js
var root = [null];
function Selection2(groups2, parents) {
  this._groups = groups2;
  this._parents = parents;
}
function selection() {
  return new Selection2([[document.documentElement]], root);
}
function selection_selection() {
  return this;
}
Selection2.prototype = selection.prototype = {
  constructor: Selection2,
  select: select_default,
  selectAll: selectAll_default,
  selectChild: selectChild_default,
  selectChildren: selectChildren_default,
  filter: filter_default,
  data: data_default,
  enter: enter_default,
  exit: exit_default,
  join: join_default,
  merge: merge_default,
  selection: selection_selection,
  order: order_default,
  sort: sort_default,
  call: call_default,
  nodes: nodes_default,
  node: node_default,
  size: size_default,
  empty: empty_default,
  each: each_default,
  attr: attr_default,
  style: style_default,
  property: property_default,
  classed: classed_default,
  text: text_default,
  html: html_default,
  raise: raise_default,
  lower: lower_default,
  append: append_default,
  insert: insert_default,
  remove: remove_default,
  clone: clone_default,
  datum: datum_default,
  on: on_default,
  dispatch: dispatch_default2,
  [Symbol.iterator]: iterator_default
};
var selection_default = selection;

// ../../node_modules/d3-selection/src/select.js
function select_default2(selector) {
  return typeof selector === "string" ? new Selection2([[document.querySelector(selector)]], [document.documentElement]) : new Selection2([[selector]], root);
}

// ../../node_modules/d3-selection/src/sourceEvent.js
function sourceEvent_default(event) {
  let sourceEvent;
  while (sourceEvent = event.sourceEvent)
    event = sourceEvent;
  return event;
}

// ../../node_modules/d3-selection/src/pointer.js
function pointer_default(event, node) {
  event = sourceEvent_default(event);
  if (node === void 0)
    node = event.currentTarget;
  if (node) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
      var point6 = svg.createSVGPoint();
      point6.x = event.clientX, point6.y = event.clientY;
      point6 = point6.matrixTransform(node.getScreenCTM().inverse());
      return [point6.x, point6.y];
    }
    if (node.getBoundingClientRect) {
      var rect3 = node.getBoundingClientRect();
      return [event.clientX - rect3.left - node.clientLeft, event.clientY - rect3.top - node.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}

// ../../node_modules/d3-drag/src/noevent.js
var nonpassivecapture = { capture: true, passive: false };
function noevent_default(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}

// ../../node_modules/d3-drag/src/nodrag.js
function nodrag_default(view) {
  var root2 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", noevent_default, nonpassivecapture);
  if ("onselectstart" in root2) {
    selection2.on("selectstart.drag", noevent_default, nonpassivecapture);
  } else {
    root2.__noselect = root2.style.MozUserSelect;
    root2.style.MozUserSelect = "none";
  }
}
function yesdrag(view, noclick) {
  var root2 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", null);
  if (noclick) {
    selection2.on("click.drag", noevent_default, nonpassivecapture);
    setTimeout(function() {
      selection2.on("click.drag", null);
    }, 0);
  }
  if ("onselectstart" in root2) {
    selection2.on("selectstart.drag", null);
  } else {
    root2.style.MozUserSelect = root2.__noselect;
    delete root2.__noselect;
  }
}

// ../../node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition)
    prototype[key] = definition[key];
  return prototype;
}

// ../../node_modules/d3-color/src/color.js
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format3) {
  var m2, l;
  format3 = (format3 + "").trim().toLowerCase();
  return (m2 = reHex.exec(format3)) ? (l = m2[1].length, m2 = parseInt(m2[1], 16), l === 6 ? rgbn(m2) : l === 3 ? new Rgb(m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, (m2 & 15) << 4 | m2 & 15, 1) : l === 8 ? rgba(m2 >> 24 & 255, m2 >> 16 & 255, m2 >> 8 & 255, (m2 & 255) / 255) : l === 4 ? rgba(m2 >> 12 & 15 | m2 >> 8 & 240, m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, ((m2 & 15) << 4 | m2 & 15) / 255) : null) : (m2 = reRgbInteger.exec(format3)) ? new Rgb(m2[1], m2[2], m2[3], 1) : (m2 = reRgbPercent.exec(format3)) ? new Rgb(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, 1) : (m2 = reRgbaInteger.exec(format3)) ? rgba(m2[1], m2[2], m2[3], m2[4]) : (m2 = reRgbaPercent.exec(format3)) ? rgba(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, m2[4]) : (m2 = reHslPercent.exec(format3)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, 1) : (m2 = reHslaPercent.exec(format3)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, m2[4]) : named.hasOwnProperty(format3) ? rgbn(named[format3]) : format3 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g2, b2, a3) {
  if (a3 <= 0)
    r = g2 = b2 = NaN;
  return new Rgb(r, g2, b2, a3);
}
function rgbConvert(o) {
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g2, b2, opacity2) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g2, b2, opacity2 == null ? 1 : opacity2);
}
function Rgb(r, g2, b2, opacity2) {
  this.r = +r;
  this.g = +g2;
  this.b = +b2;
  this.opacity = +opacity2;
}
define_default(Rgb, rgb, extend(Color, {
  brighter(k3) {
    k3 = k3 == null ? brighter : Math.pow(brighter, k3);
    return new Rgb(this.r * k3, this.g * k3, this.b * k3, this.opacity);
  },
  darker(k3) {
    k3 = k3 == null ? darker : Math.pow(darker, k3);
    return new Rgb(this.r * k3, this.g * k3, this.b * k3, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a3 = clampa(this.opacity);
  return `${a3 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a3 === 1 ? ")" : `, ${a3})`}`;
}
function clampa(opacity2) {
  return isNaN(opacity2) ? 1 : Math.max(0, Math.min(1, opacity2));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h2, s2, l, a3) {
  if (a3 <= 0)
    h2 = s2 = l = NaN;
  else if (l <= 0 || l >= 1)
    h2 = s2 = NaN;
  else if (s2 <= 0)
    h2 = NaN;
  return new Hsl(h2, s2, l, a3);
}
function hslConvert(o) {
  if (o instanceof Hsl)
    return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Hsl();
  if (o instanceof Hsl)
    return o;
  o = o.rgb();
  var r = o.r / 255, g2 = o.g / 255, b2 = o.b / 255, min5 = Math.min(r, g2, b2), max4 = Math.max(r, g2, b2), h2 = NaN, s2 = max4 - min5, l = (max4 + min5) / 2;
  if (s2) {
    if (r === max4)
      h2 = (g2 - b2) / s2 + (g2 < b2) * 6;
    else if (g2 === max4)
      h2 = (b2 - r) / s2 + 2;
    else
      h2 = (r - g2) / s2 + 4;
    s2 /= l < 0.5 ? max4 + min5 : 2 - max4 - min5;
    h2 *= 60;
  } else {
    s2 = l > 0 && l < 1 ? 0 : h2;
  }
  return new Hsl(h2, s2, l, o.opacity);
}
function hsl(h2, s2, l, opacity2) {
  return arguments.length === 1 ? hslConvert(h2) : new Hsl(h2, s2, l, opacity2 == null ? 1 : opacity2);
}
function Hsl(h2, s2, l, opacity2) {
  this.h = +h2;
  this.s = +s2;
  this.l = +l;
  this.opacity = +opacity2;
}
define_default(Hsl, hsl, extend(Color, {
  brighter(k3) {
    k3 = k3 == null ? brighter : Math.pow(brighter, k3);
    return new Hsl(this.h, this.s, this.l * k3, this.opacity);
  },
  darker(k3) {
    k3 = k3 == null ? darker : Math.pow(darker, k3);
    return new Hsl(this.h, this.s, this.l * k3, this.opacity);
  },
  rgb() {
    var h2 = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s2, m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m2),
      hsl2rgb(h2, m1, m2),
      hsl2rgb(h2 < 120 ? h2 + 240 : h2 - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a3 = clampa(this.opacity);
    return `${a3 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a3 === 1 ? ")" : `, ${a3})`}`;
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h2, m1, m2) {
  return (h2 < 60 ? m1 + (m2 - m1) * h2 / 60 : h2 < 180 ? m2 : h2 < 240 ? m1 + (m2 - m1) * (240 - h2) / 60 : m1) * 255;
}

// ../../node_modules/d3-color/src/math.js
var radians = Math.PI / 180;
var degrees = 180 / Math.PI;

// ../../node_modules/d3-color/src/lab.js
var K2 = 18;
var Xn = 0.96422;
var Yn = 1;
var Zn = 0.82521;
var t0 = 4 / 29;
var t1 = 6 / 29;
var t2 = 3 * t1 * t1;
var t3 = t1 * t1 * t1;
function labConvert(o) {
  if (o instanceof Lab)
    return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl)
    return hcl2lab(o);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r = rgb2lrgb(o.r), g2 = rgb2lrgb(o.g), b2 = rgb2lrgb(o.b), y4 = xyz2lab((0.2225045 * r + 0.7168786 * g2 + 0.0606169 * b2) / Yn), x4, z2;
  if (r === g2 && g2 === b2)
    x4 = z2 = y4;
  else {
    x4 = xyz2lab((0.4360747 * r + 0.3850649 * g2 + 0.1430804 * b2) / Xn);
    z2 = xyz2lab((0.0139322 * r + 0.0971045 * g2 + 0.7141733 * b2) / Zn);
  }
  return new Lab(116 * y4 - 16, 500 * (x4 - y4), 200 * (y4 - z2), o.opacity);
}
function lab(l, a3, b2, opacity2) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a3, b2, opacity2 == null ? 1 : opacity2);
}
function Lab(l, a3, b2, opacity2) {
  this.l = +l;
  this.a = +a3;
  this.b = +b2;
  this.opacity = +opacity2;
}
define_default(Lab, lab, extend(Color, {
  brighter(k3) {
    return new Lab(this.l + K2 * (k3 == null ? 1 : k3), this.a, this.b, this.opacity);
  },
  darker(k3) {
    return new Lab(this.l - K2 * (k3 == null ? 1 : k3), this.a, this.b, this.opacity);
  },
  rgb() {
    var y4 = (this.l + 16) / 116, x4 = isNaN(this.a) ? y4 : y4 + this.a / 500, z2 = isNaN(this.b) ? y4 : y4 - this.b / 200;
    x4 = Xn * lab2xyz(x4);
    y4 = Yn * lab2xyz(y4);
    z2 = Zn * lab2xyz(z2);
    return new Rgb(
      lrgb2rgb(3.1338561 * x4 - 1.6168667 * y4 - 0.4906146 * z2),
      lrgb2rgb(-0.9787684 * x4 + 1.9161415 * y4 + 0.033454 * z2),
      lrgb2rgb(0.0719453 * x4 - 0.2289914 * y4 + 1.4052427 * z2),
      this.opacity
    );
  }
}));
function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}
function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}
function lrgb2rgb(x4) {
  return 255 * (x4 <= 31308e-7 ? 12.92 * x4 : 1.055 * Math.pow(x4, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x4) {
  return (x4 /= 255) <= 0.04045 ? x4 / 12.92 : Math.pow((x4 + 0.055) / 1.055, 2.4);
}
function hclConvert(o) {
  if (o instanceof Hcl)
    return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab))
    o = labConvert(o);
  if (o.a === 0 && o.b === 0)
    return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h2 = Math.atan2(o.b, o.a) * degrees;
  return new Hcl(h2 < 0 ? h2 + 360 : h2, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}
function hcl(h2, c4, l, opacity2) {
  return arguments.length === 1 ? hclConvert(h2) : new Hcl(h2, c4, l, opacity2 == null ? 1 : opacity2);
}
function Hcl(h2, c4, l, opacity2) {
  this.h = +h2;
  this.c = +c4;
  this.l = +l;
  this.opacity = +opacity2;
}
function hcl2lab(o) {
  if (isNaN(o.h))
    return new Lab(o.l, 0, 0, o.opacity);
  var h2 = o.h * radians;
  return new Lab(o.l, Math.cos(h2) * o.c, Math.sin(h2) * o.c, o.opacity);
}
define_default(Hcl, hcl, extend(Color, {
  brighter(k3) {
    return new Hcl(this.h, this.c, this.l + K2 * (k3 == null ? 1 : k3), this.opacity);
  },
  darker(k3) {
    return new Hcl(this.h, this.c, this.l - K2 * (k3 == null ? 1 : k3), this.opacity);
  },
  rgb() {
    return hcl2lab(this).rgb();
  }
}));

// ../../node_modules/d3-color/src/cubehelix.js
var A2 = -0.14861;
var B = 1.78277;
var C2 = -0.29227;
var D2 = -0.90649;
var E2 = 1.97294;
var ED = E2 * D2;
var EB = E2 * B;
var BC_DA = B * C2 - D2 * A2;
function cubehelixConvert(o) {
  if (o instanceof Cubehelix)
    return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r = o.r / 255, g2 = o.g / 255, b2 = o.b / 255, l = (BC_DA * b2 + ED * r - EB * g2) / (BC_DA + ED - EB), bl = b2 - l, k3 = (E2 * (g2 - l) - C2 * bl) / D2, s2 = Math.sqrt(k3 * k3 + bl * bl) / (E2 * l * (1 - l)), h2 = s2 ? Math.atan2(k3, bl) * degrees - 120 : NaN;
  return new Cubehelix(h2 < 0 ? h2 + 360 : h2, s2, l, o.opacity);
}
function cubehelix(h2, s2, l, opacity2) {
  return arguments.length === 1 ? cubehelixConvert(h2) : new Cubehelix(h2, s2, l, opacity2 == null ? 1 : opacity2);
}
function Cubehelix(h2, s2, l, opacity2) {
  this.h = +h2;
  this.s = +s2;
  this.l = +l;
  this.opacity = +opacity2;
}
define_default(Cubehelix, cubehelix, extend(Color, {
  brighter(k3) {
    k3 = k3 == null ? brighter : Math.pow(brighter, k3);
    return new Cubehelix(this.h, this.s, this.l * k3, this.opacity);
  },
  darker(k3) {
    k3 = k3 == null ? darker : Math.pow(darker, k3);
    return new Cubehelix(this.h, this.s, this.l * k3, this.opacity);
  },
  rgb() {
    var h2 = isNaN(this.h) ? 0 : (this.h + 120) * radians, l = +this.l, a3 = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh2 = Math.cos(h2), sinh2 = Math.sin(h2);
    return new Rgb(
      255 * (l + a3 * (A2 * cosh2 + B * sinh2)),
      255 * (l + a3 * (C2 * cosh2 + D2 * sinh2)),
      255 * (l + a3 * (E2 * cosh2)),
      this.opacity
    );
  }
}));

// ../../node_modules/d3-interpolate/src/basis.js
function basis(t13, v0, v1, v22, v3) {
  var t22 = t13 * t13, t32 = t22 * t13;
  return ((1 - 3 * t13 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t13 + 3 * t22 - 3 * t32) * v22 + t32 * v3) / 6;
}
function basis_default(values2) {
  var n = values2.length - 1;
  return function(t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values2[i], v22 = values2[i + 1], v0 = i > 0 ? values2[i - 1] : 2 * v1 - v22, v3 = i < n - 1 ? values2[i + 2] : 2 * v22 - v1;
    return basis((t - i / n) * n, v0, v1, v22, v3);
  };
}

// ../../node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default(values2) {
  var n = values2.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values2[(i + n - 1) % n], v1 = values2[i % n], v22 = values2[(i + 1) % n], v3 = values2[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v22, v3);
  };
}

// ../../node_modules/d3-interpolate/src/constant.js
var constant_default2 = (x4) => () => x4;

// ../../node_modules/d3-interpolate/src/color.js
function linear(a3, d) {
  return function(t) {
    return a3 + t * d;
  };
}
function exponential(a3, b2, y4) {
  return a3 = Math.pow(a3, y4), b2 = Math.pow(b2, y4) - a3, y4 = 1 / y4, function(t) {
    return Math.pow(a3 + t * b2, y4);
  };
}
function hue(a3, b2) {
  var d = b2 - a3;
  return d ? linear(a3, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant_default2(isNaN(a3) ? b2 : a3);
}
function gamma(y4) {
  return (y4 = +y4) === 1 ? nogamma : function(a3, b2) {
    return b2 - a3 ? exponential(a3, b2, y4) : constant_default2(isNaN(a3) ? b2 : a3);
  };
}
function nogamma(a3, b2) {
  var d = b2 - a3;
  return d ? linear(a3, d) : constant_default2(isNaN(a3) ? b2 : a3);
}

// ../../node_modules/d3-interpolate/src/rgb.js
var rgb_default = function rgbGamma(y4) {
  var color3 = gamma(y4);
  function rgb2(start2, end) {
    var r = color3((start2 = rgb(start2)).r, (end = rgb(end)).r), g2 = color3(start2.g, end.g), b2 = color3(start2.b, end.b), opacity2 = nogamma(start2.opacity, end.opacity);
    return function(t) {
      start2.r = r(t);
      start2.g = g2(t);
      start2.b = b2(t);
      start2.opacity = opacity2(t);
      return start2 + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length, r = new Array(n), g2 = new Array(n), b2 = new Array(n), i, color3;
    for (i = 0; i < n; ++i) {
      color3 = rgb(colors[i]);
      r[i] = color3.r || 0;
      g2[i] = color3.g || 0;
      b2[i] = color3.b || 0;
    }
    r = spline(r);
    g2 = spline(g2);
    b2 = spline(b2);
    color3.opacity = 1;
    return function(t) {
      color3.r = r(t);
      color3.g = g2(t);
      color3.b = b2(t);
      return color3 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis_default);
var rgbBasisClosed = rgbSpline(basisClosed_default);

// ../../node_modules/d3-interpolate/src/numberArray.js
function numberArray_default(a3, b2) {
  if (!b2)
    b2 = [];
  var n = a3 ? Math.min(b2.length, a3.length) : 0, c4 = b2.slice(), i;
  return function(t) {
    for (i = 0; i < n; ++i)
      c4[i] = a3[i] * (1 - t) + b2[i] * t;
    return c4;
  };
}
function isNumberArray(x4) {
  return ArrayBuffer.isView(x4) && !(x4 instanceof DataView);
}

// ../../node_modules/d3-interpolate/src/array.js
function genericArray(a3, b2) {
  var nb = b2 ? b2.length : 0, na = a3 ? Math.min(nb, a3.length) : 0, x4 = new Array(na), c4 = new Array(nb), i;
  for (i = 0; i < na; ++i)
    x4[i] = value_default(a3[i], b2[i]);
  for (; i < nb; ++i)
    c4[i] = b2[i];
  return function(t) {
    for (i = 0; i < na; ++i)
      c4[i] = x4[i](t);
    return c4;
  };
}

// ../../node_modules/d3-interpolate/src/date.js
function date_default(a3, b2) {
  var d = /* @__PURE__ */ new Date();
  return a3 = +a3, b2 = +b2, function(t) {
    return d.setTime(a3 * (1 - t) + b2 * t), d;
  };
}

// ../../node_modules/d3-interpolate/src/number.js
function number_default(a3, b2) {
  return a3 = +a3, b2 = +b2, function(t) {
    return a3 * (1 - t) + b2 * t;
  };
}

// ../../node_modules/d3-interpolate/src/object.js
function object_default(a3, b2) {
  var i = {}, c4 = {}, k3;
  if (a3 === null || typeof a3 !== "object")
    a3 = {};
  if (b2 === null || typeof b2 !== "object")
    b2 = {};
  for (k3 in b2) {
    if (k3 in a3) {
      i[k3] = value_default(a3[k3], b2[k3]);
    } else {
      c4[k3] = b2[k3];
    }
  }
  return function(t) {
    for (k3 in i)
      c4[k3] = i[k3](t);
    return c4;
  };
}

// ../../node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero2(b2) {
  return function() {
    return b2;
  };
}
function one(b2) {
  return function(t) {
    return b2(t) + "";
  };
}
function string_default(a3, b2) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s2 = [], q2 = [];
  a3 = a3 + "", b2 = b2 + "";
  while ((am = reA.exec(a3)) && (bm = reB.exec(b2))) {
    if ((bs = bm.index) > bi) {
      bs = b2.slice(bi, bs);
      if (s2[i])
        s2[i] += bs;
      else
        s2[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s2[i])
        s2[i] += bm;
      else
        s2[++i] = bm;
    } else {
      s2[++i] = null;
      q2.push({ i, x: number_default(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b2.length) {
    bs = b2.slice(bi);
    if (s2[i])
      s2[i] += bs;
    else
      s2[++i] = bs;
  }
  return s2.length < 2 ? q2[0] ? one(q2[0].x) : zero2(b2) : (b2 = q2.length, function(t) {
    for (var i2 = 0, o; i2 < b2; ++i2)
      s2[(o = q2[i2]).i] = o.x(t);
    return s2.join("");
  });
}

// ../../node_modules/d3-interpolate/src/value.js
function value_default(a3, b2) {
  var t = typeof b2, c4;
  return b2 == null || t === "boolean" ? constant_default2(b2) : (t === "number" ? number_default : t === "string" ? (c4 = color(b2)) ? (b2 = c4, rgb_default) : string_default : b2 instanceof color ? rgb_default : b2 instanceof Date ? date_default : isNumberArray(b2) ? numberArray_default : Array.isArray(b2) ? genericArray : typeof b2.valueOf !== "function" && typeof b2.toString !== "function" || isNaN(b2) ? object_default : number_default)(a3, b2);
}

// ../../node_modules/d3-interpolate/src/round.js
function round_default(a3, b2) {
  return a3 = +a3, b2 = +b2, function(t) {
    return Math.round(a3 * (1 - t) + b2 * t);
  };
}

// ../../node_modules/d3-interpolate/src/transform/decompose.js
var degrees2 = 180 / Math.PI;
var identity3 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose_default(a3, b2, c4, d, e, f2) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a3 * a3 + b2 * b2))
    a3 /= scaleX, b2 /= scaleX;
  if (skewX = a3 * c4 + b2 * d)
    c4 -= a3 * skewX, d -= b2 * skewX;
  if (scaleY = Math.sqrt(c4 * c4 + d * d))
    c4 /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a3 * d < b2 * c4)
    a3 = -a3, b2 = -b2, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f2,
    rotate: Math.atan2(b2, a3) * degrees2,
    skewX: Math.atan(skewX) * degrees2,
    scaleX,
    scaleY
  };
}

// ../../node_modules/d3-interpolate/src/transform/parse.js
var svgNode;
function parseCss(value) {
  const m2 = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m2.isIdentity ? identity3 : decompose_default(m2.a, m2.b, m2.c, m2.d, m2.e, m2.f);
}
function parseSvg(value) {
  if (value == null)
    return identity3;
  if (!svgNode)
    svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate()))
    return identity3;
  value = value.matrix;
  return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
}

// ../../node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse2, pxComma, pxParen, degParen) {
  function pop(s2) {
    return s2.length ? s2.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s2, q2) {
    if (xa !== xb || ya !== yb) {
      var i = s2.push("translate(", null, pxComma, null, pxParen);
      q2.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb || yb) {
      s2.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate(a3, b2, s2, q2) {
    if (a3 !== b2) {
      if (a3 - b2 > 180)
        b2 += 360;
      else if (b2 - a3 > 180)
        a3 += 360;
      q2.push({ i: s2.push(pop(s2) + "rotate(", null, degParen) - 2, x: number_default(a3, b2) });
    } else if (b2) {
      s2.push(pop(s2) + "rotate(" + b2 + degParen);
    }
  }
  function skewX(a3, b2, s2, q2) {
    if (a3 !== b2) {
      q2.push({ i: s2.push(pop(s2) + "skewX(", null, degParen) - 2, x: number_default(a3, b2) });
    } else if (b2) {
      s2.push(pop(s2) + "skewX(" + b2 + degParen);
    }
  }
  function scale3(xa, ya, xb, yb, s2, q2) {
    if (xa !== xb || ya !== yb) {
      var i = s2.push(pop(s2) + "scale(", null, ",", null, ")");
      q2.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s2.push(pop(s2) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a3, b2) {
    var s2 = [], q2 = [];
    a3 = parse2(a3), b2 = parse2(b2);
    translate(a3.translateX, a3.translateY, b2.translateX, b2.translateY, s2, q2);
    rotate(a3.rotate, b2.rotate, s2, q2);
    skewX(a3.skewX, b2.skewX, s2, q2);
    scale3(a3.scaleX, a3.scaleY, b2.scaleX, b2.scaleY, s2, q2);
    a3 = b2 = null;
    return function(t) {
      var i = -1, n = q2.length, o;
      while (++i < n)
        s2[(o = q2[i]).i] = o.x(t);
      return s2.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// ../../node_modules/d3-interpolate/src/zoom.js
var epsilon2 = 1e-12;
function cosh(x4) {
  return ((x4 = Math.exp(x4)) + 1 / x4) / 2;
}
function sinh(x4) {
  return ((x4 = Math.exp(x4)) - 1 / x4) / 2;
}
function tanh(x4) {
  return ((x4 = Math.exp(2 * x4)) - 1) / (x4 + 1);
}
var zoom_default = function zoomRho(rho, rho2, rho4) {
  function zoom2(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S2;
    if (d2 < epsilon2) {
      S2 = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S2)
        ];
      };
    } else {
      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S2 = (r1 - r0) / rho;
      i = function(t) {
        var s2 = t * S2, coshr0 = cosh(r0), u4 = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s2 + r0) - sinh(r0));
        return [
          ux0 + u4 * dx,
          uy0 + u4 * dy,
          w0 * coshr0 / cosh(rho * s2 + r0)
        ];
      };
    }
    i.duration = S2 * 1e3 * rho / Math.SQRT2;
    return i;
  }
  zoom2.rho = function(_2) {
    var _1 = Math.max(1e-3, +_2), _22 = _1 * _1, _4 = _22 * _22;
    return zoomRho(_1, _22, _4);
  };
  return zoom2;
}(Math.SQRT2, 2, 4);

// ../../node_modules/d3-interpolate/src/hsl.js
function hsl2(hue2) {
  return function(start2, end) {
    var h2 = hue2((start2 = hsl(start2)).h, (end = hsl(end)).h), s2 = nogamma(start2.s, end.s), l = nogamma(start2.l, end.l), opacity2 = nogamma(start2.opacity, end.opacity);
    return function(t) {
      start2.h = h2(t);
      start2.s = s2(t);
      start2.l = l(t);
      start2.opacity = opacity2(t);
      return start2 + "";
    };
  };
}
var hsl_default = hsl2(hue);
var hslLong = hsl2(nogamma);

// ../../node_modules/d3-interpolate/src/lab.js
function lab2(start2, end) {
  var l = nogamma((start2 = lab(start2)).l, (end = lab(end)).l), a3 = nogamma(start2.a, end.a), b2 = nogamma(start2.b, end.b), opacity2 = nogamma(start2.opacity, end.opacity);
  return function(t) {
    start2.l = l(t);
    start2.a = a3(t);
    start2.b = b2(t);
    start2.opacity = opacity2(t);
    return start2 + "";
  };
}

// ../../node_modules/d3-interpolate/src/hcl.js
function hcl2(hue2) {
  return function(start2, end) {
    var h2 = hue2((start2 = hcl(start2)).h, (end = hcl(end)).h), c4 = nogamma(start2.c, end.c), l = nogamma(start2.l, end.l), opacity2 = nogamma(start2.opacity, end.opacity);
    return function(t) {
      start2.h = h2(t);
      start2.c = c4(t);
      start2.l = l(t);
      start2.opacity = opacity2(t);
      return start2 + "";
    };
  };
}
var hcl_default = hcl2(hue);
var hclLong = hcl2(nogamma);

// ../../node_modules/d3-interpolate/src/cubehelix.js
function cubehelix2(hue2) {
  return function cubehelixGamma(y4) {
    y4 = +y4;
    function cubehelix3(start2, end) {
      var h2 = hue2((start2 = cubehelix(start2)).h, (end = cubehelix(end)).h), s2 = nogamma(start2.s, end.s), l = nogamma(start2.l, end.l), opacity2 = nogamma(start2.opacity, end.opacity);
      return function(t) {
        start2.h = h2(t);
        start2.s = s2(t);
        start2.l = l(Math.pow(t, y4));
        start2.opacity = opacity2(t);
        return start2 + "";
      };
    }
    cubehelix3.gamma = cubehelixGamma;
    return cubehelix3;
  }(1);
}
var cubehelix_default = cubehelix2(hue);
var cubehelixLong = cubehelix2(nogamma);

// ../../node_modules/d3-interpolate/src/piecewise.js
function piecewise(interpolate, values2) {
  if (values2 === void 0)
    values2 = interpolate, interpolate = value_default;
  var i = 0, n = values2.length - 1, v3 = values2[0], I2 = new Array(n < 0 ? 0 : n);
  while (i < n)
    I2[i] = interpolate(v3, v3 = values2[++i]);
  return function(t) {
    var i2 = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I2[i2](t - i2);
  };
}

// ../../node_modules/d3-interpolate/src/quantize.js
function quantize_default(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i)
    samples[i] = interpolator(i / (n - 1));
  return samples;
}

// ../../node_modules/d3-timer/src/timer.js
var frame = 0;
var timeout = 0;
var interval = 0;
var pokeDelay = 1e3;
var taskHead;
var taskTail;
var clockLast = 0;
var clockNow = 0;
var clockSkew = 0;
var clock = typeof performance === "object" && performance.now ? performance : Date;
var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f2) {
  setTimeout(f2, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time2) {
    if (typeof callback !== "function")
      throw new TypeError("callback is not a function");
    time2 = (time2 == null ? now() : +time2) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail)
        taskTail._next = this;
      else
        taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time2;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time2) {
  var t = new Timer();
  t.restart(callback, delay, time2);
  return t;
}
function timerFlush() {
  now();
  ++frame;
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0)
      t._call.call(void 0, e);
    t = t._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay)
    clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t03, t13 = taskHead, t22, time2 = Infinity;
  while (t13) {
    if (t13._call) {
      if (time2 > t13._time)
        time2 = t13._time;
      t03 = t13, t13 = t13._next;
    } else {
      t22 = t13._next, t13._next = null;
      t13 = t03 ? t03._next = t22 : taskHead = t22;
    }
  }
  taskTail = t03;
  sleep(time2);
}
function sleep(time2) {
  if (frame)
    return;
  if (timeout)
    timeout = clearTimeout(timeout);
  var delay = time2 - clockNow;
  if (delay > 24) {
    if (time2 < Infinity)
      timeout = setTimeout(wake, time2 - clock.now() - clockSkew);
    if (interval)
      interval = clearInterval(interval);
  } else {
    if (!interval)
      clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

// ../../node_modules/d3-timer/src/timeout.js
function timeout_default(callback, delay, time2) {
  var t = new Timer();
  delay = delay == null ? 0 : +delay;
  t.restart((elapsed) => {
    t.stop();
    callback(elapsed + delay);
  }, delay, time2);
  return t;
}

// ../../node_modules/d3-transition/src/transition/schedule.js
var emptyOn = dispatch_default("start", "end", "cancel", "interrupt");
var emptyTween = [];
var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;
function schedule_default(node, name2, id2, index2, group3, timing) {
  var schedules = node.__transition;
  if (!schedules)
    node.__transition = {};
  else if (id2 in schedules)
    return;
  create2(node, id2, {
    name: name2,
    index: index2,
    // For context during callback.
    group: group3,
    // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init(node, id2) {
  var schedule = get2(node, id2);
  if (schedule.state > CREATED)
    throw new Error("too late; already scheduled");
  return schedule;
}
function set2(node, id2) {
  var schedule = get2(node, id2);
  if (schedule.state > STARTED)
    throw new Error("too late; already running");
  return schedule;
}
function get2(node, id2) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id2]))
    throw new Error("transition not found");
  return schedule;
}
function create2(node, id2, self) {
  var schedules = node.__transition, tween;
  schedules[id2] = self;
  self.timer = timer(schedule, 0, self.time);
  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start2, self.delay, self.time);
    if (self.delay <= elapsed)
      start2(elapsed - self.delay);
  }
  function start2(elapsed) {
    var i, j2, n, o;
    if (self.state !== SCHEDULED)
      return stop();
    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name)
        continue;
      if (o.state === STARTED)
        return timeout_default(start2);
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      } else if (+i < id2) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }
    timeout_default(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING)
      return;
    self.state = STARTED;
    tween = new Array(n = self.tween.length);
    for (i = 0, j2 = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j2] = o;
      }
    }
    tween.length = j2 + 1;
  }
  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1), i = -1, n = tween.length;
    while (++i < n) {
      tween[i].call(node, t);
    }
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }
  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id2];
    for (var i in schedules)
      return;
    delete node.__transition;
  }
}

// ../../node_modules/d3-transition/src/interrupt.js
function interrupt_default(node, name2) {
  var schedules = node.__transition, schedule, active, empty4 = true, i;
  if (!schedules)
    return;
  name2 = name2 == null ? null : name2 + "";
  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name2) {
      empty4 = false;
      continue;
    }
    active = schedule.state > STARTING && schedule.state < ENDING;
    schedule.state = ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }
  if (empty4)
    delete node.__transition;
}

// ../../node_modules/d3-transition/src/selection/interrupt.js
function interrupt_default2(name2) {
  return this.each(function() {
    interrupt_default(this, name2);
  });
}

// ../../node_modules/d3-transition/src/transition/tween.js
function tweenRemove(id2, name2) {
  var tween0, tween1;
  return function() {
    var schedule = set2(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name2) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }
    schedule.tween = tween1;
  };
}
function tweenFunction(id2, name2, value) {
  var tween0, tween1;
  if (typeof value !== "function")
    throw new Error();
  return function() {
    var schedule = set2(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = { name: name2, value }, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name2) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n)
        tween1.push(t);
    }
    schedule.tween = tween1;
  };
}
function tween_default(name2, value) {
  var id2 = this._id;
  name2 += "";
  if (arguments.length < 2) {
    var tween = get2(this.node(), id2).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name2) {
        return t.value;
      }
    }
    return null;
  }
  return this.each((value == null ? tweenRemove : tweenFunction)(id2, name2, value));
}
function tweenValue(transition2, name2, value) {
  var id2 = transition2._id;
  transition2.each(function() {
    var schedule = set2(this, id2);
    (schedule.value || (schedule.value = {}))[name2] = value.apply(this, arguments);
  });
  return function(node) {
    return get2(node, id2).value[name2];
  };
}

// ../../node_modules/d3-transition/src/transition/interpolate.js
function interpolate_default(a3, b2) {
  var c4;
  return (typeof b2 === "number" ? number_default : b2 instanceof color ? rgb_default : (c4 = color(b2)) ? (b2 = c4, rgb_default) : string_default)(a3, b2);
}

// ../../node_modules/d3-transition/src/transition/attr.js
function attrRemove2(name2) {
  return function() {
    this.removeAttribute(name2);
  };
}
function attrRemoveNS2(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant2(name2, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttribute(name2);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrConstantNS2(fullname, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrFunction2(name2, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null)
      return void this.removeAttribute(name2);
    string0 = this.getAttribute(name2);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attrFunctionNS2(fullname, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null)
      return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attr_default2(name2, value) {
  var fullname = namespace_default(name2), i = fullname === "transform" ? interpolateTransformSvg : interpolate_default;
  return this.attrTween(name2, typeof value === "function" ? (fullname.local ? attrFunctionNS2 : attrFunction2)(fullname, i, tweenValue(this, "attr." + name2, value)) : value == null ? (fullname.local ? attrRemoveNS2 : attrRemove2)(fullname) : (fullname.local ? attrConstantNS2 : attrConstant2)(fullname, i, value));
}

// ../../node_modules/d3-transition/src/transition/attrTween.js
function attrInterpolate(name2, i) {
  return function(t) {
    this.setAttribute(name2, i.call(this, t));
  };
}
function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}
function attrTweenNS(fullname, value) {
  var t03, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t03 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t03;
  }
  tween._value = value;
  return tween;
}
function attrTween(name2, value) {
  var t03, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t03 = (i0 = i) && attrInterpolate(name2, i);
    return t03;
  }
  tween._value = value;
  return tween;
}
function attrTween_default(name2, value) {
  var key = "attr." + name2;
  if (arguments.length < 2)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  var fullname = namespace_default(name2);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}

// ../../node_modules/d3-transition/src/transition/delay.js
function delayFunction(id2, value) {
  return function() {
    init(this, id2).delay = +value.apply(this, arguments);
  };
}
function delayConstant(id2, value) {
  return value = +value, function() {
    init(this, id2).delay = value;
  };
}
function delay_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get2(this.node(), id2).delay;
}

// ../../node_modules/d3-transition/src/transition/duration.js
function durationFunction(id2, value) {
  return function() {
    set2(this, id2).duration = +value.apply(this, arguments);
  };
}
function durationConstant(id2, value) {
  return value = +value, function() {
    set2(this, id2).duration = value;
  };
}
function duration_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get2(this.node(), id2).duration;
}

// ../../node_modules/d3-transition/src/transition/ease.js
function easeConstant(id2, value) {
  if (typeof value !== "function")
    throw new Error();
  return function() {
    set2(this, id2).ease = value;
  };
}
function ease_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each(easeConstant(id2, value)) : get2(this.node(), id2).ease;
}

// ../../node_modules/d3-transition/src/transition/easeVarying.js
function easeVarying(id2, value) {
  return function() {
    var v3 = value.apply(this, arguments);
    if (typeof v3 !== "function")
      throw new Error();
    set2(this, id2).ease = v3;
  };
}
function easeVarying_default(value) {
  if (typeof value !== "function")
    throw new Error();
  return this.each(easeVarying(this._id, value));
}

// ../../node_modules/d3-transition/src/transition/filter.js
function filter_default2(match) {
  if (typeof match !== "function")
    match = matcher_default(match);
  for (var groups2 = this._groups, m2 = groups2.length, subgroups = new Array(m2), j2 = 0; j2 < m2; ++j2) {
    for (var group3 = groups2[j2], n = group3.length, subgroup = subgroups[j2] = [], node, i = 0; i < n; ++i) {
      if ((node = group3[i]) && match.call(node, node.__data__, i, group3)) {
        subgroup.push(node);
      }
    }
  }
  return new Transition(subgroups, this._parents, this._name, this._id);
}

// ../../node_modules/d3-transition/src/transition/merge.js
function merge_default2(transition2) {
  if (transition2._id !== this._id)
    throw new Error();
  for (var groups0 = this._groups, groups1 = transition2._groups, m0 = groups0.length, m1 = groups1.length, m2 = Math.min(m0, m1), merges = new Array(m0), j2 = 0; j2 < m2; ++j2) {
    for (var group0 = groups0[j2], group1 = groups1[j2], n = group0.length, merge2 = merges[j2] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge2[i] = node;
      }
    }
  }
  for (; j2 < m0; ++j2) {
    merges[j2] = groups0[j2];
  }
  return new Transition(merges, this._parents, this._name, this._id);
}

// ../../node_modules/d3-transition/src/transition/on.js
function start(name2) {
  return (name2 + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0)
      t = t.slice(0, i);
    return !t || t === "start";
  });
}
function onFunction(id2, name2, listener) {
  var on0, on1, sit = start(name2) ? init : set2;
  return function() {
    var schedule = sit(this, id2), on = schedule.on;
    if (on !== on0)
      (on1 = (on0 = on).copy()).on(name2, listener);
    schedule.on = on1;
  };
}
function on_default2(name2, listener) {
  var id2 = this._id;
  return arguments.length < 2 ? get2(this.node(), id2).on.on(name2) : this.each(onFunction(id2, name2, listener));
}

// ../../node_modules/d3-transition/src/transition/remove.js
function removeFunction(id2) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition)
      if (+i !== id2)
        return;
    if (parent)
      parent.removeChild(this);
  };
}
function remove_default2() {
  return this.on("end.remove", removeFunction(this._id));
}

// ../../node_modules/d3-transition/src/transition/select.js
function select_default3(select2) {
  var name2 = this._name, id2 = this._id;
  if (typeof select2 !== "function")
    select2 = selector_default(select2);
  for (var groups2 = this._groups, m2 = groups2.length, subgroups = new Array(m2), j2 = 0; j2 < m2; ++j2) {
    for (var group3 = groups2[j2], n = group3.length, subgroup = subgroups[j2] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group3[i]) && (subnode = select2.call(node, node.__data__, i, group3))) {
        if ("__data__" in node)
          subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        schedule_default(subgroup[i], name2, id2, i, subgroup, get2(node, id2));
      }
    }
  }
  return new Transition(subgroups, this._parents, name2, id2);
}

// ../../node_modules/d3-transition/src/transition/selectAll.js
function selectAll_default2(select2) {
  var name2 = this._name, id2 = this._id;
  if (typeof select2 !== "function")
    select2 = selectorAll_default(select2);
  for (var groups2 = this._groups, m2 = groups2.length, subgroups = [], parents = [], j2 = 0; j2 < m2; ++j2) {
    for (var group3 = groups2[j2], n = group3.length, node, i = 0; i < n; ++i) {
      if (node = group3[i]) {
        for (var children2 = select2.call(node, node.__data__, i, group3), child, inherit3 = get2(node, id2), k3 = 0, l = children2.length; k3 < l; ++k3) {
          if (child = children2[k3]) {
            schedule_default(child, name2, id2, k3, children2, inherit3);
          }
        }
        subgroups.push(children2);
        parents.push(node);
      }
    }
  }
  return new Transition(subgroups, parents, name2, id2);
}

// ../../node_modules/d3-transition/src/transition/selection.js
var Selection3 = selection_default.prototype.constructor;
function selection_default2() {
  return new Selection3(this._groups, this._parents);
}

// ../../node_modules/d3-transition/src/transition/style.js
function styleNull(name2, interpolate) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name2), string1 = (this.style.removeProperty(name2), styleValue(this, name2));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}
function styleRemove2(name2) {
  return function() {
    this.style.removeProperty(name2);
  };
}
function styleConstant2(name2, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = styleValue(this, name2);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function styleFunction2(name2, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name2), value1 = value(this), string1 = value1 + "";
    if (value1 == null)
      string1 = value1 = (this.style.removeProperty(name2), styleValue(this, name2));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function styleMaybeRemove(id2, name2) {
  var on0, on1, listener0, key = "style." + name2, event = "end." + key, remove2;
  return function() {
    var schedule = set2(this, id2), on = schedule.on, listener = schedule.value[key] == null ? remove2 || (remove2 = styleRemove2(name2)) : void 0;
    if (on !== on0 || listener0 !== listener)
      (on1 = (on0 = on).copy()).on(event, listener0 = listener);
    schedule.on = on1;
  };
}
function style_default2(name2, value, priority) {
  var i = (name2 += "") === "transform" ? interpolateTransformCss : interpolate_default;
  return value == null ? this.styleTween(name2, styleNull(name2, i)).on("end.style." + name2, styleRemove2(name2)) : typeof value === "function" ? this.styleTween(name2, styleFunction2(name2, i, tweenValue(this, "style." + name2, value))).each(styleMaybeRemove(this._id, name2)) : this.styleTween(name2, styleConstant2(name2, i, value), priority).on("end.style." + name2, null);
}

// ../../node_modules/d3-transition/src/transition/styleTween.js
function styleInterpolate(name2, i, priority) {
  return function(t) {
    this.style.setProperty(name2, i.call(this, t), priority);
  };
}
function styleTween(name2, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t = (i0 = i) && styleInterpolate(name2, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}
function styleTween_default(name2, value, priority) {
  var key = "style." + (name2 += "");
  if (arguments.length < 2)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  return this.tween(key, styleTween(name2, value, priority == null ? "" : priority));
}

// ../../node_modules/d3-transition/src/transition/text.js
function textConstant2(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction2(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}
function text_default2(value) {
  return this.tween("text", typeof value === "function" ? textFunction2(tweenValue(this, "text", value)) : textConstant2(value == null ? "" : value + ""));
}

// ../../node_modules/d3-transition/src/transition/textTween.js
function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}
function textTween(value) {
  var t03, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t03 = (i0 = i) && textInterpolate(i);
    return t03;
  }
  tween._value = value;
  return tween;
}
function textTween_default(value) {
  var key = "text";
  if (arguments.length < 1)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  return this.tween(key, textTween(value));
}

// ../../node_modules/d3-transition/src/transition/transition.js
function transition_default() {
  var name2 = this._name, id0 = this._id, id1 = newId();
  for (var groups2 = this._groups, m2 = groups2.length, j2 = 0; j2 < m2; ++j2) {
    for (var group3 = groups2[j2], n = group3.length, node, i = 0; i < n; ++i) {
      if (node = group3[i]) {
        var inherit3 = get2(node, id0);
        schedule_default(node, name2, id1, i, group3, {
          time: inherit3.time + inherit3.delay + inherit3.duration,
          delay: 0,
          duration: inherit3.duration,
          ease: inherit3.ease
        });
      }
    }
  }
  return new Transition(groups2, this._parents, name2, id1);
}

// ../../node_modules/d3-transition/src/transition/end.js
function end_default() {
  var on0, on1, that = this, id2 = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = { value: reject }, end = { value: function() {
      if (--size === 0)
        resolve();
    } };
    that.each(function() {
      var schedule = set2(this, id2), on = schedule.on;
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }
      schedule.on = on1;
    });
    if (size === 0)
      resolve();
  });
}

// ../../node_modules/d3-transition/src/transition/index.js
var id = 0;
function Transition(groups2, parents, name2, id2) {
  this._groups = groups2;
  this._parents = parents;
  this._name = name2;
  this._id = id2;
}
function transition(name2) {
  return selection_default().transition(name2);
}
function newId() {
  return ++id;
}
var selection_prototype = selection_default.prototype;
Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: select_default3,
  selectAll: selectAll_default2,
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: filter_default2,
  merge: merge_default2,
  selection: selection_default2,
  transition: transition_default,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: on_default2,
  attr: attr_default2,
  attrTween: attrTween_default,
  style: style_default2,
  styleTween: styleTween_default,
  text: text_default2,
  textTween: textTween_default,
  remove: remove_default2,
  tween: tween_default,
  delay: delay_default,
  duration: duration_default,
  ease: ease_default,
  easeVarying: easeVarying_default,
  end: end_default,
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};

// ../../node_modules/d3-ease/src/cubic.js
function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

// ../../node_modules/d3-transition/src/selection/transition.js
var defaultTiming = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};
function inherit(node, id2) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id2])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id2} not found`);
    }
  }
  return timing;
}
function transition_default2(name2) {
  var id2, timing;
  if (name2 instanceof Transition) {
    id2 = name2._id, name2 = name2._name;
  } else {
    id2 = newId(), (timing = defaultTiming).time = now(), name2 = name2 == null ? null : name2 + "";
  }
  for (var groups2 = this._groups, m2 = groups2.length, j2 = 0; j2 < m2; ++j2) {
    for (var group3 = groups2[j2], n = group3.length, node, i = 0; i < n; ++i) {
      if (node = group3[i]) {
        schedule_default(node, name2, id2, i, group3, timing || inherit(node, id2));
      }
    }
  }
  return new Transition(groups2, this._parents, name2, id2);
}

// ../../node_modules/d3-transition/src/selection/index.js
selection_default.prototype.interrupt = interrupt_default2;
selection_default.prototype.transition = transition_default2;

// ../../node_modules/d3-brush/src/constant.js
var constant_default3 = (x4) => () => x4;

// ../../node_modules/d3-brush/src/event.js
function BrushEvent(type2, {
  sourceEvent,
  target,
  selection: selection2,
  mode: mode3,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type2, enumerable: true, configurable: true },
    sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },
    target: { value: target, enumerable: true, configurable: true },
    selection: { value: selection2, enumerable: true, configurable: true },
    mode: { value: mode3, enumerable: true, configurable: true },
    _: { value: dispatch2 }
  });
}

// ../../node_modules/d3-brush/src/noevent.js
function nopropagation(event) {
  event.stopImmediatePropagation();
}
function noevent_default2(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}

// ../../node_modules/d3-brush/src/brush.js
var MODE_DRAG = { name: "drag" };
var MODE_SPACE = { name: "space" };
var MODE_HANDLE = { name: "handle" };
var MODE_CENTER = { name: "center" };
var { abs, max: max3, min: min3 } = Math;
function number1(e) {
  return [+e[0], +e[1]];
}
function number22(e) {
  return [number1(e[0]), number1(e[1])];
}
var X2 = {
  name: "x",
  handles: ["w", "e"].map(type),
  input: function(x4, e) {
    return x4 == null ? null : [[+x4[0], e[0][1]], [+x4[1], e[1][1]]];
  },
  output: function(xy) {
    return xy && [xy[0][0], xy[1][0]];
  }
};
var Y2 = {
  name: "y",
  handles: ["n", "s"].map(type),
  input: function(y4, e) {
    return y4 == null ? null : [[e[0][0], +y4[0]], [e[1][0], +y4[1]]];
  },
  output: function(xy) {
    return xy && [xy[0][1], xy[1][1]];
  }
};
var XY = {
  name: "xy",
  handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type),
  input: function(xy) {
    return xy == null ? null : number22(xy);
  },
  output: function(xy) {
    return xy;
  }
};
var cursors = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
};
var flipX = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
};
var flipY = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
};
var signsX = {
  overlay: 1,
  selection: 1,
  n: null,
  e: 1,
  s: null,
  w: -1,
  nw: -1,
  ne: 1,
  se: 1,
  sw: -1
};
var signsY = {
  overlay: 1,
  selection: 1,
  n: -1,
  e: null,
  s: 1,
  w: null,
  nw: -1,
  ne: -1,
  se: 1,
  sw: 1
};
function type(t) {
  return { type: t };
}
function defaultFilter(event) {
  return !event.ctrlKey && !event.button;
}
function defaultExtent() {
  var svg = this.ownerSVGElement || this;
  if (svg.hasAttribute("viewBox")) {
    svg = svg.viewBox.baseVal;
    return [[svg.x, svg.y], [svg.x + svg.width, svg.y + svg.height]];
  }
  return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
}
function defaultTouchable() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function local(node) {
  while (!node.__brush)
    if (!(node = node.parentNode))
      return;
  return node.__brush;
}
function empty3(extent4) {
  return extent4[0][0] === extent4[1][0] || extent4[0][1] === extent4[1][1];
}
function brushX() {
  return brush(X2);
}
function brushY() {
  return brush(Y2);
}
function brush_default() {
  return brush(XY);
}
function brush(dim) {
  var extent4 = defaultExtent, filter3 = defaultFilter, touchable = defaultTouchable, keys = true, listeners = dispatch_default("start", "brush", "end"), handleSize = 6, touchending;
  function brush3(group3) {
    var overlay = group3.property("__brush", initialize).selectAll(".overlay").data([type("overlay")]);
    overlay.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", cursors.overlay).merge(overlay).each(function() {
      var extent5 = local(this).extent;
      select_default2(this).attr("x", extent5[0][0]).attr("y", extent5[0][1]).attr("width", extent5[1][0] - extent5[0][0]).attr("height", extent5[1][1] - extent5[0][1]);
    });
    group3.selectAll(".selection").data([type("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", cursors.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");
    var handle = group3.selectAll(".handle").data(dim.handles, function(d) {
      return d.type;
    });
    handle.exit().remove();
    handle.enter().append("rect").attr("class", function(d) {
      return "handle handle--" + d.type;
    }).attr("cursor", function(d) {
      return cursors[d.type];
    });
    group3.each(redraw).attr("fill", "none").attr("pointer-events", "all").on("mousedown.brush", started).filter(touchable).on("touchstart.brush", started).on("touchmove.brush", touchmoved).on("touchend.brush touchcancel.brush", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  brush3.move = function(group3, selection2, event) {
    if (group3.tween) {
      group3.on("start.brush", function(event2) {
        emitter(this, arguments).beforestart().start(event2);
      }).on("interrupt.brush end.brush", function(event2) {
        emitter(this, arguments).end(event2);
      }).tween("brush", function() {
        var that = this, state = that.__brush, emit = emitter(that, arguments), selection0 = state.selection, selection1 = dim.input(typeof selection2 === "function" ? selection2.apply(this, arguments) : selection2, state.extent), i = value_default(selection0, selection1);
        function tween(t) {
          state.selection = t === 1 && selection1 === null ? null : i(t);
          redraw.call(that);
          emit.brush();
        }
        return selection0 !== null && selection1 !== null ? tween : tween(1);
      });
    } else {
      group3.each(function() {
        var that = this, args = arguments, state = that.__brush, selection1 = dim.input(typeof selection2 === "function" ? selection2.apply(that, args) : selection2, state.extent), emit = emitter(that, args).beforestart();
        interrupt_default(that);
        state.selection = selection1 === null ? null : selection1;
        redraw.call(that);
        emit.start(event).brush(event).end(event);
      });
    }
  };
  brush3.clear = function(group3, event) {
    brush3.move(group3, null, event);
  };
  function redraw() {
    var group3 = select_default2(this), selection2 = local(this).selection;
    if (selection2) {
      group3.selectAll(".selection").style("display", null).attr("x", selection2[0][0]).attr("y", selection2[0][1]).attr("width", selection2[1][0] - selection2[0][0]).attr("height", selection2[1][1] - selection2[0][1]);
      group3.selectAll(".handle").style("display", null).attr("x", function(d) {
        return d.type[d.type.length - 1] === "e" ? selection2[1][0] - handleSize / 2 : selection2[0][0] - handleSize / 2;
      }).attr("y", function(d) {
        return d.type[0] === "s" ? selection2[1][1] - handleSize / 2 : selection2[0][1] - handleSize / 2;
      }).attr("width", function(d) {
        return d.type === "n" || d.type === "s" ? selection2[1][0] - selection2[0][0] + handleSize : handleSize;
      }).attr("height", function(d) {
        return d.type === "e" || d.type === "w" ? selection2[1][1] - selection2[0][1] + handleSize : handleSize;
      });
    } else {
      group3.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
    }
  }
  function emitter(that, args, clean) {
    var emit = that.__brush.emitter;
    return emit && (!clean || !emit.clean) ? emit : new Emitter(that, args, clean);
  }
  function Emitter(that, args, clean) {
    this.that = that;
    this.args = args;
    this.state = that.__brush;
    this.active = 0;
    this.clean = clean;
  }
  Emitter.prototype = {
    beforestart: function() {
      if (++this.active === 1)
        this.state.emitter = this, this.starting = true;
      return this;
    },
    start: function(event, mode3) {
      if (this.starting)
        this.starting = false, this.emit("start", event, mode3);
      else
        this.emit("brush", event);
      return this;
    },
    brush: function(event, mode3) {
      this.emit("brush", event, mode3);
      return this;
    },
    end: function(event, mode3) {
      if (--this.active === 0)
        delete this.state.emitter, this.emit("end", event, mode3);
      return this;
    },
    emit: function(type2, event, mode3) {
      var d = select_default2(this.that).datum();
      listeners.call(
        type2,
        this.that,
        new BrushEvent(type2, {
          sourceEvent: event,
          target: brush3,
          selection: dim.output(this.state.selection),
          mode: mode3,
          dispatch: listeners
        }),
        d
      );
    }
  };
  function started(event) {
    if (touchending && !event.touches)
      return;
    if (!filter3.apply(this, arguments))
      return;
    var that = this, type2 = event.target.__data__.type, mode3 = (keys && event.metaKey ? type2 = "overlay" : type2) === "selection" ? MODE_DRAG : keys && event.altKey ? MODE_CENTER : MODE_HANDLE, signX = dim === Y2 ? null : signsX[type2], signY = dim === X2 ? null : signsY[type2], state = local(that), extent5 = state.extent, selection2 = state.selection, W2 = extent5[0][0], w0, w1, N2 = extent5[0][1], n0, n1, E3 = extent5[1][0], e0, e1, S2 = extent5[1][1], s0, s1, dx = 0, dy = 0, moving, shifting = signX && signY && keys && event.shiftKey, lockX, lockY, points2 = Array.from(event.touches || [event], (t) => {
      const i = t.identifier;
      t = pointer_default(t, that);
      t.point0 = t.slice();
      t.identifier = i;
      return t;
    });
    interrupt_default(that);
    var emit = emitter(that, arguments, true).beforestart();
    if (type2 === "overlay") {
      if (selection2)
        moving = true;
      const pts = [points2[0], points2[1] || points2[0]];
      state.selection = selection2 = [[
        w0 = dim === Y2 ? W2 : min3(pts[0][0], pts[1][0]),
        n0 = dim === X2 ? N2 : min3(pts[0][1], pts[1][1])
      ], [
        e0 = dim === Y2 ? E3 : max3(pts[0][0], pts[1][0]),
        s0 = dim === X2 ? S2 : max3(pts[0][1], pts[1][1])
      ]];
      if (points2.length > 1)
        move(event);
    } else {
      w0 = selection2[0][0];
      n0 = selection2[0][1];
      e0 = selection2[1][0];
      s0 = selection2[1][1];
    }
    w1 = w0;
    n1 = n0;
    e1 = e0;
    s1 = s0;
    var group3 = select_default2(that).attr("pointer-events", "none");
    var overlay = group3.selectAll(".overlay").attr("cursor", cursors[type2]);
    if (event.touches) {
      emit.moved = moved;
      emit.ended = ended;
    } else {
      var view = select_default2(event.view).on("mousemove.brush", moved, true).on("mouseup.brush", ended, true);
      if (keys)
        view.on("keydown.brush", keydowned, true).on("keyup.brush", keyupped, true);
      nodrag_default(event.view);
    }
    redraw.call(that);
    emit.start(event, mode3.name);
    function moved(event2) {
      for (const p2 of event2.changedTouches || [event2]) {
        for (const d of points2)
          if (d.identifier === p2.identifier)
            d.cur = pointer_default(p2, that);
      }
      if (shifting && !lockX && !lockY && points2.length === 1) {
        const point6 = points2[0];
        if (abs(point6.cur[0] - point6[0]) > abs(point6.cur[1] - point6[1]))
          lockY = true;
        else
          lockX = true;
      }
      for (const point6 of points2)
        if (point6.cur)
          point6[0] = point6.cur[0], point6[1] = point6.cur[1];
      moving = true;
      noevent_default2(event2);
      move(event2);
    }
    function move(event2) {
      const point6 = points2[0], point0 = point6.point0;
      var t;
      dx = point6[0] - point0[0];
      dy = point6[1] - point0[1];
      switch (mode3) {
        case MODE_SPACE:
        case MODE_DRAG: {
          if (signX)
            dx = max3(W2 - w0, min3(E3 - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
          if (signY)
            dy = max3(N2 - n0, min3(S2 - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
          break;
        }
        case MODE_HANDLE: {
          if (points2[1]) {
            if (signX)
              w1 = max3(W2, min3(E3, points2[0][0])), e1 = max3(W2, min3(E3, points2[1][0])), signX = 1;
            if (signY)
              n1 = max3(N2, min3(S2, points2[0][1])), s1 = max3(N2, min3(S2, points2[1][1])), signY = 1;
          } else {
            if (signX < 0)
              dx = max3(W2 - w0, min3(E3 - w0, dx)), w1 = w0 + dx, e1 = e0;
            else if (signX > 0)
              dx = max3(W2 - e0, min3(E3 - e0, dx)), w1 = w0, e1 = e0 + dx;
            if (signY < 0)
              dy = max3(N2 - n0, min3(S2 - n0, dy)), n1 = n0 + dy, s1 = s0;
            else if (signY > 0)
              dy = max3(N2 - s0, min3(S2 - s0, dy)), n1 = n0, s1 = s0 + dy;
          }
          break;
        }
        case MODE_CENTER: {
          if (signX)
            w1 = max3(W2, min3(E3, w0 - dx * signX)), e1 = max3(W2, min3(E3, e0 + dx * signX));
          if (signY)
            n1 = max3(N2, min3(S2, n0 - dy * signY)), s1 = max3(N2, min3(S2, s0 + dy * signY));
          break;
        }
      }
      if (e1 < w1) {
        signX *= -1;
        t = w0, w0 = e0, e0 = t;
        t = w1, w1 = e1, e1 = t;
        if (type2 in flipX)
          overlay.attr("cursor", cursors[type2 = flipX[type2]]);
      }
      if (s1 < n1) {
        signY *= -1;
        t = n0, n0 = s0, s0 = t;
        t = n1, n1 = s1, s1 = t;
        if (type2 in flipY)
          overlay.attr("cursor", cursors[type2 = flipY[type2]]);
      }
      if (state.selection)
        selection2 = state.selection;
      if (lockX)
        w1 = selection2[0][0], e1 = selection2[1][0];
      if (lockY)
        n1 = selection2[0][1], s1 = selection2[1][1];
      if (selection2[0][0] !== w1 || selection2[0][1] !== n1 || selection2[1][0] !== e1 || selection2[1][1] !== s1) {
        state.selection = [[w1, n1], [e1, s1]];
        redraw.call(that);
        emit.brush(event2, mode3.name);
      }
    }
    function ended(event2) {
      nopropagation(event2);
      if (event2.touches) {
        if (event2.touches.length)
          return;
        if (touchending)
          clearTimeout(touchending);
        touchending = setTimeout(function() {
          touchending = null;
        }, 500);
      } else {
        yesdrag(event2.view, moving);
        view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      }
      group3.attr("pointer-events", "all");
      overlay.attr("cursor", cursors.overlay);
      if (state.selection)
        selection2 = state.selection;
      if (empty3(selection2))
        state.selection = null, redraw.call(that);
      emit.end(event2, mode3.name);
    }
    function keydowned(event2) {
      switch (event2.keyCode) {
        case 16: {
          shifting = signX && signY;
          break;
        }
        case 18: {
          if (mode3 === MODE_HANDLE) {
            if (signX)
              e0 = e1 - dx * signX, w0 = w1 + dx * signX;
            if (signY)
              s0 = s1 - dy * signY, n0 = n1 + dy * signY;
            mode3 = MODE_CENTER;
            move(event2);
          }
          break;
        }
        case 32: {
          if (mode3 === MODE_HANDLE || mode3 === MODE_CENTER) {
            if (signX < 0)
              e0 = e1 - dx;
            else if (signX > 0)
              w0 = w1 - dx;
            if (signY < 0)
              s0 = s1 - dy;
            else if (signY > 0)
              n0 = n1 - dy;
            mode3 = MODE_SPACE;
            overlay.attr("cursor", cursors.selection);
            move(event2);
          }
          break;
        }
        default:
          return;
      }
      noevent_default2(event2);
    }
    function keyupped(event2) {
      switch (event2.keyCode) {
        case 16: {
          if (shifting) {
            lockX = lockY = shifting = false;
            move(event2);
          }
          break;
        }
        case 18: {
          if (mode3 === MODE_CENTER) {
            if (signX < 0)
              e0 = e1;
            else if (signX > 0)
              w0 = w1;
            if (signY < 0)
              s0 = s1;
            else if (signY > 0)
              n0 = n1;
            mode3 = MODE_HANDLE;
            move(event2);
          }
          break;
        }
        case 32: {
          if (mode3 === MODE_SPACE) {
            if (event2.altKey) {
              if (signX)
                e0 = e1 - dx * signX, w0 = w1 + dx * signX;
              if (signY)
                s0 = s1 - dy * signY, n0 = n1 + dy * signY;
              mode3 = MODE_CENTER;
            } else {
              if (signX < 0)
                e0 = e1;
              else if (signX > 0)
                w0 = w1;
              if (signY < 0)
                s0 = s1;
              else if (signY > 0)
                n0 = n1;
              mode3 = MODE_HANDLE;
            }
            overlay.attr("cursor", cursors[type2]);
            move(event2);
          }
          break;
        }
        default:
          return;
      }
      noevent_default2(event2);
    }
  }
  function touchmoved(event) {
    emitter(this, arguments).moved(event);
  }
  function touchended(event) {
    emitter(this, arguments).ended(event);
  }
  function initialize() {
    var state = this.__brush || { selection: null };
    state.extent = number22(extent4.apply(this, arguments));
    state.dim = dim;
    return state;
  }
  brush3.extent = function(_2) {
    return arguments.length ? (extent4 = typeof _2 === "function" ? _2 : constant_default3(number22(_2)), brush3) : extent4;
  };
  brush3.filter = function(_2) {
    return arguments.length ? (filter3 = typeof _2 === "function" ? _2 : constant_default3(!!_2), brush3) : filter3;
  };
  brush3.touchable = function(_2) {
    return arguments.length ? (touchable = typeof _2 === "function" ? _2 : constant_default3(!!_2), brush3) : touchable;
  };
  brush3.handleSize = function(_2) {
    return arguments.length ? (handleSize = +_2, brush3) : handleSize;
  };
  brush3.keyModifiers = function(_2) {
    return arguments.length ? (keys = !!_2, brush3) : keys;
  };
  brush3.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? brush3 : value;
  };
  return brush3;
}

// ../../node_modules/d3-path/src/path.js
var pi = Math.PI;
var tau = 2 * pi;
var epsilon3 = 1e-6;
var tauEpsilon = tau - epsilon3;
function append(strings) {
  this._ += strings[0];
  for (let i = 1, n = strings.length; i < n; ++i) {
    this._ += arguments[i] + strings[i];
  }
}
function appendRound(digits) {
  let d = Math.floor(digits);
  if (!(d >= 0))
    throw new Error(`invalid digits: ${digits}`);
  if (d > 15)
    return append;
  const k3 = 10 ** d;
  return function(strings) {
    this._ += strings[0];
    for (let i = 1, n = strings.length; i < n; ++i) {
      this._ += Math.round(arguments[i] * k3) / k3 + strings[i];
    }
  };
}
var Path = class {
  constructor(digits) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null;
    this._ = "";
    this._append = digits == null ? append : appendRound(digits);
  }
  moveTo(x4, y4) {
    this._append`M${this._x0 = this._x1 = +x4},${this._y0 = this._y1 = +y4}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._append`Z`;
    }
  }
  lineTo(x4, y4) {
    this._append`L${this._x1 = +x4},${this._y1 = +y4}`;
  }
  quadraticCurveTo(x12, y12, x4, y4) {
    this._append`Q${+x12},${+y12},${this._x1 = +x4},${this._y1 = +y4}`;
  }
  bezierCurveTo(x12, y12, x22, y22, x4, y4) {
    this._append`C${+x12},${+y12},${+x22},${+y22},${this._x1 = +x4},${this._y1 = +y4}`;
  }
  arcTo(x12, y12, x22, y22, r) {
    x12 = +x12, y12 = +y12, x22 = +x22, y22 = +y22, r = +r;
    if (r < 0)
      throw new Error(`negative radius: ${r}`);
    let x06 = this._x1, y06 = this._y1, x21 = x22 - x12, y21 = y22 - y12, x01 = x06 - x12, y01 = y06 - y12, l01_2 = x01 * x01 + y01 * y01;
    if (this._x1 === null) {
      this._append`M${this._x1 = x12},${this._y1 = y12}`;
    } else if (!(l01_2 > epsilon3))
      ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon3) || !r) {
      this._append`L${this._x1 = x12},${this._y1 = y12}`;
    } else {
      let x20 = x22 - x06, y20 = y22 - y06, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
      if (Math.abs(t01 - 1) > epsilon3) {
        this._append`L${x12 + t01 * x01},${y12 + t01 * y01}`;
      }
      this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x12 + t21 * x21},${this._y1 = y12 + t21 * y21}`;
    }
  }
  arc(x4, y4, r, a0, a1, ccw) {
    x4 = +x4, y4 = +y4, r = +r, ccw = !!ccw;
    if (r < 0)
      throw new Error(`negative radius: ${r}`);
    let dx = r * Math.cos(a0), dy = r * Math.sin(a0), x06 = x4 + dx, y06 = y4 + dy, cw = 1 ^ ccw, da2 = ccw ? a0 - a1 : a1 - a0;
    if (this._x1 === null) {
      this._append`M${x06},${y06}`;
    } else if (Math.abs(this._x1 - x06) > epsilon3 || Math.abs(this._y1 - y06) > epsilon3) {
      this._append`L${x06},${y06}`;
    }
    if (!r)
      return;
    if (da2 < 0)
      da2 = da2 % tau + tau;
    if (da2 > tauEpsilon) {
      this._append`A${r},${r},0,1,${cw},${x4 - dx},${y4 - dy}A${r},${r},0,1,${cw},${this._x1 = x06},${this._y1 = y06}`;
    } else if (da2 > epsilon3) {
      this._append`A${r},${r},0,${+(da2 >= pi)},${cw},${this._x1 = x4 + r * Math.cos(a1)},${this._y1 = y4 + r * Math.sin(a1)}`;
    }
  }
  rect(x4, y4, w, h2) {
    this._append`M${this._x0 = this._x1 = +x4},${this._y0 = this._y1 = +y4}h${w = +w}v${+h2}h${-w}Z`;
  }
  toString() {
    return this._;
  }
};
function path() {
  return new Path();
}
path.prototype = Path.prototype;
function pathRound(digits = 3) {
  return new Path(+digits);
}

// ../../node_modules/d3-contour/src/array.js
var array2 = Array.prototype;
var slice = array2.slice;

// ../../node_modules/d3-contour/src/ascending.js
function ascending_default(a3, b2) {
  return a3 - b2;
}

// ../../node_modules/d3-contour/src/area.js
function area_default(ring) {
  var i = 0, n = ring.length, area3 = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
  while (++i < n)
    area3 += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
  return area3;
}

// ../../node_modules/d3-contour/src/constant.js
var constant_default4 = (x4) => () => x4;

// ../../node_modules/d3-contour/src/contains.js
function contains_default(ring, hole) {
  var i = -1, n = hole.length, c4;
  while (++i < n)
    if (c4 = ringContains(ring, hole[i]))
      return c4;
  return 0;
}
function ringContains(ring, point6) {
  var x4 = point6[0], y4 = point6[1], contains2 = -1;
  for (var i = 0, n = ring.length, j2 = n - 1; i < n; j2 = i++) {
    var pi5 = ring[i], xi = pi5[0], yi = pi5[1], pj = ring[j2], xj = pj[0], yj = pj[1];
    if (segmentContains(pi5, pj, point6))
      return 0;
    if (yi > y4 !== yj > y4 && x4 < (xj - xi) * (y4 - yi) / (yj - yi) + xi)
      contains2 = -contains2;
  }
  return contains2;
}
function segmentContains(a3, b2, c4) {
  var i;
  return collinear(a3, b2, c4) && within(a3[i = +(a3[0] === b2[0])], c4[i], b2[i]);
}
function collinear(a3, b2, c4) {
  return (b2[0] - a3[0]) * (c4[1] - a3[1]) === (c4[0] - a3[0]) * (b2[1] - a3[1]);
}
function within(p2, q2, r) {
  return p2 <= q2 && q2 <= r || r <= q2 && q2 <= p2;
}

// ../../node_modules/d3-contour/src/noop.js
function noop_default() {
}

// ../../node_modules/d3-contour/src/contours.js
var cases = [
  [],
  [[[1, 1.5], [0.5, 1]]],
  [[[1.5, 1], [1, 1.5]]],
  [[[1.5, 1], [0.5, 1]]],
  [[[1, 0.5], [1.5, 1]]],
  [[[1, 1.5], [0.5, 1]], [[1, 0.5], [1.5, 1]]],
  [[[1, 0.5], [1, 1.5]]],
  [[[1, 0.5], [0.5, 1]]],
  [[[0.5, 1], [1, 0.5]]],
  [[[1, 1.5], [1, 0.5]]],
  [[[0.5, 1], [1, 0.5]], [[1.5, 1], [1, 1.5]]],
  [[[1.5, 1], [1, 0.5]]],
  [[[0.5, 1], [1.5, 1]]],
  [[[1, 1.5], [1.5, 1]]],
  [[[0.5, 1], [1, 1.5]]],
  []
];
function contours_default() {
  var dx = 1, dy = 1, threshold2 = thresholdSturges, smooth = smoothLinear;
  function contours(values2) {
    var tz = threshold2(values2);
    if (!Array.isArray(tz)) {
      const e = extent(values2, finite);
      tz = ticks(...nice(e[0], e[1], tz), tz);
      while (tz[tz.length - 1] >= e[1])
        tz.pop();
      while (tz[1] < e[0])
        tz.shift();
    } else {
      tz = tz.slice().sort(ascending_default);
    }
    return tz.map((value) => contour3(values2, value));
  }
  function contour3(values2, value) {
    const v3 = value == null ? NaN : +value;
    if (isNaN(v3))
      throw new Error(`invalid value: ${value}`);
    var polygons = [], holes = [];
    isorings(values2, v3, function(ring) {
      smooth(ring, values2, v3);
      if (area_default(ring) > 0)
        polygons.push([ring]);
      else
        holes.push(ring);
    });
    holes.forEach(function(hole) {
      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
        if (contains_default((polygon = polygons[i])[0], hole) !== -1) {
          polygon.push(hole);
          return;
        }
      }
    });
    return {
      type: "MultiPolygon",
      value,
      coordinates: polygons
    };
  }
  function isorings(values2, value, callback) {
    var fragmentByStart = new Array(), fragmentByEnd = new Array(), x4, y4, t03, t13, t22, t32;
    x4 = y4 = -1;
    t13 = above(values2[0], value);
    cases[t13 << 1].forEach(stitch);
    while (++x4 < dx - 1) {
      t03 = t13, t13 = above(values2[x4 + 1], value);
      cases[t03 | t13 << 1].forEach(stitch);
    }
    cases[t13 << 0].forEach(stitch);
    while (++y4 < dy - 1) {
      x4 = -1;
      t13 = above(values2[y4 * dx + dx], value);
      t22 = above(values2[y4 * dx], value);
      cases[t13 << 1 | t22 << 2].forEach(stitch);
      while (++x4 < dx - 1) {
        t03 = t13, t13 = above(values2[y4 * dx + dx + x4 + 1], value);
        t32 = t22, t22 = above(values2[y4 * dx + x4 + 1], value);
        cases[t03 | t13 << 1 | t22 << 2 | t32 << 3].forEach(stitch);
      }
      cases[t13 | t22 << 3].forEach(stitch);
    }
    x4 = -1;
    t22 = values2[y4 * dx] >= value;
    cases[t22 << 2].forEach(stitch);
    while (++x4 < dx - 1) {
      t32 = t22, t22 = above(values2[y4 * dx + x4 + 1], value);
      cases[t22 << 2 | t32 << 3].forEach(stitch);
    }
    cases[t22 << 3].forEach(stitch);
    function stitch(line3) {
      var start2 = [line3[0][0] + x4, line3[0][1] + y4], end = [line3[1][0] + x4, line3[1][1] + y4], startIndex = index2(start2), endIndex = index2(end), f2, g2;
      if (f2 = fragmentByEnd[startIndex]) {
        if (g2 = fragmentByStart[endIndex]) {
          delete fragmentByEnd[f2.end];
          delete fragmentByStart[g2.start];
          if (f2 === g2) {
            f2.ring.push(end);
            callback(f2.ring);
          } else {
            fragmentByStart[f2.start] = fragmentByEnd[g2.end] = { start: f2.start, end: g2.end, ring: f2.ring.concat(g2.ring) };
          }
        } else {
          delete fragmentByEnd[f2.end];
          f2.ring.push(end);
          fragmentByEnd[f2.end = endIndex] = f2;
        }
      } else if (f2 = fragmentByStart[endIndex]) {
        if (g2 = fragmentByEnd[startIndex]) {
          delete fragmentByStart[f2.start];
          delete fragmentByEnd[g2.end];
          if (f2 === g2) {
            f2.ring.push(end);
            callback(f2.ring);
          } else {
            fragmentByStart[g2.start] = fragmentByEnd[f2.end] = { start: g2.start, end: f2.end, ring: g2.ring.concat(f2.ring) };
          }
        } else {
          delete fragmentByStart[f2.start];
          f2.ring.unshift(start2);
          fragmentByStart[f2.start = startIndex] = f2;
        }
      } else {
        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = { start: startIndex, end: endIndex, ring: [start2, end] };
      }
    }
  }
  function index2(point6) {
    return point6[0] * 2 + point6[1] * (dx + 1) * 4;
  }
  function smoothLinear(ring, values2, value) {
    ring.forEach(function(point6) {
      var x4 = point6[0], y4 = point6[1], xt = x4 | 0, yt = y4 | 0, v1 = valid(values2[yt * dx + xt]);
      if (x4 > 0 && x4 < dx && xt === x4) {
        point6[0] = smooth1(x4, valid(values2[yt * dx + xt - 1]), v1, value);
      }
      if (y4 > 0 && y4 < dy && yt === y4) {
        point6[1] = smooth1(y4, valid(values2[(yt - 1) * dx + xt]), v1, value);
      }
    });
  }
  contours.contour = contour3;
  contours.size = function(_2) {
    if (!arguments.length)
      return [dx, dy];
    var _0 = Math.floor(_2[0]), _1 = Math.floor(_2[1]);
    if (!(_0 >= 0 && _1 >= 0))
      throw new Error("invalid size");
    return dx = _0, dy = _1, contours;
  };
  contours.thresholds = function(_2) {
    return arguments.length ? (threshold2 = typeof _2 === "function" ? _2 : Array.isArray(_2) ? constant_default4(slice.call(_2)) : constant_default4(_2), contours) : threshold2;
  };
  contours.smooth = function(_2) {
    return arguments.length ? (smooth = _2 ? smoothLinear : noop_default, contours) : smooth === smoothLinear;
  };
  return contours;
}
function finite(x4) {
  return isFinite(x4) ? x4 : NaN;
}
function above(x4, value) {
  return x4 == null ? false : +x4 >= value;
}
function valid(v3) {
  return v3 == null || isNaN(v3 = +v3) ? -Infinity : v3;
}
function smooth1(x4, v0, v1, value) {
  const a3 = value - v0;
  const b2 = v1 - v0;
  const d = isFinite(a3) || isFinite(b2) ? a3 / b2 : Math.sign(a3) / Math.sign(b2);
  return isNaN(d) ? x4 : x4 + d - 0.5;
}

// ../../node_modules/d3-contour/src/density.js
function defaultX(d) {
  return d[0];
}
function defaultY(d) {
  return d[1];
}
function defaultWeight() {
  return 1;
}
function density_default() {
  var x4 = defaultX, y4 = defaultY, weight = defaultWeight, dx = 960, dy = 500, r = 20, k3 = 2, o = r * 3, n = dx + o * 2 >> k3, m2 = dy + o * 2 >> k3, threshold2 = constant_default4(20);
  function grid2(data) {
    var values2 = new Float32Array(n * m2), pow2k = Math.pow(2, -k3), i = -1;
    for (const d of data) {
      var xi = (x4(d, ++i, data) + o) * pow2k, yi = (y4(d, i, data) + o) * pow2k, wi = +weight(d, i, data);
      if (wi && xi >= 0 && xi < n && yi >= 0 && yi < m2) {
        var x06 = Math.floor(xi), y06 = Math.floor(yi), xt = xi - x06 - 0.5, yt = yi - y06 - 0.5;
        values2[x06 + y06 * n] += (1 - xt) * (1 - yt) * wi;
        values2[x06 + 1 + y06 * n] += xt * (1 - yt) * wi;
        values2[x06 + 1 + (y06 + 1) * n] += xt * yt * wi;
        values2[x06 + (y06 + 1) * n] += (1 - xt) * yt * wi;
      }
    }
    blur2({ data: values2, width: n, height: m2 }, r * pow2k);
    return values2;
  }
  function density3(data) {
    var values2 = grid2(data), tz = threshold2(values2), pow4k = Math.pow(2, 2 * k3);
    if (!Array.isArray(tz)) {
      tz = ticks(Number.MIN_VALUE, max2(values2) / pow4k, tz);
    }
    return contours_default().size([n, m2]).thresholds(tz.map((d) => d * pow4k))(values2).map((c4, i) => (c4.value = +tz[i], transform3(c4)));
  }
  density3.contours = function(data) {
    var values2 = grid2(data), contours = contours_default().size([n, m2]), pow4k = Math.pow(2, 2 * k3), contour3 = (value) => {
      value = +value;
      var c4 = transform3(contours.contour(values2, value * pow4k));
      c4.value = value;
      return c4;
    };
    Object.defineProperty(contour3, "max", { get: () => max2(values2) / pow4k });
    return contour3;
  };
  function transform3(geometry) {
    geometry.coordinates.forEach(transformPolygon);
    return geometry;
  }
  function transformPolygon(coordinates) {
    coordinates.forEach(transformRing);
  }
  function transformRing(coordinates) {
    coordinates.forEach(transformPoint);
  }
  function transformPoint(coordinates) {
    coordinates[0] = coordinates[0] * Math.pow(2, k3) - o;
    coordinates[1] = coordinates[1] * Math.pow(2, k3) - o;
  }
  function resize() {
    o = r * 3;
    n = dx + o * 2 >> k3;
    m2 = dy + o * 2 >> k3;
    return density3;
  }
  density3.x = function(_2) {
    return arguments.length ? (x4 = typeof _2 === "function" ? _2 : constant_default4(+_2), density3) : x4;
  };
  density3.y = function(_2) {
    return arguments.length ? (y4 = typeof _2 === "function" ? _2 : constant_default4(+_2), density3) : y4;
  };
  density3.weight = function(_2) {
    return arguments.length ? (weight = typeof _2 === "function" ? _2 : constant_default4(+_2), density3) : weight;
  };
  density3.size = function(_2) {
    if (!arguments.length)
      return [dx, dy];
    var _0 = +_2[0], _1 = +_2[1];
    if (!(_0 >= 0 && _1 >= 0))
      throw new Error("invalid size");
    return dx = _0, dy = _1, resize();
  };
  density3.cellSize = function(_2) {
    if (!arguments.length)
      return 1 << k3;
    if (!((_2 = +_2) >= 1))
      throw new Error("invalid cell size");
    return k3 = Math.floor(Math.log(_2) / Math.LN2), resize();
  };
  density3.thresholds = function(_2) {
    return arguments.length ? (threshold2 = typeof _2 === "function" ? _2 : Array.isArray(_2) ? constant_default4(slice.call(_2)) : constant_default4(_2), density3) : threshold2;
  };
  density3.bandwidth = function(_2) {
    if (!arguments.length)
      return Math.sqrt(r * (r + 1));
    if (!((_2 = +_2) >= 0))
      throw new Error("invalid bandwidth");
    return r = (Math.sqrt(4 * _2 * _2 + 1) - 1) / 2, resize();
  };
  return density3;
}

// ../../node_modules/robust-predicates/esm/util.js
var epsilon4 = 11102230246251565e-32;
var splitter = 134217729;
var resulterrbound = (3 + 8 * epsilon4) * epsilon4;
function sum4(elen, e, flen, f2, h2) {
  let Q2, Qnew, hh, bvirt;
  let enow = e[0];
  let fnow = f2[0];
  let eindex = 0;
  let findex = 0;
  if (fnow > enow === fnow > -enow) {
    Q2 = enow;
    enow = e[++eindex];
  } else {
    Q2 = fnow;
    fnow = f2[++findex];
  }
  let hindex = 0;
  if (eindex < elen && findex < flen) {
    if (fnow > enow === fnow > -enow) {
      Qnew = enow + Q2;
      hh = Q2 - (Qnew - enow);
      enow = e[++eindex];
    } else {
      Qnew = fnow + Q2;
      hh = Q2 - (Qnew - fnow);
      fnow = f2[++findex];
    }
    Q2 = Qnew;
    if (hh !== 0) {
      h2[hindex++] = hh;
    }
    while (eindex < elen && findex < flen) {
      if (fnow > enow === fnow > -enow) {
        Qnew = Q2 + enow;
        bvirt = Qnew - Q2;
        hh = Q2 - (Qnew - bvirt) + (enow - bvirt);
        enow = e[++eindex];
      } else {
        Qnew = Q2 + fnow;
        bvirt = Qnew - Q2;
        hh = Q2 - (Qnew - bvirt) + (fnow - bvirt);
        fnow = f2[++findex];
      }
      Q2 = Qnew;
      if (hh !== 0) {
        h2[hindex++] = hh;
      }
    }
  }
  while (eindex < elen) {
    Qnew = Q2 + enow;
    bvirt = Qnew - Q2;
    hh = Q2 - (Qnew - bvirt) + (enow - bvirt);
    enow = e[++eindex];
    Q2 = Qnew;
    if (hh !== 0) {
      h2[hindex++] = hh;
    }
  }
  while (findex < flen) {
    Qnew = Q2 + fnow;
    bvirt = Qnew - Q2;
    hh = Q2 - (Qnew - bvirt) + (fnow - bvirt);
    fnow = f2[++findex];
    Q2 = Qnew;
    if (hh !== 0) {
      h2[hindex++] = hh;
    }
  }
  if (Q2 !== 0 || hindex === 0) {
    h2[hindex++] = Q2;
  }
  return hindex;
}
function estimate(elen, e) {
  let Q2 = e[0];
  for (let i = 1; i < elen; i++)
    Q2 += e[i];
  return Q2;
}
function vec(n) {
  return new Float64Array(n);
}

// ../../node_modules/robust-predicates/esm/orient2d.js
var ccwerrboundA = (3 + 16 * epsilon4) * epsilon4;
var ccwerrboundB = (2 + 12 * epsilon4) * epsilon4;
var ccwerrboundC = (9 + 64 * epsilon4) * epsilon4 * epsilon4;
var B2 = vec(4);
var C1 = vec(8);
var C22 = vec(12);
var D3 = vec(16);
var u = vec(4);
function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
  let acxtail, acytail, bcxtail, bcytail;
  let bvirt, c4, ahi, alo, bhi, blo, _i, _j3, _0, s1, s0, t13, t03, u33;
  const acx = ax - cx;
  const bcx = bx - cx;
  const acy = ay - cy;
  const bcy = by - cy;
  s1 = acx * bcy;
  c4 = splitter * acx;
  ahi = c4 - (c4 - acx);
  alo = acx - ahi;
  c4 = splitter * bcy;
  bhi = c4 - (c4 - bcy);
  blo = bcy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t13 = acy * bcx;
  c4 = splitter * acy;
  ahi = c4 - (c4 - acy);
  alo = acy - ahi;
  c4 = splitter * bcx;
  bhi = c4 - (c4 - bcx);
  blo = bcx - bhi;
  t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t03;
  bvirt = s0 - _i;
  B2[0] = s0 - (_i + bvirt) + (bvirt - t03);
  _j3 = s1 + _i;
  bvirt = _j3 - s1;
  _0 = s1 - (_j3 - bvirt) + (_i - bvirt);
  _i = _0 - t13;
  bvirt = _0 - _i;
  B2[1] = _0 - (_i + bvirt) + (bvirt - t13);
  u33 = _j3 + _i;
  bvirt = u33 - _j3;
  B2[2] = _j3 - (u33 - bvirt) + (_i - bvirt);
  B2[3] = u33;
  let det = estimate(4, B2);
  let errbound = ccwerrboundB * detsum;
  if (det >= errbound || -det >= errbound) {
    return det;
  }
  bvirt = ax - acx;
  acxtail = ax - (acx + bvirt) + (bvirt - cx);
  bvirt = bx - bcx;
  bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
  bvirt = ay - acy;
  acytail = ay - (acy + bvirt) + (bvirt - cy);
  bvirt = by - bcy;
  bcytail = by - (bcy + bvirt) + (bvirt - cy);
  if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
    return det;
  }
  errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
  det += acx * bcytail + bcy * acxtail - (acy * bcxtail + bcx * acytail);
  if (det >= errbound || -det >= errbound)
    return det;
  s1 = acxtail * bcy;
  c4 = splitter * acxtail;
  ahi = c4 - (c4 - acxtail);
  alo = acxtail - ahi;
  c4 = splitter * bcy;
  bhi = c4 - (c4 - bcy);
  blo = bcy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t13 = acytail * bcx;
  c4 = splitter * acytail;
  ahi = c4 - (c4 - acytail);
  alo = acytail - ahi;
  c4 = splitter * bcx;
  bhi = c4 - (c4 - bcx);
  blo = bcx - bhi;
  t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t03;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t03);
  _j3 = s1 + _i;
  bvirt = _j3 - s1;
  _0 = s1 - (_j3 - bvirt) + (_i - bvirt);
  _i = _0 - t13;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t13);
  u33 = _j3 + _i;
  bvirt = u33 - _j3;
  u[2] = _j3 - (u33 - bvirt) + (_i - bvirt);
  u[3] = u33;
  const C1len = sum4(4, B2, 4, u, C1);
  s1 = acx * bcytail;
  c4 = splitter * acx;
  ahi = c4 - (c4 - acx);
  alo = acx - ahi;
  c4 = splitter * bcytail;
  bhi = c4 - (c4 - bcytail);
  blo = bcytail - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t13 = acy * bcxtail;
  c4 = splitter * acy;
  ahi = c4 - (c4 - acy);
  alo = acy - ahi;
  c4 = splitter * bcxtail;
  bhi = c4 - (c4 - bcxtail);
  blo = bcxtail - bhi;
  t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t03;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t03);
  _j3 = s1 + _i;
  bvirt = _j3 - s1;
  _0 = s1 - (_j3 - bvirt) + (_i - bvirt);
  _i = _0 - t13;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t13);
  u33 = _j3 + _i;
  bvirt = u33 - _j3;
  u[2] = _j3 - (u33 - bvirt) + (_i - bvirt);
  u[3] = u33;
  const C2len = sum4(C1len, C1, 4, u, C22);
  s1 = acxtail * bcytail;
  c4 = splitter * acxtail;
  ahi = c4 - (c4 - acxtail);
  alo = acxtail - ahi;
  c4 = splitter * bcytail;
  bhi = c4 - (c4 - bcytail);
  blo = bcytail - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t13 = acytail * bcxtail;
  c4 = splitter * acytail;
  ahi = c4 - (c4 - acytail);
  alo = acytail - ahi;
  c4 = splitter * bcxtail;
  bhi = c4 - (c4 - bcxtail);
  blo = bcxtail - bhi;
  t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t03;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t03);
  _j3 = s1 + _i;
  bvirt = _j3 - s1;
  _0 = s1 - (_j3 - bvirt) + (_i - bvirt);
  _i = _0 - t13;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t13);
  u33 = _j3 + _i;
  bvirt = u33 - _j3;
  u[2] = _j3 - (u33 - bvirt) + (_i - bvirt);
  u[3] = u33;
  const Dlen = sum4(C2len, C22, 4, u, D3);
  return D3[Dlen - 1];
}
function orient2d(ax, ay, bx, by, cx, cy) {
  const detleft = (ay - cy) * (bx - cx);
  const detright = (ax - cx) * (by - cy);
  const det = detleft - detright;
  const detsum = Math.abs(detleft + detright);
  if (Math.abs(det) >= ccwerrboundA * detsum)
    return det;
  return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
}

// ../../node_modules/robust-predicates/esm/orient3d.js
var o3derrboundA = (7 + 56 * epsilon4) * epsilon4;
var o3derrboundB = (3 + 28 * epsilon4) * epsilon4;
var o3derrboundC = (26 + 288 * epsilon4) * epsilon4 * epsilon4;
var bc = vec(4);
var ca = vec(4);
var ab = vec(4);
var at_b = vec(4);
var at_c = vec(4);
var bt_c = vec(4);
var bt_a = vec(4);
var ct_a = vec(4);
var ct_b = vec(4);
var bct = vec(8);
var cat = vec(8);
var abt = vec(8);
var u2 = vec(4);
var _8 = vec(8);
var _8b = vec(8);
var _16 = vec(8);
var _12 = vec(12);
var fin = vec(192);
var fin2 = vec(192);

// ../../node_modules/robust-predicates/esm/incircle.js
var iccerrboundA = (10 + 96 * epsilon4) * epsilon4;
var iccerrboundB = (4 + 48 * epsilon4) * epsilon4;
var iccerrboundC = (44 + 576 * epsilon4) * epsilon4 * epsilon4;
var bc2 = vec(4);
var ca2 = vec(4);
var ab2 = vec(4);
var aa = vec(4);
var bb = vec(4);
var cc = vec(4);
var u3 = vec(4);
var v2 = vec(4);
var axtbc = vec(8);
var aytbc = vec(8);
var bxtca = vec(8);
var bytca = vec(8);
var cxtab = vec(8);
var cytab = vec(8);
var abt2 = vec(8);
var bct2 = vec(8);
var cat2 = vec(8);
var abtt = vec(4);
var bctt = vec(4);
var catt = vec(4);
var _82 = vec(8);
var _162 = vec(16);
var _16b = vec(16);
var _16c = vec(16);
var _32 = vec(32);
var _32b = vec(32);
var _48 = vec(48);
var _64 = vec(64);
var fin3 = vec(1152);
var fin22 = vec(1152);

// ../../node_modules/robust-predicates/esm/insphere.js
var isperrboundA = (16 + 224 * epsilon4) * epsilon4;
var isperrboundB = (5 + 72 * epsilon4) * epsilon4;
var isperrboundC = (71 + 1408 * epsilon4) * epsilon4 * epsilon4;
var ab3 = vec(4);
var bc3 = vec(4);
var cd = vec(4);
var de2 = vec(4);
var ea = vec(4);
var ac = vec(4);
var bd = vec(4);
var ce2 = vec(4);
var da = vec(4);
var eb = vec(4);
var abc = vec(24);
var bcd = vec(24);
var cde = vec(24);
var dea = vec(24);
var eab = vec(24);
var abd = vec(24);
var bce = vec(24);
var cda = vec(24);
var deb = vec(24);
var eac = vec(24);
var adet = vec(1152);
var bdet = vec(1152);
var cdet = vec(1152);
var ddet = vec(1152);
var edet = vec(1152);
var abdet = vec(2304);
var cddet = vec(2304);
var cdedet = vec(3456);
var deter = vec(5760);
var _83 = vec(8);
var _8b2 = vec(8);
var _8c = vec(8);
var _163 = vec(16);
var _24 = vec(24);
var _482 = vec(48);
var _48b = vec(48);
var _96 = vec(96);
var _192 = vec(192);
var _384x = vec(384);
var _384y = vec(384);
var _384z = vec(384);
var _768 = vec(768);
var xdet = vec(96);
var ydet = vec(96);
var zdet = vec(96);
var fin4 = vec(1152);

// ../../node_modules/delaunator/index.js
var EPSILON = Math.pow(2, -52);
var EDGE_STACK = new Uint32Array(512);
var Delaunator = class _Delaunator {
  static from(points2, getX = defaultGetX, getY = defaultGetY) {
    const n = points2.length;
    const coords = new Float64Array(n * 2);
    for (let i = 0; i < n; i++) {
      const p2 = points2[i];
      coords[2 * i] = getX(p2);
      coords[2 * i + 1] = getY(p2);
    }
    return new _Delaunator(coords);
  }
  constructor(coords) {
    const n = coords.length >> 1;
    if (n > 0 && typeof coords[0] !== "number")
      throw new Error("Expected coords to contain numbers.");
    this.coords = coords;
    const maxTriangles = Math.max(2 * n - 5, 0);
    this._triangles = new Uint32Array(maxTriangles * 3);
    this._halfedges = new Int32Array(maxTriangles * 3);
    this._hashSize = Math.ceil(Math.sqrt(n));
    this._hullPrev = new Uint32Array(n);
    this._hullNext = new Uint32Array(n);
    this._hullTri = new Uint32Array(n);
    this._hullHash = new Int32Array(this._hashSize);
    this._ids = new Uint32Array(n);
    this._dists = new Float64Array(n);
    this.update();
  }
  update() {
    const { coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash } = this;
    const n = coords.length >> 1;
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY2 = -Infinity;
    for (let i = 0; i < n; i++) {
      const x4 = coords[2 * i];
      const y4 = coords[2 * i + 1];
      if (x4 < minX)
        minX = x4;
      if (y4 < minY)
        minY = y4;
      if (x4 > maxX)
        maxX = x4;
      if (y4 > maxY2)
        maxY2 = y4;
      this._ids[i] = i;
    }
    const cx = (minX + maxX) / 2;
    const cy = (minY + maxY2) / 2;
    let i0, i1, i2;
    for (let i = 0, minDist = Infinity; i < n; i++) {
      const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);
      if (d < minDist) {
        i0 = i;
        minDist = d;
      }
    }
    const i0x = coords[2 * i0];
    const i0y = coords[2 * i0 + 1];
    for (let i = 0, minDist = Infinity; i < n; i++) {
      if (i === i0)
        continue;
      const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);
      if (d < minDist && d > 0) {
        i1 = i;
        minDist = d;
      }
    }
    let i1x = coords[2 * i1];
    let i1y = coords[2 * i1 + 1];
    let minRadius = Infinity;
    for (let i = 0; i < n; i++) {
      if (i === i0 || i === i1)
        continue;
      const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);
      if (r < minRadius) {
        i2 = i;
        minRadius = r;
      }
    }
    let i2x = coords[2 * i2];
    let i2y = coords[2 * i2 + 1];
    if (minRadius === Infinity) {
      for (let i = 0; i < n; i++) {
        this._dists[i] = coords[2 * i] - coords[0] || coords[2 * i + 1] - coords[1];
      }
      quicksort(this._ids, this._dists, 0, n - 1);
      const hull3 = new Uint32Array(n);
      let j2 = 0;
      for (let i = 0, d0 = -Infinity; i < n; i++) {
        const id2 = this._ids[i];
        const d = this._dists[id2];
        if (d > d0) {
          hull3[j2++] = id2;
          d0 = d;
        }
      }
      this.hull = hull3.subarray(0, j2);
      this.triangles = new Uint32Array(0);
      this.halfedges = new Uint32Array(0);
      return;
    }
    if (orient2d(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {
      const i = i1;
      const x4 = i1x;
      const y4 = i1y;
      i1 = i2;
      i1x = i2x;
      i1y = i2y;
      i2 = i;
      i2x = x4;
      i2y = y4;
    }
    const center2 = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
    this._cx = center2.x;
    this._cy = center2.y;
    for (let i = 0; i < n; i++) {
      this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center2.x, center2.y);
    }
    quicksort(this._ids, this._dists, 0, n - 1);
    this._hullStart = i0;
    let hullSize = 3;
    hullNext[i0] = hullPrev[i2] = i1;
    hullNext[i1] = hullPrev[i0] = i2;
    hullNext[i2] = hullPrev[i1] = i0;
    hullTri[i0] = 0;
    hullTri[i1] = 1;
    hullTri[i2] = 2;
    hullHash.fill(-1);
    hullHash[this._hashKey(i0x, i0y)] = i0;
    hullHash[this._hashKey(i1x, i1y)] = i1;
    hullHash[this._hashKey(i2x, i2y)] = i2;
    this.trianglesLen = 0;
    this._addTriangle(i0, i1, i2, -1, -1, -1);
    for (let k3 = 0, xp, yp; k3 < this._ids.length; k3++) {
      const i = this._ids[k3];
      const x4 = coords[2 * i];
      const y4 = coords[2 * i + 1];
      if (k3 > 0 && Math.abs(x4 - xp) <= EPSILON && Math.abs(y4 - yp) <= EPSILON)
        continue;
      xp = x4;
      yp = y4;
      if (i === i0 || i === i1 || i === i2)
        continue;
      let start2 = 0;
      for (let j2 = 0, key = this._hashKey(x4, y4); j2 < this._hashSize; j2++) {
        start2 = hullHash[(key + j2) % this._hashSize];
        if (start2 !== -1 && start2 !== hullNext[start2])
          break;
      }
      start2 = hullPrev[start2];
      let e = start2, q2;
      while (q2 = hullNext[e], orient2d(x4, y4, coords[2 * e], coords[2 * e + 1], coords[2 * q2], coords[2 * q2 + 1]) >= 0) {
        e = q2;
        if (e === start2) {
          e = -1;
          break;
        }
      }
      if (e === -1)
        continue;
      let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);
      hullTri[i] = this._legalize(t + 2);
      hullTri[e] = t;
      hullSize++;
      let n2 = hullNext[e];
      while (q2 = hullNext[n2], orient2d(x4, y4, coords[2 * n2], coords[2 * n2 + 1], coords[2 * q2], coords[2 * q2 + 1]) < 0) {
        t = this._addTriangle(n2, i, q2, hullTri[i], -1, hullTri[n2]);
        hullTri[i] = this._legalize(t + 2);
        hullNext[n2] = n2;
        hullSize--;
        n2 = q2;
      }
      if (e === start2) {
        while (q2 = hullPrev[e], orient2d(x4, y4, coords[2 * q2], coords[2 * q2 + 1], coords[2 * e], coords[2 * e + 1]) < 0) {
          t = this._addTriangle(q2, i, e, -1, hullTri[e], hullTri[q2]);
          this._legalize(t + 2);
          hullTri[q2] = t;
          hullNext[e] = e;
          hullSize--;
          e = q2;
        }
      }
      this._hullStart = hullPrev[i] = e;
      hullNext[e] = hullPrev[n2] = i;
      hullNext[i] = n2;
      hullHash[this._hashKey(x4, y4)] = i;
      hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;
    }
    this.hull = new Uint32Array(hullSize);
    for (let i = 0, e = this._hullStart; i < hullSize; i++) {
      this.hull[i] = e;
      e = hullNext[e];
    }
    this.triangles = this._triangles.subarray(0, this.trianglesLen);
    this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
  }
  _hashKey(x4, y4) {
    return Math.floor(pseudoAngle(x4 - this._cx, y4 - this._cy) * this._hashSize) % this._hashSize;
  }
  _legalize(a3) {
    const { _triangles: triangles, _halfedges: halfedges, coords } = this;
    let i = 0;
    let ar = 0;
    while (true) {
      const b2 = halfedges[a3];
      const a0 = a3 - a3 % 3;
      ar = a0 + (a3 + 2) % 3;
      if (b2 === -1) {
        if (i === 0)
          break;
        a3 = EDGE_STACK[--i];
        continue;
      }
      const b0 = b2 - b2 % 3;
      const al = a0 + (a3 + 1) % 3;
      const bl = b0 + (b2 + 2) % 3;
      const p0 = triangles[ar];
      const pr = triangles[a3];
      const pl = triangles[al];
      const p1 = triangles[bl];
      const illegal = inCircle(
        coords[2 * p0],
        coords[2 * p0 + 1],
        coords[2 * pr],
        coords[2 * pr + 1],
        coords[2 * pl],
        coords[2 * pl + 1],
        coords[2 * p1],
        coords[2 * p1 + 1]
      );
      if (illegal) {
        triangles[a3] = p1;
        triangles[b2] = p0;
        const hbl = halfedges[bl];
        if (hbl === -1) {
          let e = this._hullStart;
          do {
            if (this._hullTri[e] === bl) {
              this._hullTri[e] = a3;
              break;
            }
            e = this._hullPrev[e];
          } while (e !== this._hullStart);
        }
        this._link(a3, hbl);
        this._link(b2, halfedges[ar]);
        this._link(ar, bl);
        const br = b0 + (b2 + 1) % 3;
        if (i < EDGE_STACK.length) {
          EDGE_STACK[i++] = br;
        }
      } else {
        if (i === 0)
          break;
        a3 = EDGE_STACK[--i];
      }
    }
    return ar;
  }
  _link(a3, b2) {
    this._halfedges[a3] = b2;
    if (b2 !== -1)
      this._halfedges[b2] = a3;
  }
  // add a new triangle given vertex indices and adjacent half-edge ids
  _addTriangle(i0, i1, i2, a3, b2, c4) {
    const t = this.trianglesLen;
    this._triangles[t] = i0;
    this._triangles[t + 1] = i1;
    this._triangles[t + 2] = i2;
    this._link(t, a3);
    this._link(t + 1, b2);
    this._link(t + 2, c4);
    this.trianglesLen += 3;
    return t;
  }
};
function pseudoAngle(dx, dy) {
  const p2 = dx / (Math.abs(dx) + Math.abs(dy));
  return (dy > 0 ? 3 - p2 : 1 + p2) / 4;
}
function dist(ax, ay, bx, by) {
  const dx = ax - bx;
  const dy = ay - by;
  return dx * dx + dy * dy;
}
function inCircle(ax, ay, bx, by, cx, cy, px, py) {
  const dx = ax - px;
  const dy = ay - py;
  const ex = bx - px;
  const ey = by - py;
  const fx = cx - px;
  const fy = cy - py;
  const ap = dx * dx + dy * dy;
  const bp = ex * ex + ey * ey;
  const cp = fx * fx + fy * fy;
  return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;
}
function circumradius(ax, ay, bx, by, cx, cy) {
  const dx = bx - ax;
  const dy = by - ay;
  const ex = cx - ax;
  const ey = cy - ay;
  const bl = dx * dx + dy * dy;
  const cl = ex * ex + ey * ey;
  const d = 0.5 / (dx * ey - dy * ex);
  const x4 = (ey * bl - dy * cl) * d;
  const y4 = (dx * cl - ex * bl) * d;
  return x4 * x4 + y4 * y4;
}
function circumcenter(ax, ay, bx, by, cx, cy) {
  const dx = bx - ax;
  const dy = by - ay;
  const ex = cx - ax;
  const ey = cy - ay;
  const bl = dx * dx + dy * dy;
  const cl = ex * ex + ey * ey;
  const d = 0.5 / (dx * ey - dy * ex);
  const x4 = ax + (ey * bl - dy * cl) * d;
  const y4 = ay + (dx * cl - ex * bl) * d;
  return { x: x4, y: y4 };
}
function quicksort(ids, dists, left2, right2) {
  if (right2 - left2 <= 20) {
    for (let i = left2 + 1; i <= right2; i++) {
      const temp = ids[i];
      const tempDist = dists[temp];
      let j2 = i - 1;
      while (j2 >= left2 && dists[ids[j2]] > tempDist)
        ids[j2 + 1] = ids[j2--];
      ids[j2 + 1] = temp;
    }
  } else {
    const median3 = left2 + right2 >> 1;
    let i = left2 + 1;
    let j2 = right2;
    swap2(ids, median3, i);
    if (dists[ids[left2]] > dists[ids[right2]])
      swap2(ids, left2, right2);
    if (dists[ids[i]] > dists[ids[right2]])
      swap2(ids, i, right2);
    if (dists[ids[left2]] > dists[ids[i]])
      swap2(ids, left2, i);
    const temp = ids[i];
    const tempDist = dists[temp];
    while (true) {
      do
        i++;
      while (dists[ids[i]] < tempDist);
      do
        j2--;
      while (dists[ids[j2]] > tempDist);
      if (j2 < i)
        break;
      swap2(ids, i, j2);
    }
    ids[left2 + 1] = ids[j2];
    ids[j2] = temp;
    if (right2 - i + 1 >= j2 - left2) {
      quicksort(ids, dists, i, right2);
      quicksort(ids, dists, left2, j2 - 1);
    } else {
      quicksort(ids, dists, left2, j2 - 1);
      quicksort(ids, dists, i, right2);
    }
  }
}
function swap2(arr, i, j2) {
  const tmp3 = arr[i];
  arr[i] = arr[j2];
  arr[j2] = tmp3;
}
function defaultGetX(p2) {
  return p2[0];
}
function defaultGetY(p2) {
  return p2[1];
}

// ../../node_modules/d3-delaunay/src/path.js
var epsilon5 = 1e-6;
var Path2 = class {
  constructor() {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null;
    this._ = "";
  }
  moveTo(x4, y4) {
    this._ += `M${this._x0 = this._x1 = +x4},${this._y0 = this._y1 = +y4}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  }
  lineTo(x4, y4) {
    this._ += `L${this._x1 = +x4},${this._y1 = +y4}`;
  }
  arc(x4, y4, r) {
    x4 = +x4, y4 = +y4, r = +r;
    const x06 = x4 + r;
    const y06 = y4;
    if (r < 0)
      throw new Error("negative radius");
    if (this._x1 === null)
      this._ += `M${x06},${y06}`;
    else if (Math.abs(this._x1 - x06) > epsilon5 || Math.abs(this._y1 - y06) > epsilon5)
      this._ += "L" + x06 + "," + y06;
    if (!r)
      return;
    this._ += `A${r},${r},0,1,1,${x4 - r},${y4}A${r},${r},0,1,1,${this._x1 = x06},${this._y1 = y06}`;
  }
  rect(x4, y4, w, h2) {
    this._ += `M${this._x0 = this._x1 = +x4},${this._y0 = this._y1 = +y4}h${+w}v${+h2}h${-w}Z`;
  }
  value() {
    return this._ || null;
  }
};

// ../../node_modules/d3-delaunay/src/polygon.js
var Polygon = class {
  constructor() {
    this._ = [];
  }
  moveTo(x4, y4) {
    this._.push([x4, y4]);
  }
  closePath() {
    this._.push(this._[0].slice());
  }
  lineTo(x4, y4) {
    this._.push([x4, y4]);
  }
  value() {
    return this._.length ? this._ : null;
  }
};

// ../../node_modules/d3-delaunay/src/voronoi.js
var Voronoi = class {
  constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {
    if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin)))
      throw new Error("invalid bounds");
    this.delaunay = delaunay;
    this._circumcenters = new Float64Array(delaunay.points.length * 2);
    this.vectors = new Float64Array(delaunay.points.length * 2);
    this.xmax = xmax, this.xmin = xmin;
    this.ymax = ymax, this.ymin = ymin;
    this._init();
  }
  update() {
    this.delaunay.update();
    this._init();
    return this;
  }
  _init() {
    const { delaunay: { points: points2, hull: hull3, triangles }, vectors } = this;
    let bx, by;
    const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);
    for (let i = 0, j2 = 0, n = triangles.length, x4, y4; i < n; i += 3, j2 += 2) {
      const t13 = triangles[i] * 2;
      const t22 = triangles[i + 1] * 2;
      const t32 = triangles[i + 2] * 2;
      const x13 = points2[t13];
      const y13 = points2[t13 + 1];
      const x22 = points2[t22];
      const y22 = points2[t22 + 1];
      const x32 = points2[t32];
      const y32 = points2[t32 + 1];
      const dx = x22 - x13;
      const dy = y22 - y13;
      const ex = x32 - x13;
      const ey = y32 - y13;
      const ab4 = (dx * ey - dy * ex) * 2;
      if (Math.abs(ab4) < 1e-9) {
        if (bx === void 0) {
          bx = by = 0;
          for (const i2 of hull3)
            bx += points2[i2 * 2], by += points2[i2 * 2 + 1];
          bx /= hull3.length, by /= hull3.length;
        }
        const a3 = 1e9 * Math.sign((bx - x13) * ey - (by - y13) * ex);
        x4 = (x13 + x32) / 2 - a3 * ey;
        y4 = (y13 + y32) / 2 + a3 * ex;
      } else {
        const d = 1 / ab4;
        const bl = dx * dx + dy * dy;
        const cl = ex * ex + ey * ey;
        x4 = x13 + (ey * bl - dy * cl) * d;
        y4 = y13 + (dx * cl - ex * bl) * d;
      }
      circumcenters[j2] = x4;
      circumcenters[j2 + 1] = y4;
    }
    let h2 = hull3[hull3.length - 1];
    let p0, p1 = h2 * 4;
    let x06, x12 = points2[2 * h2];
    let y06, y12 = points2[2 * h2 + 1];
    vectors.fill(0);
    for (let i = 0; i < hull3.length; ++i) {
      h2 = hull3[i];
      p0 = p1, x06 = x12, y06 = y12;
      p1 = h2 * 4, x12 = points2[2 * h2], y12 = points2[2 * h2 + 1];
      vectors[p0 + 2] = vectors[p1] = y06 - y12;
      vectors[p0 + 3] = vectors[p1 + 1] = x12 - x06;
    }
  }
  render(context) {
    const buffer = context == null ? context = new Path2() : void 0;
    const { delaunay: { halfedges, inedges, hull: hull3 }, circumcenters, vectors } = this;
    if (hull3.length <= 1)
      return null;
    for (let i = 0, n = halfedges.length; i < n; ++i) {
      const j2 = halfedges[i];
      if (j2 < i)
        continue;
      const ti = Math.floor(i / 3) * 2;
      const tj = Math.floor(j2 / 3) * 2;
      const xi = circumcenters[ti];
      const yi = circumcenters[ti + 1];
      const xj = circumcenters[tj];
      const yj = circumcenters[tj + 1];
      this._renderSegment(xi, yi, xj, yj, context);
    }
    let h0, h1 = hull3[hull3.length - 1];
    for (let i = 0; i < hull3.length; ++i) {
      h0 = h1, h1 = hull3[i];
      const t = Math.floor(inedges[h1] / 3) * 2;
      const x4 = circumcenters[t];
      const y4 = circumcenters[t + 1];
      const v3 = h0 * 4;
      const p2 = this._project(x4, y4, vectors[v3 + 2], vectors[v3 + 3]);
      if (p2)
        this._renderSegment(x4, y4, p2[0], p2[1], context);
    }
    return buffer && buffer.value();
  }
  renderBounds(context) {
    const buffer = context == null ? context = new Path2() : void 0;
    context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);
    return buffer && buffer.value();
  }
  renderCell(i, context) {
    const buffer = context == null ? context = new Path2() : void 0;
    const points2 = this._clip(i);
    if (points2 === null || !points2.length)
      return;
    context.moveTo(points2[0], points2[1]);
    let n = points2.length;
    while (points2[0] === points2[n - 2] && points2[1] === points2[n - 1] && n > 1)
      n -= 2;
    for (let i2 = 2; i2 < n; i2 += 2) {
      if (points2[i2] !== points2[i2 - 2] || points2[i2 + 1] !== points2[i2 - 1])
        context.lineTo(points2[i2], points2[i2 + 1]);
    }
    context.closePath();
    return buffer && buffer.value();
  }
  *cellPolygons() {
    const { delaunay: { points: points2 } } = this;
    for (let i = 0, n = points2.length / 2; i < n; ++i) {
      const cell3 = this.cellPolygon(i);
      if (cell3)
        cell3.index = i, yield cell3;
    }
  }
  cellPolygon(i) {
    const polygon = new Polygon();
    this.renderCell(i, polygon);
    return polygon.value();
  }
  _renderSegment(x06, y06, x12, y12, context) {
    let S2;
    const c0 = this._regioncode(x06, y06);
    const c1 = this._regioncode(x12, y12);
    if (c0 === 0 && c1 === 0) {
      context.moveTo(x06, y06);
      context.lineTo(x12, y12);
    } else if (S2 = this._clipSegment(x06, y06, x12, y12, c0, c1)) {
      context.moveTo(S2[0], S2[1]);
      context.lineTo(S2[2], S2[3]);
    }
  }
  contains(i, x4, y4) {
    if ((x4 = +x4, x4 !== x4) || (y4 = +y4, y4 !== y4))
      return false;
    return this.delaunay._step(i, x4, y4) === i;
  }
  *neighbors(i) {
    const ci = this._clip(i);
    if (ci)
      for (const j2 of this.delaunay.neighbors(i)) {
        const cj = this._clip(j2);
        if (cj)
          loop:
            for (let ai = 0, li = ci.length; ai < li; ai += 2) {
              for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {
                if (ci[ai] === cj[aj] && ci[ai + 1] === cj[aj + 1] && ci[(ai + 2) % li] === cj[(aj + lj - 2) % lj] && ci[(ai + 3) % li] === cj[(aj + lj - 1) % lj]) {
                  yield j2;
                  break loop;
                }
              }
            }
      }
  }
  _cell(i) {
    const { circumcenters, delaunay: { inedges, halfedges, triangles } } = this;
    const e0 = inedges[i];
    if (e0 === -1)
      return null;
    const points2 = [];
    let e = e0;
    do {
      const t = Math.floor(e / 3);
      points2.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i)
        break;
      e = halfedges[e];
    } while (e !== e0 && e !== -1);
    return points2;
  }
  _clip(i) {
    if (i === 0 && this.delaunay.hull.length === 1) {
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    }
    const points2 = this._cell(i);
    if (points2 === null)
      return null;
    const { vectors: V2 } = this;
    const v3 = i * 4;
    return this._simplify(V2[v3] || V2[v3 + 1] ? this._clipInfinite(i, points2, V2[v3], V2[v3 + 1], V2[v3 + 2], V2[v3 + 3]) : this._clipFinite(i, points2));
  }
  _clipFinite(i, points2) {
    const n = points2.length;
    let P2 = null;
    let x06, y06, x12 = points2[n - 2], y12 = points2[n - 1];
    let c0, c1 = this._regioncode(x12, y12);
    let e0, e1 = 0;
    for (let j2 = 0; j2 < n; j2 += 2) {
      x06 = x12, y06 = y12, x12 = points2[j2], y12 = points2[j2 + 1];
      c0 = c1, c1 = this._regioncode(x12, y12);
      if (c0 === 0 && c1 === 0) {
        e0 = e1, e1 = 0;
        if (P2)
          P2.push(x12, y12);
        else
          P2 = [x12, y12];
      } else {
        let S2, sx0, sy0, sx1, sy1;
        if (c0 === 0) {
          if ((S2 = this._clipSegment(x06, y06, x12, y12, c0, c1)) === null)
            continue;
          [sx0, sy0, sx1, sy1] = S2;
        } else {
          if ((S2 = this._clipSegment(x12, y12, x06, y06, c1, c0)) === null)
            continue;
          [sx1, sy1, sx0, sy0] = S2;
          e0 = e1, e1 = this._edgecode(sx0, sy0);
          if (e0 && e1)
            this._edge(i, e0, e1, P2, P2.length);
          if (P2)
            P2.push(sx0, sy0);
          else
            P2 = [sx0, sy0];
        }
        e0 = e1, e1 = this._edgecode(sx1, sy1);
        if (e0 && e1)
          this._edge(i, e0, e1, P2, P2.length);
        if (P2)
          P2.push(sx1, sy1);
        else
          P2 = [sx1, sy1];
      }
    }
    if (P2) {
      e0 = e1, e1 = this._edgecode(P2[0], P2[1]);
      if (e0 && e1)
        this._edge(i, e0, e1, P2, P2.length);
    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    }
    return P2;
  }
  _clipSegment(x06, y06, x12, y12, c0, c1) {
    const flip2 = c0 < c1;
    if (flip2)
      [x06, y06, x12, y12, c0, c1] = [x12, y12, x06, y06, c1, c0];
    while (true) {
      if (c0 === 0 && c1 === 0)
        return flip2 ? [x12, y12, x06, y06] : [x06, y06, x12, y12];
      if (c0 & c1)
        return null;
      let x4, y4, c4 = c0 || c1;
      if (c4 & 8)
        x4 = x06 + (x12 - x06) * (this.ymax - y06) / (y12 - y06), y4 = this.ymax;
      else if (c4 & 4)
        x4 = x06 + (x12 - x06) * (this.ymin - y06) / (y12 - y06), y4 = this.ymin;
      else if (c4 & 2)
        y4 = y06 + (y12 - y06) * (this.xmax - x06) / (x12 - x06), x4 = this.xmax;
      else
        y4 = y06 + (y12 - y06) * (this.xmin - x06) / (x12 - x06), x4 = this.xmin;
      if (c0)
        x06 = x4, y06 = y4, c0 = this._regioncode(x06, y06);
      else
        x12 = x4, y12 = y4, c1 = this._regioncode(x12, y12);
    }
  }
  _clipInfinite(i, points2, vx0, vy0, vxn, vyn) {
    let P2 = Array.from(points2), p2;
    if (p2 = this._project(P2[0], P2[1], vx0, vy0))
      P2.unshift(p2[0], p2[1]);
    if (p2 = this._project(P2[P2.length - 2], P2[P2.length - 1], vxn, vyn))
      P2.push(p2[0], p2[1]);
    if (P2 = this._clipFinite(i, P2)) {
      for (let j2 = 0, n = P2.length, c0, c1 = this._edgecode(P2[n - 2], P2[n - 1]); j2 < n; j2 += 2) {
        c0 = c1, c1 = this._edgecode(P2[j2], P2[j2 + 1]);
        if (c0 && c1)
          j2 = this._edge(i, c0, c1, P2, j2), n = P2.length;
      }
    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
      P2 = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];
    }
    return P2;
  }
  _edge(i, e0, e1, P2, j2) {
    while (e0 !== e1) {
      let x4, y4;
      switch (e0) {
        case 5:
          e0 = 4;
          continue;
        case 4:
          e0 = 6, x4 = this.xmax, y4 = this.ymin;
          break;
        case 6:
          e0 = 2;
          continue;
        case 2:
          e0 = 10, x4 = this.xmax, y4 = this.ymax;
          break;
        case 10:
          e0 = 8;
          continue;
        case 8:
          e0 = 9, x4 = this.xmin, y4 = this.ymax;
          break;
        case 9:
          e0 = 1;
          continue;
        case 1:
          e0 = 5, x4 = this.xmin, y4 = this.ymin;
          break;
      }
      if ((P2[j2] !== x4 || P2[j2 + 1] !== y4) && this.contains(i, x4, y4)) {
        P2.splice(j2, 0, x4, y4), j2 += 2;
      }
    }
    return j2;
  }
  _project(x06, y06, vx, vy) {
    let t = Infinity, c4, x4, y4;
    if (vy < 0) {
      if (y06 <= this.ymin)
        return null;
      if ((c4 = (this.ymin - y06) / vy) < t)
        y4 = this.ymin, x4 = x06 + (t = c4) * vx;
    } else if (vy > 0) {
      if (y06 >= this.ymax)
        return null;
      if ((c4 = (this.ymax - y06) / vy) < t)
        y4 = this.ymax, x4 = x06 + (t = c4) * vx;
    }
    if (vx > 0) {
      if (x06 >= this.xmax)
        return null;
      if ((c4 = (this.xmax - x06) / vx) < t)
        x4 = this.xmax, y4 = y06 + (t = c4) * vy;
    } else if (vx < 0) {
      if (x06 <= this.xmin)
        return null;
      if ((c4 = (this.xmin - x06) / vx) < t)
        x4 = this.xmin, y4 = y06 + (t = c4) * vy;
    }
    return [x4, y4];
  }
  _edgecode(x4, y4) {
    return (x4 === this.xmin ? 1 : x4 === this.xmax ? 2 : 0) | (y4 === this.ymin ? 4 : y4 === this.ymax ? 8 : 0);
  }
  _regioncode(x4, y4) {
    return (x4 < this.xmin ? 1 : x4 > this.xmax ? 2 : 0) | (y4 < this.ymin ? 4 : y4 > this.ymax ? 8 : 0);
  }
  _simplify(P2) {
    if (P2 && P2.length > 4) {
      for (let i = 0; i < P2.length; i += 2) {
        const j2 = (i + 2) % P2.length, k3 = (i + 4) % P2.length;
        if (P2[i] === P2[j2] && P2[j2] === P2[k3] || P2[i + 1] === P2[j2 + 1] && P2[j2 + 1] === P2[k3 + 1]) {
          P2.splice(j2, 2), i -= 2;
        }
      }
      if (!P2.length)
        P2 = null;
    }
    return P2;
  }
};

// ../../node_modules/d3-delaunay/src/delaunay.js
var tau2 = 2 * Math.PI;
var pow = Math.pow;
function pointX(p2) {
  return p2[0];
}
function pointY(p2) {
  return p2[1];
}
function collinear2(d) {
  const { triangles, coords } = d;
  for (let i = 0; i < triangles.length; i += 3) {
    const a3 = 2 * triangles[i], b2 = 2 * triangles[i + 1], c4 = 2 * triangles[i + 2], cross3 = (coords[c4] - coords[a3]) * (coords[b2 + 1] - coords[a3 + 1]) - (coords[b2] - coords[a3]) * (coords[c4 + 1] - coords[a3 + 1]);
    if (cross3 > 1e-10)
      return false;
  }
  return true;
}
function jitter(x4, y4, r) {
  return [x4 + Math.sin(x4 + y4) * r, y4 + Math.cos(x4 - y4) * r];
}
var Delaunay = class _Delaunay {
  static from(points2, fx = pointX, fy = pointY, that) {
    return new _Delaunay("length" in points2 ? flatArray(points2, fx, fy, that) : Float64Array.from(flatIterable(points2, fx, fy, that)));
  }
  constructor(points2) {
    this._delaunator = new Delaunator(points2);
    this.inedges = new Int32Array(points2.length / 2);
    this._hullIndex = new Int32Array(points2.length / 2);
    this.points = this._delaunator.coords;
    this._init();
  }
  update() {
    this._delaunator.update();
    this._init();
    return this;
  }
  _init() {
    const d = this._delaunator, points2 = this.points;
    if (d.hull && d.hull.length > 2 && collinear2(d)) {
      this.collinear = Int32Array.from({ length: points2.length / 2 }, (_2, i) => i).sort((i, j2) => points2[2 * i] - points2[2 * j2] || points2[2 * i + 1] - points2[2 * j2 + 1]);
      const e = this.collinear[0], f2 = this.collinear[this.collinear.length - 1], bounds = [points2[2 * e], points2[2 * e + 1], points2[2 * f2], points2[2 * f2 + 1]], r = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);
      for (let i = 0, n = points2.length / 2; i < n; ++i) {
        const p2 = jitter(points2[2 * i], points2[2 * i + 1], r);
        points2[2 * i] = p2[0];
        points2[2 * i + 1] = p2[1];
      }
      this._delaunator = new Delaunator(points2);
    } else {
      delete this.collinear;
    }
    const halfedges = this.halfedges = this._delaunator.halfedges;
    const hull3 = this.hull = this._delaunator.hull;
    const triangles = this.triangles = this._delaunator.triangles;
    const inedges = this.inedges.fill(-1);
    const hullIndex = this._hullIndex.fill(-1);
    for (let e = 0, n = halfedges.length; e < n; ++e) {
      const p2 = triangles[e % 3 === 2 ? e - 2 : e + 1];
      if (halfedges[e] === -1 || inedges[p2] === -1)
        inedges[p2] = e;
    }
    for (let i = 0, n = hull3.length; i < n; ++i) {
      hullIndex[hull3[i]] = i;
    }
    if (hull3.length <= 2 && hull3.length > 0) {
      this.triangles = new Int32Array(3).fill(-1);
      this.halfedges = new Int32Array(3).fill(-1);
      this.triangles[0] = hull3[0];
      inedges[hull3[0]] = 1;
      if (hull3.length === 2) {
        inedges[hull3[1]] = 0;
        this.triangles[1] = hull3[1];
        this.triangles[2] = hull3[1];
      }
    }
  }
  voronoi(bounds) {
    return new Voronoi(this, bounds);
  }
  *neighbors(i) {
    const { inedges, hull: hull3, _hullIndex, halfedges, triangles, collinear: collinear3 } = this;
    if (collinear3) {
      const l = collinear3.indexOf(i);
      if (l > 0)
        yield collinear3[l - 1];
      if (l < collinear3.length - 1)
        yield collinear3[l + 1];
      return;
    }
    const e0 = inedges[i];
    if (e0 === -1)
      return;
    let e = e0, p0 = -1;
    do {
      yield p0 = triangles[e];
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i)
        return;
      e = halfedges[e];
      if (e === -1) {
        const p2 = hull3[(_hullIndex[i] + 1) % hull3.length];
        if (p2 !== p0)
          yield p2;
        return;
      }
    } while (e !== e0);
  }
  find(x4, y4, i = 0) {
    if ((x4 = +x4, x4 !== x4) || (y4 = +y4, y4 !== y4))
      return -1;
    const i0 = i;
    let c4;
    while ((c4 = this._step(i, x4, y4)) >= 0 && c4 !== i && c4 !== i0)
      i = c4;
    return c4;
  }
  _step(i, x4, y4) {
    const { inedges, hull: hull3, _hullIndex, halfedges, triangles, points: points2 } = this;
    if (inedges[i] === -1 || !points2.length)
      return (i + 1) % (points2.length >> 1);
    let c4 = i;
    let dc = pow(x4 - points2[i * 2], 2) + pow(y4 - points2[i * 2 + 1], 2);
    const e0 = inedges[i];
    let e = e0;
    do {
      let t = triangles[e];
      const dt = pow(x4 - points2[t * 2], 2) + pow(y4 - points2[t * 2 + 1], 2);
      if (dt < dc)
        dc = dt, c4 = t;
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i)
        break;
      e = halfedges[e];
      if (e === -1) {
        e = hull3[(_hullIndex[i] + 1) % hull3.length];
        if (e !== t) {
          if (pow(x4 - points2[e * 2], 2) + pow(y4 - points2[e * 2 + 1], 2) < dc)
            return e;
        }
        break;
      }
    } while (e !== e0);
    return c4;
  }
  render(context) {
    const buffer = context == null ? context = new Path2() : void 0;
    const { points: points2, halfedges, triangles } = this;
    for (let i = 0, n = halfedges.length; i < n; ++i) {
      const j2 = halfedges[i];
      if (j2 < i)
        continue;
      const ti = triangles[i] * 2;
      const tj = triangles[j2] * 2;
      context.moveTo(points2[ti], points2[ti + 1]);
      context.lineTo(points2[tj], points2[tj + 1]);
    }
    this.renderHull(context);
    return buffer && buffer.value();
  }
  renderPoints(context, r) {
    if (r === void 0 && (!context || typeof context.moveTo !== "function"))
      r = context, context = null;
    r = r == void 0 ? 2 : +r;
    const buffer = context == null ? context = new Path2() : void 0;
    const { points: points2 } = this;
    for (let i = 0, n = points2.length; i < n; i += 2) {
      const x4 = points2[i], y4 = points2[i + 1];
      context.moveTo(x4 + r, y4);
      context.arc(x4, y4, r, 0, tau2);
    }
    return buffer && buffer.value();
  }
  renderHull(context) {
    const buffer = context == null ? context = new Path2() : void 0;
    const { hull: hull3, points: points2 } = this;
    const h2 = hull3[0] * 2, n = hull3.length;
    context.moveTo(points2[h2], points2[h2 + 1]);
    for (let i = 1; i < n; ++i) {
      const h3 = 2 * hull3[i];
      context.lineTo(points2[h3], points2[h3 + 1]);
    }
    context.closePath();
    return buffer && buffer.value();
  }
  hullPolygon() {
    const polygon = new Polygon();
    this.renderHull(polygon);
    return polygon.value();
  }
  renderTriangle(i, context) {
    const buffer = context == null ? context = new Path2() : void 0;
    const { points: points2, triangles } = this;
    const t03 = triangles[i *= 3] * 2;
    const t13 = triangles[i + 1] * 2;
    const t22 = triangles[i + 2] * 2;
    context.moveTo(points2[t03], points2[t03 + 1]);
    context.lineTo(points2[t13], points2[t13 + 1]);
    context.lineTo(points2[t22], points2[t22 + 1]);
    context.closePath();
    return buffer && buffer.value();
  }
  *trianglePolygons() {
    const { triangles } = this;
    for (let i = 0, n = triangles.length / 3; i < n; ++i) {
      yield this.trianglePolygon(i);
    }
  }
  trianglePolygon(i) {
    const polygon = new Polygon();
    this.renderTriangle(i, polygon);
    return polygon.value();
  }
};
function flatArray(points2, fx, fy, that) {
  const n = points2.length;
  const array4 = new Float64Array(n * 2);
  for (let i = 0; i < n; ++i) {
    const p2 = points2[i];
    array4[i * 2] = fx.call(that, p2, i, points2);
    array4[i * 2 + 1] = fy.call(that, p2, i, points2);
  }
  return array4;
}
function* flatIterable(points2, fx, fy, that) {
  let i = 0;
  for (const p2 of points2) {
    yield fx.call(that, p2, i, points2);
    yield fy.call(that, p2, i, points2);
    ++i;
  }
}

// ../../node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default(x4) {
  return Math.abs(x4 = Math.round(x4)) >= 1e21 ? x4.toLocaleString("en").replace(/,/g, "") : x4.toString(10);
}
function formatDecimalParts(x4, p2) {
  if ((i = (x4 = p2 ? x4.toExponential(p2 - 1) : x4.toExponential()).indexOf("e")) < 0)
    return null;
  var i, coefficient = x4.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x4.slice(i + 1)
  ];
}

// ../../node_modules/d3-format/src/exponent.js
function exponent_default(x4) {
  return x4 = formatDecimalParts(Math.abs(x4)), x4 ? x4[1] : NaN;
}

// ../../node_modules/d3-format/src/formatGroup.js
function formatGroup_default(grouping, thousands) {
  return function(value, width2) {
    var i = value.length, t = [], j2 = 0, g2 = grouping[0], length4 = 0;
    while (i > 0 && g2 > 0) {
      if (length4 + g2 + 1 > width2)
        g2 = Math.max(1, width2 - length4);
      t.push(value.substring(i -= g2, i + g2));
      if ((length4 += g2 + 1) > width2)
        break;
      g2 = grouping[j2 = (j2 + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}

// ../../node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

// ../../node_modules/d3-format/src/formatSpecifier.js
var re2 = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re2.exec(specifier)))
    throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};

// ../../node_modules/d3-format/src/formatTrim.js
function formatTrim_default(s2) {
  out:
    for (var n = s2.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s2[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          if (i0 === 0)
            i0 = i;
          i1 = i;
          break;
        default:
          if (!+s2[i])
            break out;
          if (i0 > 0)
            i0 = 0;
          break;
      }
    }
  return i0 > 0 ? s2.slice(0, i0) + s2.slice(i1 + 1) : s2;
}

// ../../node_modules/d3-format/src/formatPrefixAuto.js
var prefixExponent;
function formatPrefixAuto_default(x4, p2) {
  var d = formatDecimalParts(x4, p2);
  if (!d)
    return x4 + "";
  var coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x4, Math.max(0, p2 + i - 1))[0];
}

// ../../node_modules/d3-format/src/formatRounded.js
function formatRounded_default(x4, p2) {
  var d = formatDecimalParts(x4, p2);
  if (!d)
    return x4 + "";
  var coefficient = d[0], exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

// ../../node_modules/d3-format/src/formatTypes.js
var formatTypes_default = {
  "%": (x4, p2) => (x4 * 100).toFixed(p2),
  "b": (x4) => Math.round(x4).toString(2),
  "c": (x4) => x4 + "",
  "d": formatDecimal_default,
  "e": (x4, p2) => x4.toExponential(p2),
  "f": (x4, p2) => x4.toFixed(p2),
  "g": (x4, p2) => x4.toPrecision(p2),
  "o": (x4) => Math.round(x4).toString(8),
  "p": (x4, p2) => formatRounded_default(x4 * 100, p2),
  "r": formatRounded_default,
  "s": formatPrefixAuto_default,
  "X": (x4) => Math.round(x4).toString(16).toUpperCase(),
  "x": (x4) => Math.round(x4).toString(16)
};

// ../../node_modules/d3-format/src/identity.js
function identity_default2(x4) {
  return x4;
}

// ../../node_modules/d3-format/src/locale.js
var map = Array.prototype.map;
var prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function locale_default(locale3) {
  var group3 = locale3.grouping === void 0 || locale3.thousands === void 0 ? identity_default2 : formatGroup_default(map.call(locale3.grouping, Number), locale3.thousands + ""), currencyPrefix = locale3.currency === void 0 ? "" : locale3.currency[0] + "", currencySuffix = locale3.currency === void 0 ? "" : locale3.currency[1] + "", decimal = locale3.decimal === void 0 ? "." : locale3.decimal + "", numerals = locale3.numerals === void 0 ? identity_default2 : formatNumerals_default(map.call(locale3.numerals, String)), percent = locale3.percent === void 0 ? "%" : locale3.percent + "", minus = locale3.minus === void 0 ? "\u2212" : locale3.minus + "", nan = locale3.nan === void 0 ? "NaN" : locale3.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align2 = specifier.align, sign3 = specifier.sign, symbol2 = specifier.symbol, zero3 = specifier.zero, width2 = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type2 = specifier.type;
    if (type2 === "n")
      comma = true, type2 = "g";
    else if (!formatTypes_default[type2])
      precision === void 0 && (precision = 12), trim = true, type2 = "g";
    if (zero3 || fill === "0" && align2 === "=")
      zero3 = true, fill = "0", align2 = "=";
    var prefix2 = symbol2 === "$" ? currencyPrefix : symbol2 === "#" && /[boxX]/.test(type2) ? "0" + type2.toLowerCase() : "", suffix2 = symbol2 === "$" ? currencySuffix : /[%p]/.test(type2) ? percent : "";
    var formatType = formatTypes_default[type2], maybeSuffix = /[defgprs%]/.test(type2);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type2) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format3(value) {
      var valuePrefix = prefix2, valueSuffix = suffix2, i, n, c4;
      if (type2 === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        var valueNegative = value < 0 || 1 / value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
        if (trim)
          value = formatTrim_default(value);
        if (valueNegative && +value === 0 && sign3 !== "+")
          valueNegative = false;
        valuePrefix = (valueNegative ? sign3 === "(" ? sign3 : minus : sign3 === "-" || sign3 === "(" ? "" : sign3) + valuePrefix;
        valueSuffix = (type2 === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign3 === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c4 = value.charCodeAt(i), 48 > c4 || c4 > 57) {
              valueSuffix = (c4 === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero3)
        value = group3(value, Infinity);
      var length4 = valuePrefix.length + value.length + valueSuffix.length, padding2 = length4 < width2 ? new Array(width2 - length4 + 1).join(fill) : "";
      if (comma && zero3)
        value = group3(padding2 + value, padding2.length ? width2 - valueSuffix.length : Infinity), padding2 = "";
      switch (align2) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding2;
          break;
        case "=":
          value = valuePrefix + padding2 + value + valueSuffix;
          break;
        case "^":
          value = padding2.slice(0, length4 = padding2.length >> 1) + valuePrefix + value + valueSuffix + padding2.slice(length4);
          break;
        default:
          value = padding2 + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format3.toString = function() {
      return specifier + "";
    };
    return format3;
  }
  function formatPrefix2(specifier, value) {
    var f2 = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3, k3 = Math.pow(10, -e), prefix2 = prefixes[8 + e / 3];
    return function(value2) {
      return f2(k3 * value2) + prefix2;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}

// ../../node_modules/d3-format/src/defaultLocale.js
var locale;
var format;
var formatPrefix;
defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale(definition) {
  locale = locale_default(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}

// ../../node_modules/d3-format/src/precisionFixed.js
function precisionFixed_default(step) {
  return Math.max(0, -exponent_default(Math.abs(step)));
}

// ../../node_modules/d3-format/src/precisionPrefix.js
function precisionPrefix_default(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3 - exponent_default(Math.abs(step)));
}

// ../../node_modules/d3-format/src/precisionRound.js
function precisionRound_default(step, max4) {
  step = Math.abs(step), max4 = Math.abs(max4) - step;
  return Math.max(0, exponent_default(max4) - exponent_default(step)) + 1;
}

// ../../node_modules/d3-geo/src/math.js
var epsilon6 = 1e-6;
var epsilon22 = 1e-12;
var pi2 = Math.PI;
var halfPi = pi2 / 2;
var quarterPi = pi2 / 4;
var tau3 = pi2 * 2;
var degrees3 = 180 / pi2;
var radians2 = pi2 / 180;
var abs2 = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var cos = Math.cos;
var ceil = Math.ceil;
var exp = Math.exp;
var hypot = Math.hypot;
var log = Math.log;
var pow2 = Math.pow;
var sin = Math.sin;
var sign = Math.sign || function(x4) {
  return x4 > 0 ? 1 : x4 < 0 ? -1 : 0;
};
var sqrt = Math.sqrt;
var tan = Math.tan;
function acos(x4) {
  return x4 > 1 ? 0 : x4 < -1 ? pi2 : Math.acos(x4);
}
function asin(x4) {
  return x4 > 1 ? halfPi : x4 < -1 ? -halfPi : Math.asin(x4);
}

// ../../node_modules/d3-geo/src/noop.js
function noop2() {
}

// ../../node_modules/d3-geo/src/stream.js
function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}
var streamObjectType = {
  Feature: function(object, stream) {
    streamGeometry(object.geometry, stream);
  },
  FeatureCollection: function(object, stream) {
    var features = object.features, i = -1, n = features.length;
    while (++i < n)
      streamGeometry(features[i].geometry, stream);
  }
};
var streamGeometryType = {
  Sphere: function(object, stream) {
    stream.sphere();
  },
  Point: function(object, stream) {
    object = object.coordinates;
    stream.point(object[0], object[1], object[2]);
  },
  MultiPoint: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n)
      object = coordinates[i], stream.point(object[0], object[1], object[2]);
  },
  LineString: function(object, stream) {
    streamLine(object.coordinates, stream, 0);
  },
  MultiLineString: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n)
      streamLine(coordinates[i], stream, 0);
  },
  Polygon: function(object, stream) {
    streamPolygon(object.coordinates, stream);
  },
  MultiPolygon: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n)
      streamPolygon(coordinates[i], stream);
  },
  GeometryCollection: function(object, stream) {
    var geometries = object.geometries, i = -1, n = geometries.length;
    while (++i < n)
      streamGeometry(geometries[i], stream);
  }
};
function streamLine(coordinates, stream, closed) {
  var i = -1, n = coordinates.length - closed, coordinate;
  stream.lineStart();
  while (++i < n)
    coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}
function streamPolygon(coordinates, stream) {
  var i = -1, n = coordinates.length;
  stream.polygonStart();
  while (++i < n)
    streamLine(coordinates[i], stream, 1);
  stream.polygonEnd();
}
function stream_default(object, stream) {
  if (object && streamObjectType.hasOwnProperty(object.type)) {
    streamObjectType[object.type](object, stream);
  } else {
    streamGeometry(object, stream);
  }
}

// ../../node_modules/d3-geo/src/cartesian.js
function spherical(cartesian2) {
  return [atan2(cartesian2[1], cartesian2[0]), asin(cartesian2[2])];
}
function cartesian(spherical2) {
  var lambda = spherical2[0], phi = spherical2[1], cosPhi = cos(phi);
  return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];
}
function cartesianDot(a3, b2) {
  return a3[0] * b2[0] + a3[1] * b2[1] + a3[2] * b2[2];
}
function cartesianCross(a3, b2) {
  return [a3[1] * b2[2] - a3[2] * b2[1], a3[2] * b2[0] - a3[0] * b2[2], a3[0] * b2[1] - a3[1] * b2[0]];
}
function cartesianAddInPlace(a3, b2) {
  a3[0] += b2[0], a3[1] += b2[1], a3[2] += b2[2];
}
function cartesianScale(vector3, k3) {
  return [vector3[0] * k3, vector3[1] * k3, vector3[2] * k3];
}
function cartesianNormalizeInPlace(d) {
  var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}

// ../../node_modules/d3-geo/src/centroid.js
var W0;
var W1;
var X0;
var Y0;
var Z0;
var X1;
var Y1;
var Z1;
var X22;
var Y22;
var Z2;
var lambda00;
var phi00;
var x0;
var y0;
var z0;
var centroidStream = {
  sphere: noop2,
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  }
};
function centroidPoint(lambda, phi) {
  lambda *= radians2, phi *= radians2;
  var cosPhi = cos(phi);
  centroidPointCartesian(cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi));
}
function centroidPointCartesian(x4, y4, z2) {
  ++W0;
  X0 += (x4 - X0) / W0;
  Y0 += (y4 - Y0) / W0;
  Z0 += (z2 - Z0) / W0;
}
function centroidLineStart() {
  centroidStream.point = centroidLinePointFirst;
}
function centroidLinePointFirst(lambda, phi) {
  lambda *= radians2, phi *= radians2;
  var cosPhi = cos(phi);
  x0 = cosPhi * cos(lambda);
  y0 = cosPhi * sin(lambda);
  z0 = sin(phi);
  centroidStream.point = centroidLinePoint;
  centroidPointCartesian(x0, y0, z0);
}
function centroidLinePoint(lambda, phi) {
  lambda *= radians2, phi *= radians2;
  var cosPhi = cos(phi), x4 = cosPhi * cos(lambda), y4 = cosPhi * sin(lambda), z2 = sin(phi), w = atan2(sqrt((w = y0 * z2 - z0 * y4) * w + (w = z0 * x4 - x0 * z2) * w + (w = x0 * y4 - y0 * x4) * w), x0 * x4 + y0 * y4 + z0 * z2);
  W1 += w;
  X1 += w * (x0 + (x0 = x4));
  Y1 += w * (y0 + (y0 = y4));
  Z1 += w * (z0 + (z0 = z2));
  centroidPointCartesian(x0, y0, z0);
}
function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}
function centroidRingStart() {
  centroidStream.point = centroidRingPointFirst;
}
function centroidRingEnd() {
  centroidRingPoint(lambda00, phi00);
  centroidStream.point = centroidPoint;
}
function centroidRingPointFirst(lambda, phi) {
  lambda00 = lambda, phi00 = phi;
  lambda *= radians2, phi *= radians2;
  centroidStream.point = centroidRingPoint;
  var cosPhi = cos(phi);
  x0 = cosPhi * cos(lambda);
  y0 = cosPhi * sin(lambda);
  z0 = sin(phi);
  centroidPointCartesian(x0, y0, z0);
}
function centroidRingPoint(lambda, phi) {
  lambda *= radians2, phi *= radians2;
  var cosPhi = cos(phi), x4 = cosPhi * cos(lambda), y4 = cosPhi * sin(lambda), z2 = sin(phi), cx = y0 * z2 - z0 * y4, cy = z0 * x4 - x0 * z2, cz = x0 * y4 - y0 * x4, m2 = hypot(cx, cy, cz), w = asin(m2), v3 = m2 && -w / m2;
  X22.add(v3 * cx);
  Y22.add(v3 * cy);
  Z2.add(v3 * cz);
  W1 += w;
  X1 += w * (x0 + (x0 = x4));
  Y1 += w * (y0 + (y0 = y4));
  Z1 += w * (z0 + (z0 = z2));
  centroidPointCartesian(x0, y0, z0);
}
function centroid_default(object) {
  W0 = W1 = X0 = Y0 = Z0 = X1 = Y1 = Z1 = 0;
  X22 = new Adder();
  Y22 = new Adder();
  Z2 = new Adder();
  stream_default(object, centroidStream);
  var x4 = +X22, y4 = +Y22, z2 = +Z2, m2 = hypot(x4, y4, z2);
  if (m2 < epsilon22) {
    x4 = X1, y4 = Y1, z2 = Z1;
    if (W1 < epsilon6)
      x4 = X0, y4 = Y0, z2 = Z0;
    m2 = hypot(x4, y4, z2);
    if (m2 < epsilon22)
      return [NaN, NaN];
  }
  return [atan2(y4, x4) * degrees3, asin(z2 / m2) * degrees3];
}

// ../../node_modules/d3-geo/src/compose.js
function compose_default(a3, b2) {
  function compose(x4, y4) {
    return x4 = a3(x4, y4), b2(x4[0], x4[1]);
  }
  if (a3.invert && b2.invert)
    compose.invert = function(x4, y4) {
      return x4 = b2.invert(x4, y4), x4 && a3.invert(x4[0], x4[1]);
    };
  return compose;
}

// ../../node_modules/d3-geo/src/rotation.js
function rotationIdentity(lambda, phi) {
  if (abs2(lambda) > pi2)
    lambda -= Math.round(lambda / tau3) * tau3;
  return [lambda, phi];
}
rotationIdentity.invert = rotationIdentity;
function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= tau3) ? deltaPhi || deltaGamma ? compose_default(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
}
function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi) {
    lambda += deltaLambda;
    if (abs2(lambda) > pi2)
      lambda -= Math.round(lambda / tau3) * tau3;
    return [lambda, phi];
  };
}
function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}
function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = cos(deltaPhi), sinDeltaPhi = sin(deltaPhi), cosDeltaGamma = cos(deltaGamma), sinDeltaGamma = sin(deltaGamma);
  function rotation(lambda, phi) {
    var cosPhi = cos(phi), x4 = cos(lambda) * cosPhi, y4 = sin(lambda) * cosPhi, z2 = sin(phi), k3 = z2 * cosDeltaPhi + x4 * sinDeltaPhi;
    return [
      atan2(y4 * cosDeltaGamma - k3 * sinDeltaGamma, x4 * cosDeltaPhi - z2 * sinDeltaPhi),
      asin(k3 * cosDeltaGamma + y4 * sinDeltaGamma)
    ];
  }
  rotation.invert = function(lambda, phi) {
    var cosPhi = cos(phi), x4 = cos(lambda) * cosPhi, y4 = sin(lambda) * cosPhi, z2 = sin(phi), k3 = z2 * cosDeltaGamma - y4 * sinDeltaGamma;
    return [
      atan2(y4 * cosDeltaGamma + z2 * sinDeltaGamma, x4 * cosDeltaPhi + k3 * sinDeltaPhi),
      asin(k3 * cosDeltaPhi - x4 * sinDeltaPhi)
    ];
  };
  return rotation;
}
function rotation_default(rotate) {
  rotate = rotateRadians(rotate[0] * radians2, rotate[1] * radians2, rotate.length > 2 ? rotate[2] * radians2 : 0);
  function forward(coordinates) {
    coordinates = rotate(coordinates[0] * radians2, coordinates[1] * radians2);
    return coordinates[0] *= degrees3, coordinates[1] *= degrees3, coordinates;
  }
  forward.invert = function(coordinates) {
    coordinates = rotate.invert(coordinates[0] * radians2, coordinates[1] * radians2);
    return coordinates[0] *= degrees3, coordinates[1] *= degrees3, coordinates;
  };
  return forward;
}

// ../../node_modules/d3-geo/src/circle.js
function circleStream(stream, radius2, delta, direction, t03, t13) {
  if (!delta)
    return;
  var cosRadius = cos(radius2), sinRadius = sin(radius2), step = direction * delta;
  if (t03 == null) {
    t03 = radius2 + direction * tau3;
    t13 = radius2 - step / 2;
  } else {
    t03 = circleRadius(cosRadius, t03);
    t13 = circleRadius(cosRadius, t13);
    if (direction > 0 ? t03 < t13 : t03 > t13)
      t03 += direction * tau3;
  }
  for (var point6, t = t03; direction > 0 ? t > t13 : t < t13; t -= step) {
    point6 = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);
    stream.point(point6[0], point6[1]);
  }
}
function circleRadius(cosRadius, point6) {
  point6 = cartesian(point6), point6[0] -= cosRadius;
  cartesianNormalizeInPlace(point6);
  var radius2 = acos(-point6[1]);
  return ((-point6[2] < 0 ? -radius2 : radius2) + tau3 - epsilon6) % tau3;
}

// ../../node_modules/d3-geo/src/clip/buffer.js
function buffer_default() {
  var lines = [], line3;
  return {
    point: function(x4, y4, m2) {
      line3.push([x4, y4, m2]);
    },
    lineStart: function() {
      lines.push(line3 = []);
    },
    lineEnd: noop2,
    rejoin: function() {
      if (lines.length > 1)
        lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line3 = null;
      return result;
    }
  };
}

// ../../node_modules/d3-geo/src/pointEqual.js
function pointEqual_default(a3, b2) {
  return abs2(a3[0] - b2[0]) < epsilon6 && abs2(a3[1] - b2[1]) < epsilon6;
}

// ../../node_modules/d3-geo/src/clip/rejoin.js
function Intersection(point6, points2, other, entry) {
  this.x = point6;
  this.z = points2;
  this.o = other;
  this.e = entry;
  this.v = false;
  this.n = this.p = null;
}
function rejoin_default(segments, compareIntersection2, startInside, interpolate, stream) {
  var subject = [], clip = [], i, n;
  segments.forEach(function(segment) {
    if ((n2 = segment.length - 1) <= 0)
      return;
    var n2, p0 = segment[0], p1 = segment[n2], x4;
    if (pointEqual_default(p0, p1)) {
      if (!p0[2] && !p1[2]) {
        stream.lineStart();
        for (i = 0; i < n2; ++i)
          stream.point((p0 = segment[i])[0], p0[1]);
        stream.lineEnd();
        return;
      }
      p1[0] += 2 * epsilon6;
    }
    subject.push(x4 = new Intersection(p0, segment, null, true));
    clip.push(x4.o = new Intersection(p0, null, x4, false));
    subject.push(x4 = new Intersection(p1, segment, null, false));
    clip.push(x4.o = new Intersection(p1, null, x4, true));
  });
  if (!subject.length)
    return;
  clip.sort(compareIntersection2);
  link(subject);
  link(clip);
  for (i = 0, n = clip.length; i < n; ++i) {
    clip[i].e = startInside = !startInside;
  }
  var start2 = subject[0], points2, point6;
  while (1) {
    var current = start2, isSubject = true;
    while (current.v)
      if ((current = current.n) === start2)
        return;
    points2 = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points2.length; i < n; ++i)
            stream.point((point6 = points2[i])[0], point6[1]);
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points2 = current.p.z;
          for (i = points2.length - 1; i >= 0; --i)
            stream.point((point6 = points2[i])[0], point6[1]);
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points2 = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}
function link(array4) {
  if (!(n = array4.length))
    return;
  var n, i = 0, a3 = array4[0], b2;
  while (++i < n) {
    a3.n = b2 = array4[i];
    b2.p = a3;
    a3 = b2;
  }
  a3.n = b2 = array4[0];
  b2.p = a3;
}

// ../../node_modules/d3-geo/src/polygonContains.js
function longitude(point6) {
  return abs2(point6[0]) <= pi2 ? point6[0] : sign(point6[0]) * ((abs2(point6[0]) + pi2) % tau3 - pi2);
}
function polygonContains_default(polygon, point6) {
  var lambda = longitude(point6), phi = point6[1], sinPhi = sin(phi), normal = [sin(lambda), -cos(lambda), 0], angle = 0, winding = 0;
  var sum5 = new Adder();
  if (sinPhi === 1)
    phi = halfPi + epsilon6;
  else if (sinPhi === -1)
    phi = -halfPi - epsilon6;
  for (var i = 0, n = polygon.length; i < n; ++i) {
    if (!(m2 = (ring = polygon[i]).length))
      continue;
    var ring, m2, point0 = ring[m2 - 1], lambda0 = longitude(point0), phi0 = point0[1] / 2 + quarterPi, sinPhi0 = sin(phi0), cosPhi0 = cos(phi0);
    for (var j2 = 0; j2 < m2; ++j2, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j2], lambda1 = longitude(point1), phi1 = point1[1] / 2 + quarterPi, sinPhi1 = sin(phi1), cosPhi1 = cos(phi1), delta = lambda1 - lambda0, sign3 = delta >= 0 ? 1 : -1, absDelta = sign3 * delta, antimeridian = absDelta > pi2, k3 = sinPhi0 * sinPhi1;
      sum5.add(atan2(k3 * sign3 * sin(absDelta), cosPhi0 * cosPhi1 + k3 * cos(absDelta)));
      angle += antimeridian ? delta + sign3 * tau3 : delta;
      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = cartesianCross(cartesian(point0), cartesian(point1));
        cartesianNormalizeInPlace(arc);
        var intersection = cartesianCross(normal, arc);
        cartesianNormalizeInPlace(intersection);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);
        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }
  return (angle < -epsilon6 || angle < epsilon6 && sum5 < -epsilon22) ^ winding & 1;
}

// ../../node_modules/d3-geo/src/clip/index.js
function clip_default(pointVisible, clipLine, interpolate, start2) {
  return function(sink) {
    var line3 = clipLine(sink), ringBuffer = buffer_default(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon, segments, ring;
    var clip = {
      point: point6,
      lineStart,
      lineEnd,
      polygonStart: function() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip.point = point6;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = merge(segments);
        var startInside = polygonContains_default(polygon, start2);
        if (segments.length) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          rejoin_default(segments, compareIntersection, startInside, interpolate, sink);
        } else if (startInside) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted)
          sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };
    function point6(lambda, phi) {
      if (pointVisible(lambda, phi))
        sink.point(lambda, phi);
    }
    function pointLine(lambda, phi) {
      line3.point(lambda, phi);
    }
    function lineStart() {
      clip.point = pointLine;
      line3.lineStart();
    }
    function lineEnd() {
      clip.point = point6;
      line3.lineEnd();
    }
    function pointRing(lambda, phi) {
      ring.push([lambda, phi]);
      ringSink.point(lambda, phi);
    }
    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }
    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();
      var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m2, segment, point7;
      ring.pop();
      polygon.push(ring);
      ring = null;
      if (!n)
        return;
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m2 = segment.length - 1) > 0) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i = 0; i < m2; ++i)
            sink.point((point7 = segment[i])[0], point7[1]);
          sink.lineEnd();
        }
        return;
      }
      if (n > 1 && clean & 2)
        ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
      segments.push(ringSegments.filter(validSegment));
    }
    return clip;
  };
}
function validSegment(segment) {
  return segment.length > 1;
}
function compareIntersection(a3, b2) {
  return ((a3 = a3.x)[0] < 0 ? a3[1] - halfPi - epsilon6 : halfPi - a3[1]) - ((b2 = b2.x)[0] < 0 ? b2[1] - halfPi - epsilon6 : halfPi - b2[1]);
}

// ../../node_modules/d3-geo/src/clip/antimeridian.js
var antimeridian_default = clip_default(
  function() {
    return true;
  },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-pi2, -halfPi]
);
function clipAntimeridianLine(stream) {
  var lambda0 = NaN, phi0 = NaN, sign0 = NaN, clean;
  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda1, phi1) {
      var sign1 = lambda1 > 0 ? pi2 : -pi2, delta = abs2(lambda1 - lambda0);
      if (abs2(delta - pi2) < epsilon6) {
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= pi2) {
        if (abs2(lambda0 - sign0) < epsilon6)
          lambda0 -= sign0 * epsilon6;
        if (abs2(lambda1 - sign1) < epsilon6)
          lambda1 -= sign1 * epsilon6;
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        clean = 0;
      }
      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function() {
      return 2 - clean;
    }
  };
}
function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0, cosPhi1, sinLambda0Lambda1 = sin(lambda0 - lambda1);
  return abs2(sinLambda0Lambda1) > epsilon6 ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1) - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;
}
function clipAntimeridianInterpolate(from2, to, direction, stream) {
  var phi;
  if (from2 == null) {
    phi = direction * halfPi;
    stream.point(-pi2, phi);
    stream.point(0, phi);
    stream.point(pi2, phi);
    stream.point(pi2, 0);
    stream.point(pi2, -phi);
    stream.point(0, -phi);
    stream.point(-pi2, -phi);
    stream.point(-pi2, 0);
    stream.point(-pi2, phi);
  } else if (abs2(from2[0] - to[0]) > epsilon6) {
    var lambda = from2[0] < to[0] ? pi2 : -pi2;
    phi = direction * lambda / 2;
    stream.point(-lambda, phi);
    stream.point(0, phi);
    stream.point(lambda, phi);
  } else {
    stream.point(to[0], to[1]);
  }
}

// ../../node_modules/d3-geo/src/clip/circle.js
function circle_default(radius2) {
  var cr = cos(radius2), delta = 6 * radians2, smallRadius = cr > 0, notHemisphere = abs2(cr) > epsilon6;
  function interpolate(from2, to, direction, stream) {
    circleStream(stream, radius2, delta, direction, from2, to);
  }
  function visible(lambda, phi) {
    return cos(lambda) * cos(phi) > cr;
  }
  function clipLine(stream) {
    var point0, c0, v0, v00, clean;
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi) {
        var point1 = [lambda, phi], point22, v3 = visible(lambda, phi), c4 = smallRadius ? v3 ? 0 : code(lambda, phi) : v3 ? code(lambda + (lambda < 0 ? pi2 : -pi2), phi) : 0;
        if (!point0 && (v00 = v0 = v3))
          stream.lineStart();
        if (v3 !== v0) {
          point22 = intersect(point0, point1);
          if (!point22 || pointEqual_default(point0, point22) || pointEqual_default(point1, point22))
            point1[2] = 1;
        }
        if (v3 !== v0) {
          clean = 0;
          if (v3) {
            stream.lineStart();
            point22 = intersect(point1, point0);
            stream.point(point22[0], point22[1]);
          } else {
            point22 = intersect(point0, point1);
            stream.point(point22[0], point22[1], 2);
            stream.lineEnd();
          }
          point0 = point22;
        } else if (notHemisphere && point0 && smallRadius ^ v3) {
          var t;
          if (!(c4 & c0) && (t = intersect(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t[0][0], t[0][1], 3);
            }
          }
        }
        if (v3 && (!point0 || !pointEqual_default(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v3, c0 = c4;
      },
      lineEnd: function() {
        if (v0)
          stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return clean | (v00 && v0) << 1;
      }
    };
  }
  function intersect(a3, b2, two) {
    var pa = cartesian(a3), pb = cartesian(b2);
    var n1 = [1, 0, 0], n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
    if (!determinant)
      return !two && a3;
    var c1 = cr * n2n2 / determinant, c22 = -cr * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A5 = cartesianScale(n1, c1), B3 = cartesianScale(n2, c22);
    cartesianAddInPlace(A5, B3);
    var u4 = n1xn2, w = cartesianDot(A5, u4), uu = cartesianDot(u4, u4), t22 = w * w - uu * (cartesianDot(A5, A5) - 1);
    if (t22 < 0)
      return;
    var t = sqrt(t22), q2 = cartesianScale(u4, (-w - t) / uu);
    cartesianAddInPlace(q2, A5);
    q2 = spherical(q2);
    if (!two)
      return q2;
    var lambda0 = a3[0], lambda1 = b2[0], phi0 = a3[1], phi1 = b2[1], z2;
    if (lambda1 < lambda0)
      z2 = lambda0, lambda0 = lambda1, lambda1 = z2;
    var delta2 = lambda1 - lambda0, polar = abs2(delta2 - pi2) < epsilon6, meridian = polar || delta2 < epsilon6;
    if (!polar && phi1 < phi0)
      z2 = phi0, phi0 = phi1, phi1 = z2;
    if (meridian ? polar ? phi0 + phi1 > 0 ^ q2[1] < (abs2(q2[0] - lambda0) < epsilon6 ? phi0 : phi1) : phi0 <= q2[1] && q2[1] <= phi1 : delta2 > pi2 ^ (lambda0 <= q2[0] && q2[0] <= lambda1)) {
      var q1 = cartesianScale(u4, (-w + t) / uu);
      cartesianAddInPlace(q1, A5);
      return [q2, spherical(q1)];
    }
  }
  function code(lambda, phi) {
    var r = smallRadius ? radius2 : pi2 - radius2, code2 = 0;
    if (lambda < -r)
      code2 |= 1;
    else if (lambda > r)
      code2 |= 2;
    if (phi < -r)
      code2 |= 4;
    else if (phi > r)
      code2 |= 8;
    return code2;
  }
  return clip_default(visible, clipLine, interpolate, smallRadius ? [0, -radius2] : [-pi2, radius2 - pi2]);
}

// ../../node_modules/d3-geo/src/clip/line.js
function line_default(a3, b2, x06, y06, x12, y12) {
  var ax = a3[0], ay = a3[1], bx = b2[0], by = b2[1], t03 = 0, t13 = 1, dx = bx - ax, dy = by - ay, r;
  r = x06 - ax;
  if (!dx && r > 0)
    return;
  r /= dx;
  if (dx < 0) {
    if (r < t03)
      return;
    if (r < t13)
      t13 = r;
  } else if (dx > 0) {
    if (r > t13)
      return;
    if (r > t03)
      t03 = r;
  }
  r = x12 - ax;
  if (!dx && r < 0)
    return;
  r /= dx;
  if (dx < 0) {
    if (r > t13)
      return;
    if (r > t03)
      t03 = r;
  } else if (dx > 0) {
    if (r < t03)
      return;
    if (r < t13)
      t13 = r;
  }
  r = y06 - ay;
  if (!dy && r > 0)
    return;
  r /= dy;
  if (dy < 0) {
    if (r < t03)
      return;
    if (r < t13)
      t13 = r;
  } else if (dy > 0) {
    if (r > t13)
      return;
    if (r > t03)
      t03 = r;
  }
  r = y12 - ay;
  if (!dy && r < 0)
    return;
  r /= dy;
  if (dy < 0) {
    if (r > t13)
      return;
    if (r > t03)
      t03 = r;
  } else if (dy > 0) {
    if (r < t03)
      return;
    if (r < t13)
      t13 = r;
  }
  if (t03 > 0)
    a3[0] = ax + t03 * dx, a3[1] = ay + t03 * dy;
  if (t13 < 1)
    b2[0] = ax + t13 * dx, b2[1] = ay + t13 * dy;
  return true;
}

// ../../node_modules/d3-geo/src/clip/rectangle.js
var clipMax = 1e9;
var clipMin = -clipMax;
function clipRectangle(x06, y06, x12, y12) {
  function visible(x4, y4) {
    return x06 <= x4 && x4 <= x12 && y06 <= y4 && y4 <= y12;
  }
  function interpolate(from2, to, direction, stream) {
    var a3 = 0, a1 = 0;
    if (from2 == null || (a3 = corner(from2, direction)) !== (a1 = corner(to, direction)) || comparePoint(from2, to) < 0 ^ direction > 0) {
      do
        stream.point(a3 === 0 || a3 === 3 ? x06 : x12, a3 > 1 ? y12 : y06);
      while ((a3 = (a3 + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }
  function corner(p2, direction) {
    return abs2(p2[0] - x06) < epsilon6 ? direction > 0 ? 0 : 3 : abs2(p2[0] - x12) < epsilon6 ? direction > 0 ? 2 : 1 : abs2(p2[1] - y06) < epsilon6 ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
  }
  function compareIntersection2(a3, b2) {
    return comparePoint(a3.x, b2.x);
  }
  function comparePoint(a3, b2) {
    var ca3 = corner(a3, 1), cb = corner(b2, 1);
    return ca3 !== cb ? ca3 - cb : ca3 === 0 ? b2[1] - a3[1] : ca3 === 1 ? a3[0] - b2[0] : ca3 === 2 ? a3[1] - b2[1] : b2[0] - a3[0];
  }
  return function(stream) {
    var activeStream = stream, bufferStream = buffer_default(), segments, polygon, ring, x__, y__, v__, x_, y_, v_, first3, clean;
    var clipStream = {
      point: point6,
      lineStart,
      lineEnd,
      polygonStart,
      polygonEnd
    };
    function point6(x4, y4) {
      if (visible(x4, y4))
        activeStream.point(x4, y4);
    }
    function polygonInside() {
      var winding = 0;
      for (var i = 0, n = polygon.length; i < n; ++i) {
        for (var ring2 = polygon[i], j2 = 1, m2 = ring2.length, point7 = ring2[0], a0, a1, b0 = point7[0], b1 = point7[1]; j2 < m2; ++j2) {
          a0 = b0, a1 = b1, point7 = ring2[j2], b0 = point7[0], b1 = point7[1];
          if (a1 <= y12) {
            if (b1 > y12 && (b0 - a0) * (y12 - a1) > (b1 - a1) * (x06 - a0))
              ++winding;
          } else {
            if (b1 <= y12 && (b0 - a0) * (y12 - a1) < (b1 - a1) * (x06 - a0))
              --winding;
          }
        }
      }
      return winding;
    }
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }
    function polygonEnd() {
      var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments = merge(segments)).length;
      if (cleanInside || visible2) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible2) {
          rejoin_default(segments, compareIntersection2, startInside, interpolate, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon = ring = null;
    }
    function lineStart() {
      clipStream.point = linePoint;
      if (polygon)
        polygon.push(ring = []);
      first3 = true;
      v_ = false;
      x_ = y_ = NaN;
    }
    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_)
          bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point6;
      if (v_)
        activeStream.lineEnd();
    }
    function linePoint(x4, y4) {
      var v3 = visible(x4, y4);
      if (polygon)
        ring.push([x4, y4]);
      if (first3) {
        x__ = x4, y__ = y4, v__ = v3;
        first3 = false;
        if (v3) {
          activeStream.lineStart();
          activeStream.point(x4, y4);
        }
      } else {
        if (v3 && v_)
          activeStream.point(x4, y4);
        else {
          var a3 = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b2 = [x4 = Math.max(clipMin, Math.min(clipMax, x4)), y4 = Math.max(clipMin, Math.min(clipMax, y4))];
          if (line_default(a3, b2, x06, y06, x12, y12)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a3[0], a3[1]);
            }
            activeStream.point(b2[0], b2[1]);
            if (!v3)
              activeStream.lineEnd();
            clean = false;
          } else if (v3) {
            activeStream.lineStart();
            activeStream.point(x4, y4);
            clean = false;
          }
        }
      }
      x_ = x4, y_ = y4, v_ = v3;
    }
    return clipStream;
  };
}

// ../../node_modules/d3-geo/src/graticule.js
function graticuleX(y06, y12, dy) {
  var y4 = range(y06, y12 - epsilon6, dy).concat(y12);
  return function(x4) {
    return y4.map(function(y5) {
      return [x4, y5];
    });
  };
}
function graticuleY(x06, x12, dx) {
  var x4 = range(x06, x12 - epsilon6, dx).concat(x12);
  return function(y4) {
    return x4.map(function(x5) {
      return [x5, y4];
    });
  };
}
function graticule() {
  var x12, x06, X13, X03, y12, y06, Y13, Y03, dx = 10, dy = dx, DX = 90, DY = 360, x4, y4, X3, Y3, precision = 2.5;
  function graticule4() {
    return { type: "MultiLineString", coordinates: lines() };
  }
  function lines() {
    return range(ceil(X03 / DX) * DX, X13, DX).map(X3).concat(range(ceil(Y03 / DY) * DY, Y13, DY).map(Y3)).concat(range(ceil(x06 / dx) * dx, x12, dx).filter(function(x5) {
      return abs2(x5 % DX) > epsilon6;
    }).map(x4)).concat(range(ceil(y06 / dy) * dy, y12, dy).filter(function(y5) {
      return abs2(y5 % DY) > epsilon6;
    }).map(y4));
  }
  graticule4.lines = function() {
    return lines().map(function(coordinates) {
      return { type: "LineString", coordinates };
    });
  };
  graticule4.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        X3(X03).concat(
          Y3(Y13).slice(1),
          X3(X13).reverse().slice(1),
          Y3(Y03).reverse().slice(1)
        )
      ]
    };
  };
  graticule4.extent = function(_2) {
    if (!arguments.length)
      return graticule4.extentMinor();
    return graticule4.extentMajor(_2).extentMinor(_2);
  };
  graticule4.extentMajor = function(_2) {
    if (!arguments.length)
      return [[X03, Y03], [X13, Y13]];
    X03 = +_2[0][0], X13 = +_2[1][0];
    Y03 = +_2[0][1], Y13 = +_2[1][1];
    if (X03 > X13)
      _2 = X03, X03 = X13, X13 = _2;
    if (Y03 > Y13)
      _2 = Y03, Y03 = Y13, Y13 = _2;
    return graticule4.precision(precision);
  };
  graticule4.extentMinor = function(_2) {
    if (!arguments.length)
      return [[x06, y06], [x12, y12]];
    x06 = +_2[0][0], x12 = +_2[1][0];
    y06 = +_2[0][1], y12 = +_2[1][1];
    if (x06 > x12)
      _2 = x06, x06 = x12, x12 = _2;
    if (y06 > y12)
      _2 = y06, y06 = y12, y12 = _2;
    return graticule4.precision(precision);
  };
  graticule4.step = function(_2) {
    if (!arguments.length)
      return graticule4.stepMinor();
    return graticule4.stepMajor(_2).stepMinor(_2);
  };
  graticule4.stepMajor = function(_2) {
    if (!arguments.length)
      return [DX, DY];
    DX = +_2[0], DY = +_2[1];
    return graticule4;
  };
  graticule4.stepMinor = function(_2) {
    if (!arguments.length)
      return [dx, dy];
    dx = +_2[0], dy = +_2[1];
    return graticule4;
  };
  graticule4.precision = function(_2) {
    if (!arguments.length)
      return precision;
    precision = +_2;
    x4 = graticuleX(y06, y12, 90);
    y4 = graticuleY(x06, x12, precision);
    X3 = graticuleX(Y03, Y13, 90);
    Y3 = graticuleY(X03, X13, precision);
    return graticule4;
  };
  return graticule4.extentMajor([[-180, -90 + epsilon6], [180, 90 - epsilon6]]).extentMinor([[-180, -80 - epsilon6], [180, 80 + epsilon6]]);
}
function graticule10() {
  return graticule()();
}

// ../../node_modules/d3-geo/src/identity.js
var identity_default3 = (x4) => x4;

// ../../node_modules/d3-geo/src/path/area.js
var areaSum = new Adder();
var areaRingSum = new Adder();
var x00;
var y00;
var x02;
var y02;
var areaStream = {
  point: noop2,
  lineStart: noop2,
  lineEnd: noop2,
  polygonStart: function() {
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    areaStream.lineStart = areaStream.lineEnd = areaStream.point = noop2;
    areaSum.add(abs2(areaRingSum));
    areaRingSum = new Adder();
  },
  result: function() {
    var area3 = areaSum / 2;
    areaSum = new Adder();
    return area3;
  }
};
function areaRingStart() {
  areaStream.point = areaPointFirst;
}
function areaPointFirst(x4, y4) {
  areaStream.point = areaPoint;
  x00 = x02 = x4, y00 = y02 = y4;
}
function areaPoint(x4, y4) {
  areaRingSum.add(y02 * x4 - x02 * y4);
  x02 = x4, y02 = y4;
}
function areaRingEnd() {
  areaPoint(x00, y00);
}
var area_default2 = areaStream;

// ../../node_modules/d3-geo/src/path/bounds.js
var x03 = Infinity;
var y03 = x03;
var x1 = -x03;
var y1 = x1;
var boundsStream = {
  point: boundsPoint,
  lineStart: noop2,
  lineEnd: noop2,
  polygonStart: noop2,
  polygonEnd: noop2,
  result: function() {
    var bounds = [[x03, y03], [x1, y1]];
    x1 = y1 = -(y03 = x03 = Infinity);
    return bounds;
  }
};
function boundsPoint(x4, y4) {
  if (x4 < x03)
    x03 = x4;
  if (x4 > x1)
    x1 = x4;
  if (y4 < y03)
    y03 = y4;
  if (y4 > y1)
    y1 = y4;
}
var bounds_default = boundsStream;

// ../../node_modules/d3-geo/src/path/centroid.js
var X02 = 0;
var Y02 = 0;
var Z02 = 0;
var X12 = 0;
var Y12 = 0;
var Z12 = 0;
var X23 = 0;
var Y23 = 0;
var Z22 = 0;
var x002;
var y002;
var x04;
var y04;
var centroidStream2 = {
  point: centroidPoint2,
  lineStart: centroidLineStart2,
  lineEnd: centroidLineEnd2,
  polygonStart: function() {
    centroidStream2.lineStart = centroidRingStart2;
    centroidStream2.lineEnd = centroidRingEnd2;
  },
  polygonEnd: function() {
    centroidStream2.point = centroidPoint2;
    centroidStream2.lineStart = centroidLineStart2;
    centroidStream2.lineEnd = centroidLineEnd2;
  },
  result: function() {
    var centroid3 = Z22 ? [X23 / Z22, Y23 / Z22] : Z12 ? [X12 / Z12, Y12 / Z12] : Z02 ? [X02 / Z02, Y02 / Z02] : [NaN, NaN];
    X02 = Y02 = Z02 = X12 = Y12 = Z12 = X23 = Y23 = Z22 = 0;
    return centroid3;
  }
};
function centroidPoint2(x4, y4) {
  X02 += x4;
  Y02 += y4;
  ++Z02;
}
function centroidLineStart2() {
  centroidStream2.point = centroidPointFirstLine;
}
function centroidPointFirstLine(x4, y4) {
  centroidStream2.point = centroidPointLine;
  centroidPoint2(x04 = x4, y04 = y4);
}
function centroidPointLine(x4, y4) {
  var dx = x4 - x04, dy = y4 - y04, z2 = sqrt(dx * dx + dy * dy);
  X12 += z2 * (x04 + x4) / 2;
  Y12 += z2 * (y04 + y4) / 2;
  Z12 += z2;
  centroidPoint2(x04 = x4, y04 = y4);
}
function centroidLineEnd2() {
  centroidStream2.point = centroidPoint2;
}
function centroidRingStart2() {
  centroidStream2.point = centroidPointFirstRing;
}
function centroidRingEnd2() {
  centroidPointRing(x002, y002);
}
function centroidPointFirstRing(x4, y4) {
  centroidStream2.point = centroidPointRing;
  centroidPoint2(x002 = x04 = x4, y002 = y04 = y4);
}
function centroidPointRing(x4, y4) {
  var dx = x4 - x04, dy = y4 - y04, z2 = sqrt(dx * dx + dy * dy);
  X12 += z2 * (x04 + x4) / 2;
  Y12 += z2 * (y04 + y4) / 2;
  Z12 += z2;
  z2 = y04 * x4 - x04 * y4;
  X23 += z2 * (x04 + x4);
  Y23 += z2 * (y04 + y4);
  Z22 += z2 * 3;
  centroidPoint2(x04 = x4, y04 = y4);
}
var centroid_default2 = centroidStream2;

// ../../node_modules/d3-geo/src/path/context.js
function PathContext(context) {
  this._context = context;
}
PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_2) {
    return this._radius = _2, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0)
      this._context.closePath();
    this._point = NaN;
  },
  point: function(x4, y4) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x4, y4);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x4, y4);
        break;
      }
      default: {
        this._context.moveTo(x4 + this._radius, y4);
        this._context.arc(x4, y4, this._radius, 0, tau3);
        break;
      }
    }
  },
  result: noop2
};

// ../../node_modules/d3-geo/src/path/measure.js
var lengthSum = new Adder();
var lengthRing;
var x003;
var y003;
var x05;
var y05;
var lengthStream = {
  point: noop2,
  lineStart: function() {
    lengthStream.point = lengthPointFirst;
  },
  lineEnd: function() {
    if (lengthRing)
      lengthPoint(x003, y003);
    lengthStream.point = noop2;
  },
  polygonStart: function() {
    lengthRing = true;
  },
  polygonEnd: function() {
    lengthRing = null;
  },
  result: function() {
    var length4 = +lengthSum;
    lengthSum = new Adder();
    return length4;
  }
};
function lengthPointFirst(x4, y4) {
  lengthStream.point = lengthPoint;
  x003 = x05 = x4, y003 = y05 = y4;
}
function lengthPoint(x4, y4) {
  x05 -= x4, y05 -= y4;
  lengthSum.add(sqrt(x05 * x05 + y05 * y05));
  x05 = x4, y05 = y4;
}
var measure_default = lengthStream;

// ../../node_modules/d3-geo/src/path/string.js
var cacheDigits;
var cacheAppend;
var cacheRadius;
var cacheCircle;
var PathString = class {
  constructor(digits) {
    this._append = digits == null ? append2 : appendRound2(digits);
    this._radius = 4.5;
    this._ = "";
  }
  pointRadius(_2) {
    this._radius = +_2;
    return this;
  }
  polygonStart() {
    this._line = 0;
  }
  polygonEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    if (this._line === 0)
      this._ += "Z";
    this._point = NaN;
  }
  point(x4, y4) {
    switch (this._point) {
      case 0: {
        this._append`M${x4},${y4}`;
        this._point = 1;
        break;
      }
      case 1: {
        this._append`L${x4},${y4}`;
        break;
      }
      default: {
        this._append`M${x4},${y4}`;
        if (this._radius !== cacheRadius || this._append !== cacheAppend) {
          const r = this._radius;
          const s2 = this._;
          this._ = "";
          this._append`m0,${r}a${r},${r} 0 1,1 0,${-2 * r}a${r},${r} 0 1,1 0,${2 * r}z`;
          cacheRadius = r;
          cacheAppend = this._append;
          cacheCircle = this._;
          this._ = s2;
        }
        this._ += cacheCircle;
        break;
      }
    }
  }
  result() {
    const result = this._;
    this._ = "";
    return result.length ? result : null;
  }
};
function append2(strings) {
  let i = 1;
  this._ += strings[0];
  for (const j2 = strings.length; i < j2; ++i) {
    this._ += arguments[i] + strings[i];
  }
}
function appendRound2(digits) {
  const d = Math.floor(digits);
  if (!(d >= 0))
    throw new RangeError(`invalid digits: ${digits}`);
  if (d > 15)
    return append2;
  if (d !== cacheDigits) {
    const k3 = 10 ** d;
    cacheDigits = d;
    cacheAppend = function append3(strings) {
      let i = 1;
      this._ += strings[0];
      for (const j2 = strings.length; i < j2; ++i) {
        this._ += Math.round(arguments[i] * k3) / k3 + strings[i];
      }
    };
  }
  return cacheAppend;
}

// ../../node_modules/d3-geo/src/path/index.js
function path_default(projection3, context) {
  let digits = 3, pointRadius = 4.5, projectionStream, contextStream;
  function path2(object) {
    if (object) {
      if (typeof pointRadius === "function")
        contextStream.pointRadius(+pointRadius.apply(this, arguments));
      stream_default(object, projectionStream(contextStream));
    }
    return contextStream.result();
  }
  path2.area = function(object) {
    stream_default(object, projectionStream(area_default2));
    return area_default2.result();
  };
  path2.measure = function(object) {
    stream_default(object, projectionStream(measure_default));
    return measure_default.result();
  };
  path2.bounds = function(object) {
    stream_default(object, projectionStream(bounds_default));
    return bounds_default.result();
  };
  path2.centroid = function(object) {
    stream_default(object, projectionStream(centroid_default2));
    return centroid_default2.result();
  };
  path2.projection = function(_2) {
    if (!arguments.length)
      return projection3;
    projectionStream = _2 == null ? (projection3 = null, identity_default3) : (projection3 = _2).stream;
    return path2;
  };
  path2.context = function(_2) {
    if (!arguments.length)
      return context;
    contextStream = _2 == null ? (context = null, new PathString(digits)) : new PathContext(context = _2);
    if (typeof pointRadius !== "function")
      contextStream.pointRadius(pointRadius);
    return path2;
  };
  path2.pointRadius = function(_2) {
    if (!arguments.length)
      return pointRadius;
    pointRadius = typeof _2 === "function" ? _2 : (contextStream.pointRadius(+_2), +_2);
    return path2;
  };
  path2.digits = function(_2) {
    if (!arguments.length)
      return digits;
    if (_2 == null)
      digits = null;
    else {
      const d = Math.floor(_2);
      if (!(d >= 0))
        throw new RangeError(`invalid digits: ${_2}`);
      digits = d;
    }
    if (context === null)
      contextStream = new PathString(digits);
    return path2;
  };
  return path2.projection(projection3).digits(digits).context(context);
}

// ../../node_modules/d3-geo/src/transform.js
function transform_default(methods) {
  return {
    stream: transformer(methods)
  };
}
function transformer(methods) {
  return function(stream) {
    var s2 = new TransformStream();
    for (var key in methods)
      s2[key] = methods[key];
    s2.stream = stream;
    return s2;
  };
}
function TransformStream() {
}
TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x4, y4) {
    this.stream.point(x4, y4);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};

// ../../node_modules/d3-geo/src/projection/fit.js
function fit(projection3, fitBounds, object) {
  var clip = projection3.clipExtent && projection3.clipExtent();
  projection3.scale(150).translate([0, 0]);
  if (clip != null)
    projection3.clipExtent(null);
  stream_default(object, projection3.stream(bounds_default));
  fitBounds(bounds_default.result());
  if (clip != null)
    projection3.clipExtent(clip);
  return projection3;
}
function fitExtent(projection3, extent4, object) {
  return fit(projection3, function(b2) {
    var w = extent4[1][0] - extent4[0][0], h2 = extent4[1][1] - extent4[0][1], k3 = Math.min(w / (b2[1][0] - b2[0][0]), h2 / (b2[1][1] - b2[0][1])), x4 = +extent4[0][0] + (w - k3 * (b2[1][0] + b2[0][0])) / 2, y4 = +extent4[0][1] + (h2 - k3 * (b2[1][1] + b2[0][1])) / 2;
    projection3.scale(150 * k3).translate([x4, y4]);
  }, object);
}
function fitSize(projection3, size, object) {
  return fitExtent(projection3, [[0, 0], size], object);
}
function fitWidth(projection3, width2, object) {
  return fit(projection3, function(b2) {
    var w = +width2, k3 = w / (b2[1][0] - b2[0][0]), x4 = (w - k3 * (b2[1][0] + b2[0][0])) / 2, y4 = -k3 * b2[0][1];
    projection3.scale(150 * k3).translate([x4, y4]);
  }, object);
}
function fitHeight(projection3, height2, object) {
  return fit(projection3, function(b2) {
    var h2 = +height2, k3 = h2 / (b2[1][1] - b2[0][1]), x4 = -k3 * b2[0][0], y4 = (h2 - k3 * (b2[1][1] + b2[0][1])) / 2;
    projection3.scale(150 * k3).translate([x4, y4]);
  }, object);
}

// ../../node_modules/d3-geo/src/projection/resample.js
var maxDepth = 16;
var cosMinDistance = cos(30 * radians2);
function resample_default(project2, delta2) {
  return +delta2 ? resample(project2, delta2) : resampleNone(project2);
}
function resampleNone(project2) {
  return transformer({
    point: function(x4, y4) {
      x4 = project2(x4, y4);
      this.stream.point(x4[0], x4[1]);
    }
  });
}
function resample(project2, delta2) {
  function resampleLineTo(x06, y06, lambda0, a0, b0, c0, x12, y12, lambda1, a1, b1, c1, depth, stream) {
    var dx = x12 - x06, dy = y12 - y06, d2 = dx * dx + dy * dy;
    if (d2 > 4 * delta2 && depth--) {
      var a3 = a0 + a1, b2 = b0 + b1, c4 = c0 + c1, m2 = sqrt(a3 * a3 + b2 * b2 + c4 * c4), phi2 = asin(c4 /= m2), lambda2 = abs2(abs2(c4) - 1) < epsilon6 || abs2(lambda0 - lambda1) < epsilon6 ? (lambda0 + lambda1) / 2 : atan2(b2, a3), p2 = project2(lambda2, phi2), x22 = p2[0], y22 = p2[1], dx2 = x22 - x06, dy2 = y22 - y06, dz = dy * dx2 - dx * dy2;
      if (dz * dz / d2 > delta2 || abs2((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
        resampleLineTo(x06, y06, lambda0, a0, b0, c0, x22, y22, lambda2, a3 /= m2, b2 /= m2, c4, depth, stream);
        stream.point(x22, y22);
        resampleLineTo(x22, y22, lambda2, a3, b2, c4, x12, y12, lambda1, a1, b1, c1, depth, stream);
      }
    }
  }
  return function(stream) {
    var lambda002, x004, y004, a00, b00, c00, lambda0, x06, y06, a0, b0, c0;
    var resampleStream = {
      point: point6,
      lineStart,
      lineEnd,
      polygonStart: function() {
        stream.polygonStart();
        resampleStream.lineStart = ringStart;
      },
      polygonEnd: function() {
        stream.polygonEnd();
        resampleStream.lineStart = lineStart;
      }
    };
    function point6(x4, y4) {
      x4 = project2(x4, y4);
      stream.point(x4[0], x4[1]);
    }
    function lineStart() {
      x06 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }
    function linePoint(lambda, phi) {
      var c4 = cartesian([lambda, phi]), p2 = project2(lambda, phi);
      resampleLineTo(x06, y06, lambda0, a0, b0, c0, x06 = p2[0], y06 = p2[1], lambda0 = lambda, a0 = c4[0], b0 = c4[1], c0 = c4[2], maxDepth, stream);
      stream.point(x06, y06);
    }
    function lineEnd() {
      resampleStream.point = point6;
      stream.lineEnd();
    }
    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }
    function ringPoint(lambda, phi) {
      linePoint(lambda002 = lambda, phi), x004 = x06, y004 = y06, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint;
    }
    function ringEnd() {
      resampleLineTo(x06, y06, lambda0, a0, b0, c0, x004, y004, lambda002, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }
    return resampleStream;
  };
}

// ../../node_modules/d3-geo/src/projection/index.js
var transformRadians = transformer({
  point: function(x4, y4) {
    this.stream.point(x4 * radians2, y4 * radians2);
  }
});
function transformRotate(rotate) {
  return transformer({
    point: function(x4, y4) {
      var r = rotate(x4, y4);
      return this.stream.point(r[0], r[1]);
    }
  });
}
function scaleTranslate(k3, dx, dy, sx, sy) {
  function transform3(x4, y4) {
    x4 *= sx;
    y4 *= sy;
    return [dx + k3 * x4, dy - k3 * y4];
  }
  transform3.invert = function(x4, y4) {
    return [(x4 - dx) / k3 * sx, (dy - y4) / k3 * sy];
  };
  return transform3;
}
function scaleTranslateRotate(k3, dx, dy, sx, sy, alpha) {
  if (!alpha)
    return scaleTranslate(k3, dx, dy, sx, sy);
  var cosAlpha = cos(alpha), sinAlpha = sin(alpha), a3 = cosAlpha * k3, b2 = sinAlpha * k3, ai = cosAlpha / k3, bi = sinAlpha / k3, ci = (sinAlpha * dy - cosAlpha * dx) / k3, fi = (sinAlpha * dx + cosAlpha * dy) / k3;
  function transform3(x4, y4) {
    x4 *= sx;
    y4 *= sy;
    return [a3 * x4 - b2 * y4 + dx, dy - b2 * x4 - a3 * y4];
  }
  transform3.invert = function(x4, y4) {
    return [sx * (ai * x4 - bi * y4 + ci), sy * (fi - bi * x4 - ai * y4)];
  };
  return transform3;
}
function projection(project2) {
  return projectionMutator(function() {
    return project2;
  })();
}
function projectionMutator(projectAt) {
  var project2, k3 = 150, x4 = 480, y4 = 250, lambda = 0, phi = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, alpha = 0, sx = 1, sy = 1, theta = null, preclip = antimeridian_default, x06 = null, y06, x12, y12, postclip = identity_default3, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache, cacheStream;
  function projection3(point6) {
    return projectRotateTransform(point6[0] * radians2, point6[1] * radians2);
  }
  function invert2(point6) {
    point6 = projectRotateTransform.invert(point6[0], point6[1]);
    return point6 && [point6[0] * degrees3, point6[1] * degrees3];
  }
  projection3.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
  };
  projection3.preclip = function(_2) {
    return arguments.length ? (preclip = _2, theta = void 0, reset()) : preclip;
  };
  projection3.postclip = function(_2) {
    return arguments.length ? (postclip = _2, x06 = y06 = x12 = y12 = null, reset()) : postclip;
  };
  projection3.clipAngle = function(_2) {
    return arguments.length ? (preclip = +_2 ? circle_default(theta = _2 * radians2) : (theta = null, antimeridian_default), reset()) : theta * degrees3;
  };
  projection3.clipExtent = function(_2) {
    return arguments.length ? (postclip = _2 == null ? (x06 = y06 = x12 = y12 = null, identity_default3) : clipRectangle(x06 = +_2[0][0], y06 = +_2[0][1], x12 = +_2[1][0], y12 = +_2[1][1]), reset()) : x06 == null ? null : [[x06, y06], [x12, y12]];
  };
  projection3.scale = function(_2) {
    return arguments.length ? (k3 = +_2, recenter()) : k3;
  };
  projection3.translate = function(_2) {
    return arguments.length ? (x4 = +_2[0], y4 = +_2[1], recenter()) : [x4, y4];
  };
  projection3.center = function(_2) {
    return arguments.length ? (lambda = _2[0] % 360 * radians2, phi = _2[1] % 360 * radians2, recenter()) : [lambda * degrees3, phi * degrees3];
  };
  projection3.rotate = function(_2) {
    return arguments.length ? (deltaLambda = _2[0] % 360 * radians2, deltaPhi = _2[1] % 360 * radians2, deltaGamma = _2.length > 2 ? _2[2] % 360 * radians2 : 0, recenter()) : [deltaLambda * degrees3, deltaPhi * degrees3, deltaGamma * degrees3];
  };
  projection3.angle = function(_2) {
    return arguments.length ? (alpha = _2 % 360 * radians2, recenter()) : alpha * degrees3;
  };
  projection3.reflectX = function(_2) {
    return arguments.length ? (sx = _2 ? -1 : 1, recenter()) : sx < 0;
  };
  projection3.reflectY = function(_2) {
    return arguments.length ? (sy = _2 ? -1 : 1, recenter()) : sy < 0;
  };
  projection3.precision = function(_2) {
    return arguments.length ? (projectResample = resample_default(projectTransform, delta2 = _2 * _2), reset()) : sqrt(delta2);
  };
  projection3.fitExtent = function(extent4, object) {
    return fitExtent(projection3, extent4, object);
  };
  projection3.fitSize = function(size, object) {
    return fitSize(projection3, size, object);
  };
  projection3.fitWidth = function(width2, object) {
    return fitWidth(projection3, width2, object);
  };
  projection3.fitHeight = function(height2, object) {
    return fitHeight(projection3, height2, object);
  };
  function recenter() {
    var center2 = scaleTranslateRotate(k3, 0, 0, sx, sy, alpha).apply(null, project2(lambda, phi)), transform3 = scaleTranslateRotate(k3, x4 - center2[0], y4 - center2[1], sx, sy, alpha);
    rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
    projectTransform = compose_default(project2, transform3);
    projectRotateTransform = compose_default(rotate, projectTransform);
    projectResample = resample_default(projectTransform, delta2);
    return reset();
  }
  function reset() {
    cache = cacheStream = null;
    return projection3;
  }
  return function() {
    project2 = projectAt.apply(this, arguments);
    projection3.invert = project2.invert && invert2;
    return recenter();
  };
}

// ../../node_modules/d3-geo/src/projection/conic.js
function conicProjection(projectAt) {
  var phi0 = 0, phi1 = pi2 / 3, m2 = projectionMutator(projectAt), p2 = m2(phi0, phi1);
  p2.parallels = function(_2) {
    return arguments.length ? m2(phi0 = _2[0] * radians2, phi1 = _2[1] * radians2) : [phi0 * degrees3, phi1 * degrees3];
  };
  return p2;
}

// ../../node_modules/d3-geo/src/projection/cylindricalEqualArea.js
function cylindricalEqualAreaRaw(phi0) {
  var cosPhi0 = cos(phi0);
  function forward(lambda, phi) {
    return [lambda * cosPhi0, sin(phi) / cosPhi0];
  }
  forward.invert = function(x4, y4) {
    return [x4 / cosPhi0, asin(y4 * cosPhi0)];
  };
  return forward;
}

// ../../node_modules/d3-geo/src/projection/conicEqualArea.js
function conicEqualAreaRaw(y06, y12) {
  var sy0 = sin(y06), n = (sy0 + sin(y12)) / 2;
  if (abs2(n) < epsilon6)
    return cylindricalEqualAreaRaw(y06);
  var c4 = 1 + sy0 * (2 * n - sy0), r0 = sqrt(c4) / n;
  function project2(x4, y4) {
    var r = sqrt(c4 - 2 * n * sin(y4)) / n;
    return [r * sin(x4 *= n), r0 - r * cos(x4)];
  }
  project2.invert = function(x4, y4) {
    var r0y = r0 - y4, l = atan2(x4, abs2(r0y)) * sign(r0y);
    if (r0y * n < 0)
      l -= pi2 * sign(x4) * sign(r0y);
    return [l / n, asin((c4 - (x4 * x4 + r0y * r0y) * n * n) / (2 * n))];
  };
  return project2;
}
function conicEqualArea_default() {
  return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
}

// ../../node_modules/d3-geo/src/projection/albers.js
function albers_default() {
  return conicEqualArea_default().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
}

// ../../node_modules/d3-geo/src/projection/albersUsa.js
function multiplex(streams) {
  var n = streams.length;
  return {
    point: function(x4, y4) {
      var i = -1;
      while (++i < n)
        streams[i].point(x4, y4);
    },
    sphere: function() {
      var i = -1;
      while (++i < n)
        streams[i].sphere();
    },
    lineStart: function() {
      var i = -1;
      while (++i < n)
        streams[i].lineStart();
    },
    lineEnd: function() {
      var i = -1;
      while (++i < n)
        streams[i].lineEnd();
    },
    polygonStart: function() {
      var i = -1;
      while (++i < n)
        streams[i].polygonStart();
    },
    polygonEnd: function() {
      var i = -1;
      while (++i < n)
        streams[i].polygonEnd();
    }
  };
}
function albersUsa_default() {
  var cache, cacheStream, lower48 = albers_default(), lower48Point, alaska = conicEqualArea_default().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = conicEqualArea_default().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point6, pointStream = { point: function(x4, y4) {
    point6 = [x4, y4];
  } };
  function albersUsa(coordinates) {
    var x4 = coordinates[0], y4 = coordinates[1];
    return point6 = null, (lower48Point.point(x4, y4), point6) || (alaskaPoint.point(x4, y4), point6) || (hawaiiPoint.point(x4, y4), point6);
  }
  albersUsa.invert = function(coordinates) {
    var k3 = lower48.scale(), t = lower48.translate(), x4 = (coordinates[0] - t[0]) / k3, y4 = (coordinates[1] - t[1]) / k3;
    return (y4 >= 0.12 && y4 < 0.234 && x4 >= -0.425 && x4 < -0.214 ? alaska : y4 >= 0.166 && y4 < 0.234 && x4 >= -0.214 && x4 < -0.115 ? hawaii : lower48).invert(coordinates);
  };
  albersUsa.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
  };
  albersUsa.precision = function(_2) {
    if (!arguments.length)
      return lower48.precision();
    lower48.precision(_2), alaska.precision(_2), hawaii.precision(_2);
    return reset();
  };
  albersUsa.scale = function(_2) {
    if (!arguments.length)
      return lower48.scale();
    lower48.scale(_2), alaska.scale(_2 * 0.35), hawaii.scale(_2);
    return albersUsa.translate(lower48.translate());
  };
  albersUsa.translate = function(_2) {
    if (!arguments.length)
      return lower48.translate();
    var k3 = lower48.scale(), x4 = +_2[0], y4 = +_2[1];
    lower48Point = lower48.translate(_2).clipExtent([[x4 - 0.455 * k3, y4 - 0.238 * k3], [x4 + 0.455 * k3, y4 + 0.238 * k3]]).stream(pointStream);
    alaskaPoint = alaska.translate([x4 - 0.307 * k3, y4 + 0.201 * k3]).clipExtent([[x4 - 0.425 * k3 + epsilon6, y4 + 0.12 * k3 + epsilon6], [x4 - 0.214 * k3 - epsilon6, y4 + 0.234 * k3 - epsilon6]]).stream(pointStream);
    hawaiiPoint = hawaii.translate([x4 - 0.205 * k3, y4 + 0.212 * k3]).clipExtent([[x4 - 0.214 * k3 + epsilon6, y4 + 0.166 * k3 + epsilon6], [x4 - 0.115 * k3 - epsilon6, y4 + 0.234 * k3 - epsilon6]]).stream(pointStream);
    return reset();
  };
  albersUsa.fitExtent = function(extent4, object) {
    return fitExtent(albersUsa, extent4, object);
  };
  albersUsa.fitSize = function(size, object) {
    return fitSize(albersUsa, size, object);
  };
  albersUsa.fitWidth = function(width2, object) {
    return fitWidth(albersUsa, width2, object);
  };
  albersUsa.fitHeight = function(height2, object) {
    return fitHeight(albersUsa, height2, object);
  };
  function reset() {
    cache = cacheStream = null;
    return albersUsa;
  }
  return albersUsa.scale(1070);
}

// ../../node_modules/d3-geo/src/projection/azimuthal.js
function azimuthalRaw(scale3) {
  return function(x4, y4) {
    var cx = cos(x4), cy = cos(y4), k3 = scale3(cx * cy);
    if (k3 === Infinity)
      return [2, 0];
    return [
      k3 * cy * sin(x4),
      k3 * sin(y4)
    ];
  };
}
function azimuthalInvert(angle) {
  return function(x4, y4) {
    var z2 = sqrt(x4 * x4 + y4 * y4), c4 = angle(z2), sc = sin(c4), cc2 = cos(c4);
    return [
      atan2(x4 * sc, z2 * cc2),
      asin(z2 && y4 * sc / z2)
    ];
  };
}

// ../../node_modules/d3-geo/src/projection/azimuthalEqualArea.js
var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
  return sqrt(2 / (1 + cxcy));
});
azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z2) {
  return 2 * asin(z2 / 2);
});
function azimuthalEqualArea_default() {
  return projection(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
}

// ../../node_modules/d3-geo/src/projection/azimuthalEquidistant.js
var azimuthalEquidistantRaw = azimuthalRaw(function(c4) {
  return (c4 = acos(c4)) && c4 / sin(c4);
});
azimuthalEquidistantRaw.invert = azimuthalInvert(function(z2) {
  return z2;
});
function azimuthalEquidistant_default() {
  return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
}

// ../../node_modules/d3-geo/src/projection/mercator.js
function mercatorRaw(lambda, phi) {
  return [lambda, log(tan((halfPi + phi) / 2))];
}
mercatorRaw.invert = function(x4, y4) {
  return [x4, 2 * atan(exp(y4)) - halfPi];
};
function mercator_default() {
  return mercatorProjection(mercatorRaw).scale(961 / tau3);
}
function mercatorProjection(project2) {
  var m2 = projection(project2), center2 = m2.center, scale3 = m2.scale, translate = m2.translate, clipExtent = m2.clipExtent, x06 = null, y06, x12, y12;
  m2.scale = function(_2) {
    return arguments.length ? (scale3(_2), reclip()) : scale3();
  };
  m2.translate = function(_2) {
    return arguments.length ? (translate(_2), reclip()) : translate();
  };
  m2.center = function(_2) {
    return arguments.length ? (center2(_2), reclip()) : center2();
  };
  m2.clipExtent = function(_2) {
    return arguments.length ? (_2 == null ? x06 = y06 = x12 = y12 = null : (x06 = +_2[0][0], y06 = +_2[0][1], x12 = +_2[1][0], y12 = +_2[1][1]), reclip()) : x06 == null ? null : [[x06, y06], [x12, y12]];
  };
  function reclip() {
    var k3 = pi2 * scale3(), t = m2(rotation_default(m2.rotate()).invert([0, 0]));
    return clipExtent(x06 == null ? [[t[0] - k3, t[1] - k3], [t[0] + k3, t[1] + k3]] : project2 === mercatorRaw ? [[Math.max(t[0] - k3, x06), y06], [Math.min(t[0] + k3, x12), y12]] : [[x06, Math.max(t[1] - k3, y06)], [x12, Math.min(t[1] + k3, y12)]]);
  }
  return reclip();
}

// ../../node_modules/d3-geo/src/projection/conicConformal.js
function tany(y4) {
  return tan((halfPi + y4) / 2);
}
function conicConformalRaw(y06, y12) {
  var cy0 = cos(y06), n = y06 === y12 ? sin(y06) : log(cy0 / cos(y12)) / log(tany(y12) / tany(y06)), f2 = cy0 * pow2(tany(y06), n) / n;
  if (!n)
    return mercatorRaw;
  function project2(x4, y4) {
    if (f2 > 0) {
      if (y4 < -halfPi + epsilon6)
        y4 = -halfPi + epsilon6;
    } else {
      if (y4 > halfPi - epsilon6)
        y4 = halfPi - epsilon6;
    }
    var r = f2 / pow2(tany(y4), n);
    return [r * sin(n * x4), f2 - r * cos(n * x4)];
  }
  project2.invert = function(x4, y4) {
    var fy = f2 - y4, r = sign(n) * sqrt(x4 * x4 + fy * fy), l = atan2(x4, abs2(fy)) * sign(fy);
    if (fy * n < 0)
      l -= pi2 * sign(x4) * sign(fy);
    return [l / n, 2 * atan(pow2(f2 / r, 1 / n)) - halfPi];
  };
  return project2;
}
function conicConformal_default() {
  return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
}

// ../../node_modules/d3-geo/src/projection/equirectangular.js
function equirectangularRaw(lambda, phi) {
  return [lambda, phi];
}
equirectangularRaw.invert = equirectangularRaw;
function equirectangular_default() {
  return projection(equirectangularRaw).scale(152.63);
}

// ../../node_modules/d3-geo/src/projection/conicEquidistant.js
function conicEquidistantRaw(y06, y12) {
  var cy0 = cos(y06), n = y06 === y12 ? sin(y06) : (cy0 - cos(y12)) / (y12 - y06), g2 = cy0 / n + y06;
  if (abs2(n) < epsilon6)
    return equirectangularRaw;
  function project2(x4, y4) {
    var gy = g2 - y4, nx = n * x4;
    return [gy * sin(nx), g2 - gy * cos(nx)];
  }
  project2.invert = function(x4, y4) {
    var gy = g2 - y4, l = atan2(x4, abs2(gy)) * sign(gy);
    if (gy * n < 0)
      l -= pi2 * sign(x4) * sign(gy);
    return [l / n, g2 - sign(n) * sqrt(x4 * x4 + gy * gy)];
  };
  return project2;
}
function conicEquidistant_default() {
  return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
}

// ../../node_modules/d3-geo/src/projection/equalEarth.js
var A1 = 1.340264;
var A22 = -0.081106;
var A3 = 893e-6;
var A4 = 3796e-6;
var M2 = sqrt(3) / 2;
var iterations = 12;
function equalEarthRaw(lambda, phi) {
  var l = asin(M2 * sin(phi)), l2 = l * l, l6 = l2 * l2 * l2;
  return [
    lambda * cos(l) / (M2 * (A1 + 3 * A22 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
    l * (A1 + A22 * l2 + l6 * (A3 + A4 * l2))
  ];
}
equalEarthRaw.invert = function(x4, y4) {
  var l = y4, l2 = l * l, l6 = l2 * l2 * l2;
  for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
    fy = l * (A1 + A22 * l2 + l6 * (A3 + A4 * l2)) - y4;
    fpy = A1 + 3 * A22 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
    l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
    if (abs2(delta) < epsilon22)
      break;
  }
  return [
    M2 * x4 * (A1 + 3 * A22 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos(l),
    asin(sin(l) / M2)
  ];
};
function equalEarth_default() {
  return projection(equalEarthRaw).scale(177.158);
}

// ../../node_modules/d3-geo/src/projection/gnomonic.js
function gnomonicRaw(x4, y4) {
  var cy = cos(y4), k3 = cos(x4) * cy;
  return [cy * sin(x4) / k3, sin(y4) / k3];
}
gnomonicRaw.invert = azimuthalInvert(atan);
function gnomonic_default() {
  return projection(gnomonicRaw).scale(144.049).clipAngle(60);
}

// ../../node_modules/d3-geo/src/projection/orthographic.js
function orthographicRaw(x4, y4) {
  return [cos(y4) * sin(x4), sin(y4)];
}
orthographicRaw.invert = azimuthalInvert(asin);
function orthographic_default() {
  return projection(orthographicRaw).scale(249.5).clipAngle(90 + epsilon6);
}

// ../../node_modules/d3-geo/src/projection/stereographic.js
function stereographicRaw(x4, y4) {
  var cy = cos(y4), k3 = 1 + cos(x4) * cy;
  return [cy * sin(x4) / k3, sin(y4) / k3];
}
stereographicRaw.invert = azimuthalInvert(function(z2) {
  return 2 * atan(z2);
});
function stereographic_default() {
  return projection(stereographicRaw).scale(250).clipAngle(142);
}

// ../../node_modules/d3-geo/src/projection/transverseMercator.js
function transverseMercatorRaw(lambda, phi) {
  return [log(tan((halfPi + phi) / 2)), -lambda];
}
transverseMercatorRaw.invert = function(x4, y4) {
  return [-y4, 2 * atan(exp(x4)) - halfPi];
};
function transverseMercator_default() {
  var m2 = mercatorProjection(transverseMercatorRaw), center2 = m2.center, rotate = m2.rotate;
  m2.center = function(_2) {
    return arguments.length ? center2([-_2[1], _2[0]]) : (_2 = center2(), [_2[1], -_2[0]]);
  };
  m2.rotate = function(_2) {
    return arguments.length ? rotate([_2[0], _2[1], _2.length > 2 ? _2[2] + 90 : 90]) : (_2 = rotate(), [_2[0], _2[1], _2[2] - 90]);
  };
  return rotate([0, 0, 90]).scale(159.155);
}

// ../../node_modules/d3-hierarchy/src/cluster.js
function defaultSeparation(a3, b2) {
  return a3.parent === b2.parent ? 1 : 2;
}
function meanX(children2) {
  return children2.reduce(meanXReduce, 0) / children2.length;
}
function meanXReduce(x4, c4) {
  return x4 + c4.x;
}
function maxY(children2) {
  return 1 + children2.reduce(maxYReduce, 0);
}
function maxYReduce(y4, c4) {
  return Math.max(y4, c4.y);
}
function leafLeft(node) {
  var children2;
  while (children2 = node.children)
    node = children2[0];
  return node;
}
function leafRight(node) {
  var children2;
  while (children2 = node.children)
    node = children2[children2.length - 1];
  return node;
}
function cluster_default() {
  var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = false;
  function cluster2(root2) {
    var previousNode, x4 = 0;
    root2.eachAfter(function(node) {
      var children2 = node.children;
      if (children2) {
        node.x = meanX(children2);
        node.y = maxY(children2);
      } else {
        node.x = previousNode ? x4 += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });
    var left2 = leafLeft(root2), right2 = leafRight(root2), x06 = left2.x - separation(left2, right2) / 2, x12 = right2.x + separation(right2, left2) / 2;
    return root2.eachAfter(nodeSize ? function(node) {
      node.x = (node.x - root2.x) * dx;
      node.y = (root2.y - node.y) * dy;
    } : function(node) {
      node.x = (node.x - x06) / (x12 - x06) * dx;
      node.y = (1 - (root2.y ? node.y / root2.y : 1)) * dy;
    });
  }
  cluster2.separation = function(x4) {
    return arguments.length ? (separation = x4, cluster2) : separation;
  };
  cluster2.size = function(x4) {
    return arguments.length ? (nodeSize = false, dx = +x4[0], dy = +x4[1], cluster2) : nodeSize ? null : [dx, dy];
  };
  cluster2.nodeSize = function(x4) {
    return arguments.length ? (nodeSize = true, dx = +x4[0], dy = +x4[1], cluster2) : nodeSize ? [dx, dy] : null;
  };
  return cluster2;
}

// ../../node_modules/d3-hierarchy/src/hierarchy/count.js
function count3(node) {
  var sum5 = 0, children2 = node.children, i = children2 && children2.length;
  if (!i)
    sum5 = 1;
  else
    while (--i >= 0)
      sum5 += children2[i].value;
  node.value = sum5;
}
function count_default() {
  return this.eachAfter(count3);
}

// ../../node_modules/d3-hierarchy/src/hierarchy/each.js
function each_default2(callback, that) {
  let index2 = -1;
  for (const node of this) {
    callback.call(that, node, ++index2, this);
  }
  return this;
}

// ../../node_modules/d3-hierarchy/src/hierarchy/eachBefore.js
function eachBefore_default(callback, that) {
  var node = this, nodes = [node], children2, i, index2 = -1;
  while (node = nodes.pop()) {
    callback.call(that, node, ++index2, this);
    if (children2 = node.children) {
      for (i = children2.length - 1; i >= 0; --i) {
        nodes.push(children2[i]);
      }
    }
  }
  return this;
}

// ../../node_modules/d3-hierarchy/src/hierarchy/eachAfter.js
function eachAfter_default(callback, that) {
  var node = this, nodes = [node], next = [], children2, i, n, index2 = -1;
  while (node = nodes.pop()) {
    next.push(node);
    if (children2 = node.children) {
      for (i = 0, n = children2.length; i < n; ++i) {
        nodes.push(children2[i]);
      }
    }
  }
  while (node = next.pop()) {
    callback.call(that, node, ++index2, this);
  }
  return this;
}

// ../../node_modules/d3-hierarchy/src/hierarchy/find.js
function find_default(callback, that) {
  let index2 = -1;
  for (const node of this) {
    if (callback.call(that, node, ++index2, this)) {
      return node;
    }
  }
}

// ../../node_modules/d3-hierarchy/src/hierarchy/sum.js
function sum_default(value) {
  return this.eachAfter(function(node) {
    var sum5 = +value(node.data) || 0, children2 = node.children, i = children2 && children2.length;
    while (--i >= 0)
      sum5 += children2[i].value;
    node.value = sum5;
  });
}

// ../../node_modules/d3-hierarchy/src/hierarchy/sort.js
function sort_default2(compare) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
}

// ../../node_modules/d3-hierarchy/src/hierarchy/path.js
function path_default2(end) {
  var start2 = this, ancestor = leastCommonAncestor(start2, end), nodes = [start2];
  while (start2 !== ancestor) {
    start2 = start2.parent;
    nodes.push(start2);
  }
  var k3 = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k3, 0, end);
    end = end.parent;
  }
  return nodes;
}
function leastCommonAncestor(a3, b2) {
  if (a3 === b2)
    return a3;
  var aNodes = a3.ancestors(), bNodes = b2.ancestors(), c4 = null;
  a3 = aNodes.pop();
  b2 = bNodes.pop();
  while (a3 === b2) {
    c4 = a3;
    a3 = aNodes.pop();
    b2 = bNodes.pop();
  }
  return c4;
}

// ../../node_modules/d3-hierarchy/src/hierarchy/ancestors.js
function ancestors_default() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}

// ../../node_modules/d3-hierarchy/src/hierarchy/descendants.js
function descendants_default() {
  return Array.from(this);
}

// ../../node_modules/d3-hierarchy/src/hierarchy/leaves.js
function leaves_default() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}

// ../../node_modules/d3-hierarchy/src/hierarchy/links.js
function links_default() {
  var root2 = this, links = [];
  root2.each(function(node) {
    if (node !== root2) {
      links.push({ source: node.parent, target: node });
    }
  });
  return links;
}

// ../../node_modules/d3-hierarchy/src/hierarchy/iterator.js
function* iterator_default2() {
  var node = this, current, next = [node], children2, i, n;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      yield node;
      if (children2 = node.children) {
        for (i = 0, n = children2.length; i < n; ++i) {
          next.push(children2[i]);
        }
      }
    }
  } while (next.length);
}

// ../../node_modules/d3-hierarchy/src/hierarchy/index.js
function hierarchy(data, children2) {
  if (data instanceof Map) {
    data = [void 0, data];
    if (children2 === void 0)
      children2 = mapChildren;
  } else if (children2 === void 0) {
    children2 = objectChildren;
  }
  var root2 = new Node(data), node, nodes = [root2], child, childs, i, n;
  while (node = nodes.pop()) {
    if ((childs = children2(node.data)) && (n = (childs = Array.from(childs)).length)) {
      node.children = childs;
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = childs[i] = new Node(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }
  return root2.eachBefore(computeHeight);
}
function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}
function objectChildren(d) {
  return d.children;
}
function mapChildren(d) {
  return Array.isArray(d) ? d[1] : null;
}
function copyData(node) {
  if (node.data.value !== void 0)
    node.value = node.data.value;
  node.data = node.data.data;
}
function computeHeight(node) {
  var height2 = 0;
  do
    node.height = height2;
  while ((node = node.parent) && node.height < ++height2);
}
function Node(data) {
  this.data = data;
  this.depth = this.height = 0;
  this.parent = null;
}
Node.prototype = hierarchy.prototype = {
  constructor: Node,
  count: count_default,
  each: each_default2,
  eachAfter: eachAfter_default,
  eachBefore: eachBefore_default,
  find: find_default,
  sum: sum_default,
  sort: sort_default2,
  path: path_default2,
  ancestors: ancestors_default,
  descendants: descendants_default,
  leaves: leaves_default,
  links: links_default,
  copy: node_copy,
  [Symbol.iterator]: iterator_default2
};

// ../../node_modules/d3-hierarchy/src/accessors.js
function optional(f2) {
  return f2 == null ? null : required(f2);
}
function required(f2) {
  if (typeof f2 !== "function")
    throw new Error();
  return f2;
}

// ../../node_modules/d3-hierarchy/src/stratify.js
var preroot = { depth: -1 };
var ambiguous = {};
var imputed = {};
function defaultId(d) {
  return d.id;
}
function defaultParentId(d) {
  return d.parentId;
}
function stratify_default() {
  var id2 = defaultId, parentId = defaultParentId, path2;
  function stratify(data) {
    var nodes = Array.from(data), currentId = id2, currentParentId = parentId, n, d, i, root2, parent, node, nodeId, nodeKey, nodeByKey = /* @__PURE__ */ new Map();
    if (path2 != null) {
      const I2 = nodes.map((d2, i2) => normalize(path2(d2, i2, data)));
      const P2 = I2.map(parentof);
      const S2 = new Set(I2).add("");
      for (const i2 of P2) {
        if (!S2.has(i2)) {
          S2.add(i2);
          I2.push(i2);
          P2.push(parentof(i2));
          nodes.push(imputed);
        }
      }
      currentId = (_2, i2) => I2[i2];
      currentParentId = (_2, i2) => P2[i2];
    }
    for (i = 0, n = nodes.length; i < n; ++i) {
      d = nodes[i], node = nodes[i] = new Node(d);
      if ((nodeId = currentId(d, i, data)) != null && (nodeId += "")) {
        nodeKey = node.id = nodeId;
        nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
      }
      if ((nodeId = currentParentId(d, i, data)) != null && (nodeId += "")) {
        node.parent = nodeId;
      }
    }
    for (i = 0; i < n; ++i) {
      node = nodes[i];
      if (nodeId = node.parent) {
        parent = nodeByKey.get(nodeId);
        if (!parent)
          throw new Error("missing: " + nodeId);
        if (parent === ambiguous)
          throw new Error("ambiguous: " + nodeId);
        if (parent.children)
          parent.children.push(node);
        else
          parent.children = [node];
        node.parent = parent;
      } else {
        if (root2)
          throw new Error("multiple roots");
        root2 = node;
      }
    }
    if (!root2)
      throw new Error("no root");
    if (path2 != null) {
      while (root2.data === imputed && root2.children.length === 1) {
        root2 = root2.children[0], --n;
      }
      for (let i2 = nodes.length - 1; i2 >= 0; --i2) {
        node = nodes[i2];
        if (node.data !== imputed)
          break;
        node.data = null;
      }
    }
    root2.parent = preroot;
    root2.eachBefore(function(node2) {
      node2.depth = node2.parent.depth + 1;
      --n;
    }).eachBefore(computeHeight);
    root2.parent = null;
    if (n > 0)
      throw new Error("cycle");
    return root2;
  }
  stratify.id = function(x4) {
    return arguments.length ? (id2 = optional(x4), stratify) : id2;
  };
  stratify.parentId = function(x4) {
    return arguments.length ? (parentId = optional(x4), stratify) : parentId;
  };
  stratify.path = function(x4) {
    return arguments.length ? (path2 = optional(x4), stratify) : path2;
  };
  return stratify;
}
function normalize(path2) {
  path2 = `${path2}`;
  let i = path2.length;
  if (slash(path2, i - 1) && !slash(path2, i - 2))
    path2 = path2.slice(0, -1);
  return path2[0] === "/" ? path2 : `/${path2}`;
}
function parentof(path2) {
  let i = path2.length;
  if (i < 2)
    return "";
  while (--i > 1)
    if (slash(path2, i))
      break;
  return path2.slice(0, i);
}
function slash(path2, i) {
  if (path2[i] === "/") {
    let k3 = 0;
    while (i > 0 && path2[--i] === "\\")
      ++k3;
    if ((k3 & 1) === 0)
      return true;
  }
  return false;
}

// ../../node_modules/d3-hierarchy/src/tree.js
function defaultSeparation2(a3, b2) {
  return a3.parent === b2.parent ? 1 : 2;
}
function nextLeft(v3) {
  var children2 = v3.children;
  return children2 ? children2[0] : v3.t;
}
function nextRight(v3) {
  var children2 = v3.children;
  return children2 ? children2[children2.length - 1] : v3.t;
}
function moveSubtree(wm, wp, shift) {
  var change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  wp.m += shift;
}
function executeShifts(v3) {
  var shift = 0, change = 0, children2 = v3.children, i = children2.length, w;
  while (--i >= 0) {
    w = children2[i];
    w.z += shift;
    w.m += shift;
    shift += w.s + (change += w.c);
  }
}
function nextAncestor(vim, v3, ancestor) {
  return vim.a.parent === v3.parent ? vim.a : ancestor;
}
function TreeNode(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null;
  this.a = this;
  this.z = 0;
  this.m = 0;
  this.c = 0;
  this.s = 0;
  this.t = null;
  this.i = i;
}
TreeNode.prototype = Object.create(Node.prototype);
function treeRoot(root2) {
  var tree2 = new TreeNode(root2, 0), node, nodes = [tree2], child, children2, i, n;
  while (node = nodes.pop()) {
    if (children2 = node._.children) {
      node.children = new Array(n = children2.length);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new TreeNode(children2[i], i));
        child.parent = node;
      }
    }
  }
  (tree2.parent = new TreeNode(null, 0)).children = [tree2];
  return tree2;
}
function tree_default() {
  var separation = defaultSeparation2, dx = 1, dy = 1, nodeSize = null;
  function tree2(root2) {
    var t = treeRoot(root2);
    t.eachAfter(firstWalk), t.parent.m = -t.z;
    t.eachBefore(secondWalk);
    if (nodeSize)
      root2.eachBefore(sizeNode);
    else {
      var left2 = root2, right2 = root2, bottom2 = root2;
      root2.eachBefore(function(node) {
        if (node.x < left2.x)
          left2 = node;
        if (node.x > right2.x)
          right2 = node;
        if (node.depth > bottom2.depth)
          bottom2 = node;
      });
      var s2 = left2 === right2 ? 1 : separation(left2, right2) / 2, tx = s2 - left2.x, kx2 = dx / (right2.x + s2 + tx), ky2 = dy / (bottom2.depth || 1);
      root2.eachBefore(function(node) {
        node.x = (node.x + tx) * kx2;
        node.y = node.depth * ky2;
      });
    }
    return root2;
  }
  function firstWalk(v3) {
    var children2 = v3.children, siblings = v3.parent.children, w = v3.i ? siblings[v3.i - 1] : null;
    if (children2) {
      executeShifts(v3);
      var midpoint = (children2[0].z + children2[children2.length - 1].z) / 2;
      if (w) {
        v3.z = w.z + separation(v3._, w._);
        v3.m = v3.z - midpoint;
      } else {
        v3.z = midpoint;
      }
    } else if (w) {
      v3.z = w.z + separation(v3._, w._);
    }
    v3.parent.A = apportion(v3, w, v3.parent.A || siblings[0]);
  }
  function secondWalk(v3) {
    v3._.x = v3.z + v3.parent.m;
    v3.m += v3.parent.m;
  }
  function apportion(v3, w, ancestor) {
    if (w) {
      var vip = v3, vop = v3, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v3;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v3, ancestor), v3, shift);
          sip += shift;
          sop += shift;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v3;
      }
    }
    return ancestor;
  }
  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }
  tree2.separation = function(x4) {
    return arguments.length ? (separation = x4, tree2) : separation;
  };
  tree2.size = function(x4) {
    return arguments.length ? (nodeSize = false, dx = +x4[0], dy = +x4[1], tree2) : nodeSize ? null : [dx, dy];
  };
  tree2.nodeSize = function(x4) {
    return arguments.length ? (nodeSize = true, dx = +x4[0], dy = +x4[1], tree2) : nodeSize ? [dx, dy] : null;
  };
  return tree2;
}

// ../../node_modules/d3-random/src/lcg.js
var mul = 1664525;
var inc = 1013904223;
var eps = 1 / 4294967296;
function lcg(seed = Math.random()) {
  let state = (0 <= seed && seed < 1 ? seed / eps : Math.abs(seed)) | 0;
  return () => (state = mul * state + inc | 0, eps * (state >>> 0));
}

// ../../node_modules/d3-scale/src/init.js
function initRange(domain, range3) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range3).domain(domain);
      break;
  }
  return this;
}
function initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      if (typeof domain === "function")
        this.interpolator(domain);
      else
        this.range(domain);
      break;
    }
    default: {
      this.domain(domain);
      if (typeof interpolator === "function")
        this.interpolator(interpolator);
      else
        this.range(interpolator);
      break;
    }
  }
  return this;
}

// ../../node_modules/d3-scale/src/ordinal.js
var implicit = Symbol("implicit");
function ordinal() {
  var index2 = new InternMap(), domain = [], range3 = [], unknown = implicit;
  function scale3(d) {
    let i = index2.get(d);
    if (i === void 0) {
      if (unknown !== implicit)
        return unknown;
      index2.set(d, i = domain.push(d) - 1);
    }
    return range3[i % range3.length];
  }
  scale3.domain = function(_2) {
    if (!arguments.length)
      return domain.slice();
    domain = [], index2 = new InternMap();
    for (const value of _2) {
      if (index2.has(value))
        continue;
      index2.set(value, domain.push(value) - 1);
    }
    return scale3;
  };
  scale3.range = function(_2) {
    return arguments.length ? (range3 = Array.from(_2), scale3) : range3.slice();
  };
  scale3.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale3) : unknown;
  };
  scale3.copy = function() {
    return ordinal(domain, range3).unknown(unknown);
  };
  initRange.apply(scale3, arguments);
  return scale3;
}

// ../../node_modules/d3-scale/src/band.js
function band() {
  var scale3 = ordinal().unknown(void 0), domain = scale3.domain, ordinalRange2 = scale3.range, r0 = 0, r1 = 1, step, bandwidth, round2 = false, paddingInner = 0, paddingOuter = 0, align2 = 0.5;
  delete scale3.unknown;
  function rescale() {
    var n = domain().length, reverse3 = r1 < r0, start2 = reverse3 ? r1 : r0, stop = reverse3 ? r0 : r1;
    step = (stop - start2) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round2)
      step = Math.floor(step);
    start2 += (stop - start2 - step * (n - paddingInner)) * align2;
    bandwidth = step * (1 - paddingInner);
    if (round2)
      start2 = Math.round(start2), bandwidth = Math.round(bandwidth);
    var values2 = range(n).map(function(i) {
      return start2 + step * i;
    });
    return ordinalRange2(reverse3 ? values2.reverse() : values2);
  }
  scale3.domain = function(_2) {
    return arguments.length ? (domain(_2), rescale()) : domain();
  };
  scale3.range = function(_2) {
    return arguments.length ? ([r0, r1] = _2, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
  };
  scale3.rangeRound = function(_2) {
    return [r0, r1] = _2, r0 = +r0, r1 = +r1, round2 = true, rescale();
  };
  scale3.bandwidth = function() {
    return bandwidth;
  };
  scale3.step = function() {
    return step;
  };
  scale3.round = function(_2) {
    return arguments.length ? (round2 = !!_2, rescale()) : round2;
  };
  scale3.padding = function(_2) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_2), rescale()) : paddingInner;
  };
  scale3.paddingInner = function(_2) {
    return arguments.length ? (paddingInner = Math.min(1, _2), rescale()) : paddingInner;
  };
  scale3.paddingOuter = function(_2) {
    return arguments.length ? (paddingOuter = +_2, rescale()) : paddingOuter;
  };
  scale3.align = function(_2) {
    return arguments.length ? (align2 = Math.max(0, Math.min(1, _2)), rescale()) : align2;
  };
  scale3.copy = function() {
    return band(domain(), [r0, r1]).round(round2).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align2);
  };
  return initRange.apply(rescale(), arguments);
}
function pointish(scale3) {
  var copy4 = scale3.copy;
  scale3.padding = scale3.paddingOuter;
  delete scale3.paddingInner;
  delete scale3.paddingOuter;
  scale3.copy = function() {
    return pointish(copy4());
  };
  return scale3;
}
function point() {
  return pointish(band.apply(null, arguments).paddingInner(1));
}

// ../../node_modules/d3-scale/src/constant.js
function constants(x4) {
  return function() {
    return x4;
  };
}

// ../../node_modules/d3-scale/src/number.js
function number3(x4) {
  return +x4;
}

// ../../node_modules/d3-scale/src/continuous.js
var unit = [0, 1];
function identity4(x4) {
  return x4;
}
function normalize2(a3, b2) {
  return (b2 -= a3 = +a3) ? function(x4) {
    return (x4 - a3) / b2;
  } : constants(isNaN(b2) ? NaN : 0.5);
}
function clamper(a3, b2) {
  var t;
  if (a3 > b2)
    t = a3, a3 = b2, b2 = t;
  return function(x4) {
    return Math.max(a3, Math.min(b2, x4));
  };
}
function bimap(domain, range3, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range3[0], r1 = range3[1];
  if (d1 < d0)
    d0 = normalize2(d1, d0), r0 = interpolate(r1, r0);
  else
    d0 = normalize2(d0, d1), r0 = interpolate(r0, r1);
  return function(x4) {
    return r0(d0(x4));
  };
}
function polymap(domain, range3, interpolate) {
  var j2 = Math.min(domain.length, range3.length) - 1, d = new Array(j2), r = new Array(j2), i = -1;
  if (domain[j2] < domain[0]) {
    domain = domain.slice().reverse();
    range3 = range3.slice().reverse();
  }
  while (++i < j2) {
    d[i] = normalize2(domain[i], domain[i + 1]);
    r[i] = interpolate(range3[i], range3[i + 1]);
  }
  return function(x4) {
    var i2 = bisect_default(domain, x4, 1, j2) - 1;
    return r[i2](d[i2](x4));
  };
}
function copy(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer2() {
  var domain = unit, range3 = unit, interpolate = value_default, transform3, untransform, unknown, clamp = identity4, piecewise2, output, input3;
  function rescale() {
    var n = Math.min(domain.length, range3.length);
    if (clamp !== identity4)
      clamp = clamper(domain[0], domain[n - 1]);
    piecewise2 = n > 2 ? polymap : bimap;
    output = input3 = null;
    return scale3;
  }
  function scale3(x4) {
    return x4 == null || isNaN(x4 = +x4) ? unknown : (output || (output = piecewise2(domain.map(transform3), range3, interpolate)))(transform3(clamp(x4)));
  }
  scale3.invert = function(y4) {
    return clamp(untransform((input3 || (input3 = piecewise2(range3, domain.map(transform3), number_default)))(y4)));
  };
  scale3.domain = function(_2) {
    return arguments.length ? (domain = Array.from(_2, number3), rescale()) : domain.slice();
  };
  scale3.range = function(_2) {
    return arguments.length ? (range3 = Array.from(_2), rescale()) : range3.slice();
  };
  scale3.rangeRound = function(_2) {
    return range3 = Array.from(_2), interpolate = round_default, rescale();
  };
  scale3.clamp = function(_2) {
    return arguments.length ? (clamp = _2 ? true : identity4, rescale()) : clamp !== identity4;
  };
  scale3.interpolate = function(_2) {
    return arguments.length ? (interpolate = _2, rescale()) : interpolate;
  };
  scale3.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale3) : unknown;
  };
  return function(t, u4) {
    transform3 = t, untransform = u4;
    return rescale();
  };
}
function continuous() {
  return transformer2()(identity4, identity4);
}

// ../../node_modules/d3-scale/src/tickFormat.js
function tickFormat(start2, stop, count4, specifier) {
  var step = tickStep(start2, stop, count4), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start2), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step, value)))
        specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound_default(step, Math.max(Math.abs(start2), Math.abs(stop)))))
        specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step)))
        specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format(specifier);
}

// ../../node_modules/d3-scale/src/linear.js
function linearish(scale3) {
  var domain = scale3.domain;
  scale3.ticks = function(count4) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], count4 == null ? 10 : count4);
  };
  scale3.tickFormat = function(count4, specifier) {
    var d = domain();
    return tickFormat(d[0], d[d.length - 1], count4 == null ? 10 : count4, specifier);
  };
  scale3.nice = function(count4) {
    if (count4 == null)
      count4 = 10;
    var d = domain();
    var i0 = 0;
    var i1 = d.length - 1;
    var start2 = d[i0];
    var stop = d[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop < start2) {
      step = start2, start2 = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start2, stop, count4);
      if (step === prestep) {
        d[i0] = start2;
        d[i1] = stop;
        return domain(d);
      } else if (step > 0) {
        start2 = Math.floor(start2 / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start2 = Math.ceil(start2 * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale3;
  };
  return scale3;
}
function linear2() {
  var scale3 = continuous();
  scale3.copy = function() {
    return copy(scale3, linear2());
  };
  initRange.apply(scale3, arguments);
  return linearish(scale3);
}

// ../../node_modules/d3-scale/src/identity.js
function identity5(domain) {
  var unknown;
  function scale3(x4) {
    return x4 == null || isNaN(x4 = +x4) ? unknown : x4;
  }
  scale3.invert = scale3;
  scale3.domain = scale3.range = function(_2) {
    return arguments.length ? (domain = Array.from(_2, number3), scale3) : domain.slice();
  };
  scale3.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale3) : unknown;
  };
  scale3.copy = function() {
    return identity5(domain).unknown(unknown);
  };
  domain = arguments.length ? Array.from(domain, number3) : [0, 1];
  return linearish(scale3);
}

// ../../node_modules/d3-scale/src/nice.js
function nice2(domain, interval2) {
  domain = domain.slice();
  var i0 = 0, i1 = domain.length - 1, x06 = domain[i0], x12 = domain[i1], t;
  if (x12 < x06) {
    t = i0, i0 = i1, i1 = t;
    t = x06, x06 = x12, x12 = t;
  }
  domain[i0] = interval2.floor(x06);
  domain[i1] = interval2.ceil(x12);
  return domain;
}

// ../../node_modules/d3-scale/src/log.js
function transformLog(x4) {
  return Math.log(x4);
}
function transformExp(x4) {
  return Math.exp(x4);
}
function transformLogn(x4) {
  return -Math.log(-x4);
}
function transformExpn(x4) {
  return -Math.exp(-x4);
}
function pow10(x4) {
  return isFinite(x4) ? +("1e" + x4) : x4 < 0 ? 0 : x4;
}
function powp(base) {
  return base === 10 ? pow10 : base === Math.E ? Math.exp : (x4) => Math.pow(base, x4);
}
function logp(base) {
  return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), (x4) => Math.log(x4) / base);
}
function reflect(f2) {
  return (x4, k3) => -f2(-x4, k3);
}
function loggish(transform3) {
  const scale3 = transform3(transformLog, transformExp);
  const domain = scale3.domain;
  let base = 10;
  let logs;
  let pows;
  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform3(transformLogn, transformExpn);
    } else {
      transform3(transformLog, transformExp);
    }
    return scale3;
  }
  scale3.base = function(_2) {
    return arguments.length ? (base = +_2, rescale()) : base;
  };
  scale3.domain = function(_2) {
    return arguments.length ? (domain(_2), rescale()) : domain();
  };
  scale3.ticks = (count4) => {
    const d = domain();
    let u4 = d[0];
    let v3 = d[d.length - 1];
    const r = v3 < u4;
    if (r)
      [u4, v3] = [v3, u4];
    let i = logs(u4);
    let j2 = logs(v3);
    let k3;
    let t;
    const n = count4 == null ? 10 : +count4;
    let z2 = [];
    if (!(base % 1) && j2 - i < n) {
      i = Math.floor(i), j2 = Math.ceil(j2);
      if (u4 > 0)
        for (; i <= j2; ++i) {
          for (k3 = 1; k3 < base; ++k3) {
            t = i < 0 ? k3 / pows(-i) : k3 * pows(i);
            if (t < u4)
              continue;
            if (t > v3)
              break;
            z2.push(t);
          }
        }
      else
        for (; i <= j2; ++i) {
          for (k3 = base - 1; k3 >= 1; --k3) {
            t = i > 0 ? k3 / pows(-i) : k3 * pows(i);
            if (t < u4)
              continue;
            if (t > v3)
              break;
            z2.push(t);
          }
        }
      if (z2.length * 2 < n)
        z2 = ticks(u4, v3, n);
    } else {
      z2 = ticks(i, j2, Math.min(j2 - i, n)).map(pows);
    }
    return r ? z2.reverse() : z2;
  };
  scale3.tickFormat = (count4, specifier) => {
    if (count4 == null)
      count4 = 10;
    if (specifier == null)
      specifier = base === 10 ? "s" : ",";
    if (typeof specifier !== "function") {
      if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null)
        specifier.trim = true;
      specifier = format(specifier);
    }
    if (count4 === Infinity)
      return specifier;
    const k3 = Math.max(1, base * count4 / scale3.ticks().length);
    return (d) => {
      let i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5)
        i *= base;
      return i <= k3 ? specifier(d) : "";
    };
  };
  scale3.nice = () => {
    return domain(nice2(domain(), {
      floor: (x4) => pows(Math.floor(logs(x4))),
      ceil: (x4) => pows(Math.ceil(logs(x4)))
    }));
  };
  return scale3;
}
function log2() {
  const scale3 = loggish(transformer2()).domain([1, 10]);
  scale3.copy = () => copy(scale3, log2()).base(scale3.base());
  initRange.apply(scale3, arguments);
  return scale3;
}

// ../../node_modules/d3-scale/src/symlog.js
function transformSymlog(c4) {
  return function(x4) {
    return Math.sign(x4) * Math.log1p(Math.abs(x4 / c4));
  };
}
function transformSymexp(c4) {
  return function(x4) {
    return Math.sign(x4) * Math.expm1(Math.abs(x4)) * c4;
  };
}
function symlogish(transform3) {
  var c4 = 1, scale3 = transform3(transformSymlog(c4), transformSymexp(c4));
  scale3.constant = function(_2) {
    return arguments.length ? transform3(transformSymlog(c4 = +_2), transformSymexp(c4)) : c4;
  };
  return linearish(scale3);
}
function symlog() {
  var scale3 = symlogish(transformer2());
  scale3.copy = function() {
    return copy(scale3, symlog()).constant(scale3.constant());
  };
  return initRange.apply(scale3, arguments);
}

// ../../node_modules/d3-scale/src/pow.js
function transformPow(exponent) {
  return function(x4) {
    return x4 < 0 ? -Math.pow(-x4, exponent) : Math.pow(x4, exponent);
  };
}
function transformSqrt(x4) {
  return x4 < 0 ? -Math.sqrt(-x4) : Math.sqrt(x4);
}
function transformSquare(x4) {
  return x4 < 0 ? -x4 * x4 : x4 * x4;
}
function powish(transform3) {
  var scale3 = transform3(identity4, identity4), exponent = 1;
  function rescale() {
    return exponent === 1 ? transform3(identity4, identity4) : exponent === 0.5 ? transform3(transformSqrt, transformSquare) : transform3(transformPow(exponent), transformPow(1 / exponent));
  }
  scale3.exponent = function(_2) {
    return arguments.length ? (exponent = +_2, rescale()) : exponent;
  };
  return linearish(scale3);
}
function pow3() {
  var scale3 = powish(transformer2());
  scale3.copy = function() {
    return copy(scale3, pow3()).exponent(scale3.exponent());
  };
  initRange.apply(scale3, arguments);
  return scale3;
}

// ../../node_modules/d3-scale/src/quantile.js
function quantile3() {
  var domain = [], range3 = [], thresholds = [], unknown;
  function rescale() {
    var i = 0, n = Math.max(1, range3.length);
    thresholds = new Array(n - 1);
    while (++i < n)
      thresholds[i - 1] = quantileSorted(domain, i / n);
    return scale3;
  }
  function scale3(x4) {
    return x4 == null || isNaN(x4 = +x4) ? unknown : range3[bisect_default(thresholds, x4)];
  }
  scale3.invertExtent = function(y4) {
    var i = range3.indexOf(y4);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };
  scale3.domain = function(_2) {
    if (!arguments.length)
      return domain.slice();
    domain = [];
    for (let d of _2)
      if (d != null && !isNaN(d = +d))
        domain.push(d);
    domain.sort(ascending);
    return rescale();
  };
  scale3.range = function(_2) {
    return arguments.length ? (range3 = Array.from(_2), rescale()) : range3.slice();
  };
  scale3.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale3) : unknown;
  };
  scale3.quantiles = function() {
    return thresholds.slice();
  };
  scale3.copy = function() {
    return quantile3().domain(domain).range(range3).unknown(unknown);
  };
  return initRange.apply(scale3, arguments);
}

// ../../node_modules/d3-scale/src/threshold.js
function threshold() {
  var domain = [0.5], range3 = [0, 1], unknown, n = 1;
  function scale3(x4) {
    return x4 != null && x4 <= x4 ? range3[bisect_default(domain, x4, 0, n)] : unknown;
  }
  scale3.domain = function(_2) {
    return arguments.length ? (domain = Array.from(_2), n = Math.min(domain.length, range3.length - 1), scale3) : domain.slice();
  };
  scale3.range = function(_2) {
    return arguments.length ? (range3 = Array.from(_2), n = Math.min(domain.length, range3.length - 1), scale3) : range3.slice();
  };
  scale3.invertExtent = function(y4) {
    var i = range3.indexOf(y4);
    return [domain[i - 1], domain[i]];
  };
  scale3.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale3) : unknown;
  };
  scale3.copy = function() {
    return threshold().domain(domain).range(range3).unknown(unknown);
  };
  return initRange.apply(scale3, arguments);
}

// ../../node_modules/d3-time/src/interval.js
var t02 = /* @__PURE__ */ new Date();
var t12 = /* @__PURE__ */ new Date();
function timeInterval(floori, offseti, count4, field2) {
  function interval2(date2) {
    return floori(date2 = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date2)), date2;
  }
  interval2.floor = (date2) => {
    return floori(date2 = /* @__PURE__ */ new Date(+date2)), date2;
  };
  interval2.ceil = (date2) => {
    return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
  };
  interval2.round = (date2) => {
    const d0 = interval2(date2), d1 = interval2.ceil(date2);
    return date2 - d0 < d1 - date2 ? d0 : d1;
  };
  interval2.offset = (date2, step) => {
    return offseti(date2 = /* @__PURE__ */ new Date(+date2), step == null ? 1 : Math.floor(step)), date2;
  };
  interval2.range = (start2, stop, step) => {
    const range3 = [];
    start2 = interval2.ceil(start2);
    step = step == null ? 1 : Math.floor(step);
    if (!(start2 < stop) || !(step > 0))
      return range3;
    let previous;
    do
      range3.push(previous = /* @__PURE__ */ new Date(+start2)), offseti(start2, step), floori(start2);
    while (previous < start2 && start2 < stop);
    return range3;
  };
  interval2.filter = (test) => {
    return timeInterval((date2) => {
      if (date2 >= date2)
        while (floori(date2), !test(date2))
          date2.setTime(date2 - 1);
    }, (date2, step) => {
      if (date2 >= date2) {
        if (step < 0)
          while (++step <= 0) {
            while (offseti(date2, -1), !test(date2)) {
            }
          }
        else
          while (--step >= 0) {
            while (offseti(date2, 1), !test(date2)) {
            }
          }
      }
    });
  };
  if (count4) {
    interval2.count = (start2, end) => {
      t02.setTime(+start2), t12.setTime(+end);
      floori(t02), floori(t12);
      return Math.floor(count4(t02, t12));
    };
    interval2.every = (step) => {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval2 : interval2.filter(field2 ? (d) => field2(d) % step === 0 : (d) => interval2.count(0, d) % step === 0);
    };
  }
  return interval2;
}

// ../../node_modules/d3-time/src/millisecond.js
var millisecond = timeInterval(() => {
}, (date2, step) => {
  date2.setTime(+date2 + step);
}, (start2, end) => {
  return end - start2;
});
millisecond.every = (k3) => {
  k3 = Math.floor(k3);
  if (!isFinite(k3) || !(k3 > 0))
    return null;
  if (!(k3 > 1))
    return millisecond;
  return timeInterval((date2) => {
    date2.setTime(Math.floor(date2 / k3) * k3);
  }, (date2, step) => {
    date2.setTime(+date2 + step * k3);
  }, (start2, end) => {
    return (end - start2) / k3;
  });
};
var milliseconds = millisecond.range;

// ../../node_modules/d3-time/src/duration.js
var durationSecond = 1e3;
var durationMinute = durationSecond * 60;
var durationHour = durationMinute * 60;
var durationDay = durationHour * 24;
var durationWeek = durationDay * 7;
var durationMonth = durationDay * 30;
var durationYear = durationDay * 365;

// ../../node_modules/d3-time/src/second.js
var second = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds());
}, (date2, step) => {
  date2.setTime(+date2 + step * durationSecond);
}, (start2, end) => {
  return (end - start2) / durationSecond;
}, (date2) => {
  return date2.getUTCSeconds();
});
var seconds = second.range;

// ../../node_modules/d3-time/src/minute.js
var timeMinute = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationMinute);
}, (start2, end) => {
  return (end - start2) / durationMinute;
}, (date2) => {
  return date2.getMinutes();
});
var timeMinutes = timeMinute.range;
var utcMinute = timeInterval((date2) => {
  date2.setUTCSeconds(0, 0);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationMinute);
}, (start2, end) => {
  return (end - start2) / durationMinute;
}, (date2) => {
  return date2.getUTCMinutes();
});
var utcMinutes = utcMinute.range;

// ../../node_modules/d3-time/src/hour.js
var timeHour = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond - date2.getMinutes() * durationMinute);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationHour);
}, (start2, end) => {
  return (end - start2) / durationHour;
}, (date2) => {
  return date2.getHours();
});
var timeHours = timeHour.range;
var utcHour = timeInterval((date2) => {
  date2.setUTCMinutes(0, 0, 0);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationHour);
}, (start2, end) => {
  return (end - start2) / durationHour;
}, (date2) => {
  return date2.getUTCHours();
});
var utcHours = utcHour.range;

// ../../node_modules/d3-time/src/day.js
var timeDay = timeInterval(
  (date2) => date2.setHours(0, 0, 0, 0),
  (date2, step) => date2.setDate(date2.getDate() + step),
  (start2, end) => (end - start2 - (end.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationDay,
  (date2) => date2.getDate() - 1
);
var timeDays = timeDay.range;
var utcDay = timeInterval((date2) => {
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCDate(date2.getUTCDate() + step);
}, (start2, end) => {
  return (end - start2) / durationDay;
}, (date2) => {
  return date2.getUTCDate() - 1;
});
var utcDays = utcDay.range;
var unixDay = timeInterval((date2) => {
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCDate(date2.getUTCDate() + step);
}, (start2, end) => {
  return (end - start2) / durationDay;
}, (date2) => {
  return Math.floor(date2 / durationDay);
});
var unixDays = unixDay.range;

// ../../node_modules/d3-time/src/week.js
function timeWeekday(i) {
  return timeInterval((date2) => {
    date2.setDate(date2.getDate() - (date2.getDay() + 7 - i) % 7);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setDate(date2.getDate() + step * 7);
  }, (start2, end) => {
    return (end - start2 - (end.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}
var timeSunday = timeWeekday(0);
var timeMonday = timeWeekday(1);
var timeTuesday = timeWeekday(2);
var timeWednesday = timeWeekday(3);
var timeThursday = timeWeekday(4);
var timeFriday = timeWeekday(5);
var timeSaturday = timeWeekday(6);
var timeSundays = timeSunday.range;
var timeMondays = timeMonday.range;
var timeTuesdays = timeTuesday.range;
var timeWednesdays = timeWednesday.range;
var timeThursdays = timeThursday.range;
var timeFridays = timeFriday.range;
var timeSaturdays = timeSaturday.range;
function utcWeekday(i) {
  return timeInterval((date2) => {
    date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i) % 7);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCDate(date2.getUTCDate() + step * 7);
  }, (start2, end) => {
    return (end - start2) / durationWeek;
  });
}
var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);
var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

// ../../node_modules/d3-time/src/month.js
var timeMonth = timeInterval((date2) => {
  date2.setDate(1);
  date2.setHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setMonth(date2.getMonth() + step);
}, (start2, end) => {
  return end.getMonth() - start2.getMonth() + (end.getFullYear() - start2.getFullYear()) * 12;
}, (date2) => {
  return date2.getMonth();
});
var timeMonths = timeMonth.range;
var utcMonth = timeInterval((date2) => {
  date2.setUTCDate(1);
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCMonth(date2.getUTCMonth() + step);
}, (start2, end) => {
  return end.getUTCMonth() - start2.getUTCMonth() + (end.getUTCFullYear() - start2.getUTCFullYear()) * 12;
}, (date2) => {
  return date2.getUTCMonth();
});
var utcMonths = utcMonth.range;

// ../../node_modules/d3-time/src/year.js
var timeYear = timeInterval((date2) => {
  date2.setMonth(0, 1);
  date2.setHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setFullYear(date2.getFullYear() + step);
}, (start2, end) => {
  return end.getFullYear() - start2.getFullYear();
}, (date2) => {
  return date2.getFullYear();
});
timeYear.every = (k3) => {
  return !isFinite(k3 = Math.floor(k3)) || !(k3 > 0) ? null : timeInterval((date2) => {
    date2.setFullYear(Math.floor(date2.getFullYear() / k3) * k3);
    date2.setMonth(0, 1);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setFullYear(date2.getFullYear() + step * k3);
  });
};
var timeYears = timeYear.range;
var utcYear = timeInterval((date2) => {
  date2.setUTCMonth(0, 1);
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCFullYear(date2.getUTCFullYear() + step);
}, (start2, end) => {
  return end.getUTCFullYear() - start2.getUTCFullYear();
}, (date2) => {
  return date2.getUTCFullYear();
});
utcYear.every = (k3) => {
  return !isFinite(k3 = Math.floor(k3)) || !(k3 > 0) ? null : timeInterval((date2) => {
    date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k3) * k3);
    date2.setUTCMonth(0, 1);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCFullYear(date2.getUTCFullYear() + step * k3);
  });
};
var utcYears = utcYear.range;

// ../../node_modules/d3-time/src/ticks.js
function ticker(year, month, week, day, hour, minute) {
  const tickIntervals2 = [
    [second, 1, durationSecond],
    [second, 5, 5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute, 1, durationMinute],
    [minute, 5, 5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [hour, 1, durationHour],
    [hour, 3, 3 * durationHour],
    [hour, 6, 6 * durationHour],
    [hour, 12, 12 * durationHour],
    [day, 1, durationDay],
    [day, 2, 2 * durationDay],
    [week, 1, durationWeek],
    [month, 1, durationMonth],
    [month, 3, 3 * durationMonth],
    [year, 1, durationYear]
  ];
  function ticks2(start2, stop, count4) {
    const reverse3 = stop < start2;
    if (reverse3)
      [start2, stop] = [stop, start2];
    const interval2 = count4 && typeof count4.range === "function" ? count4 : tickInterval(start2, stop, count4);
    const ticks3 = interval2 ? interval2.range(start2, +stop + 1) : [];
    return reverse3 ? ticks3.reverse() : ticks3;
  }
  function tickInterval(start2, stop, count4) {
    const target = Math.abs(stop - start2) / count4;
    const i = bisector(([, , step2]) => step2).right(tickIntervals2, target);
    if (i === tickIntervals2.length)
      return year.every(tickStep(start2 / durationYear, stop / durationYear, count4));
    if (i === 0)
      return millisecond.every(Math.max(tickStep(start2, stop, count4), 1));
    const [t, step] = tickIntervals2[target / tickIntervals2[i - 1][2] < tickIntervals2[i][2] / target ? i - 1 : i];
    return t.every(step);
  }
  return [ticks2, tickInterval];
}
var [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);
var [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);

// ../../node_modules/d3-time-format/src/locale.js
function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date2.setFullYear(d.y);
    return date2;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}
function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date2.setUTCFullYear(d.y);
    return date2;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}
function newDate(y4, m2, d) {
  return { y: y4, m: m2, d, H: 0, M: 0, S: 0, L: 0 };
}
function formatLocale(locale3) {
  var locale_dateTime = locale3.dateTime, locale_date = locale3.date, locale_time = locale3.time, locale_periods = locale3.periods, locale_weekdays = locale3.days, locale_shortWeekdays = locale3.shortDays, locale_months = locale3.months, locale_shortMonths = locale3.shortMonths;
  var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday2,
    "b": formatShortMonth,
    "B": formatMonth2,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);
  function newFormat(specifier, formats2) {
    return function(date2) {
      var string2 = [], i = -1, j2 = 0, n = specifier.length, c4, pad3, format3;
      if (!(date2 instanceof Date))
        date2 = /* @__PURE__ */ new Date(+date2);
      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string2.push(specifier.slice(j2, i));
          if ((pad3 = pads[c4 = specifier.charAt(++i)]) != null)
            c4 = specifier.charAt(++i);
          else
            pad3 = c4 === "e" ? " " : "0";
          if (format3 = formats2[c4])
            c4 = format3(date2, pad3);
          string2.push(c4);
          j2 = i + 1;
        }
      }
      string2.push(specifier.slice(j2, i));
      return string2.join("");
    };
  }
  function newParse(specifier, Z3) {
    return function(string2) {
      var d = newDate(1900, void 0, 1), i = parseSpecifier(d, specifier, string2 += "", 0), week, day;
      if (i != string2.length)
        return null;
      if ("Q" in d)
        return new Date(d.Q);
      if ("s" in d)
        return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
      if (Z3 && !("Z" in d))
        d.Z = 0;
      if ("p" in d)
        d.H = d.H % 12 + d.p * 12;
      if (d.m === void 0)
        d.m = "q" in d ? d.q : 0;
      if ("V" in d) {
        if (d.V < 1 || d.V > 53)
          return null;
        if (!("w" in d))
          d.w = 1;
        if ("Z" in d) {
          week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = utcDay.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
          week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);
          week = timeDay.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d))
          d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      }
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }
      return localDate(d);
    };
  }
  function parseSpecifier(d, specifier, string2, j2) {
    var i = 0, n = specifier.length, m2 = string2.length, c4, parse2;
    while (i < n) {
      if (j2 >= m2)
        return -1;
      c4 = specifier.charCodeAt(i++);
      if (c4 === 37) {
        c4 = specifier.charAt(i++);
        parse2 = parses[c4 in pads ? specifier.charAt(i++) : c4];
        if (!parse2 || (j2 = parse2(d, string2, j2)) < 0)
          return -1;
      } else if (c4 != string2.charCodeAt(j2++)) {
        return -1;
      }
    }
    return j2;
  }
  function parsePeriod(d, string2, i) {
    var n = periodRe.exec(string2.slice(i));
    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortWeekday(d, string2, i) {
    var n = shortWeekdayRe.exec(string2.slice(i));
    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseWeekday(d, string2, i) {
    var n = weekdayRe.exec(string2.slice(i));
    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortMonth(d, string2, i) {
    var n = shortMonthRe.exec(string2.slice(i));
    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseMonth(d, string2, i) {
    var n = monthRe.exec(string2.slice(i));
    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseLocaleDateTime(d, string2, i) {
    return parseSpecifier(d, locale_dateTime, string2, i);
  }
  function parseLocaleDate(d, string2, i) {
    return parseSpecifier(d, locale_date, string2, i);
  }
  function parseLocaleTime(d, string2, i) {
    return parseSpecifier(d, locale_time, string2, i);
  }
  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }
  function formatWeekday2(d) {
    return locale_weekdays[d.getDay()];
  }
  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }
  function formatMonth2(d) {
    return locale_months[d.getMonth()];
  }
  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }
  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }
  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }
  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }
  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }
  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }
  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }
  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }
  return {
    format: function(specifier) {
      var f2 = newFormat(specifier += "", formats);
      f2.toString = function() {
        return specifier;
      };
      return f2;
    },
    parse: function(specifier) {
      var p2 = newParse(specifier += "", false);
      p2.toString = function() {
        return specifier;
      };
      return p2;
    },
    utcFormat: function(specifier) {
      var f2 = newFormat(specifier += "", utcFormats);
      f2.toString = function() {
        return specifier;
      };
      return f2;
    },
    utcParse: function(specifier) {
      var p2 = newParse(specifier += "", true);
      p2.toString = function() {
        return specifier;
      };
      return p2;
    }
  };
}
var pads = { "-": "", "_": " ", "0": "0" };
var numberRe = /^\s*\d+/;
var percentRe = /^%/;
var requoteRe = /[\\^$*+?|[\]().{}]/g;
function pad(value, fill, width2) {
  var sign3 = value < 0 ? "-" : "", string2 = (sign3 ? -value : value) + "", length4 = string2.length;
  return sign3 + (length4 < width2 ? new Array(width2 - length4 + 1).join(fill) + string2 : string2);
}
function requote(s2) {
  return s2.replace(requoteRe, "\\$&");
}
function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}
function formatLookup(names) {
  return new Map(names.map((name2, i) => [name2.toLowerCase(), i]));
}
function parseWeekdayNumberSunday(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}
function parseWeekdayNumberMonday(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberSunday(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberISO(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberMonday(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}
function parseFullYear(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}
function parseYear(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
}
function parseZone(d, string2, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string2.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}
function parseQuarter(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}
function parseMonthNumber(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}
function parseDayOfMonth(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}
function parseDayOfYear(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}
function parseHour24(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}
function parseMinutes(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}
function parseSeconds(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}
function parseMilliseconds(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}
function parseMicroseconds(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
}
function parseLiteralPercent(d, string2, i) {
  var n = percentRe.exec(string2.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}
function parseUnixTimestamp(d, string2, i) {
  var n = numberRe.exec(string2.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}
function parseUnixTimestampSeconds(d, string2, i) {
  var n = numberRe.exec(string2.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}
function formatDayOfMonth(d, p2) {
  return pad(d.getDate(), p2, 2);
}
function formatHour24(d, p2) {
  return pad(d.getHours(), p2, 2);
}
function formatHour12(d, p2) {
  return pad(d.getHours() % 12 || 12, p2, 2);
}
function formatDayOfYear(d, p2) {
  return pad(1 + timeDay.count(timeYear(d), d), p2, 3);
}
function formatMilliseconds(d, p2) {
  return pad(d.getMilliseconds(), p2, 3);
}
function formatMicroseconds(d, p2) {
  return formatMilliseconds(d, p2) + "000";
}
function formatMonthNumber(d, p2) {
  return pad(d.getMonth() + 1, p2, 2);
}
function formatMinutes(d, p2) {
  return pad(d.getMinutes(), p2, 2);
}
function formatSeconds(d, p2) {
  return pad(d.getSeconds(), p2, 2);
}
function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}
function formatWeekNumberSunday(d, p2) {
  return pad(timeSunday.count(timeYear(d) - 1, d), p2, 2);
}
function dISO(d) {
  var day = d.getDay();
  return day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
}
function formatWeekNumberISO(d, p2) {
  d = dISO(d);
  return pad(timeThursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p2, 2);
}
function formatWeekdayNumberSunday(d) {
  return d.getDay();
}
function formatWeekNumberMonday(d, p2) {
  return pad(timeMonday.count(timeYear(d) - 1, d), p2, 2);
}
function formatYear(d, p2) {
  return pad(d.getFullYear() % 100, p2, 2);
}
function formatYearISO(d, p2) {
  d = dISO(d);
  return pad(d.getFullYear() % 100, p2, 2);
}
function formatFullYear(d, p2) {
  return pad(d.getFullYear() % 1e4, p2, 4);
}
function formatFullYearISO(d, p2) {
  var day = d.getDay();
  d = day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
  return pad(d.getFullYear() % 1e4, p2, 4);
}
function formatZone(d) {
  var z2 = d.getTimezoneOffset();
  return (z2 > 0 ? "-" : (z2 *= -1, "+")) + pad(z2 / 60 | 0, "0", 2) + pad(z2 % 60, "0", 2);
}
function formatUTCDayOfMonth(d, p2) {
  return pad(d.getUTCDate(), p2, 2);
}
function formatUTCHour24(d, p2) {
  return pad(d.getUTCHours(), p2, 2);
}
function formatUTCHour12(d, p2) {
  return pad(d.getUTCHours() % 12 || 12, p2, 2);
}
function formatUTCDayOfYear(d, p2) {
  return pad(1 + utcDay.count(utcYear(d), d), p2, 3);
}
function formatUTCMilliseconds(d, p2) {
  return pad(d.getUTCMilliseconds(), p2, 3);
}
function formatUTCMicroseconds(d, p2) {
  return formatUTCMilliseconds(d, p2) + "000";
}
function formatUTCMonthNumber(d, p2) {
  return pad(d.getUTCMonth() + 1, p2, 2);
}
function formatUTCMinutes(d, p2) {
  return pad(d.getUTCMinutes(), p2, 2);
}
function formatUTCSeconds(d, p2) {
  return pad(d.getUTCSeconds(), p2, 2);
}
function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday(d, p2) {
  return pad(utcSunday.count(utcYear(d) - 1, d), p2, 2);
}
function UTCdISO(d) {
  var day = d.getUTCDay();
  return day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
}
function formatUTCWeekNumberISO(d, p2) {
  d = UTCdISO(d);
  return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p2, 2);
}
function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}
function formatUTCWeekNumberMonday(d, p2) {
  return pad(utcMonday.count(utcYear(d) - 1, d), p2, 2);
}
function formatUTCYear(d, p2) {
  return pad(d.getUTCFullYear() % 100, p2, 2);
}
function formatUTCYearISO(d, p2) {
  d = UTCdISO(d);
  return pad(d.getUTCFullYear() % 100, p2, 2);
}
function formatUTCFullYear(d, p2) {
  return pad(d.getUTCFullYear() % 1e4, p2, 4);
}
function formatUTCFullYearISO(d, p2) {
  var day = d.getUTCDay();
  d = day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
  return pad(d.getUTCFullYear() % 1e4, p2, 4);
}
function formatUTCZone() {
  return "+0000";
}
function formatLiteralPercent() {
  return "%";
}
function formatUnixTimestamp(d) {
  return +d;
}
function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1e3);
}

// ../../node_modules/d3-time-format/src/defaultLocale.js
var locale2;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;
defaultLocale2({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function defaultLocale2(definition) {
  locale2 = formatLocale(definition);
  timeFormat = locale2.format;
  timeParse = locale2.parse;
  utcFormat = locale2.utcFormat;
  utcParse = locale2.utcParse;
  return locale2;
}

// ../../node_modules/d3-scale/src/time.js
function date(t) {
  return new Date(t);
}
function number4(t) {
  return t instanceof Date ? +t : +/* @__PURE__ */ new Date(+t);
}
function calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second3, format3) {
  var scale3 = continuous(), invert2 = scale3.invert, domain = scale3.domain;
  var formatMillisecond = format3(".%L"), formatSecond = format3(":%S"), formatMinute = format3("%I:%M"), formatHour = format3("%I %p"), formatDay = format3("%a %d"), formatWeek = format3("%b %d"), formatMonth2 = format3("%B"), formatYear3 = format3("%Y");
  function tickFormat2(date2) {
    return (second3(date2) < date2 ? formatMillisecond : minute(date2) < date2 ? formatSecond : hour(date2) < date2 ? formatMinute : day(date2) < date2 ? formatHour : month(date2) < date2 ? week(date2) < date2 ? formatDay : formatWeek : year(date2) < date2 ? formatMonth2 : formatYear3)(date2);
  }
  scale3.invert = function(y4) {
    return new Date(invert2(y4));
  };
  scale3.domain = function(_2) {
    return arguments.length ? domain(Array.from(_2, number4)) : domain().map(date);
  };
  scale3.ticks = function(interval2) {
    var d = domain();
    return ticks2(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);
  };
  scale3.tickFormat = function(count4, specifier) {
    return specifier == null ? tickFormat2 : format3(specifier);
  };
  scale3.nice = function(interval2) {
    var d = domain();
    if (!interval2 || typeof interval2.range !== "function")
      interval2 = tickInterval(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);
    return interval2 ? domain(nice2(d, interval2)) : scale3;
  };
  scale3.copy = function() {
    return copy(scale3, calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second3, format3));
  };
  return scale3;
}
function time() {
  return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute, second, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}

// ../../node_modules/d3-scale/src/utcTime.js
function utcTime() {
  return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}

// ../../node_modules/d3-scale/src/sequential.js
function copy2(source, target) {
  return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());
}

// ../../node_modules/d3-scale/src/diverging.js
function transformer3() {
  var x06 = 0, x12 = 0.5, x22 = 1, s2 = 1, t03, t13, t22, k10, k21, interpolator = identity4, transform3, clamp = false, unknown;
  function scale3(x4) {
    return isNaN(x4 = +x4) ? unknown : (x4 = 0.5 + ((x4 = +transform3(x4)) - t13) * (s2 * x4 < s2 * t13 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x4)) : x4));
  }
  scale3.domain = function(_2) {
    return arguments.length ? ([x06, x12, x22] = _2, t03 = transform3(x06 = +x06), t13 = transform3(x12 = +x12), t22 = transform3(x22 = +x22), k10 = t03 === t13 ? 0 : 0.5 / (t13 - t03), k21 = t13 === t22 ? 0 : 0.5 / (t22 - t13), s2 = t13 < t03 ? -1 : 1, scale3) : [x06, x12, x22];
  };
  scale3.clamp = function(_2) {
    return arguments.length ? (clamp = !!_2, scale3) : clamp;
  };
  scale3.interpolator = function(_2) {
    return arguments.length ? (interpolator = _2, scale3) : interpolator;
  };
  function range3(interpolate) {
    return function(_2) {
      var r0, r1, r2;
      return arguments.length ? ([r0, r1, r2] = _2, interpolator = piecewise(interpolate, [r0, r1, r2]), scale3) : [interpolator(0), interpolator(0.5), interpolator(1)];
    };
  }
  scale3.range = range3(value_default);
  scale3.rangeRound = range3(round_default);
  scale3.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale3) : unknown;
  };
  return function(t) {
    transform3 = t, t03 = t(x06), t13 = t(x12), t22 = t(x22), k10 = t03 === t13 ? 0 : 0.5 / (t13 - t03), k21 = t13 === t22 ? 0 : 0.5 / (t22 - t13), s2 = t13 < t03 ? -1 : 1;
    return scale3;
  };
}
function diverging() {
  var scale3 = linearish(transformer3()(identity4));
  scale3.copy = function() {
    return copy2(scale3, diverging());
  };
  return initInterpolator.apply(scale3, arguments);
}
function divergingLog() {
  var scale3 = loggish(transformer3()).domain([0.1, 1, 10]);
  scale3.copy = function() {
    return copy2(scale3, divergingLog()).base(scale3.base());
  };
  return initInterpolator.apply(scale3, arguments);
}
function divergingSymlog() {
  var scale3 = symlogish(transformer3());
  scale3.copy = function() {
    return copy2(scale3, divergingSymlog()).constant(scale3.constant());
  };
  return initInterpolator.apply(scale3, arguments);
}
function divergingPow() {
  var scale3 = powish(transformer3());
  scale3.copy = function() {
    return copy2(scale3, divergingPow()).exponent(scale3.exponent());
  };
  return initInterpolator.apply(scale3, arguments);
}

// ../../node_modules/d3-scale-chromatic/src/colors.js
function colors_default(specifier) {
  var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
  while (i < n)
    colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
  return colors;
}

// ../../node_modules/d3-scale-chromatic/src/categorical/category10.js
var category10_default = colors_default("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

// ../../node_modules/d3-scale-chromatic/src/categorical/Accent.js
var Accent_default = colors_default("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

// ../../node_modules/d3-scale-chromatic/src/categorical/Dark2.js
var Dark2_default = colors_default("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

// ../../node_modules/d3-scale-chromatic/src/categorical/observable10.js
var observable10_default = colors_default("4269d0efb118ff725c6cc5b03ca951ff8ab7a463f297bbf59c6b4e9498a0");

// ../../node_modules/d3-scale-chromatic/src/categorical/Paired.js
var Paired_default = colors_default("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

// ../../node_modules/d3-scale-chromatic/src/categorical/Pastel1.js
var Pastel1_default = colors_default("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

// ../../node_modules/d3-scale-chromatic/src/categorical/Pastel2.js
var Pastel2_default = colors_default("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

// ../../node_modules/d3-scale-chromatic/src/categorical/Set1.js
var Set1_default = colors_default("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

// ../../node_modules/d3-scale-chromatic/src/categorical/Set2.js
var Set2_default = colors_default("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

// ../../node_modules/d3-scale-chromatic/src/categorical/Set3.js
var Set3_default = colors_default("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

// ../../node_modules/d3-scale-chromatic/src/categorical/Tableau10.js
var Tableau10_default = colors_default("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");

// ../../node_modules/d3-scale-chromatic/src/ramp.js
var ramp_default = (scheme28) => rgbBasis(scheme28[scheme28.length - 1]);

// ../../node_modules/d3-scale-chromatic/src/diverging/BrBG.js
var scheme = new Array(3).concat(
  "d8b365f5f5f55ab4ac",
  "a6611adfc27d80cdc1018571",
  "a6611adfc27df5f5f580cdc1018571",
  "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
  "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
  "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
  "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
  "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
  "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
).map(colors_default);
var BrBG_default = ramp_default(scheme);

// ../../node_modules/d3-scale-chromatic/src/diverging/PRGn.js
var scheme2 = new Array(3).concat(
  "af8dc3f7f7f77fbf7b",
  "7b3294c2a5cfa6dba0008837",
  "7b3294c2a5cff7f7f7a6dba0008837",
  "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
  "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
  "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
  "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
  "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
  "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
).map(colors_default);
var PRGn_default = ramp_default(scheme2);

// ../../node_modules/d3-scale-chromatic/src/diverging/PiYG.js
var scheme3 = new Array(3).concat(
  "e9a3c9f7f7f7a1d76a",
  "d01c8bf1b6dab8e1864dac26",
  "d01c8bf1b6daf7f7f7b8e1864dac26",
  "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
  "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
  "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
  "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
  "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
  "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
).map(colors_default);
var PiYG_default = ramp_default(scheme3);

// ../../node_modules/d3-scale-chromatic/src/diverging/PuOr.js
var scheme4 = new Array(3).concat(
  "998ec3f7f7f7f1a340",
  "5e3c99b2abd2fdb863e66101",
  "5e3c99b2abd2f7f7f7fdb863e66101",
  "542788998ec3d8daebfee0b6f1a340b35806",
  "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
  "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
  "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
  "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
  "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
).map(colors_default);
var PuOr_default = ramp_default(scheme4);

// ../../node_modules/d3-scale-chromatic/src/diverging/RdBu.js
var scheme5 = new Array(3).concat(
  "ef8a62f7f7f767a9cf",
  "ca0020f4a58292c5de0571b0",
  "ca0020f4a582f7f7f792c5de0571b0",
  "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
  "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
  "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
  "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
  "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
  "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
).map(colors_default);
var RdBu_default = ramp_default(scheme5);

// ../../node_modules/d3-scale-chromatic/src/diverging/RdGy.js
var scheme6 = new Array(3).concat(
  "ef8a62ffffff999999",
  "ca0020f4a582bababa404040",
  "ca0020f4a582ffffffbababa404040",
  "b2182bef8a62fddbc7e0e0e09999994d4d4d",
  "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
  "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
  "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
  "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
  "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
).map(colors_default);
var RdGy_default = ramp_default(scheme6);

// ../../node_modules/d3-scale-chromatic/src/diverging/RdYlBu.js
var scheme7 = new Array(3).concat(
  "fc8d59ffffbf91bfdb",
  "d7191cfdae61abd9e92c7bb6",
  "d7191cfdae61ffffbfabd9e92c7bb6",
  "d73027fc8d59fee090e0f3f891bfdb4575b4",
  "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
  "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
  "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
  "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
  "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
).map(colors_default);
var RdYlBu_default = ramp_default(scheme7);

// ../../node_modules/d3-scale-chromatic/src/diverging/RdYlGn.js
var scheme8 = new Array(3).concat(
  "fc8d59ffffbf91cf60",
  "d7191cfdae61a6d96a1a9641",
  "d7191cfdae61ffffbfa6d96a1a9641",
  "d73027fc8d59fee08bd9ef8b91cf601a9850",
  "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
  "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
  "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
  "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
  "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
).map(colors_default);
var RdYlGn_default = ramp_default(scheme8);

// ../../node_modules/d3-scale-chromatic/src/diverging/Spectral.js
var scheme9 = new Array(3).concat(
  "fc8d59ffffbf99d594",
  "d7191cfdae61abdda42b83ba",
  "d7191cfdae61ffffbfabdda42b83ba",
  "d53e4ffc8d59fee08be6f59899d5943288bd",
  "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
  "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
  "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
  "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
  "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
).map(colors_default);
var Spectral_default = ramp_default(scheme9);

// ../../node_modules/d3-scale-chromatic/src/sequential-multi/BuGn.js
var scheme10 = new Array(3).concat(
  "e5f5f999d8c92ca25f",
  "edf8fbb2e2e266c2a4238b45",
  "edf8fbb2e2e266c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
).map(colors_default);
var BuGn_default = ramp_default(scheme10);

// ../../node_modules/d3-scale-chromatic/src/sequential-multi/BuPu.js
var scheme11 = new Array(3).concat(
  "e0ecf49ebcda8856a7",
  "edf8fbb3cde38c96c688419d",
  "edf8fbb3cde38c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
).map(colors_default);
var BuPu_default = ramp_default(scheme11);

// ../../node_modules/d3-scale-chromatic/src/sequential-multi/GnBu.js
var scheme12 = new Array(3).concat(
  "e0f3dba8ddb543a2ca",
  "f0f9e8bae4bc7bccc42b8cbe",
  "f0f9e8bae4bc7bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
).map(colors_default);
var GnBu_default = ramp_default(scheme12);

// ../../node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js
var scheme13 = new Array(3).concat(
  "fee8c8fdbb84e34a33",
  "fef0d9fdcc8afc8d59d7301f",
  "fef0d9fdcc8afc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
).map(colors_default);
var OrRd_default = ramp_default(scheme13);

// ../../node_modules/d3-scale-chromatic/src/sequential-multi/PuBuGn.js
var scheme14 = new Array(3).concat(
  "ece2f0a6bddb1c9099",
  "f6eff7bdc9e167a9cf02818a",
  "f6eff7bdc9e167a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
).map(colors_default);
var PuBuGn_default = ramp_default(scheme14);

// ../../node_modules/d3-scale-chromatic/src/sequential-multi/PuBu.js
var scheme15 = new Array(3).concat(
  "ece7f2a6bddb2b8cbe",
  "f1eef6bdc9e174a9cf0570b0",
  "f1eef6bdc9e174a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
).map(colors_default);
var PuBu_default = ramp_default(scheme15);

// ../../node_modules/d3-scale-chromatic/src/sequential-multi/PuRd.js
var scheme16 = new Array(3).concat(
  "e7e1efc994c7dd1c77",
  "f1eef6d7b5d8df65b0ce1256",
  "f1eef6d7b5d8df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
).map(colors_default);
var PuRd_default = ramp_default(scheme16);

// ../../node_modules/d3-scale-chromatic/src/sequential-multi/RdPu.js
var scheme17 = new Array(3).concat(
  "fde0ddfa9fb5c51b8a",
  "feebe2fbb4b9f768a1ae017e",
  "feebe2fbb4b9f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
).map(colors_default);
var RdPu_default = ramp_default(scheme17);

// ../../node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js
var scheme18 = new Array(3).concat(
  "edf8b17fcdbb2c7fb8",
  "ffffcca1dab441b6c4225ea8",
  "ffffcca1dab441b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
).map(colors_default);
var YlGnBu_default = ramp_default(scheme18);

// ../../node_modules/d3-scale-chromatic/src/sequential-multi/YlGn.js
var scheme19 = new Array(3).concat(
  "f7fcb9addd8e31a354",
  "ffffccc2e69978c679238443",
  "ffffccc2e69978c67931a354006837",
  "ffffccd9f0a3addd8e78c67931a354006837",
  "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
).map(colors_default);
var YlGn_default = ramp_default(scheme19);

// ../../node_modules/d3-scale-chromatic/src/sequential-multi/YlOrBr.js
var scheme20 = new Array(3).concat(
  "fff7bcfec44fd95f0e",
  "ffffd4fed98efe9929cc4c02",
  "ffffd4fed98efe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
).map(colors_default);
var YlOrBr_default = ramp_default(scheme20);

// ../../node_modules/d3-scale-chromatic/src/sequential-multi/YlOrRd.js
var scheme21 = new Array(3).concat(
  "ffeda0feb24cf03b20",
  "ffffb2fecc5cfd8d3ce31a1c",
  "ffffb2fecc5cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
).map(colors_default);
var YlOrRd_default = ramp_default(scheme21);

// ../../node_modules/d3-scale-chromatic/src/sequential-single/Blues.js
var scheme22 = new Array(3).concat(
  "deebf79ecae13182bd",
  "eff3ffbdd7e76baed62171b5",
  "eff3ffbdd7e76baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
).map(colors_default);
var Blues_default = ramp_default(scheme22);

// ../../node_modules/d3-scale-chromatic/src/sequential-single/Greens.js
var scheme23 = new Array(3).concat(
  "e5f5e0a1d99b31a354",
  "edf8e9bae4b374c476238b45",
  "edf8e9bae4b374c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
).map(colors_default);
var Greens_default = ramp_default(scheme23);

// ../../node_modules/d3-scale-chromatic/src/sequential-single/Greys.js
var scheme24 = new Array(3).concat(
  "f0f0f0bdbdbd636363",
  "f7f7f7cccccc969696525252",
  "f7f7f7cccccc969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
).map(colors_default);
var Greys_default = ramp_default(scheme24);

// ../../node_modules/d3-scale-chromatic/src/sequential-single/Purples.js
var scheme25 = new Array(3).concat(
  "efedf5bcbddc756bb1",
  "f2f0f7cbc9e29e9ac86a51a3",
  "f2f0f7cbc9e29e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
).map(colors_default);
var Purples_default = ramp_default(scheme25);

// ../../node_modules/d3-scale-chromatic/src/sequential-single/Reds.js
var scheme26 = new Array(3).concat(
  "fee0d2fc9272de2d26",
  "fee5d9fcae91fb6a4acb181d",
  "fee5d9fcae91fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
).map(colors_default);
var Reds_default = ramp_default(scheme26);

// ../../node_modules/d3-scale-chromatic/src/sequential-single/Oranges.js
var scheme27 = new Array(3).concat(
  "fee6cefdae6be6550d",
  "feeddefdbe85fd8d3cd94701",
  "feeddefdbe85fd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
).map(colors_default);
var Oranges_default = ramp_default(scheme27);

// ../../node_modules/d3-scale-chromatic/src/sequential-multi/cividis.js
function cividis_default(t) {
  t = Math.max(0, Math.min(1, t));
  return "rgb(" + Math.max(0, Math.min(255, Math.round(-4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - t * 2710.57))))))) + ", " + Math.max(0, Math.min(255, Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - t * 67.37))))))) + ", " + Math.max(0, Math.min(255, Math.round(81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - t * 2475.67))))))) + ")";
}

// ../../node_modules/d3-scale-chromatic/src/sequential-multi/cubehelix.js
var cubehelix_default2 = cubehelixLong(cubehelix(300, 0.5, 0), cubehelix(-240, 0.5, 1));

// ../../node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js
var warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
var cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
var c = cubehelix();
function rainbow_default(t) {
  if (t < 0 || t > 1)
    t -= Math.floor(t);
  var ts = Math.abs(t - 0.5);
  c.h = 360 * t - 100;
  c.s = 1.5 - 1.5 * ts;
  c.l = 0.8 - 0.9 * ts;
  return c + "";
}

// ../../node_modules/d3-scale-chromatic/src/sequential-multi/sinebow.js
var c2 = rgb();
var pi_1_3 = Math.PI / 3;
var pi_2_3 = Math.PI * 2 / 3;
function sinebow_default(t) {
  var x4;
  t = (0.5 - t) * Math.PI;
  c2.r = 255 * (x4 = Math.sin(t)) * x4;
  c2.g = 255 * (x4 = Math.sin(t + pi_1_3)) * x4;
  c2.b = 255 * (x4 = Math.sin(t + pi_2_3)) * x4;
  return c2 + "";
}

// ../../node_modules/d3-scale-chromatic/src/sequential-multi/turbo.js
function turbo_default(t) {
  t = Math.max(0, Math.min(1, t));
  return "rgb(" + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + ", " + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + ", " + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66))))))) + ")";
}

// ../../node_modules/d3-scale-chromatic/src/sequential-multi/viridis.js
function ramp(range3) {
  var n = range3.length;
  return function(t) {
    return range3[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}
var viridis_default = ramp(colors_default("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
var magma = ramp(colors_default("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
var inferno = ramp(colors_default("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
var plasma = ramp(colors_default("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

// ../../node_modules/d3-shape/src/constant.js
function constant_default5(x4) {
  return function constant2() {
    return x4;
  };
}

// ../../node_modules/d3-shape/src/math.js
var cos2 = Math.cos;
var min4 = Math.min;
var sin2 = Math.sin;
var sqrt3 = Math.sqrt;
var epsilon7 = 1e-12;
var pi3 = Math.PI;
var halfPi2 = pi3 / 2;
var tau4 = 2 * pi3;

// ../../node_modules/d3-shape/src/path.js
function withPath(shape) {
  let digits = 3;
  shape.digits = function(_2) {
    if (!arguments.length)
      return digits;
    if (_2 == null) {
      digits = null;
    } else {
      const d = Math.floor(_2);
      if (!(d >= 0))
        throw new RangeError(`invalid digits: ${_2}`);
      digits = d;
    }
    return shape;
  };
  return () => new Path(digits);
}

// ../../node_modules/d3-shape/src/array.js
var slice2 = Array.prototype.slice;
function array_default(x4) {
  return typeof x4 === "object" && "length" in x4 ? x4 : Array.from(x4);
}

// ../../node_modules/d3-shape/src/curve/linear.js
function Linear(context) {
  this._context = context;
}
Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(x4, y4);
        break;
    }
  }
};
function linear_default(context) {
  return new Linear(context);
}

// ../../node_modules/d3-shape/src/point.js
function x3(p2) {
  return p2[0];
}
function y3(p2) {
  return p2[1];
}

// ../../node_modules/d3-shape/src/line.js
function line_default2(x4, y4) {
  var defined2 = constant_default5(true), context = null, curve = linear_default, output = null, path2 = withPath(line3);
  x4 = typeof x4 === "function" ? x4 : x4 === void 0 ? x3 : constant_default5(x4);
  y4 = typeof y4 === "function" ? y4 : y4 === void 0 ? y3 : constant_default5(y4);
  function line3(data) {
    var i, n = (data = array_default(data)).length, d, defined0 = false, buffer;
    if (context == null)
      output = curve(buffer = path2());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined2(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0)
          output.lineStart();
        else
          output.lineEnd();
      }
      if (defined0)
        output.point(+x4(d, i, data), +y4(d, i, data));
    }
    if (buffer)
      return output = null, buffer + "" || null;
  }
  line3.x = function(_2) {
    return arguments.length ? (x4 = typeof _2 === "function" ? _2 : constant_default5(+_2), line3) : x4;
  };
  line3.y = function(_2) {
    return arguments.length ? (y4 = typeof _2 === "function" ? _2 : constant_default5(+_2), line3) : y4;
  };
  line3.defined = function(_2) {
    return arguments.length ? (defined2 = typeof _2 === "function" ? _2 : constant_default5(!!_2), line3) : defined2;
  };
  line3.curve = function(_2) {
    return arguments.length ? (curve = _2, context != null && (output = curve(context)), line3) : curve;
  };
  line3.context = function(_2) {
    return arguments.length ? (_2 == null ? context = output = null : output = curve(context = _2), line3) : context;
  };
  return line3;
}

// ../../node_modules/d3-shape/src/area.js
function area_default3(x06, y06, y12) {
  var x12 = null, defined2 = constant_default5(true), context = null, curve = linear_default, output = null, path2 = withPath(area3);
  x06 = typeof x06 === "function" ? x06 : x06 === void 0 ? x3 : constant_default5(+x06);
  y06 = typeof y06 === "function" ? y06 : y06 === void 0 ? constant_default5(0) : constant_default5(+y06);
  y12 = typeof y12 === "function" ? y12 : y12 === void 0 ? y3 : constant_default5(+y12);
  function area3(data) {
    var i, j2, k3, n = (data = array_default(data)).length, d, defined0 = false, buffer, x0z = new Array(n), y0z = new Array(n);
    if (context == null)
      output = curve(buffer = path2());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined2(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j2 = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k3 = i - 1; k3 >= j2; --k3) {
            output.point(x0z[k3], y0z[k3]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x06(d, i, data), y0z[i] = +y06(d, i, data);
        output.point(x12 ? +x12(d, i, data) : x0z[i], y12 ? +y12(d, i, data) : y0z[i]);
      }
    }
    if (buffer)
      return output = null, buffer + "" || null;
  }
  function arealine() {
    return line_default2().defined(defined2).curve(curve).context(context);
  }
  area3.x = function(_2) {
    return arguments.length ? (x06 = typeof _2 === "function" ? _2 : constant_default5(+_2), x12 = null, area3) : x06;
  };
  area3.x0 = function(_2) {
    return arguments.length ? (x06 = typeof _2 === "function" ? _2 : constant_default5(+_2), area3) : x06;
  };
  area3.x1 = function(_2) {
    return arguments.length ? (x12 = _2 == null ? null : typeof _2 === "function" ? _2 : constant_default5(+_2), area3) : x12;
  };
  area3.y = function(_2) {
    return arguments.length ? (y06 = typeof _2 === "function" ? _2 : constant_default5(+_2), y12 = null, area3) : y06;
  };
  area3.y0 = function(_2) {
    return arguments.length ? (y06 = typeof _2 === "function" ? _2 : constant_default5(+_2), area3) : y06;
  };
  area3.y1 = function(_2) {
    return arguments.length ? (y12 = _2 == null ? null : typeof _2 === "function" ? _2 : constant_default5(+_2), area3) : y12;
  };
  area3.lineX0 = area3.lineY0 = function() {
    return arealine().x(x06).y(y06);
  };
  area3.lineY1 = function() {
    return arealine().x(x06).y(y12);
  };
  area3.lineX1 = function() {
    return arealine().x(x12).y(y06);
  };
  area3.defined = function(_2) {
    return arguments.length ? (defined2 = typeof _2 === "function" ? _2 : constant_default5(!!_2), area3) : defined2;
  };
  area3.curve = function(_2) {
    return arguments.length ? (curve = _2, context != null && (output = curve(context)), area3) : curve;
  };
  area3.context = function(_2) {
    return arguments.length ? (_2 == null ? context = output = null : output = curve(context = _2), area3) : context;
  };
  return area3;
}

// ../../node_modules/d3-shape/src/curve/bump.js
var Bump = class {
  constructor(context, x4) {
    this._context = context;
    this._x = x4;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  }
  point(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0: {
        this._point = 1;
        if (this._line)
          this._context.lineTo(x4, y4);
        else
          this._context.moveTo(x4, y4);
        break;
      }
      case 1:
        this._point = 2;
      default: {
        if (this._x)
          this._context.bezierCurveTo(this._x0 = (this._x0 + x4) / 2, this._y0, this._x0, y4, x4, y4);
        else
          this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y4) / 2, x4, this._y0, x4, y4);
        break;
      }
    }
    this._x0 = x4, this._y0 = y4;
  }
};
function bumpX(context) {
  return new Bump(context, true);
}
function bumpY(context) {
  return new Bump(context, false);
}

// ../../node_modules/d3-shape/src/symbol/asterisk.js
var sqrt32 = sqrt3(3);
var asterisk_default = {
  draw(context, size) {
    const r = sqrt3(size + min4(size / 28, 0.75)) * 0.59436;
    const t = r / 2;
    const u4 = t * sqrt32;
    context.moveTo(0, r);
    context.lineTo(0, -r);
    context.moveTo(-u4, -t);
    context.lineTo(u4, t);
    context.moveTo(-u4, t);
    context.lineTo(u4, -t);
  }
};

// ../../node_modules/d3-shape/src/symbol/circle.js
var circle_default2 = {
  draw(context, size) {
    const r = sqrt3(size / pi3);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, tau4);
  }
};

// ../../node_modules/d3-shape/src/symbol/cross.js
var cross_default = {
  draw(context, size) {
    const r = sqrt3(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
};

// ../../node_modules/d3-shape/src/symbol/diamond.js
var tan30 = sqrt3(1 / 3);
var tan30_2 = tan30 * 2;
var diamond_default = {
  draw(context, size) {
    const y4 = sqrt3(size / tan30_2);
    const x4 = y4 * tan30;
    context.moveTo(0, -y4);
    context.lineTo(x4, 0);
    context.lineTo(0, y4);
    context.lineTo(-x4, 0);
    context.closePath();
  }
};

// ../../node_modules/d3-shape/src/symbol/diamond2.js
var diamond2_default = {
  draw(context, size) {
    const r = sqrt3(size) * 0.62625;
    context.moveTo(0, -r);
    context.lineTo(r, 0);
    context.lineTo(0, r);
    context.lineTo(-r, 0);
    context.closePath();
  }
};

// ../../node_modules/d3-shape/src/symbol/plus.js
var plus_default = {
  draw(context, size) {
    const r = sqrt3(size - min4(size / 7, 2)) * 0.87559;
    context.moveTo(-r, 0);
    context.lineTo(r, 0);
    context.moveTo(0, r);
    context.lineTo(0, -r);
  }
};

// ../../node_modules/d3-shape/src/symbol/square.js
var square_default = {
  draw(context, size) {
    const w = sqrt3(size);
    const x4 = -w / 2;
    context.rect(x4, x4, w, w);
  }
};

// ../../node_modules/d3-shape/src/symbol/square2.js
var square2_default = {
  draw(context, size) {
    const r = sqrt3(size) * 0.4431;
    context.moveTo(r, r);
    context.lineTo(r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, r);
    context.closePath();
  }
};

// ../../node_modules/d3-shape/src/symbol/star.js
var ka = 0.8908130915292852;
var kr = sin2(pi3 / 10) / sin2(7 * pi3 / 10);
var kx = sin2(tau4 / 10) * kr;
var ky = -cos2(tau4 / 10) * kr;
var star_default = {
  draw(context, size) {
    const r = sqrt3(size * ka);
    const x4 = kx * r;
    const y4 = ky * r;
    context.moveTo(0, -r);
    context.lineTo(x4, y4);
    for (let i = 1; i < 5; ++i) {
      const a3 = tau4 * i / 5;
      const c4 = cos2(a3);
      const s2 = sin2(a3);
      context.lineTo(s2 * r, -c4 * r);
      context.lineTo(c4 * x4 - s2 * y4, s2 * x4 + c4 * y4);
    }
    context.closePath();
  }
};

// ../../node_modules/d3-shape/src/symbol/triangle.js
var sqrt33 = sqrt3(3);
var triangle_default = {
  draw(context, size) {
    const y4 = -sqrt3(size / (sqrt33 * 3));
    context.moveTo(0, y4 * 2);
    context.lineTo(-sqrt33 * y4, -y4);
    context.lineTo(sqrt33 * y4, -y4);
    context.closePath();
  }
};

// ../../node_modules/d3-shape/src/symbol/triangle2.js
var sqrt34 = sqrt3(3);
var triangle2_default = {
  draw(context, size) {
    const s2 = sqrt3(size) * 0.6824;
    const t = s2 / 2;
    const u4 = s2 * sqrt34 / 2;
    context.moveTo(0, -s2);
    context.lineTo(u4, t);
    context.lineTo(-u4, t);
    context.closePath();
  }
};

// ../../node_modules/d3-shape/src/symbol/wye.js
var c3 = -0.5;
var s = sqrt3(3) / 2;
var k2 = 1 / sqrt3(12);
var a2 = (k2 / 2 + 1) * 3;
var wye_default = {
  draw(context, size) {
    const r = sqrt3(size / a2);
    const x06 = r / 2, y06 = r * k2;
    const x12 = x06, y12 = r * k2 + r;
    const x22 = -x12, y22 = y12;
    context.moveTo(x06, y06);
    context.lineTo(x12, y12);
    context.lineTo(x22, y22);
    context.lineTo(c3 * x06 - s * y06, s * x06 + c3 * y06);
    context.lineTo(c3 * x12 - s * y12, s * x12 + c3 * y12);
    context.lineTo(c3 * x22 - s * y22, s * x22 + c3 * y22);
    context.lineTo(c3 * x06 + s * y06, c3 * y06 - s * x06);
    context.lineTo(c3 * x12 + s * y12, c3 * y12 - s * x12);
    context.lineTo(c3 * x22 + s * y22, c3 * y22 - s * x22);
    context.closePath();
  }
};

// ../../node_modules/d3-shape/src/symbol/times.js
var times_default = {
  draw(context, size) {
    const r = sqrt3(size - min4(size / 6, 1.7)) * 0.6189;
    context.moveTo(-r, -r);
    context.lineTo(r, r);
    context.moveTo(-r, r);
    context.lineTo(r, -r);
  }
};

// ../../node_modules/d3-shape/src/symbol.js
var symbolsFill = [
  circle_default2,
  cross_default,
  diamond_default,
  square_default,
  star_default,
  triangle_default,
  wye_default
];
var symbolsStroke = [
  circle_default2,
  plus_default,
  times_default,
  triangle2_default,
  asterisk_default,
  square2_default,
  diamond2_default
];

// ../../node_modules/d3-shape/src/noop.js
function noop_default2() {
}

// ../../node_modules/d3-shape/src/curve/basis.js
function point2(that, x4, y4) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x4) / 6,
    (that._y0 + 4 * that._y1 + y4) / 6
  );
}
function Basis(context) {
  this._context = context;
}
Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        point2(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        point2(this, x4, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = x4;
    this._y0 = this._y1, this._y1 = y4;
  }
};
function basis_default2(context) {
  return new Basis(context);
}

// ../../node_modules/d3-shape/src/curve/basisClosed.js
function BasisClosed(context) {
  this._context = context;
}
BasisClosed.prototype = {
  areaStart: noop_default2,
  areaEnd: noop_default2,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x2 = x4, this._y2 = y4;
        break;
      case 1:
        this._point = 2;
        this._x3 = x4, this._y3 = y4;
        break;
      case 2:
        this._point = 3;
        this._x4 = x4, this._y4 = y4;
        this._context.moveTo((this._x0 + 4 * this._x1 + x4) / 6, (this._y0 + 4 * this._y1 + y4) / 6);
        break;
      default:
        point2(this, x4, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = x4;
    this._y0 = this._y1, this._y1 = y4;
  }
};
function basisClosed_default2(context) {
  return new BasisClosed(context);
}

// ../../node_modules/d3-shape/src/curve/basisOpen.js
function BasisOpen(context) {
  this._context = context;
}
BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var x06 = (this._x0 + 4 * this._x1 + x4) / 6, y06 = (this._y0 + 4 * this._y1 + y4) / 6;
        this._line ? this._context.lineTo(x06, y06) : this._context.moveTo(x06, y06);
        break;
      case 3:
        this._point = 4;
      default:
        point2(this, x4, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = x4;
    this._y0 = this._y1, this._y1 = y4;
  }
};
function basisOpen_default(context) {
  return new BasisOpen(context);
}

// ../../node_modules/d3-shape/src/curve/bundle.js
function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}
Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x4 = this._x, y4 = this._y, j2 = x4.length - 1;
    if (j2 > 0) {
      var x06 = x4[0], y06 = y4[0], dx = x4[j2] - x06, dy = y4[j2] - y06, i = -1, t;
      while (++i <= j2) {
        t = i / j2;
        this._basis.point(
          this._beta * x4[i] + (1 - this._beta) * (x06 + t * dx),
          this._beta * y4[i] + (1 - this._beta) * (y06 + t * dy)
        );
      }
    }
    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x4, y4) {
    this._x.push(+x4);
    this._y.push(+y4);
  }
};
var bundle_default = function custom(beta) {
  function bundle(context) {
    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
  }
  bundle.beta = function(beta2) {
    return custom(+beta2);
  };
  return bundle;
}(0.85);

// ../../node_modules/d3-shape/src/curve/cardinal.js
function point3(that, x4, y4) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x4),
    that._y2 + that._k * (that._y1 - y4),
    that._x2,
    that._y2
  );
}
function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        point3(this, this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
        break;
      case 1:
        this._point = 2;
        this._x1 = x4, this._y1 = y4;
        break;
      case 2:
        this._point = 3;
      default:
        point3(this, x4, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var cardinal_default = function custom2(tension) {
  function cardinal(context) {
    return new Cardinal(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom2(+tension2);
  };
  return cardinal;
}(0);

// ../../node_modules/d3-shape/src/curve/cardinalClosed.js
function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalClosed.prototype = {
  areaStart: noop_default2,
  areaEnd: noop_default2,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x4, this._y3 = y4;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x4, this._y4 = y4);
        break;
      case 2:
        this._point = 3;
        this._x5 = x4, this._y5 = y4;
        break;
      default:
        point3(this, x4, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var cardinalClosed_default = function custom3(tension) {
  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom3(+tension2);
  };
  return cardinal;
}(0);

// ../../node_modules/d3-shape/src/curve/cardinalOpen.js
function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point3(this, x4, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var cardinalOpen_default = function custom4(tension) {
  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom4(+tension2);
  };
  return cardinal;
}(0);

// ../../node_modules/d3-shape/src/curve/catmullRom.js
function point4(that, x4, y4) {
  var x12 = that._x1, y12 = that._y1, x22 = that._x2, y22 = that._y2;
  if (that._l01_a > epsilon7) {
    var a3 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x12 = (x12 * a3 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y12 = (y12 * a3 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }
  if (that._l23_a > epsilon7) {
    var b2 = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m2 = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x22 = (x22 * b2 + that._x1 * that._l23_2a - x4 * that._l12_2a) / m2;
    y22 = (y22 * b2 + that._y1 * that._l23_2a - y4 * that._l12_2a) / m2;
  }
  that._context.bezierCurveTo(x12, y12, x22, y22, that._x2, that._y2);
}
function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    if (this._point) {
      var x23 = this._x2 - x4, y23 = this._y2 - y4;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        point4(this, x4, y4);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var catmullRom_default = function custom5(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom5(+alpha2);
  };
  return catmullRom;
}(0.5);

// ../../node_modules/d3-shape/src/curve/catmullRomClosed.js
function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomClosed.prototype = {
  areaStart: noop_default2,
  areaEnd: noop_default2,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    if (this._point) {
      var x23 = this._x2 - x4, y23 = this._y2 - y4;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x4, this._y3 = y4;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x4, this._y4 = y4);
        break;
      case 2:
        this._point = 3;
        this._x5 = x4, this._y5 = y4;
        break;
      default:
        point4(this, x4, y4);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var catmullRomClosed_default = function custom6(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom6(+alpha2);
  };
  return catmullRom;
}(0.5);

// ../../node_modules/d3-shape/src/curve/catmullRomOpen.js
function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    if (this._point) {
      var x23 = this._x2 - x4, y23 = this._y2 - y4;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point4(this, x4, y4);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var catmullRomOpen_default = function custom7(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom7(+alpha2);
  };
  return catmullRom;
}(0.5);

// ../../node_modules/d3-shape/src/curve/linearClosed.js
function LinearClosed(context) {
  this._context = context;
}
LinearClosed.prototype = {
  areaStart: noop_default2,
  areaEnd: noop_default2,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point)
      this._context.closePath();
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    if (this._point)
      this._context.lineTo(x4, y4);
    else
      this._point = 1, this._context.moveTo(x4, y4);
  }
};
function linearClosed_default(context) {
  return new LinearClosed(context);
}

// ../../node_modules/d3-shape/src/curve/monotone.js
function sign2(x4) {
  return x4 < 0 ? -1 : 1;
}
function slope3(that, x22, y22) {
  var h0 = that._x1 - that._x0, h1 = x22 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y22 - that._y1) / (h1 || h0 < 0 && -0), p2 = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign2(s0) + sign2(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p2)) || 0;
}
function slope2(that, t) {
  var h2 = that._x1 - that._x0;
  return h2 ? (3 * (that._y1 - that._y0) / h2 - t) / 2 : t;
}
function point5(that, t03, t13) {
  var x06 = that._x0, y06 = that._y0, x12 = that._x1, y12 = that._y1, dx = (x12 - x06) / 3;
  that._context.bezierCurveTo(x06 + dx, y06 + dx * t03, x12 - dx, y12 - dx * t13, x12, y12);
}
function MonotoneX(context) {
  this._context = context;
}
MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        point5(this, this._t0, slope2(this, this._t0));
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    var t13 = NaN;
    x4 = +x4, y4 = +y4;
    if (x4 === this._x1 && y4 === this._y1)
      return;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        point5(this, slope2(this, t13 = slope3(this, x4, y4)), t13);
        break;
      default:
        point5(this, this._t0, t13 = slope3(this, x4, y4));
        break;
    }
    this._x0 = this._x1, this._x1 = x4;
    this._y0 = this._y1, this._y1 = y4;
    this._t0 = t13;
  }
};
function MonotoneY(context) {
  this._context = new ReflectContext(context);
}
(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x4, y4) {
  MonotoneX.prototype.point.call(this, y4, x4);
};
function ReflectContext(context) {
  this._context = context;
}
ReflectContext.prototype = {
  moveTo: function(x4, y4) {
    this._context.moveTo(y4, x4);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(x4, y4) {
    this._context.lineTo(y4, x4);
  },
  bezierCurveTo: function(x12, y12, x22, y22, x4, y4) {
    this._context.bezierCurveTo(y12, x12, y22, x22, y4, x4);
  }
};
function monotoneX(context) {
  return new MonotoneX(context);
}
function monotoneY(context) {
  return new MonotoneY(context);
}

// ../../node_modules/d3-shape/src/curve/natural.js
function Natural(context) {
  this._context = context;
}
Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x4 = this._x, y4 = this._y, n = x4.length;
    if (n) {
      this._line ? this._context.lineTo(x4[0], y4[0]) : this._context.moveTo(x4[0], y4[0]);
      if (n === 2) {
        this._context.lineTo(x4[1], y4[1]);
      } else {
        var px = controlPoints(x4), py = controlPoints(y4);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x4[i1], y4[i1]);
        }
      }
    }
    if (this._line || this._line !== 0 && n === 1)
      this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x4, y4) {
    this._x.push(+x4);
    this._y.push(+y4);
  }
};
function controlPoints(x4) {
  var i, n = x4.length - 1, m2, a3 = new Array(n), b2 = new Array(n), r = new Array(n);
  a3[0] = 0, b2[0] = 2, r[0] = x4[0] + 2 * x4[1];
  for (i = 1; i < n - 1; ++i)
    a3[i] = 1, b2[i] = 4, r[i] = 4 * x4[i] + 2 * x4[i + 1];
  a3[n - 1] = 2, b2[n - 1] = 7, r[n - 1] = 8 * x4[n - 1] + x4[n];
  for (i = 1; i < n; ++i)
    m2 = a3[i] / b2[i - 1], b2[i] -= m2, r[i] -= m2 * r[i - 1];
  a3[n - 1] = r[n - 1] / b2[n - 1];
  for (i = n - 2; i >= 0; --i)
    a3[i] = (r[i] - a3[i + 1]) / b2[i];
  b2[n - 1] = (x4[n] + a3[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i)
    b2[i] = 2 * x4[i + 1] - a3[i + 1];
  return [a3, b2];
}
function natural_default(context) {
  return new Natural(context);
}

// ../../node_modules/d3-shape/src/curve/step.js
function Step(context, t) {
  this._context = context;
  this._t = t;
}
Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2)
      this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    if (this._line >= 0)
      this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x4, y4) {
    x4 = +x4, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x4, y4) : this._context.moveTo(x4, y4);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y4);
          this._context.lineTo(x4, y4);
        } else {
          var x12 = this._x * (1 - this._t) + x4 * this._t;
          this._context.lineTo(x12, this._y);
          this._context.lineTo(x12, y4);
        }
        break;
      }
    }
    this._x = x4, this._y = y4;
  }
};
function step_default(context) {
  return new Step(context, 0.5);
}
function stepBefore(context) {
  return new Step(context, 0);
}
function stepAfter(context) {
  return new Step(context, 1);
}

// ../../node_modules/d3-zoom/src/constant.js
var constant_default6 = (x4) => () => x4;

// ../../node_modules/d3-zoom/src/event.js
function ZoomEvent(type2, {
  sourceEvent,
  target,
  transform: transform3,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type2, enumerable: true, configurable: true },
    sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },
    target: { value: target, enumerable: true, configurable: true },
    transform: { value: transform3, enumerable: true, configurable: true },
    _: { value: dispatch2 }
  });
}

// ../../node_modules/d3-zoom/src/transform.js
function Transform2(k3, x4, y4) {
  this.k = k3;
  this.x = x4;
  this.y = y4;
}
Transform2.prototype = {
  constructor: Transform2,
  scale: function(k3) {
    return k3 === 1 ? this : new Transform2(this.k * k3, this.x, this.y);
  },
  translate: function(x4, y4) {
    return x4 === 0 & y4 === 0 ? this : new Transform2(this.k, this.x + this.k * x4, this.y + this.k * y4);
  },
  apply: function(point6) {
    return [point6[0] * this.k + this.x, point6[1] * this.k + this.y];
  },
  applyX: function(x4) {
    return x4 * this.k + this.x;
  },
  applyY: function(y4) {
    return y4 * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x4) {
    return (x4 - this.x) / this.k;
  },
  invertY: function(y4) {
    return (y4 - this.y) / this.k;
  },
  rescaleX: function(x4) {
    return x4.copy().domain(x4.range().map(this.invertX, this).map(x4.invert, x4));
  },
  rescaleY: function(y4) {
    return y4.copy().domain(y4.range().map(this.invertY, this).map(y4.invert, y4));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var identity6 = new Transform2(1, 0, 0);
transform.prototype = Transform2.prototype;
function transform(node) {
  while (!node.__zoom)
    if (!(node = node.parentNode))
      return identity6;
  return node.__zoom;
}

// ../../node_modules/d3-zoom/src/noevent.js
function nopropagation2(event) {
  event.stopImmediatePropagation();
}
function noevent_default3(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}

// ../../node_modules/d3-zoom/src/zoom.js
function defaultFilter2(event) {
  return (!event.ctrlKey || event.type === "wheel") && !event.button;
}
function defaultExtent2() {
  var e = this;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    if (e.hasAttribute("viewBox")) {
      e = e.viewBox.baseVal;
      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
    }
    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
  }
  return [[0, 0], [e.clientWidth, e.clientHeight]];
}
function defaultTransform() {
  return this.__zoom || identity6;
}
function defaultWheelDelta(event) {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * (event.ctrlKey ? 10 : 1);
}
function defaultTouchable2() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function defaultConstrain(transform3, extent4, translateExtent) {
  var dx0 = transform3.invertX(extent4[0][0]) - translateExtent[0][0], dx1 = transform3.invertX(extent4[1][0]) - translateExtent[1][0], dy0 = transform3.invertY(extent4[0][1]) - translateExtent[0][1], dy1 = transform3.invertY(extent4[1][1]) - translateExtent[1][1];
  return transform3.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}
function zoom_default2() {
  var filter3 = defaultFilter2, extent4 = defaultExtent2, constrain = defaultConstrain, wheelDelta = defaultWheelDelta, touchable = defaultTouchable2, scaleExtent = [0, Infinity], translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]], duration = 250, interpolate = zoom_default, listeners = dispatch_default("start", "zoom", "end"), touchstarting, touchfirst, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0, tapDistance = 10;
  function zoom2(selection2) {
    selection2.property("__zoom", defaultTransform).on("wheel.zoom", wheeled, { passive: false }).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  zoom2.transform = function(collection, transform3, point6, event) {
    var selection2 = collection.selection ? collection.selection() : collection;
    selection2.property("__zoom", defaultTransform);
    if (collection !== selection2) {
      schedule(collection, transform3, point6, event);
    } else {
      selection2.interrupt().each(function() {
        gesture(this, arguments).event(event).start().zoom(null, typeof transform3 === "function" ? transform3.apply(this, arguments) : transform3).end();
      });
    }
  };
  zoom2.scaleBy = function(selection2, k3, p2, event) {
    zoom2.scaleTo(selection2, function() {
      var k0 = this.__zoom.k, k1 = typeof k3 === "function" ? k3.apply(this, arguments) : k3;
      return k0 * k1;
    }, p2, event);
  };
  zoom2.scaleTo = function(selection2, k3, p2, event) {
    zoom2.transform(selection2, function() {
      var e = extent4.apply(this, arguments), t03 = this.__zoom, p0 = p2 == null ? centroid3(e) : typeof p2 === "function" ? p2.apply(this, arguments) : p2, p1 = t03.invert(p0), k1 = typeof k3 === "function" ? k3.apply(this, arguments) : k3;
      return constrain(translate(scale3(t03, k1), p0, p1), e, translateExtent);
    }, p2, event);
  };
  zoom2.translateBy = function(selection2, x4, y4, event) {
    zoom2.transform(selection2, function() {
      return constrain(this.__zoom.translate(
        typeof x4 === "function" ? x4.apply(this, arguments) : x4,
        typeof y4 === "function" ? y4.apply(this, arguments) : y4
      ), extent4.apply(this, arguments), translateExtent);
    }, null, event);
  };
  zoom2.translateTo = function(selection2, x4, y4, p2, event) {
    zoom2.transform(selection2, function() {
      var e = extent4.apply(this, arguments), t = this.__zoom, p0 = p2 == null ? centroid3(e) : typeof p2 === "function" ? p2.apply(this, arguments) : p2;
      return constrain(identity6.translate(p0[0], p0[1]).scale(t.k).translate(
        typeof x4 === "function" ? -x4.apply(this, arguments) : -x4,
        typeof y4 === "function" ? -y4.apply(this, arguments) : -y4
      ), e, translateExtent);
    }, p2, event);
  };
  function scale3(transform3, k3) {
    k3 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k3));
    return k3 === transform3.k ? transform3 : new Transform2(k3, transform3.x, transform3.y);
  }
  function translate(transform3, p0, p1) {
    var x4 = p0[0] - p1[0] * transform3.k, y4 = p0[1] - p1[1] * transform3.k;
    return x4 === transform3.x && y4 === transform3.y ? transform3 : new Transform2(transform3.k, x4, y4);
  }
  function centroid3(extent5) {
    return [(+extent5[0][0] + +extent5[1][0]) / 2, (+extent5[0][1] + +extent5[1][1]) / 2];
  }
  function schedule(transition2, transform3, point6, event) {
    transition2.on("start.zoom", function() {
      gesture(this, arguments).event(event).start();
    }).on("interrupt.zoom end.zoom", function() {
      gesture(this, arguments).event(event).end();
    }).tween("zoom", function() {
      var that = this, args = arguments, g2 = gesture(that, args).event(event), e = extent4.apply(that, args), p2 = point6 == null ? centroid3(e) : typeof point6 === "function" ? point6.apply(that, args) : point6, w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]), a3 = that.__zoom, b2 = typeof transform3 === "function" ? transform3.apply(that, args) : transform3, i = interpolate(a3.invert(p2).concat(w / a3.k), b2.invert(p2).concat(w / b2.k));
      return function(t) {
        if (t === 1)
          t = b2;
        else {
          var l = i(t), k3 = w / l[2];
          t = new Transform2(k3, p2[0] - l[0] * k3, p2[1] - l[1] * k3);
        }
        g2.zoom(null, t);
      };
    });
  }
  function gesture(that, args, clean) {
    return !clean && that.__zooming || new Gesture(that, args);
  }
  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.sourceEvent = null;
    this.extent = extent4.apply(that, args);
    this.taps = 0;
  }
  Gesture.prototype = {
    event: function(event) {
      if (event)
        this.sourceEvent = event;
      return this;
    },
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform3) {
      if (this.mouse && key !== "mouse")
        this.mouse[1] = transform3.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch")
        this.touch0[1] = transform3.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch")
        this.touch1[1] = transform3.invert(this.touch1[0]);
      this.that.__zoom = transform3;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type2) {
      var d = select_default2(this.that).datum();
      listeners.call(
        type2,
        this.that,
        new ZoomEvent(type2, {
          sourceEvent: this.sourceEvent,
          target: zoom2,
          type: type2,
          transform: this.that.__zoom,
          dispatch: listeners
        }),
        d
      );
    }
  };
  function wheeled(event, ...args) {
    if (!filter3.apply(this, arguments))
      return;
    var g2 = gesture(this, args).event(event), t = this.__zoom, k3 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))), p2 = pointer_default(event);
    if (g2.wheel) {
      if (g2.mouse[0][0] !== p2[0] || g2.mouse[0][1] !== p2[1]) {
        g2.mouse[1] = t.invert(g2.mouse[0] = p2);
      }
      clearTimeout(g2.wheel);
    } else if (t.k === k3)
      return;
    else {
      g2.mouse = [p2, t.invert(p2)];
      interrupt_default(this);
      g2.start();
    }
    noevent_default3(event);
    g2.wheel = setTimeout(wheelidled, wheelDelay);
    g2.zoom("mouse", constrain(translate(scale3(t, k3), g2.mouse[0], g2.mouse[1]), g2.extent, translateExtent));
    function wheelidled() {
      g2.wheel = null;
      g2.end();
    }
  }
  function mousedowned(event, ...args) {
    if (touchending || !filter3.apply(this, arguments))
      return;
    var currentTarget = event.currentTarget, g2 = gesture(this, args, true).event(event), v3 = select_default2(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true), p2 = pointer_default(event, currentTarget), x06 = event.clientX, y06 = event.clientY;
    nodrag_default(event.view);
    nopropagation2(event);
    g2.mouse = [p2, this.__zoom.invert(p2)];
    interrupt_default(this);
    g2.start();
    function mousemoved(event2) {
      noevent_default3(event2);
      if (!g2.moved) {
        var dx = event2.clientX - x06, dy = event2.clientY - y06;
        g2.moved = dx * dx + dy * dy > clickDistance2;
      }
      g2.event(event2).zoom("mouse", constrain(translate(g2.that.__zoom, g2.mouse[0] = pointer_default(event2, currentTarget), g2.mouse[1]), g2.extent, translateExtent));
    }
    function mouseupped(event2) {
      v3.on("mousemove.zoom mouseup.zoom", null);
      yesdrag(event2.view, g2.moved);
      noevent_default3(event2);
      g2.event(event2).end();
    }
  }
  function dblclicked(event, ...args) {
    if (!filter3.apply(this, arguments))
      return;
    var t03 = this.__zoom, p0 = pointer_default(event.changedTouches ? event.changedTouches[0] : event, this), p1 = t03.invert(p0), k1 = t03.k * (event.shiftKey ? 0.5 : 2), t13 = constrain(translate(scale3(t03, k1), p0, p1), extent4.apply(this, args), translateExtent);
    noevent_default3(event);
    if (duration > 0)
      select_default2(this).transition().duration(duration).call(schedule, t13, p0, event);
    else
      select_default2(this).call(zoom2.transform, t13, p0, event);
  }
  function touchstarted(event, ...args) {
    if (!filter3.apply(this, arguments))
      return;
    var touches = event.touches, n = touches.length, g2 = gesture(this, args, event.changedTouches.length === n).event(event), started, i, t, p2;
    nopropagation2(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p2 = pointer_default(t, this);
      p2 = [p2, this.__zoom.invert(p2), t.identifier];
      if (!g2.touch0)
        g2.touch0 = p2, started = true, g2.taps = 1 + !!touchstarting;
      else if (!g2.touch1 && g2.touch0[2] !== p2[2])
        g2.touch1 = p2, g2.taps = 0;
    }
    if (touchstarting)
      touchstarting = clearTimeout(touchstarting);
    if (started) {
      if (g2.taps < 2)
        touchfirst = p2[0], touchstarting = setTimeout(function() {
          touchstarting = null;
        }, touchDelay);
      interrupt_default(this);
      g2.start();
    }
  }
  function touchmoved(event, ...args) {
    if (!this.__zooming)
      return;
    var g2 = gesture(this, args).event(event), touches = event.changedTouches, n = touches.length, i, t, p2, l;
    noevent_default3(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p2 = pointer_default(t, this);
      if (g2.touch0 && g2.touch0[2] === t.identifier)
        g2.touch0[0] = p2;
      else if (g2.touch1 && g2.touch1[2] === t.identifier)
        g2.touch1[0] = p2;
    }
    t = g2.that.__zoom;
    if (g2.touch1) {
      var p0 = g2.touch0[0], l0 = g2.touch0[1], p1 = g2.touch1[0], l1 = g2.touch1[1], dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale3(t, Math.sqrt(dp / dl));
      p2 = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    } else if (g2.touch0)
      p2 = g2.touch0[0], l = g2.touch0[1];
    else
      return;
    g2.zoom("touch", constrain(translate(t, p2, l), g2.extent, translateExtent));
  }
  function touchended(event, ...args) {
    if (!this.__zooming)
      return;
    var g2 = gesture(this, args).event(event), touches = event.changedTouches, n = touches.length, i, t;
    nopropagation2(event);
    if (touchending)
      clearTimeout(touchending);
    touchending = setTimeout(function() {
      touchending = null;
    }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g2.touch0 && g2.touch0[2] === t.identifier)
        delete g2.touch0;
      else if (g2.touch1 && g2.touch1[2] === t.identifier)
        delete g2.touch1;
    }
    if (g2.touch1 && !g2.touch0)
      g2.touch0 = g2.touch1, delete g2.touch1;
    if (g2.touch0)
      g2.touch0[1] = this.__zoom.invert(g2.touch0[0]);
    else {
      g2.end();
      if (g2.taps === 2) {
        t = pointer_default(t, this);
        if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
          var p2 = select_default2(this).on("dblclick.zoom");
          if (p2)
            p2.apply(this, arguments);
        }
      }
    }
  }
  zoom2.wheelDelta = function(_2) {
    return arguments.length ? (wheelDelta = typeof _2 === "function" ? _2 : constant_default6(+_2), zoom2) : wheelDelta;
  };
  zoom2.filter = function(_2) {
    return arguments.length ? (filter3 = typeof _2 === "function" ? _2 : constant_default6(!!_2), zoom2) : filter3;
  };
  zoom2.touchable = function(_2) {
    return arguments.length ? (touchable = typeof _2 === "function" ? _2 : constant_default6(!!_2), zoom2) : touchable;
  };
  zoom2.extent = function(_2) {
    return arguments.length ? (extent4 = typeof _2 === "function" ? _2 : constant_default6([[+_2[0][0], +_2[0][1]], [+_2[1][0], +_2[1][1]]]), zoom2) : extent4;
  };
  zoom2.scaleExtent = function(_2) {
    return arguments.length ? (scaleExtent[0] = +_2[0], scaleExtent[1] = +_2[1], zoom2) : [scaleExtent[0], scaleExtent[1]];
  };
  zoom2.translateExtent = function(_2) {
    return arguments.length ? (translateExtent[0][0] = +_2[0][0], translateExtent[1][0] = +_2[1][0], translateExtent[0][1] = +_2[0][1], translateExtent[1][1] = +_2[1][1], zoom2) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };
  zoom2.constrain = function(_2) {
    return arguments.length ? (constrain = _2, zoom2) : constrain;
  };
  zoom2.duration = function(_2) {
    return arguments.length ? (duration = +_2, zoom2) : duration;
  };
  zoom2.interpolate = function(_2) {
    return arguments.length ? (interpolate = _2, zoom2) : interpolate;
  };
  zoom2.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom2 : value;
  };
  zoom2.clickDistance = function(_2) {
    return arguments.length ? (clickDistance2 = (_2 = +_2) * _2, zoom2) : Math.sqrt(clickDistance2);
  };
  zoom2.tapDistance = function(_2) {
    return arguments.length ? (tapDistance = +_2, zoom2) : tapDistance;
  };
  return zoom2;
}

// ../../node_modules/@observablehq/plot/src/defined.js
function defined(x4) {
  return x4 != null && !Number.isNaN(x4);
}
function ascendingDefined2(a3, b2) {
  return +defined(b2) - +defined(a3) || ascending(a3, b2);
}
function descendingDefined(a3, b2) {
  return +defined(b2) - +defined(a3) || descending(a3, b2);
}
function nonempty(x4) {
  return x4 != null && `${x4}` !== "";
}
function finite2(x4) {
  return isFinite(x4) ? x4 : NaN;
}
function positive(x4) {
  return x4 > 0 && isFinite(x4) ? x4 : NaN;
}
function negative(x4) {
  return x4 < 0 && isFinite(x4) ? x4 : NaN;
}

// ../../node_modules/isoformat/src/format.js
function format2(date2, fallback) {
  if (!(date2 instanceof Date))
    date2 = /* @__PURE__ */ new Date(+date2);
  if (isNaN(date2))
    return typeof fallback === "function" ? fallback(date2) : fallback;
  const hours = date2.getUTCHours();
  const minutes = date2.getUTCMinutes();
  const seconds2 = date2.getUTCSeconds();
  const milliseconds2 = date2.getUTCMilliseconds();
  return `${formatYear2(date2.getUTCFullYear(), 4)}-${pad2(date2.getUTCMonth() + 1, 2)}-${pad2(date2.getUTCDate(), 2)}${hours || minutes || seconds2 || milliseconds2 ? `T${pad2(hours, 2)}:${pad2(minutes, 2)}${seconds2 || milliseconds2 ? `:${pad2(seconds2, 2)}${milliseconds2 ? `.${pad2(milliseconds2, 3)}` : ``}` : ``}Z` : ``}`;
}
function formatYear2(year) {
  return year < 0 ? `-${pad2(-year, 6)}` : year > 9999 ? `+${pad2(year, 6)}` : pad2(year, 4);
}
function pad2(value, width2) {
  return `${value}`.padStart(width2, "0");
}

// ../../node_modules/isoformat/src/parse.js
var re3 = /^(?:[-+]\d{2})?\d{4}(?:-\d{2}(?:-\d{2})?)?(?:T\d{2}:\d{2}(?::\d{2}(?:\.\d{3})?)?(?:Z|[-+]\d{2}:?\d{2})?)?$/;
function parse(string2, fallback) {
  if (!re3.test(string2 += ""))
    return typeof fallback === "function" ? fallback(string2) : fallback;
  return new Date(string2);
}

// ../../node_modules/@observablehq/plot/src/order.js
function orderof(values2) {
  if (values2 == null)
    return;
  const first3 = values2[0];
  const last2 = values2[values2.length - 1];
  return descending(first3, last2);
}

// ../../node_modules/@observablehq/plot/src/time.js
var durationSecond2 = 1e3;
var durationMinute2 = durationSecond2 * 60;
var durationHour2 = durationMinute2 * 60;
var durationDay2 = durationHour2 * 24;
var durationWeek2 = durationDay2 * 7;
var durationMonth2 = durationDay2 * 30;
var durationYear2 = durationDay2 * 365;
var tickIntervals = [
  ["millisecond", 1],
  ["2 milliseconds", 2],
  ["5 milliseconds", 5],
  ["10 milliseconds", 10],
  ["20 milliseconds", 20],
  ["50 milliseconds", 50],
  ["100 milliseconds", 100],
  ["200 milliseconds", 200],
  ["500 milliseconds", 500],
  ["second", durationSecond2],
  ["5 seconds", 5 * durationSecond2],
  ["15 seconds", 15 * durationSecond2],
  ["30 seconds", 30 * durationSecond2],
  ["minute", durationMinute2],
  ["5 minutes", 5 * durationMinute2],
  ["15 minutes", 15 * durationMinute2],
  ["30 minutes", 30 * durationMinute2],
  ["hour", durationHour2],
  ["3 hours", 3 * durationHour2],
  ["6 hours", 6 * durationHour2],
  ["12 hours", 12 * durationHour2],
  ["day", durationDay2],
  ["2 days", 2 * durationDay2],
  ["week", durationWeek2],
  ["2 weeks", 2 * durationWeek2],
  // https://github.com/d3/d3-time/issues/46
  ["month", durationMonth2],
  ["3 months", 3 * durationMonth2],
  ["6 months", 6 * durationMonth2],
  // https://github.com/d3/d3-time/issues/46
  ["year", durationYear2],
  ["2 years", 2 * durationYear2],
  ["5 years", 5 * durationYear2],
  ["10 years", 10 * durationYear2],
  ["20 years", 20 * durationYear2],
  ["50 years", 50 * durationYear2],
  ["100 years", 100 * durationYear2]
  // TODO generalize to longer time scales
];
var durations = /* @__PURE__ */ new Map([
  ["second", durationSecond2],
  ["minute", durationMinute2],
  ["hour", durationHour2],
  ["day", durationDay2],
  ["monday", durationWeek2],
  ["tuesday", durationWeek2],
  ["wednesday", durationWeek2],
  ["thursday", durationWeek2],
  ["friday", durationWeek2],
  ["saturday", durationWeek2],
  ["sunday", durationWeek2],
  ["week", durationWeek2],
  ["month", durationMonth2],
  ["year", durationYear2]
]);
var timeIntervals = /* @__PURE__ */ new Map([
  ["second", second],
  ["minute", timeMinute],
  ["hour", timeHour],
  ["day", timeDay],
  // https://github.com/d3/d3-time/issues/62
  ["monday", timeMonday],
  ["tuesday", timeTuesday],
  ["wednesday", timeWednesday],
  ["thursday", timeThursday],
  ["friday", timeFriday],
  ["saturday", timeSaturday],
  ["sunday", timeSunday],
  ["week", timeSunday],
  ["month", timeMonth],
  ["year", timeYear]
]);
var utcIntervals = /* @__PURE__ */ new Map([
  ["second", second],
  ["minute", utcMinute],
  ["hour", utcHour],
  ["day", unixDay],
  ["monday", utcMonday],
  ["tuesday", utcTuesday],
  ["wednesday", utcWednesday],
  ["thursday", utcThursday],
  ["friday", utcFriday],
  ["saturday", utcSaturday],
  ["sunday", utcSunday],
  ["week", utcSunday],
  ["month", utcMonth],
  ["year", utcYear]
]);
var intervalDuration = Symbol("intervalDuration");
var intervalType = Symbol("intervalType");
for (const [name2, interval2] of timeIntervals) {
  interval2[intervalDuration] = durations.get(name2);
  interval2[intervalType] = "time";
}
for (const [name2, interval2] of utcIntervals) {
  interval2[intervalDuration] = durations.get(name2);
  interval2[intervalType] = "utc";
}
var utcFormatIntervals = [
  ["year", utcYear, "utc"],
  ["month", utcMonth, "utc"],
  ["day", unixDay, "utc", 6 * durationMonth2],
  ["hour", utcHour, "utc", 3 * durationDay2],
  ["minute", utcMinute, "utc", 6 * durationHour2],
  ["second", second, "utc", 30 * durationMinute2]
];
var timeFormatIntervals = [
  ["year", timeYear, "time"],
  ["month", timeMonth, "time"],
  ["day", timeDay, "time", 6 * durationMonth2],
  ["hour", timeHour, "time", 3 * durationDay2],
  ["minute", timeMinute, "time", 6 * durationHour2],
  ["second", second, "time", 30 * durationMinute2]
];
var formatIntervals = [
  utcFormatIntervals[0],
  timeFormatIntervals[0],
  utcFormatIntervals[1],
  timeFormatIntervals[1],
  utcFormatIntervals[2],
  timeFormatIntervals[2],
  // Below day, local time typically has an hourly offset from UTC and hence the
  // two are aligned and indistinguishable; therefore, we only consider UTC, and
  // we dont consider these if the domain only has a single value.
  ...utcFormatIntervals.slice(3)
];
function parseTimeInterval(input3) {
  let name2 = `${input3}`.toLowerCase();
  if (name2.endsWith("s"))
    name2 = name2.slice(0, -1);
  let period = 1;
  const match = /^(?:(\d+)\s+)/.exec(name2);
  if (match) {
    name2 = name2.slice(match[0].length);
    period = +match[1];
  }
  switch (name2) {
    case "quarter":
      name2 = "month";
      period *= 3;
      break;
    case "half":
      name2 = "month";
      period *= 6;
      break;
  }
  let interval2 = utcIntervals.get(name2);
  if (!interval2)
    throw new Error(`unknown interval: ${input3}`);
  if (period > 1 && !interval2.every)
    throw new Error(`non-periodic interval: ${name2}`);
  return [name2, period];
}
function maybeTimeInterval(input3) {
  return asInterval(parseTimeInterval(input3), "time");
}
function maybeUtcInterval(input3) {
  return asInterval(parseTimeInterval(input3), "utc");
}
function asInterval([name2, period], type2) {
  let interval2 = (type2 === "time" ? timeIntervals : utcIntervals).get(name2);
  if (period > 1) {
    interval2 = interval2.every(period);
    interval2[intervalDuration] = durations.get(name2) * period;
    interval2[intervalType] = type2;
  }
  return interval2;
}
function generalizeTimeInterval(interval2, n) {
  if (!(n > 1))
    return;
  const duration = interval2[intervalDuration];
  if (!tickIntervals.some(([, d]) => d === duration))
    return;
  if (duration % durationDay2 === 0 && durationDay2 < duration && duration < durationMonth2)
    return;
  const [i] = tickIntervals[bisector(([, step]) => Math.log(step)).center(tickIntervals, Math.log(duration * n))];
  return (interval2[intervalType] === "time" ? maybeTimeInterval : maybeUtcInterval)(i);
}
function formatTimeInterval(name2, type2, anchor) {
  const format3 = type2 === "time" ? timeFormat : utcFormat;
  if (anchor == null) {
    return format3(
      name2 === "year" ? "%Y" : name2 === "month" ? "%Y-%m" : name2 === "day" ? "%Y-%m-%d" : name2 === "hour" || name2 === "minute" ? "%Y-%m-%dT%H:%M" : name2 === "second" ? "%Y-%m-%dT%H:%M:%S" : "%Y-%m-%dT%H:%M:%S.%L"
    );
  }
  const template2 = getTimeTemplate(anchor);
  switch (name2) {
    case "millisecond":
      return formatConditional(format3(".%L"), format3(":%M:%S"), template2);
    case "second":
      return formatConditional(format3(":%S"), format3("%-I:%M"), template2);
    case "minute":
      return formatConditional(format3("%-I:%M"), format3("%p"), template2);
    case "hour":
      return formatConditional(format3("%-I %p"), format3("%b %-d"), template2);
    case "day":
      return formatConditional(format3("%-d"), format3("%b"), template2);
    case "month":
      return formatConditional(format3("%b"), format3("%Y"), template2);
    case "year":
      return format3("%Y");
  }
  throw new Error("unable to format time ticks");
}
function getTimeTemplate(anchor) {
  return anchor === "left" || anchor === "right" ? (f1, f2) => `
${f1}
${f2}` : anchor === "top" ? (f1, f2) => `${f2}
${f1}` : (f1, f2) => `${f1}
${f2}`;
}
function getFormatIntervals(type2) {
  return type2 === "time" ? timeFormatIntervals : type2 === "utc" ? utcFormatIntervals : formatIntervals;
}
function inferTimeFormat(type2, dates, anchor) {
  const step = max2(pairs(dates, (a3, b2) => Math.abs(b2 - a3)));
  if (step < 1e3)
    return formatTimeInterval("millisecond", "utc", anchor);
  for (const [name2, interval2, intervalType2, maxStep] of getFormatIntervals(type2)) {
    if (step > maxStep)
      break;
    if (name2 === "hour" && !step)
      break;
    if (dates.every((d) => interval2.floor(d) >= d))
      return formatTimeInterval(name2, intervalType2, anchor);
  }
}
function formatConditional(format1, format22, template2) {
  return (x4, i, X3) => {
    const f1 = format1(x4, i);
    const f2 = format22(x4, i);
    const j2 = i - orderof(X3);
    return i !== j2 && X3[j2] !== void 0 && f2 === format22(X3[j2], j2) ? f1 : template2(f1, f2);
  };
}

// ../../node_modules/@observablehq/plot/src/options.js
var TypedArray = Object.getPrototypeOf(Uint8Array);
var objectToString = Object.prototype.toString;
var reindex = Symbol("reindex");
function valueof(data, value, type2) {
  const valueType = typeof value;
  return valueType === "string" ? maybeTypedMap(data, field(value), type2) : valueType === "function" ? maybeTypedMap(data, value, type2) : valueType === "number" || value instanceof Date || valueType === "boolean" ? map2(data, constant(value), type2) : typeof value?.transform === "function" ? maybeTypedArrayify(value.transform(data), type2) : maybeTake(maybeTypedArrayify(value, type2), data?.[reindex]);
}
function maybeTake(values2, index2) {
  return index2 ? take(values2, index2) : values2;
}
function maybeTypedMap(data, f2, type2) {
  return map2(data, type2?.prototype instanceof TypedArray ? floater(f2) : f2, type2);
}
function maybeTypedArrayify(data, type2) {
  return type2 === void 0 ? arrayify2(data) : data instanceof type2 ? data : type2.prototype instanceof TypedArray && !(data instanceof TypedArray) ? type2.from(data, coerceNumber) : type2.from(data);
}
function floater(f2) {
  return (d, i) => coerceNumber(f2(d, i));
}
var singleton = [null];
var field = (name2) => (d) => d[name2];
var indexOf = { transform: range2 };
var identity7 = { transform: (d) => d };
var one2 = () => 1;
var yes = () => true;
var string = (x4) => x4 == null ? x4 : `${x4}`;
var number5 = (x4) => x4 == null ? x4 : +x4;
var first2 = (x4) => x4 ? x4[0] : void 0;
var second2 = (x4) => x4 ? x4[1] : void 0;
var third = (x4) => x4 ? x4[2] : void 0;
var constant = (x4) => () => x4;
function percentile(reduce) {
  const p2 = +`${reduce}`.slice(1) / 100;
  return (I2, f2) => quantile2(I2, p2, f2);
}
function coerceNumbers(values2) {
  return values2 instanceof TypedArray ? values2 : map2(values2, coerceNumber, Float64Array);
}
function coerceNumber(x4) {
  return x4 == null ? NaN : Number(x4);
}
function coerceDates(values2) {
  return map2(values2, coerceDate);
}
function coerceDate(x4) {
  return x4 instanceof Date && !isNaN(x4) ? x4 : typeof x4 === "string" ? parse(x4) : x4 == null || isNaN(x4 = +x4) ? void 0 : new Date(x4);
}
function maybeColorChannel(value, defaultValue) {
  if (value === void 0)
    value = defaultValue;
  return value === null ? [void 0, "none"] : isColor(value) ? [void 0, value] : [value, void 0];
}
function maybeNumberChannel(value, defaultValue) {
  if (value === void 0)
    value = defaultValue;
  return value === null || typeof value === "number" ? [void 0, value] : [value, void 0];
}
function maybeKeyword(input3, name2, allowed) {
  if (input3 != null)
    return keyword(input3, name2, allowed);
}
function keyword(input3, name2, allowed) {
  const i = `${input3}`.toLowerCase();
  if (!allowed.includes(i))
    throw new Error(`invalid ${name2}: ${input3}`);
  return i;
}
function arrayify2(data) {
  return data == null || data instanceof Array || data instanceof TypedArray ? data : Array.from(data);
}
function map2(values2, f2, type2 = Array) {
  return values2 == null ? values2 : values2 instanceof type2 ? values2.map(f2) : type2.from(values2, f2);
}
function slice3(values2, type2 = Array) {
  return values2 instanceof type2 ? values2.slice() : type2.from(values2);
}
function hasX({ x: x4, x1: x12, x2: x22 }) {
  return x4 !== void 0 || x12 !== void 0 || x22 !== void 0;
}
function hasY({ y: y4, y1: y12, y2: y22 }) {
  return y4 !== void 0 || y12 !== void 0 || y22 !== void 0;
}
function hasXY(options) {
  return hasX(options) || hasY(options) || options.interval !== void 0;
}
function isObject3(option) {
  return option?.toString === objectToString;
}
function isScaleOptions(option) {
  return isObject3(option) && (option.type !== void 0 || option.domain !== void 0);
}
function isOptions(option) {
  return isObject3(option) && typeof option.transform !== "function";
}
function isDomainSort(sort3) {
  return isOptions(sort3) && sort3.value === void 0 && sort3.channel === void 0;
}
function maybeZero(x4, x12, x22, x32 = identity7) {
  if (x12 === void 0 && x22 === void 0) {
    x12 = 0, x22 = x4 === void 0 ? x32 : x4;
  } else if (x12 === void 0) {
    x12 = x4 === void 0 ? 0 : x4;
  } else if (x22 === void 0) {
    x22 = x4 === void 0 ? 0 : x4;
  }
  return [x12, x22];
}
function maybeTuple(x4, y4) {
  return x4 === void 0 && y4 === void 0 ? [first2, second2] : [x4, y4];
}
function maybeZ({ z: z2, fill, stroke } = {}) {
  if (z2 === void 0)
    [z2] = maybeColorChannel(fill);
  if (z2 === void 0)
    [z2] = maybeColorChannel(stroke);
  return z2;
}
function range2(data) {
  const n = data.length;
  const r = new Uint32Array(n);
  for (let i = 0; i < n; ++i)
    r[i] = i;
  return r;
}
function take(values2, index2) {
  return map2(index2, (i) => values2[i], values2.constructor);
}
function taker(f2) {
  return f2.length === 1 ? (index2, values2) => f2(take(values2, index2)) : f2;
}
function subarray(I2, i, j2) {
  return I2.subarray ? I2.subarray(i, j2) : I2.slice(i, j2);
}
function keyof2(value) {
  return value !== null && typeof value === "object" ? value.valueOf() : value;
}
function maybeInput(key, options) {
  if (options[key] !== void 0)
    return options[key];
  switch (key) {
    case "x1":
    case "x2":
      key = "x";
      break;
    case "y1":
    case "y2":
      key = "y";
      break;
  }
  return options[key];
}
function column2(source) {
  let value;
  return [
    {
      transform: () => value,
      label: labelof(source)
    },
    (v3) => value = v3
  ];
}
function maybeColumn(source) {
  return source == null ? [source] : column2(source);
}
function labelof(value, defaultValue) {
  return typeof value === "string" ? value : value && value.label !== void 0 ? value.label : defaultValue;
}
function mid(x12, x22) {
  return {
    transform(data) {
      const X13 = x12.transform(data);
      const X24 = x22.transform(data);
      return isTemporal(X13) || isTemporal(X24) ? map2(X13, (_2, i) => new Date((+X13[i] + +X24[i]) / 2)) : map2(X13, (_2, i) => (+X13[i] + +X24[i]) / 2, Float64Array);
    },
    label: x12.label
  };
}
function maybeApplyInterval(V2, scale3) {
  const t = maybeIntervalTransform(scale3?.interval, scale3?.type);
  return t ? map2(V2, t) : V2;
}
function maybeIntervalTransform(interval2, type2) {
  const i = maybeInterval(interval2, type2);
  return i && ((v3) => defined(v3) ? i.floor(v3) : v3);
}
function maybeInterval(interval2, type2) {
  if (interval2 == null)
    return;
  if (typeof interval2 === "number") {
    if (0 < interval2 && interval2 < 1 && Number.isInteger(1 / interval2))
      interval2 = -1 / interval2;
    const n = Math.abs(interval2);
    return interval2 < 0 ? {
      floor: (d) => Math.floor(d * n) / n,
      offset: (d) => (d * n + 1) / n,
      // note: no optional step for simplicity
      range: (lo, hi) => range(Math.ceil(lo * n), hi * n).map((x4) => x4 / n)
    } : {
      floor: (d) => Math.floor(d / n) * n,
      offset: (d) => d + n,
      // note: no optional step for simplicity
      range: (lo, hi) => range(Math.ceil(lo / n), hi / n).map((x4) => x4 * n)
    };
  }
  if (typeof interval2 === "string")
    return (type2 === "time" ? maybeTimeInterval : maybeUtcInterval)(interval2);
  if (typeof interval2.floor !== "function")
    throw new Error("invalid interval; missing floor method");
  if (typeof interval2.offset !== "function")
    throw new Error("invalid interval; missing offset method");
  return interval2;
}
function maybeRangeInterval(interval2, type2) {
  interval2 = maybeInterval(interval2, type2);
  if (interval2 && typeof interval2.range !== "function")
    throw new Error("invalid interval: missing range method");
  return interval2;
}
function maybeNiceInterval(interval2, type2) {
  interval2 = maybeRangeInterval(interval2, type2);
  if (interval2 && typeof interval2.ceil !== "function")
    throw new Error("invalid interval: missing ceil method");
  return interval2;
}
function isTimeInterval(t) {
  return isInterval(t) && typeof t?.floor === "function" && t.floor() instanceof Date;
}
function isInterval(t) {
  return typeof t?.range === "function";
}
function maybeValue(value) {
  return value === void 0 || isOptions(value) ? value : { value };
}
function numberChannel(source) {
  return source == null ? null : {
    transform: (data) => valueof(data, source, Float64Array),
    label: labelof(source)
  };
}
function isTuples(data) {
  if (!isIterable3(data))
    return false;
  for (const d of data) {
    if (d == null)
      continue;
    return typeof d === "object" && "0" in d && "1" in d;
  }
}
function isIterable3(value) {
  return value && typeof value[Symbol.iterator] === "function";
}
function isTextual(values2) {
  for (const value of values2) {
    if (value == null)
      continue;
    return typeof value !== "object" || value instanceof Date;
  }
}
function isOrdinal(values2) {
  for (const value of values2) {
    if (value == null)
      continue;
    const type2 = typeof value;
    return type2 === "string" || type2 === "boolean";
  }
}
function isTemporal(values2) {
  for (const value of values2) {
    if (value == null)
      continue;
    return value instanceof Date;
  }
}
function isTemporalString(values2) {
  for (const value of values2) {
    if (value == null)
      continue;
    return typeof value === "string" && isNaN(value) && parse(value);
  }
}
function isNumericString(values2) {
  for (const value of values2) {
    if (value == null)
      continue;
    if (typeof value !== "string")
      return false;
    if (!value.trim())
      continue;
    return !isNaN(value);
  }
}
function isNumeric(values2) {
  for (const value of values2) {
    if (value == null)
      continue;
    return typeof value === "number";
  }
}
function isEvery(values2, is) {
  let every;
  for (const value of values2) {
    if (value == null)
      continue;
    if (!is(value))
      return false;
    every = true;
  }
  return every;
}
var namedColors = new Set("none,currentcolor,transparent,aliceblue,antiquewhite,aqua,aquamarine,azure,beige,bisque,black,blanchedalmond,blue,blueviolet,brown,burlywood,cadetblue,chartreuse,chocolate,coral,cornflowerblue,cornsilk,crimson,cyan,darkblue,darkcyan,darkgoldenrod,darkgray,darkgreen,darkgrey,darkkhaki,darkmagenta,darkolivegreen,darkorange,darkorchid,darkred,darksalmon,darkseagreen,darkslateblue,darkslategray,darkslategrey,darkturquoise,darkviolet,deeppink,deepskyblue,dimgray,dimgrey,dodgerblue,firebrick,floralwhite,forestgreen,fuchsia,gainsboro,ghostwhite,gold,goldenrod,gray,green,greenyellow,grey,honeydew,hotpink,indianred,indigo,ivory,khaki,lavender,lavenderblush,lawngreen,lemonchiffon,lightblue,lightcoral,lightcyan,lightgoldenrodyellow,lightgray,lightgreen,lightgrey,lightpink,lightsalmon,lightseagreen,lightskyblue,lightslategray,lightslategrey,lightsteelblue,lightyellow,lime,limegreen,linen,magenta,maroon,mediumaquamarine,mediumblue,mediumorchid,mediumpurple,mediumseagreen,mediumslateblue,mediumspringgreen,mediumturquoise,mediumvioletred,midnightblue,mintcream,mistyrose,moccasin,navajowhite,navy,oldlace,olive,olivedrab,orange,orangered,orchid,palegoldenrod,palegreen,paleturquoise,palevioletred,papayawhip,peachpuff,peru,pink,plum,powderblue,purple,rebeccapurple,red,rosybrown,royalblue,saddlebrown,salmon,sandybrown,seagreen,seashell,sienna,silver,skyblue,slateblue,slategray,slategrey,snow,springgreen,steelblue,tan,teal,thistle,tomato,turquoise,violet,wheat,white,whitesmoke,yellow".split(","));
function isColor(value) {
  if (typeof value !== "string")
    return false;
  value = value.toLowerCase().trim();
  return /^#[0-9a-f]{3,8}$/.test(value) || // hex rgb, rgba, rrggbb, rrggbbaa
  /^(?:url|var|rgb|rgba|hsl|hsla|hwb|lab|lch|oklab|oklch|color|color-mix)\(.*\)$/.test(value) || // <funciri>, CSS variable, color, etc.
  namedColors.has(value);
}
function isOpacity(value) {
  return typeof value === "number" && (0 <= value && value <= 1 || isNaN(value));
}
function isNoneish(value) {
  return value == null || isNone(value);
}
function isNone(value) {
  return /^\s*none\s*$/i.test(value);
}
function isRound(value) {
  return /^\s*round\s*$/i.test(value);
}
function maybeAnchor(value, name2) {
  return maybeKeyword(value, name2, [
    "middle",
    "top-left",
    "top",
    "top-right",
    "right",
    "bottom-right",
    "bottom",
    "bottom-left",
    "left"
  ]);
}
function maybeFrameAnchor(value = "middle") {
  return maybeAnchor(value, "frameAnchor");
}
function inherit2(options = {}, ...rest) {
  let o = options;
  for (const defaults23 of rest) {
    for (const key in defaults23) {
      if (o[key] === void 0) {
        const value = defaults23[key];
        if (o === options)
          o = { ...o, [key]: value };
        else
          o[key] = value;
      }
    }
  }
  return o;
}
function named2(things) {
  console.warn("named iterables are deprecated; please use an object instead");
  const names = /* @__PURE__ */ new Set();
  return Object.fromEntries(
    Array.from(things, (thing) => {
      const { name: name2 } = thing;
      if (name2 == null)
        throw new Error("missing name");
      const key = `${name2}`;
      if (key === "__proto__")
        throw new Error(`illegal name: ${key}`);
      if (names.has(key))
        throw new Error(`duplicate name: ${key}`);
      names.add(key);
      return [name2, thing];
    })
  );
}
function maybeNamed(things) {
  return isIterable3(things) ? named2(things) : things;
}
function maybeClip(clip) {
  if (clip === true)
    clip = "frame";
  else if (clip === false)
    clip = null;
  else if (clip != null)
    clip = keyword(clip, "clip", ["frame", "sphere"]);
  return clip;
}

// ../../node_modules/@observablehq/plot/src/scales/index.js
var position = Symbol("position");
var color2 = Symbol("color");
var radius = Symbol("radius");
var length3 = Symbol("length");
var opacity = Symbol("opacity");
var symbol = Symbol("symbol");
var projection2 = Symbol("projection");
var registry = /* @__PURE__ */ new Map([
  ["x", position],
  ["y", position],
  ["fx", position],
  ["fy", position],
  ["r", radius],
  ["color", color2],
  ["opacity", opacity],
  ["symbol", symbol],
  ["length", length3],
  ["projection", projection2]
]);
function isPosition(kind) {
  return kind === position || kind === projection2;
}
function hasNumericRange(kind) {
  return kind === position || kind === radius || kind === length3 || kind === opacity;
}

// ../../node_modules/@observablehq/plot/src/symbol.js
var sqrt35 = Math.sqrt(3);
var sqrt4_3 = 2 / sqrt35;
var symbolHexagon = {
  draw(context, size) {
    const rx = Math.sqrt(size / Math.PI), ry = rx * sqrt4_3, hy = ry / 2;
    context.moveTo(0, ry);
    context.lineTo(rx, hy);
    context.lineTo(rx, -hy);
    context.lineTo(0, -ry);
    context.lineTo(-rx, -hy);
    context.lineTo(-rx, hy);
    context.closePath();
  }
};
var symbols = /* @__PURE__ */ new Map([
  ["asterisk", asterisk_default],
  ["circle", circle_default2],
  ["cross", cross_default],
  ["diamond", diamond_default],
  ["diamond2", diamond2_default],
  ["hexagon", symbolHexagon],
  ["plus", plus_default],
  ["square", square_default],
  ["square2", square2_default],
  ["star", star_default],
  ["times", times_default],
  ["triangle", triangle_default],
  ["triangle2", triangle2_default],
  ["wye", wye_default]
]);
function isSymbolObject(value) {
  return value && typeof value.draw === "function";
}
function isSymbol(value) {
  if (isSymbolObject(value))
    return true;
  if (typeof value !== "string")
    return false;
  return symbols.has(value.toLowerCase());
}
function maybeSymbol(symbol2) {
  if (symbol2 == null || isSymbolObject(symbol2))
    return symbol2;
  const value = symbols.get(`${symbol2}`.toLowerCase());
  if (value)
    return value;
  throw new Error(`invalid symbol: ${symbol2}`);
}
function maybeSymbolChannel(symbol2) {
  if (symbol2 == null || isSymbolObject(symbol2))
    return [void 0, symbol2];
  if (typeof symbol2 === "string") {
    const value = symbols.get(`${symbol2}`.toLowerCase());
    if (value)
      return [void 0, value];
  }
  return [symbol2, void 0];
}

// ../../node_modules/@observablehq/plot/src/transforms/basic.js
function basic({ filter: f1, sort: s1, reverse: r1, transform: t13, initializer: i1, ...options } = {}, transform3) {
  if (t13 === void 0) {
    if (f1 != null)
      t13 = filterTransform(f1);
    if (s1 != null && !isDomainSort(s1))
      t13 = composeTransform(t13, sortTransform(s1));
    if (r1)
      t13 = composeTransform(t13, reverseTransform);
  }
  if (transform3 != null && i1 != null)
    throw new Error("transforms cannot be applied after initializers");
  return {
    ...options,
    ...(s1 === null || isDomainSort(s1)) && { sort: s1 },
    transform: composeTransform(t13, transform3)
  };
}
function initializer({ filter: f1, sort: s1, reverse: r1, initializer: i1, ...options } = {}, initializer2) {
  if (i1 === void 0) {
    if (f1 != null)
      i1 = filterTransform(f1);
    if (s1 != null && !isDomainSort(s1))
      i1 = composeInitializer(i1, sortTransform(s1));
    if (r1)
      i1 = composeInitializer(i1, reverseTransform);
  }
  return {
    ...options,
    ...(s1 === null || isDomainSort(s1)) && { sort: s1 },
    initializer: composeInitializer(i1, initializer2)
  };
}
function composeTransform(t13, t22) {
  if (t13 == null)
    return t22 === null ? void 0 : t22;
  if (t22 == null)
    return t13 === null ? void 0 : t13;
  return function(data, facets, plotOptions) {
    ({ data, facets } = t13.call(this, data, facets, plotOptions));
    return t22.call(this, arrayify2(data), facets, plotOptions);
  };
}
function composeInitializer(i1, i2) {
  if (i1 == null)
    return i2 === null ? void 0 : i2;
  if (i2 == null)
    return i1 === null ? void 0 : i1;
  return function(data, facets, channels, ...args) {
    let c1, d1, f1, c22, d2, f2;
    ({ data: d1 = data, facets: f1 = facets, channels: c1 } = i1.call(this, data, facets, channels, ...args));
    ({ data: d2 = d1, facets: f2 = f1, channels: c22 } = i2.call(this, d1, f1, { ...channels, ...c1 }, ...args));
    return { data: d2, facets: f2, channels: { ...c1, ...c22 } };
  };
}
function apply(options, t) {
  return (options.initializer != null ? initializer : basic)(options, t);
}
function filter2(test, options) {
  return apply(options, filterTransform(test));
}
function filterTransform(value) {
  return (data, facets) => {
    const V2 = valueof(data, value);
    return { data, facets: facets.map((I2) => I2.filter((i) => V2[i])) };
  };
}
function reverse2({ sort: sort3, ...options } = {}) {
  return {
    ...apply(options, reverseTransform),
    sort: isDomainSort(sort3) ? sort3 : null
  };
}
function reverseTransform(data, facets) {
  return { data, facets: facets.map((I2) => I2.slice().reverse()) };
}
function shuffle({ seed, sort: sort3, ...options } = {}) {
  return {
    ...apply(options, sortValue(seed == null ? Math.random : lcg(seed))),
    sort: isDomainSort(sort3) ? sort3 : null
  };
}
function sort2(order, { sort: sort3, ...options } = {}) {
  return {
    ...(isOptions(order) && order.channel !== void 0 ? initializer : apply)(options, sortTransform(order)),
    sort: isDomainSort(sort3) ? sort3 : null
  };
}
function sortTransform(value) {
  return (typeof value === "function" && value.length !== 1 ? sortData : sortValue)(value);
}
function sortData(compare) {
  return (data, facets) => {
    const compareData = (i, j2) => compare(data[i], data[j2]);
    return { data, facets: facets.map((I2) => I2.slice().sort(compareData)) };
  };
}
function sortValue(value) {
  let channel, order;
  ({ channel, value, order } = { ...maybeValue(value) });
  const negate2 = channel?.startsWith("-");
  if (negate2)
    channel = channel.slice(1);
  if (order === void 0)
    order = negate2 ? descendingDefined : ascendingDefined2;
  if (typeof order !== "function") {
    switch (`${order}`.toLowerCase()) {
      case "ascending":
        order = ascendingDefined2;
        break;
      case "descending":
        order = descendingDefined;
        break;
      default:
        throw new Error(`invalid order: ${order}`);
    }
  }
  return (data, facets, channels) => {
    let V2;
    if (channel === void 0) {
      V2 = valueof(data, value);
    } else {
      if (channels === void 0)
        throw new Error("channel sort requires an initializer");
      V2 = channels[channel];
      if (!V2)
        return {};
      V2 = V2.value;
    }
    const compareValue = (i, j2) => order(V2[i], V2[j2]);
    return { data, facets: facets.map((I2) => I2.slice().sort(compareValue)) };
  };
}

// ../../node_modules/@observablehq/plot/src/transforms/group.js
function groupZ(outputs, options) {
  return groupn(null, null, outputs, options);
}
function groupX(outputs = { y: "count" }, options = {}) {
  const { x: x4 = identity7 } = options;
  if (x4 == null)
    throw new Error("missing channel: x");
  return groupn(x4, null, outputs, options);
}
function groupY(outputs = { x: "count" }, options = {}) {
  const { y: y4 = identity7 } = options;
  if (y4 == null)
    throw new Error("missing channel: y");
  return groupn(null, y4, outputs, options);
}
function group2(outputs = { fill: "count" }, options = {}) {
  let { x: x4, y: y4 } = options;
  [x4, y4] = maybeTuple(x4, y4);
  if (x4 == null)
    throw new Error("missing channel: x");
  if (y4 == null)
    throw new Error("missing channel: y");
  return groupn(x4, y4, outputs, options);
}
function groupn(x4, y4, {
  data: reduceData = reduceIdentity,
  filter: filter3,
  sort: sort3,
  reverse: reverse3,
  ...outputs
  // output channel definitions
} = {}, inputs = {}) {
  outputs = maybeGroupOutputs(outputs, inputs);
  reduceData = maybeGroupReduce(reduceData, identity7);
  sort3 = sort3 == null ? void 0 : maybeGroupOutput("sort", sort3, inputs);
  filter3 = filter3 == null ? void 0 : maybeGroupEvaluator("filter", filter3, inputs);
  const [GX, setGX] = maybeColumn(x4);
  const [GY, setGY] = maybeColumn(y4);
  const {
    z: z2,
    fill,
    stroke,
    x1: x12,
    x2: x22,
    // consumed if x is an output
    y1: y12,
    y2: y22,
    // consumed if y is an output
    ...options
  } = inputs;
  const [GZ, setGZ] = maybeColumn(z2);
  const [vfill] = maybeColorChannel(fill);
  const [vstroke] = maybeColorChannel(stroke);
  const [GF, setGF] = maybeColumn(vfill);
  const [GS, setGS] = maybeColumn(vstroke);
  return {
    ..."z" in inputs && { z: GZ || z2 },
    ..."fill" in inputs && { fill: GF || fill },
    ..."stroke" in inputs && { stroke: GS || stroke },
    ...basic(options, (data, facets, plotOptions) => {
      const X3 = maybeApplyInterval(valueof(data, x4), plotOptions?.x);
      const Y3 = maybeApplyInterval(valueof(data, y4), plotOptions?.y);
      const Z3 = valueof(data, z2);
      const F2 = valueof(data, vfill);
      const S2 = valueof(data, vstroke);
      const G = maybeSubgroup(outputs, { z: Z3, fill: F2, stroke: S2 });
      const groupFacets = [];
      const groupData = [];
      const GX2 = X3 && setGX([]);
      const GY2 = Y3 && setGY([]);
      const GZ2 = Z3 && setGZ([]);
      const GF2 = F2 && setGF([]);
      const GS2 = S2 && setGS([]);
      let i = 0;
      for (const o of outputs)
        o.initialize(data);
      if (sort3)
        sort3.initialize(data);
      if (filter3)
        filter3.initialize(data);
      for (const facet of facets) {
        const groupFacet = [];
        for (const o of outputs)
          o.scope("facet", facet);
        if (sort3)
          sort3.scope("facet", facet);
        if (filter3)
          filter3.scope("facet", facet);
        for (const [f2, I2] of maybeGroup(facet, G)) {
          for (const [y5, gg] of maybeGroup(I2, Y3)) {
            for (const [x5, g2] of maybeGroup(gg, X3)) {
              const extent4 = { data };
              if (X3)
                extent4.x = x5;
              if (Y3)
                extent4.y = y5;
              if (G)
                extent4.z = f2;
              if (filter3 && !filter3.reduce(g2, extent4))
                continue;
              groupFacet.push(i++);
              groupData.push(reduceData.reduceIndex(g2, data, extent4));
              if (X3)
                GX2.push(x5);
              if (Y3)
                GY2.push(y5);
              if (Z3)
                GZ2.push(G === Z3 ? f2 : Z3[g2[0]]);
              if (F2)
                GF2.push(G === F2 ? f2 : F2[g2[0]]);
              if (S2)
                GS2.push(G === S2 ? f2 : S2[g2[0]]);
              for (const o of outputs)
                o.reduce(g2, extent4);
              if (sort3)
                sort3.reduce(g2, extent4);
            }
          }
        }
        groupFacets.push(groupFacet);
      }
      maybeSort(groupFacets, sort3, reverse3);
      return { data: groupData, facets: groupFacets };
    }),
    ...!hasOutput(outputs, "x") && (GX ? { x: GX } : { x1: x12, x2: x22 }),
    ...!hasOutput(outputs, "y") && (GY ? { y: GY } : { y1: y12, y2: y22 }),
    ...Object.fromEntries(outputs.map(({ name: name2, output }) => [name2, output]))
  };
}
function hasOutput(outputs, ...names) {
  for (const { name: name2 } of outputs) {
    if (names.includes(name2)) {
      return true;
    }
  }
  return false;
}
function maybeOutputs(outputs, inputs, asOutput = maybeOutput) {
  const entries = Object.entries(outputs);
  if (inputs.title != null && outputs.title === void 0)
    entries.push(["title", reduceTitle]);
  if (inputs.href != null && outputs.href === void 0)
    entries.push(["href", reduceFirst]);
  return entries.filter(([, reduce]) => reduce !== void 0).map(([name2, reduce]) => reduce === null ? nullOutput(name2) : asOutput(name2, reduce, inputs));
}
function maybeOutput(name2, reduce, inputs, asEvaluator = maybeEvaluator) {
  let scale3;
  if (isObject3(reduce) && "reduce" in reduce)
    scale3 = reduce.scale, reduce = reduce.reduce;
  const evaluator = asEvaluator(name2, reduce, inputs);
  const [output, setOutput] = column2(evaluator.label);
  let O2;
  return {
    name: name2,
    output: scale3 === void 0 ? output : { value: output, scale: scale3 },
    initialize(data) {
      evaluator.initialize(data);
      O2 = setOutput([]);
    },
    scope(scope, I2) {
      evaluator.scope(scope, I2);
    },
    reduce(I2, extent4) {
      O2.push(evaluator.reduce(I2, extent4));
    }
  };
}
function nullOutput(name2) {
  return { name: name2, initialize() {
  }, scope() {
  }, reduce() {
  } };
}
function maybeEvaluator(name2, reduce, inputs, asReduce = maybeReduce) {
  const input3 = maybeInput(name2, inputs);
  const reducer2 = asReduce(reduce, input3);
  let V2, context;
  return {
    label: labelof(reducer2 === reduceCount ? null : input3, reducer2.label),
    initialize(data) {
      V2 = input3 === void 0 ? data : valueof(data, input3);
      if (reducer2.scope === "data") {
        context = reducer2.reduceIndex(range2(data), V2);
      }
    },
    scope(scope, I2) {
      if (reducer2.scope === scope) {
        context = reducer2.reduceIndex(I2, V2);
      }
    },
    reduce(I2, extent4) {
      return reducer2.scope == null ? reducer2.reduceIndex(I2, V2, extent4) : reducer2.reduceIndex(I2, V2, context, extent4);
    }
  };
}
function maybeGroup(I2, X3) {
  return X3 ? group(I2, (i) => X3[i]) : [[, I2]];
}
function maybeReduce(reduce, value, fallback = invalidReduce) {
  if (reduce == null)
    return fallback(reduce);
  if (typeof reduce.reduceIndex === "function")
    return reduce;
  if (typeof reduce.reduce === "function" && isObject3(reduce))
    return reduceReduce(reduce);
  if (typeof reduce === "function")
    return reduceFunction(reduce);
  if (/^p\d{2}$/i.test(reduce))
    return reduceAccessor(percentile(reduce));
  switch (`${reduce}`.toLowerCase()) {
    case "first":
      return reduceFirst;
    case "last":
      return reduceLast;
    case "identity":
      return reduceIdentity;
    case "count":
      return reduceCount;
    case "distinct":
      return reduceDistinct;
    case "sum":
      return value == null ? reduceCount : reduceSum;
    case "proportion":
      return reduceProportion(value, "data");
    case "proportion-facet":
      return reduceProportion(value, "facet");
    case "deviation":
      return reduceAccessor(deviation);
    case "min":
      return reduceAccessor(min2);
    case "min-index":
      return reduceAccessor(minIndex);
    case "max":
      return reduceAccessor(max2);
    case "max-index":
      return reduceAccessor(maxIndex);
    case "mean":
      return reduceMaybeTemporalAccessor(mean2);
    case "median":
      return reduceMaybeTemporalAccessor(median2);
    case "variance":
      return reduceAccessor(variance2);
    case "mode":
      return reduceAccessor(mode2);
  }
  return fallback(reduce);
}
function invalidReduce(reduce) {
  throw new Error(`invalid reduce: ${reduce}`);
}
function maybeGroupOutputs(outputs, inputs) {
  return maybeOutputs(outputs, inputs, maybeGroupOutput);
}
function maybeGroupOutput(name2, reduce, inputs) {
  return maybeOutput(name2, reduce, inputs, maybeGroupEvaluator);
}
function maybeGroupEvaluator(name2, reduce, inputs) {
  return maybeEvaluator(name2, reduce, inputs, maybeGroupReduce);
}
function maybeGroupReduce(reduce, value) {
  return maybeReduce(reduce, value, maybeGroupReduceFallback);
}
function maybeGroupReduceFallback(reduce) {
  switch (`${reduce}`.toLowerCase()) {
    case "x":
      return reduceX;
    case "y":
      return reduceY;
    case "z":
      return reduceZ;
  }
  throw new Error(`invalid group reduce: ${reduce}`);
}
function maybeSubgroup(outputs, inputs) {
  for (const name2 in inputs) {
    const value = inputs[name2];
    if (value !== void 0 && !outputs.some((o) => o.name === name2)) {
      return value;
    }
  }
}
function maybeSort(facets, sort3, reverse3) {
  if (sort3) {
    const S2 = sort3.output.transform();
    const compare = (i, j2) => ascendingDefined2(S2[i], S2[j2]);
    facets.forEach((f2) => f2.sort(compare));
  }
  if (reverse3) {
    facets.forEach((f2) => f2.reverse());
  }
}
function reduceReduce(reduce) {
  console.warn("deprecated reduce interface; implement reduceIndex instead.");
  return { ...reduce, reduceIndex: reduce.reduce.bind(reduce) };
}
function reduceFunction(f2) {
  return {
    reduceIndex(I2, X3, extent4) {
      return f2(take(X3, I2), extent4);
    }
  };
}
function reduceAccessor(f2) {
  return {
    reduceIndex(I2, X3) {
      return f2(I2, (i) => X3[i]);
    }
  };
}
function reduceMaybeTemporalAccessor(f2) {
  return {
    reduceIndex(I2, X3) {
      const x4 = f2(I2, (i) => X3[i]);
      return isTemporal(X3) ? new Date(x4) : x4;
    }
  };
}
var reduceIdentity = {
  reduceIndex(I2, X3) {
    return take(X3, I2);
  }
};
var reduceFirst = {
  reduceIndex(I2, X3) {
    return X3[I2[0]];
  }
};
var reduceTitle = {
  reduceIndex(I2, X3) {
    const n = 5;
    const groups2 = sort(
      rollup(
        I2,
        (V2) => V2.length,
        (i) => X3[i]
      ),
      second2
    );
    const top2 = groups2.slice(-n).reverse();
    if (top2.length < groups2.length) {
      const bottom2 = groups2.slice(0, 1 - n);
      top2[n - 1] = [`\u2026 ${bottom2.length.toLocaleString("en-US")} more`, sum3(bottom2, second2)];
    }
    return top2.map(([key, value]) => `${key} (${value.toLocaleString("en-US")})`).join("\n");
  }
};
var reduceLast = {
  reduceIndex(I2, X3) {
    return X3[I2[I2.length - 1]];
  }
};
var reduceCount = {
  label: "Frequency",
  reduceIndex(I2) {
    return I2.length;
  }
};
var reduceDistinct = {
  label: "Distinct",
  reduceIndex(I2, X3) {
    const s2 = new InternSet();
    for (const i of I2)
      s2.add(X3[i]);
    return s2.size;
  }
};
var reduceSum = reduceAccessor(sum3);
function reduceProportion(value, scope) {
  return value == null ? { scope, label: "Frequency", reduceIndex: (I2, V2, basis2 = 1) => I2.length / basis2 } : { scope, reduceIndex: (I2, V2, basis2 = 1) => sum3(I2, (i) => V2[i]) / basis2 };
}
var reduceX = {
  reduceIndex(I2, X3, { x: x4 }) {
    return x4;
  }
};
var reduceY = {
  reduceIndex(I2, X3, { y: y4 }) {
    return y4;
  }
};
var reduceZ = {
  reduceIndex(I2, X3, { z: z2 }) {
    return z2;
  }
};
function find2(test) {
  if (typeof test !== "function")
    throw new Error(`invalid test function: ${test}`);
  return {
    reduceIndex(I2, V2, { data }) {
      return V2[I2.find((i) => test(data[i], i, data))];
    }
  };
}

// ../../node_modules/@observablehq/plot/src/channel.js
function createChannel(data, { scale: scale3, type: type2, value, filter: filter3, hint, label: label2 = labelof(value) }, name2) {
  if (hint === void 0 && typeof value?.transform === "function")
    hint = value.hint;
  return inferChannelScale(name2, {
    scale: scale3,
    type: type2,
    value: valueof(data, value),
    label: label2,
    filter: filter3,
    hint
  });
}
function createChannels(channels, data) {
  return Object.fromEntries(
    Object.entries(channels).map(([name2, channel]) => [name2, createChannel(data, channel, name2)])
  );
}
function valueObject(channels, scales2) {
  const values2 = Object.fromEntries(
    Object.entries(channels).map(([name2, { scale: scaleName, value }]) => {
      const scale3 = scaleName == null ? null : scales2[scaleName];
      return [name2, scale3 == null ? value : map2(value, scale3)];
    })
  );
  values2.channels = channels;
  return values2;
}
function inferChannelScale(name2, channel) {
  const { scale: scale3, value } = channel;
  if (scale3 === true || scale3 === "auto") {
    switch (name2) {
      case "fill":
      case "stroke":
      case "color":
        channel.scale = scale3 !== true && isEvery(value, isColor) ? null : "color";
        break;
      case "fillOpacity":
      case "strokeOpacity":
      case "opacity":
        channel.scale = scale3 !== true && isEvery(value, isOpacity) ? null : "opacity";
        break;
      case "symbol":
        if (scale3 !== true && isEvery(value, isSymbol)) {
          channel.scale = null;
          channel.value = map2(value, maybeSymbol);
        } else {
          channel.scale = "symbol";
        }
        break;
      default:
        channel.scale = registry.has(name2) ? name2 : null;
        break;
    }
  } else if (scale3 === false) {
    channel.scale = null;
  } else if (scale3 != null && !registry.has(scale3)) {
    throw new Error(`unknown scale: ${scale3}`);
  }
  return channel;
}
function channelDomain(data, facets, channels, facetChannels, options) {
  const { order: defaultOrder, reverse: defaultReverse, reduce: defaultReduce = true, limit: defaultLimit } = options;
  for (const x4 in options) {
    if (!registry.has(x4))
      continue;
    let { value: y4, order = defaultOrder, reverse: reverse3 = defaultReverse, reduce = defaultReduce, limit = defaultLimit } = maybeValue(options[x4]);
    const negate2 = y4?.startsWith("-");
    if (negate2)
      y4 = y4.slice(1);
    order = order === void 0 ? negate2 !== (y4 === "width" || y4 === "height") ? descendingGroup : ascendingGroup : maybeOrder(order);
    if (reduce == null || reduce === false)
      continue;
    const X3 = x4 === "fx" || x4 === "fy" ? reindexFacetChannel(facets, facetChannels[x4]) : findScaleChannel(channels, x4);
    if (!X3)
      throw new Error(`missing channel for scale: ${x4}`);
    const XV = X3.value;
    const [lo = 0, hi = Infinity] = isIterable3(limit) ? limit : limit < 0 ? [limit] : [0, limit];
    if (y4 == null) {
      X3.domain = () => {
        let domain = Array.from(new InternSet(XV));
        if (reverse3)
          domain = domain.reverse();
        if (lo !== 0 || hi !== Infinity)
          domain = domain.slice(lo, hi);
        return domain;
      };
    } else {
      const YV = y4 === "data" ? data : y4 === "height" ? difference(channels, "y1", "y2") : y4 === "width" ? difference(channels, "x1", "x2") : values(channels, y4, y4 === "y" ? "y2" : y4 === "x" ? "x2" : void 0);
      const reducer2 = maybeReduce(reduce === true ? "max" : reduce, YV);
      X3.domain = () => {
        let domain = rollups(
          range2(XV),
          (I2) => reducer2.reduceIndex(I2, YV),
          (i) => XV[i]
        );
        if (order)
          domain.sort(order);
        if (reverse3)
          domain.reverse();
        if (lo !== 0 || hi !== Infinity)
          domain = domain.slice(lo, hi);
        return domain.map(first2);
      };
    }
  }
}
function findScaleChannel(channels, scale3) {
  for (const name2 in channels) {
    const channel = channels[name2];
    if (channel.scale === scale3)
      return channel;
  }
}
function reindexFacetChannel(facets, channel) {
  const originalFacets = facets.original;
  if (originalFacets === facets)
    return channel;
  const V1 = channel.value;
  const V2 = channel.value = [];
  for (let i = 0; i < originalFacets.length; ++i) {
    const vi = V1[originalFacets[i][0]];
    for (const j2 of facets[i])
      V2[j2] = vi;
  }
  return channel;
}
function difference(channels, k1, k22) {
  const X13 = values(channels, k1);
  const X24 = values(channels, k22);
  return map2(X24, (x22, i) => Math.abs(x22 - X13[i]), Float64Array);
}
function values(channels, name2, alias) {
  let channel = channels[name2];
  if (!channel && alias !== void 0)
    channel = channels[alias];
  if (channel)
    return channel.value;
  throw new Error(`missing channel: ${name2}`);
}
function maybeOrder(order) {
  if (order == null || typeof order === "function")
    return order;
  switch (`${order}`.toLowerCase()) {
    case "ascending":
      return ascendingGroup;
    case "descending":
      return descendingGroup;
  }
  throw new Error(`invalid order: ${order}`);
}
function ascendingGroup([ak, av], [bk, bv]) {
  return ascendingDefined2(av, bv) || ascendingDefined2(ak, bk);
}
function descendingGroup([ak, av], [bk, bv]) {
  return descendingDefined(av, bv) || ascendingDefined2(ak, bk);
}
function getSource(channels, key) {
  let channel = channels[key];
  if (!channel)
    return;
  while (channel.source)
    channel = channel.source;
  return channel.source === null ? null : channel;
}

// ../../node_modules/@observablehq/plot/src/context.js
function createContext(options = {}) {
  const { document: document2 = typeof window !== "undefined" ? window.document : void 0, clip } = options;
  return { document: document2, clip: maybeClip(clip) };
}
function create3(name2, { document: document2 }) {
  return select_default2(creator_default(name2).call(document2.documentElement));
}

// ../../node_modules/@observablehq/plot/src/warnings.js
var warnings = 0;
var lastMessage;
function consumeWarnings() {
  const w = warnings;
  warnings = 0;
  lastMessage = void 0;
  return w;
}
function warn(message) {
  if (message === lastMessage)
    return;
  lastMessage = message;
  console.warn(message);
  ++warnings;
}

// ../../node_modules/@observablehq/plot/src/projection.js
var pi4 = Math.PI;
var tau5 = 2 * pi4;
var defaultAspectRatio = 0.618;
function createProjection({
  projection: projection3,
  inset: globalInset = 0,
  insetTop = globalInset,
  insetRight = globalInset,
  insetBottom = globalInset,
  insetLeft = globalInset
} = {}, dimensions) {
  if (projection3 == null)
    return;
  if (typeof projection3.stream === "function")
    return projection3;
  let options;
  let domain;
  let clip = "frame";
  if (isObject3(projection3)) {
    let inset2;
    ({
      type: projection3,
      domain,
      inset: inset2,
      insetTop = inset2 !== void 0 ? inset2 : insetTop,
      insetRight = inset2 !== void 0 ? inset2 : insetRight,
      insetBottom = inset2 !== void 0 ? inset2 : insetBottom,
      insetLeft = inset2 !== void 0 ? inset2 : insetLeft,
      clip = clip,
      ...options
    } = projection3);
    if (projection3 == null)
      return;
  }
  if (typeof projection3 !== "function")
    ({ type: projection3 } = namedProjection(projection3));
  const { width: width2, height: height2, marginLeft: marginLeft2, marginRight: marginRight2, marginTop: marginTop2, marginBottom: marginBottom2 } = dimensions;
  const dx = width2 - marginLeft2 - marginRight2 - insetLeft - insetRight;
  const dy = height2 - marginTop2 - marginBottom2 - insetTop - insetBottom;
  projection3 = projection3?.({ width: dx, height: dy, clip, ...options });
  if (projection3 == null)
    return;
  clip = maybePostClip(clip, marginLeft2, marginTop2, width2 - marginRight2, height2 - marginBottom2);
  let tx = marginLeft2 + insetLeft;
  let ty = marginTop2 + insetTop;
  let transform3;
  if (domain != null) {
    const [[x06, y06], [x12, y12]] = path_default(projection3).bounds(domain);
    const k3 = Math.min(dx / (x12 - x06), dy / (y12 - y06));
    if (k3 > 0) {
      tx -= (k3 * (x06 + x12) - dx) / 2;
      ty -= (k3 * (y06 + y12) - dy) / 2;
      transform3 = transform_default({
        point(x4, y4) {
          this.stream.point(x4 * k3 + tx, y4 * k3 + ty);
        }
      });
    } else {
      warn(`Warning: the projection could not be fit to the specified domain; using the default scale.`);
    }
  }
  transform3 ??= tx === 0 && ty === 0 ? identity8() : transform_default({
    point(x4, y4) {
      this.stream.point(x4 + tx, y4 + ty);
    }
  });
  return { stream: (s2) => projection3.stream(transform3.stream(clip(s2))) };
}
function namedProjection(projection3) {
  switch (`${projection3}`.toLowerCase()) {
    case "albers-usa":
      return scaleProjection(albersUsa_default, 0.7463, 0.4673);
    case "albers":
      return conicProjection2(albers_default, 0.7463, 0.4673);
    case "azimuthal-equal-area":
      return scaleProjection(azimuthalEqualArea_default, 4, 4);
    case "azimuthal-equidistant":
      return scaleProjection(azimuthalEquidistant_default, tau5, tau5);
    case "conic-conformal":
      return conicProjection2(conicConformal_default, tau5, tau5);
    case "conic-equal-area":
      return conicProjection2(conicEqualArea_default, 6.1702, 2.9781);
    case "conic-equidistant":
      return conicProjection2(conicEquidistant_default, 7.312, 3.6282);
    case "equal-earth":
      return scaleProjection(equalEarth_default, 5.4133, 2.6347);
    case "equirectangular":
      return scaleProjection(equirectangular_default, tau5, pi4);
    case "gnomonic":
      return scaleProjection(gnomonic_default, 3.4641, 3.4641);
    case "identity":
      return { type: identity8 };
    case "reflect-y":
      return { type: reflectY };
    case "mercator":
      return scaleProjection(mercator_default, tau5, tau5);
    case "orthographic":
      return scaleProjection(orthographic_default, 2, 2);
    case "stereographic":
      return scaleProjection(stereographic_default, 2, 2);
    case "transverse-mercator":
      return scaleProjection(transverseMercator_default, tau5, tau5);
    default:
      throw new Error(`unknown projection type: ${projection3}`);
  }
}
function maybePostClip(clip, x12, y12, x22, y22) {
  if (clip === false || clip == null || typeof clip === "number")
    return (s2) => s2;
  if (clip === true)
    clip = "frame";
  switch (`${clip}`.toLowerCase()) {
    case "frame":
      return clipRectangle(x12, y12, x22, y22);
    default:
      throw new Error(`unknown projection clip type: ${clip}`);
  }
}
function scaleProjection(createProjection2, kx2, ky2) {
  return {
    type: ({ width: width2, height: height2, rotate, precision = 0.15, clip }) => {
      const projection3 = createProjection2();
      if (precision != null)
        projection3.precision?.(precision);
      if (rotate != null)
        projection3.rotate?.(rotate);
      if (typeof clip === "number")
        projection3.clipAngle?.(clip);
      projection3.scale(Math.min(width2 / kx2, height2 / ky2));
      projection3.translate([width2 / 2, height2 / 2]);
      return projection3;
    },
    aspectRatio: ky2 / kx2
  };
}
function conicProjection2(createProjection2, kx2, ky2) {
  const { type: type2, aspectRatio: aspectRatio2 } = scaleProjection(createProjection2, kx2, ky2);
  return {
    type: (options) => {
      const { parallels, domain, width: width2, height: height2 } = options;
      const projection3 = type2(options);
      if (parallels != null) {
        projection3.parallels(parallels);
        if (domain === void 0) {
          projection3.fitSize([width2, height2], { type: "Sphere" });
        }
      }
      return projection3;
    },
    aspectRatio: aspectRatio2
  };
}
var identity8 = constant({ stream: (stream) => stream });
var reflectY = constant(
  transform_default({
    point(x4, y4) {
      this.stream.point(x4, -y4);
    }
  })
);
function project(cx, cy, values2, projection3) {
  const x4 = values2[cx];
  const y4 = values2[cy];
  const n = x4.length;
  const X3 = values2[cx] = new Float64Array(n).fill(NaN);
  const Y3 = values2[cy] = new Float64Array(n).fill(NaN);
  let i;
  const stream = projection3.stream({
    point(x5, y5) {
      X3[i] = x5;
      Y3[i] = y5;
    }
  });
  for (i = 0; i < n; ++i) {
    stream.point(x4[i], y4[i]);
  }
}
function hasProjection({ projection: projection3 } = {}) {
  if (projection3 == null)
    return false;
  if (typeof projection3.stream === "function")
    return true;
  if (isObject3(projection3))
    projection3 = projection3.type;
  return projection3 != null;
}
function projectionAspectRatio(projection3) {
  if (typeof projection3?.stream === "function")
    return defaultAspectRatio;
  if (isObject3(projection3))
    projection3 = projection3.type;
  if (projection3 == null)
    return;
  if (typeof projection3 !== "function") {
    const { aspectRatio: aspectRatio2 } = namedProjection(projection3);
    if (aspectRatio2)
      return aspectRatio2;
  }
  return defaultAspectRatio;
}
function applyPosition(channels, scales2, { projection: projection3 }) {
  const { x: x4, y: y4 } = channels;
  let position3 = {};
  if (x4)
    position3.x = x4;
  if (y4)
    position3.y = y4;
  position3 = valueObject(position3, scales2);
  if (projection3 && x4?.scale === "x" && y4?.scale === "y")
    project("x", "y", position3, projection3);
  if (x4)
    position3.x = coerceNumbers(position3.x);
  if (y4)
    position3.y = coerceNumbers(position3.y);
  return position3;
}
function getGeometryChannels(channel) {
  const X3 = [];
  const Y3 = [];
  const x4 = { scale: "x", value: X3 };
  const y4 = { scale: "y", value: Y3 };
  const sink = {
    point(x5, y5) {
      X3.push(x5);
      Y3.push(y5);
    },
    lineStart() {
    },
    lineEnd() {
    },
    polygonStart() {
    },
    polygonEnd() {
    },
    sphere() {
    }
  };
  for (const object of channel.value)
    stream_default(object, sink);
  return [x4, y4];
}

// ../../node_modules/@observablehq/plot/src/scales/schemes.js
var categoricalSchemes = /* @__PURE__ */ new Map([
  ["accent", Accent_default],
  ["category10", category10_default],
  ["dark2", Dark2_default],
  ["observable10", observable10_default],
  ["paired", Paired_default],
  ["pastel1", Pastel1_default],
  ["pastel2", Pastel2_default],
  ["set1", Set1_default],
  ["set2", Set2_default],
  ["set3", Set3_default],
  ["tableau10", Tableau10_default]
]);
function isCategoricalScheme(scheme28) {
  return scheme28 != null && categoricalSchemes.has(`${scheme28}`.toLowerCase());
}
var ordinalSchemes = new Map([
  ...categoricalSchemes,
  // diverging
  ["brbg", scheme112(scheme, BrBG_default)],
  ["prgn", scheme112(scheme2, PRGn_default)],
  ["piyg", scheme112(scheme3, PiYG_default)],
  ["puor", scheme112(scheme4, PuOr_default)],
  ["rdbu", scheme112(scheme5, RdBu_default)],
  ["rdgy", scheme112(scheme6, RdGy_default)],
  ["rdylbu", scheme112(scheme7, RdYlBu_default)],
  ["rdylgn", scheme112(scheme8, RdYlGn_default)],
  ["spectral", scheme112(scheme9, Spectral_default)],
  // reversed diverging (for temperature data)
  ["burd", scheme11r(scheme5, RdBu_default)],
  ["buylrd", scheme11r(scheme7, RdYlBu_default)],
  // sequential (single-hue)
  ["blues", scheme92(scheme22, Blues_default)],
  ["greens", scheme92(scheme23, Greens_default)],
  ["greys", scheme92(scheme24, Greys_default)],
  ["oranges", scheme92(scheme27, Oranges_default)],
  ["purples", scheme92(scheme25, Purples_default)],
  ["reds", scheme92(scheme26, Reds_default)],
  // sequential (multi-hue)
  ["turbo", schemei(turbo_default)],
  ["viridis", schemei(viridis_default)],
  ["magma", schemei(magma)],
  ["inferno", schemei(inferno)],
  ["plasma", schemei(plasma)],
  ["cividis", schemei(cividis_default)],
  ["cubehelix", schemei(cubehelix_default2)],
  ["warm", schemei(warm)],
  ["cool", schemei(cool)],
  ["bugn", scheme92(scheme10, BuGn_default)],
  ["bupu", scheme92(scheme11, BuPu_default)],
  ["gnbu", scheme92(scheme12, GnBu_default)],
  ["orrd", scheme92(scheme13, OrRd_default)],
  ["pubu", scheme92(scheme15, PuBu_default)],
  ["pubugn", scheme92(scheme14, PuBuGn_default)],
  ["purd", scheme92(scheme16, PuRd_default)],
  ["rdpu", scheme92(scheme17, RdPu_default)],
  ["ylgn", scheme92(scheme19, YlGn_default)],
  ["ylgnbu", scheme92(scheme18, YlGnBu_default)],
  ["ylorbr", scheme92(scheme20, YlOrBr_default)],
  ["ylorrd", scheme92(scheme21, YlOrRd_default)],
  // cyclical
  ["rainbow", schemeicyclical(rainbow_default)],
  ["sinebow", schemeicyclical(sinebow_default)]
]);
function scheme92(scheme28, interpolate) {
  return ({ length: n }) => {
    if (n === 1)
      return [scheme28[3][1]];
    if (n === 2)
      return [scheme28[3][1], scheme28[3][2]];
    n = Math.max(3, Math.floor(n));
    return n > 9 ? quantize_default(interpolate, n) : scheme28[n];
  };
}
function scheme112(scheme28, interpolate) {
  return ({ length: n }) => {
    if (n === 2)
      return [scheme28[3][0], scheme28[3][2]];
    n = Math.max(3, Math.floor(n));
    return n > 11 ? quantize_default(interpolate, n) : scheme28[n];
  };
}
function scheme11r(scheme28, interpolate) {
  return ({ length: n }) => {
    if (n === 2)
      return [scheme28[3][2], scheme28[3][0]];
    n = Math.max(3, Math.floor(n));
    return n > 11 ? quantize_default((t) => interpolate(1 - t), n) : scheme28[n].slice().reverse();
  };
}
function schemei(interpolate) {
  return ({ length: n }) => quantize_default(interpolate, Math.max(2, Math.floor(n)));
}
function schemeicyclical(interpolate) {
  return ({ length: n }) => quantize_default(interpolate, Math.floor(n) + 1).slice(0, -1);
}
function ordinalScheme(scheme28) {
  const s2 = `${scheme28}`.toLowerCase();
  if (!ordinalSchemes.has(s2))
    throw new Error(`unknown ordinal scheme: ${s2}`);
  return ordinalSchemes.get(s2);
}
function ordinalRange(scheme28, length4) {
  const s2 = ordinalScheme(scheme28);
  const r = typeof s2 === "function" ? s2({ length: length4 }) : s2;
  return r.length !== length4 ? r.slice(0, length4) : r;
}
function maybeBooleanRange(domain, scheme28 = "greys") {
  const range3 = /* @__PURE__ */ new Set();
  const [f2, t] = ordinalRange(scheme28, 2);
  for (const value of domain) {
    if (value == null)
      continue;
    if (value === true)
      range3.add(t);
    else if (value === false)
      range3.add(f2);
    else
      return;
  }
  return [...range3];
}
var quantitativeSchemes = /* @__PURE__ */ new Map([
  // diverging
  ["brbg", BrBG_default],
  ["prgn", PRGn_default],
  ["piyg", PiYG_default],
  ["puor", PuOr_default],
  ["rdbu", RdBu_default],
  ["rdgy", RdGy_default],
  ["rdylbu", RdYlBu_default],
  ["rdylgn", RdYlGn_default],
  ["spectral", Spectral_default],
  // reversed diverging (for temperature data)
  ["burd", (t) => RdBu_default(1 - t)],
  ["buylrd", (t) => RdYlBu_default(1 - t)],
  // sequential (single-hue)
  ["blues", Blues_default],
  ["greens", Greens_default],
  ["greys", Greys_default],
  ["purples", Purples_default],
  ["reds", Reds_default],
  ["oranges", Oranges_default],
  // sequential (multi-hue)
  ["turbo", turbo_default],
  ["viridis", viridis_default],
  ["magma", magma],
  ["inferno", inferno],
  ["plasma", plasma],
  ["cividis", cividis_default],
  ["cubehelix", cubehelix_default2],
  ["warm", warm],
  ["cool", cool],
  ["bugn", BuGn_default],
  ["bupu", BuPu_default],
  ["gnbu", GnBu_default],
  ["orrd", OrRd_default],
  ["pubugn", PuBuGn_default],
  ["pubu", PuBu_default],
  ["purd", PuRd_default],
  ["rdpu", RdPu_default],
  ["ylgnbu", YlGnBu_default],
  ["ylgn", YlGn_default],
  ["ylorbr", YlOrBr_default],
  ["ylorrd", YlOrRd_default],
  // cyclical
  ["rainbow", rainbow_default],
  ["sinebow", sinebow_default]
]);
function quantitativeScheme(scheme28) {
  const s2 = `${scheme28}`.toLowerCase();
  if (!quantitativeSchemes.has(s2))
    throw new Error(`unknown quantitative scheme: ${s2}`);
  return quantitativeSchemes.get(s2);
}
var divergingSchemes = /* @__PURE__ */ new Set([
  "brbg",
  "prgn",
  "piyg",
  "puor",
  "rdbu",
  "rdgy",
  "rdylbu",
  "rdylgn",
  "spectral",
  "burd",
  "buylrd"
]);
function isDivergingScheme(scheme28) {
  return scheme28 != null && divergingSchemes.has(`${scheme28}`.toLowerCase());
}

// ../../node_modules/@observablehq/plot/src/scales/quantitative.js
var flip = (i) => (t) => i(1 - t);
var unit2 = [0, 1];
var interpolators = /* @__PURE__ */ new Map([
  // numbers
  ["number", number_default],
  // color spaces
  ["rgb", rgb_default],
  ["hsl", hsl_default],
  ["hcl", hcl_default],
  ["lab", lab2]
]);
function maybeInterpolator(interpolate) {
  const i = `${interpolate}`.toLowerCase();
  if (!interpolators.has(i))
    throw new Error(`unknown interpolator: ${i}`);
  return interpolators.get(i);
}
function createScaleQ(key, scale3, channels, {
  type: type2,
  nice: nice3,
  clamp,
  zero: zero3,
  domain = inferAutoDomain(key, channels),
  unknown,
  round: round2,
  scheme: scheme28,
  interval: interval2,
  range: range3 = registry.get(key) === radius ? inferRadialRange(channels, domain) : registry.get(key) === length3 ? inferLengthRange(channels, domain) : registry.get(key) === opacity ? unit2 : void 0,
  interpolate = registry.get(key) === color2 ? scheme28 == null && range3 !== void 0 ? rgb_default : quantitativeScheme(scheme28 !== void 0 ? scheme28 : type2 === "cyclical" ? "rainbow" : "turbo") : round2 ? round_default : number_default,
  reverse: reverse3
}) {
  interval2 = maybeRangeInterval(interval2, type2);
  if (type2 === "cyclical" || type2 === "sequential")
    type2 = "linear";
  if (typeof interpolate !== "function")
    interpolate = maybeInterpolator(interpolate);
  reverse3 = !!reverse3;
  if (range3 !== void 0) {
    const n = (domain = arrayify2(domain)).length;
    const m2 = (range3 = arrayify2(range3)).length;
    if (n !== m2) {
      if (interpolate.length === 1)
        throw new Error("invalid piecewise interpolator");
      interpolate = piecewise(interpolate, range3);
      range3 = void 0;
    }
  }
  if (interpolate.length === 1) {
    if (reverse3) {
      interpolate = flip(interpolate);
      reverse3 = false;
    }
    if (range3 === void 0) {
      range3 = Float64Array.from(domain, (_2, i) => i / (domain.length - 1));
      if (range3.length === 2)
        range3 = unit2;
    }
    scale3.interpolate((range3 === unit2 ? constant : interpolatePiecewise)(interpolate));
  } else {
    scale3.interpolate(interpolate);
  }
  if (zero3) {
    const [min5, max4] = extent(domain);
    if (min5 > 0 || max4 < 0) {
      domain = slice3(domain);
      if (orderof(domain) !== Math.sign(min5))
        domain[domain.length - 1] = 0;
      else
        domain[0] = 0;
    }
  }
  if (reverse3)
    domain = reverse(domain);
  scale3.domain(domain).unknown(unknown);
  if (nice3)
    scale3.nice(maybeNice(nice3, type2)), domain = scale3.domain();
  if (range3 !== void 0)
    scale3.range(range3);
  if (clamp)
    scale3.clamp(clamp);
  return { type: type2, domain, range: range3, scale: scale3, interpolate, interval: interval2 };
}
function maybeNice(nice3, type2) {
  return nice3 === true ? void 0 : typeof nice3 === "number" ? nice3 : maybeNiceInterval(nice3, type2);
}
function createScaleLinear(key, channels, options) {
  return createScaleQ(key, linear2(), channels, options);
}
function createScaleSqrt(key, channels, options) {
  return createScalePow(key, channels, { ...options, exponent: 0.5 });
}
function createScalePow(key, channels, { exponent = 1, ...options }) {
  return createScaleQ(key, pow3().exponent(exponent), channels, { ...options, type: "pow" });
}
function createScaleLog(key, channels, { base = 10, domain = inferLogDomain(channels), ...options }) {
  return createScaleQ(key, log2().base(base), channels, { ...options, domain });
}
function createScaleSymlog(key, channels, { constant: constant2 = 1, ...options }) {
  return createScaleQ(key, symlog().constant(constant2), channels, options);
}
function createScaleQuantile(key, channels, {
  range: range3,
  quantiles = range3 === void 0 ? 5 : (range3 = [...range3]).length,
  // deprecated; use n instead
  n = quantiles,
  scheme: scheme28 = "rdylbu",
  domain = inferQuantileDomain(channels),
  unknown,
  interpolate,
  reverse: reverse3
}) {
  if (range3 === void 0) {
    range3 = interpolate !== void 0 ? quantize_default(interpolate, n) : registry.get(key) === color2 ? ordinalRange(scheme28, n) : void 0;
  }
  if (domain.length > 0) {
    domain = quantile3(domain, range3 === void 0 ? { length: n } : range3).quantiles();
  }
  return createScaleThreshold(key, channels, { domain, range: range3, reverse: reverse3, unknown });
}
function createScaleQuantize(key, channels, {
  range: range3,
  n = range3 === void 0 ? 5 : (range3 = [...range3]).length,
  scheme: scheme28 = "rdylbu",
  domain = inferAutoDomain(key, channels),
  unknown,
  interpolate,
  reverse: reverse3
}) {
  const [min5, max4] = extent(domain);
  let thresholds;
  if (range3 === void 0) {
    thresholds = ticks(min5, max4, n);
    if (thresholds[0] <= min5)
      thresholds.splice(0, 1);
    if (thresholds[thresholds.length - 1] >= max4)
      thresholds.pop();
    n = thresholds.length + 1;
    range3 = interpolate !== void 0 ? quantize_default(interpolate, n) : registry.get(key) === color2 ? ordinalRange(scheme28, n) : void 0;
  } else {
    thresholds = quantize_default(number_default(min5, max4), n + 1).slice(1, -1);
    if (min5 instanceof Date)
      thresholds = thresholds.map((x4) => new Date(x4));
  }
  if (orderof(arrayify2(domain)) < 0)
    thresholds.reverse();
  return createScaleThreshold(key, channels, { domain: thresholds, range: range3, reverse: reverse3, unknown });
}
function createScaleThreshold(key, channels, {
  domain = [0],
  // explicit thresholds in ascending order
  unknown,
  scheme: scheme28 = "rdylbu",
  interpolate,
  range: range3 = interpolate !== void 0 ? quantize_default(interpolate, domain.length + 1) : registry.get(key) === color2 ? ordinalRange(scheme28, domain.length + 1) : void 0,
  reverse: reverse3
}) {
  domain = arrayify2(domain);
  const sign3 = orderof(domain);
  if (!isNaN(sign3) && !isOrdered(domain, sign3))
    throw new Error(`the ${key} scale has a non-monotonic domain`);
  if (reverse3)
    range3 = reverse(range3);
  return {
    type: "threshold",
    scale: threshold(sign3 < 0 ? reverse(domain) : domain, range3 === void 0 ? [] : range3).unknown(unknown),
    domain,
    range: range3
  };
}
function isOrdered(domain, sign3) {
  for (let i = 1, n = domain.length, d = domain[0]; i < n; ++i) {
    const s2 = descending(d, d = domain[i]);
    if (s2 !== 0 && s2 !== sign3)
      return false;
  }
  return true;
}
function createScaleIdentity(key) {
  return { type: "identity", scale: hasNumericRange(registry.get(key)) ? identity5() : (d) => d };
}
function inferDomain(channels, f2 = finite2) {
  return channels.length ? [
    min2(channels, ({ value }) => value === void 0 ? value : min2(value, f2)),
    max2(channels, ({ value }) => value === void 0 ? value : max2(value, f2))
  ] : [0, 1];
}
function inferAutoDomain(key, channels) {
  const type2 = registry.get(key);
  return (type2 === radius || type2 === opacity || type2 === length3 ? inferZeroDomain : inferDomain)(channels);
}
function inferZeroDomain(channels) {
  return [0, channels.length ? max2(channels, ({ value }) => value === void 0 ? value : max2(value, finite2)) : 1];
}
function inferRadialRange(channels, domain) {
  const hint = channels.find(({ radius: radius2 }) => radius2 !== void 0);
  if (hint !== void 0)
    return [0, hint.radius];
  const h25 = quantile2(channels, 0.5, ({ value }) => value === void 0 ? NaN : quantile2(value, 0.25, positive));
  const range3 = domain.map((d) => 3 * Math.sqrt(d / h25));
  const k3 = 30 / max2(range3);
  return k3 < 1 ? range3.map((r) => r * k3) : range3;
}
function inferLengthRange(channels, domain) {
  const h50 = median2(channels, ({ value }) => value === void 0 ? NaN : median2(value, Math.abs));
  const range3 = domain.map((d) => 12 * d / h50);
  const k3 = 60 / max2(range3);
  return k3 < 1 ? range3.map((r) => r * k3) : range3;
}
function inferLogDomain(channels) {
  for (const { value } of channels) {
    if (value !== void 0) {
      for (let v3 of value) {
        if (v3 > 0)
          return inferDomain(channels, positive);
        if (v3 < 0)
          return inferDomain(channels, negative);
      }
    }
  }
  return [1, 10];
}
function inferQuantileDomain(channels) {
  const domain = [];
  for (const { value } of channels) {
    if (value === void 0)
      continue;
    for (const v3 of value)
      domain.push(v3);
  }
  return domain;
}
function interpolatePiecewise(interpolate) {
  return (i, j2) => (t) => interpolate(i + t * (j2 - i));
}

// ../../node_modules/@observablehq/plot/src/scales/diverging.js
function createScaleD(key, scale3, transform3, channels, {
  type: type2,
  nice: nice3,
  clamp,
  domain = inferDomain(channels),
  unknown,
  pivot = 0,
  scheme: scheme28,
  range: range3,
  symmetric = true,
  interpolate = registry.get(key) === color2 ? scheme28 == null && range3 !== void 0 ? rgb_default : quantitativeScheme(scheme28 !== void 0 ? scheme28 : "rdbu") : number_default,
  reverse: reverse3
}) {
  pivot = +pivot;
  domain = arrayify2(domain);
  let [min5, max4] = domain;
  if (domain.length > 2)
    warn(`Warning: the diverging ${key} scale domain contains extra elements.`);
  if (descending(min5, max4) < 0)
    [min5, max4] = [max4, min5], reverse3 = !reverse3;
  min5 = Math.min(min5, pivot);
  max4 = Math.max(max4, pivot);
  if (typeof interpolate !== "function") {
    interpolate = maybeInterpolator(interpolate);
  }
  if (range3 !== void 0) {
    interpolate = interpolate.length === 1 ? interpolatePiecewise(interpolate)(...range3) : piecewise(interpolate, range3);
  }
  if (reverse3)
    interpolate = flip(interpolate);
  if (symmetric) {
    const mid2 = transform3.apply(pivot);
    const mindelta = mid2 - transform3.apply(min5);
    const maxdelta = transform3.apply(max4) - mid2;
    if (mindelta < maxdelta)
      min5 = transform3.invert(mid2 - maxdelta);
    else if (mindelta > maxdelta)
      max4 = transform3.invert(mid2 + mindelta);
  }
  scale3.domain([min5, pivot, max4]).unknown(unknown).interpolator(interpolate);
  if (clamp)
    scale3.clamp(clamp);
  if (nice3)
    scale3.nice(nice3);
  return { type: type2, domain: [min5, max4], pivot, interpolate, scale: scale3 };
}
function createScaleDiverging(key, channels, options) {
  return createScaleD(key, diverging(), transformIdentity, channels, options);
}
function createScaleDivergingSqrt(key, channels, options) {
  return createScaleDivergingPow(key, channels, { ...options, exponent: 0.5 });
}
function createScaleDivergingPow(key, channels, { exponent = 1, ...options }) {
  return createScaleD(key, divergingPow().exponent(exponent = +exponent), transformPow2(exponent), channels, {
    ...options,
    type: "diverging-pow"
  });
}
function createScaleDivergingLog(key, channels, { base = 10, pivot = 1, domain = inferDomain(channels, pivot < 0 ? negative : positive), ...options }) {
  return createScaleD(key, divergingLog().base(base = +base), transformLog2, channels, {
    domain,
    pivot,
    ...options
  });
}
function createScaleDivergingSymlog(key, channels, { constant: constant2 = 1, ...options }) {
  return createScaleD(
    key,
    divergingSymlog().constant(constant2 = +constant2),
    transformSymlog2(constant2),
    channels,
    options
  );
}
var transformIdentity = {
  apply(x4) {
    return x4;
  },
  invert(x4) {
    return x4;
  }
};
var transformLog2 = {
  apply: Math.log,
  invert: Math.exp
};
var transformSqrt2 = {
  apply(x4) {
    return Math.sign(x4) * Math.sqrt(Math.abs(x4));
  },
  invert(x4) {
    return Math.sign(x4) * (x4 * x4);
  }
};
function transformPow2(exponent) {
  return exponent === 0.5 ? transformSqrt2 : {
    apply(x4) {
      return Math.sign(x4) * Math.pow(Math.abs(x4), exponent);
    },
    invert(x4) {
      return Math.sign(x4) * Math.pow(Math.abs(x4), 1 / exponent);
    }
  };
}
function transformSymlog2(constant2) {
  return {
    apply(x4) {
      return Math.sign(x4) * Math.log1p(Math.abs(x4 / constant2));
    },
    invert(x4) {
      return Math.sign(x4) * Math.expm1(Math.abs(x4)) * constant2;
    }
  };
}

// ../../node_modules/@observablehq/plot/src/scales/temporal.js
function createScaleT(key, scale3, channels, options) {
  return createScaleQ(key, scale3, channels, options);
}
function createScaleTime(key, channels, options) {
  return createScaleT(key, time(), channels, options);
}
function createScaleUtc(key, channels, options) {
  return createScaleT(key, utcTime(), channels, options);
}

// ../../node_modules/@observablehq/plot/src/scales/ordinal.js
var ordinalImplicit = Symbol("ordinal");
function createScaleO(key, scale3, channels, { type: type2, interval: interval2, domain, range: range3, reverse: reverse3, hint }) {
  interval2 = maybeRangeInterval(interval2, type2);
  if (domain === void 0)
    domain = inferDomain2(channels, interval2, key);
  if (type2 === "categorical" || type2 === ordinalImplicit)
    type2 = "ordinal";
  if (reverse3)
    domain = reverse(domain);
  domain = scale3.domain(domain).domain();
  if (range3 !== void 0) {
    if (typeof range3 === "function")
      range3 = range3(domain);
    scale3.range(range3);
  }
  return { type: type2, domain, range: range3, scale: scale3, hint, interval: interval2 };
}
function createScaleOrdinal(key, channels, { type: type2, interval: interval2, domain, range: range3, scheme: scheme28, unknown, ...options }) {
  interval2 = maybeRangeInterval(interval2, type2);
  if (domain === void 0)
    domain = inferDomain2(channels, interval2, key);
  let hint;
  if (registry.get(key) === symbol) {
    hint = inferSymbolHint(channels);
    range3 = range3 === void 0 ? inferSymbolRange(hint) : map2(range3, maybeSymbol);
  } else if (registry.get(key) === color2) {
    if (range3 === void 0 && (type2 === "ordinal" || type2 === ordinalImplicit)) {
      range3 = maybeBooleanRange(domain, scheme28);
      if (range3 !== void 0)
        scheme28 = void 0;
    }
    if (scheme28 === void 0 && range3 === void 0) {
      scheme28 = type2 === "ordinal" ? "turbo" : "observable10";
    }
    if (scheme28 !== void 0) {
      if (range3 !== void 0) {
        const interpolate = quantitativeScheme(scheme28);
        const t03 = range3[0], d = range3[1] - range3[0];
        range3 = ({ length: n }) => quantize_default((t) => interpolate(t03 + d * t), n);
      } else {
        range3 = ordinalScheme(scheme28);
      }
    }
  }
  if (unknown === implicit) {
    throw new Error(`implicit unknown on ${key} scale is not supported`);
  }
  return createScaleO(key, ordinal().unknown(unknown), channels, { ...options, type: type2, domain, range: range3, hint });
}
function createScalePoint(key, channels, { align: align2 = 0.5, padding: padding2 = 0.5, ...options }) {
  return maybeRound(point().align(align2).padding(padding2), channels, options, key);
}
function createScaleBand(key, channels, {
  align: align2 = 0.5,
  padding: padding2 = 0.1,
  paddingInner = padding2,
  paddingOuter = key === "fx" || key === "fy" ? 0 : padding2,
  ...options
}) {
  return maybeRound(
    band().align(align2).paddingInner(paddingInner).paddingOuter(paddingOuter),
    channels,
    options,
    key
  );
}
function maybeRound(scale3, channels, options, key) {
  let { round: round2 } = options;
  if (round2 !== void 0)
    scale3.round(round2 = !!round2);
  scale3 = createScaleO(key, scale3, channels, options);
  scale3.round = round2;
  return scale3;
}
function inferDomain2(channels, interval2, key) {
  const values2 = new InternSet();
  for (const { value, domain } of channels) {
    if (domain !== void 0)
      return domain();
    if (value === void 0)
      continue;
    for (const v3 of value)
      values2.add(v3);
  }
  if (interval2 !== void 0) {
    const [min5, max4] = extent(values2).map(interval2.floor, interval2);
    return interval2.range(min5, interval2.offset(max4));
  }
  if (values2.size > 1e4 && registry.get(key) === position) {
    throw new Error(`implicit ordinal domain of ${key} scale has more than 10,000 values`);
  }
  return sort(values2, ascendingDefined2);
}
function inferHint(channels, key) {
  let value;
  for (const { hint } of channels) {
    const candidate = hint?.[key];
    if (candidate === void 0)
      continue;
    if (value === void 0)
      value = candidate;
    else if (value !== candidate)
      return;
  }
  return value;
}
function inferSymbolHint(channels) {
  return {
    fill: inferHint(channels, "fill"),
    stroke: inferHint(channels, "stroke")
  };
}
function inferSymbolRange(hint) {
  return isNoneish(hint.fill) ? symbolsStroke : symbolsFill;
}

// ../../node_modules/@observablehq/plot/src/scales.js
function createScales(channelsByScale, {
  label: globalLabel,
  inset: globalInset = 0,
  insetTop: globalInsetTop = globalInset,
  insetRight: globalInsetRight = globalInset,
  insetBottom: globalInsetBottom = globalInset,
  insetLeft: globalInsetLeft = globalInset,
  round: round2,
  nice: nice3,
  clamp,
  zero: zero3,
  align: align2,
  padding: padding2,
  projection: projection3,
  facet: { label: facetLabel2 = globalLabel } = {},
  ...options
} = {}) {
  const scales2 = {};
  for (const [key, channels] of channelsByScale) {
    const scaleOptions = options[key];
    const scale3 = createScale(key, channels, {
      round: registry.get(key) === position ? round2 : void 0,
      // only for position
      nice: nice3,
      clamp,
      zero: zero3,
      align: align2,
      padding: padding2,
      projection: projection3,
      ...scaleOptions
    });
    if (scale3) {
      let {
        label: label2 = key === "fx" || key === "fy" ? facetLabel2 : globalLabel,
        percent,
        transform: transform3,
        inset: inset2,
        insetTop = inset2 !== void 0 ? inset2 : key === "y" ? globalInsetTop : 0,
        // not fy
        insetRight = inset2 !== void 0 ? inset2 : key === "x" ? globalInsetRight : 0,
        // not fx
        insetBottom = inset2 !== void 0 ? inset2 : key === "y" ? globalInsetBottom : 0,
        // not fy
        insetLeft = inset2 !== void 0 ? inset2 : key === "x" ? globalInsetLeft : 0
        // not fx
      } = scaleOptions || {};
      if (transform3 == null)
        transform3 = void 0;
      else if (typeof transform3 !== "function")
        throw new Error("invalid scale transform; not a function");
      scale3.percent = !!percent;
      scale3.label = label2 === void 0 ? inferScaleLabel(channels, scale3) : label2;
      scale3.transform = transform3;
      if (key === "x" || key === "fx") {
        scale3.insetLeft = +insetLeft;
        scale3.insetRight = +insetRight;
      } else if (key === "y" || key === "fy") {
        scale3.insetTop = +insetTop;
        scale3.insetBottom = +insetBottom;
      }
      scales2[key] = scale3;
    }
  }
  return scales2;
}
function createScaleFunctions(descriptors) {
  const scales2 = {};
  const scaleFunctions = { scales: scales2 };
  for (const [key, descriptor] of Object.entries(descriptors)) {
    const { scale: scale3, type: type2, interval: interval2, label: label2 } = descriptor;
    scales2[key] = exposeScale(descriptor);
    scaleFunctions[key] = scale3;
    scale3.type = type2;
    if (interval2 != null)
      scale3.interval = interval2;
    if (label2 != null)
      scale3.label = label2;
  }
  return scaleFunctions;
}
function autoScaleRange(scales2, dimensions) {
  const { x: x4, y: y4, fx, fy } = scales2;
  const superdimensions = fx || fy ? outerDimensions(dimensions) : dimensions;
  if (fx)
    autoScaleRangeX(fx, superdimensions);
  if (fy)
    autoScaleRangeY(fy, superdimensions);
  const subdimensions = fx || fy ? innerDimensions(scales2, dimensions) : dimensions;
  if (x4)
    autoScaleRangeX(x4, subdimensions);
  if (y4)
    autoScaleRangeY(y4, subdimensions);
}
function inferScaleLabel(channels = [], scale3) {
  let label2;
  for (const { label: l } of channels) {
    if (l === void 0)
      continue;
    if (label2 === void 0)
      label2 = l;
    else if (label2 !== l)
      return;
  }
  if (label2 === void 0)
    return;
  if (!isOrdinalScale(scale3) && scale3.percent)
    label2 = `${label2} (%)`;
  return { inferred: true, toString: () => label2 };
}
function inferScaleOrder(scale3) {
  return Math.sign(orderof(scale3.domain())) * Math.sign(orderof(scale3.range()));
}
function outerDimensions(dimensions) {
  const {
    marginTop: marginTop2,
    marginRight: marginRight2,
    marginBottom: marginBottom2,
    marginLeft: marginLeft2,
    width: width2,
    height: height2,
    facet: {
      marginTop: facetMarginTop2,
      marginRight: facetMarginRight2,
      marginBottom: facetMarginBottom2,
      marginLeft: facetMarginLeft2
    }
  } = dimensions;
  return {
    marginTop: Math.max(marginTop2, facetMarginTop2),
    marginRight: Math.max(marginRight2, facetMarginRight2),
    marginBottom: Math.max(marginBottom2, facetMarginBottom2),
    marginLeft: Math.max(marginLeft2, facetMarginLeft2),
    width: width2,
    height: height2
  };
}
function innerDimensions({ fx, fy }, dimensions) {
  const { marginTop: marginTop2, marginRight: marginRight2, marginBottom: marginBottom2, marginLeft: marginLeft2, width: width2, height: height2 } = outerDimensions(dimensions);
  return {
    marginTop: marginTop2,
    marginRight: marginRight2,
    marginBottom: marginBottom2,
    marginLeft: marginLeft2,
    width: fx ? fx.scale.bandwidth() + marginLeft2 + marginRight2 : width2,
    height: fy ? fy.scale.bandwidth() + marginTop2 + marginBottom2 : height2,
    facet: { width: width2, height: height2 }
  };
}
function autoScaleRangeX(scale3, dimensions) {
  if (scale3.range === void 0) {
    const { insetLeft, insetRight } = scale3;
    const { width: width2, marginLeft: marginLeft2 = 0, marginRight: marginRight2 = 0 } = dimensions;
    const left2 = marginLeft2 + insetLeft;
    const right2 = width2 - marginRight2 - insetRight;
    scale3.range = [left2, Math.max(left2, right2)];
    if (!isOrdinalScale(scale3))
      scale3.range = piecewiseRange(scale3);
    scale3.scale.range(scale3.range);
  }
  autoScaleRound(scale3);
}
function autoScaleRangeY(scale3, dimensions) {
  if (scale3.range === void 0) {
    const { insetTop, insetBottom } = scale3;
    const { height: height2, marginTop: marginTop2 = 0, marginBottom: marginBottom2 = 0 } = dimensions;
    const top2 = marginTop2 + insetTop;
    const bottom2 = height2 - marginBottom2 - insetBottom;
    scale3.range = [Math.max(top2, bottom2), top2];
    if (!isOrdinalScale(scale3))
      scale3.range = piecewiseRange(scale3);
    else
      scale3.range.reverse();
    scale3.scale.range(scale3.range);
  }
  autoScaleRound(scale3);
}
function autoScaleRound(scale3) {
  if (scale3.round === void 0 && isBandScale(scale3) && roundError(scale3) <= 30) {
    scale3.scale.round(true);
  }
}
function roundError({ scale: scale3 }) {
  const n = scale3.domain().length;
  const [start2, stop] = scale3.range();
  const paddingInner = scale3.paddingInner ? scale3.paddingInner() : 1;
  const paddingOuter = scale3.paddingOuter ? scale3.paddingOuter() : scale3.padding();
  const m2 = n - paddingInner;
  const step = Math.abs(stop - start2) / Math.max(1, m2 + paddingOuter * 2);
  return (step - Math.floor(step)) * m2;
}
function piecewiseRange(scale3) {
  const length4 = scale3.scale.domain().length + isThresholdScale(scale3);
  if (!(length4 > 2))
    return scale3.range;
  const [start2, end] = scale3.range;
  return Array.from({ length: length4 }, (_2, i) => start2 + i / (length4 - 1) * (end - start2));
}
function normalizeScale(key, scale3, hint) {
  return createScale(key, hint === void 0 ? void 0 : [{ hint }], { ...scale3 });
}
function createScale(key, channels = [], options = {}) {
  const type2 = inferScaleType(key, channels, options);
  if (options.type === void 0 && options.domain === void 0 && options.range === void 0 && options.interval == null && key !== "fx" && key !== "fy" && isOrdinalScale({ type: type2 })) {
    const values2 = channels.map(({ value }) => value).filter((value) => value !== void 0);
    if (values2.some(isTemporal))
      warn(
        `Warning: some data associated with the ${key} scale are dates. Dates are typically associated with a "utc" or "time" scale rather than a "${formatScaleType(
          type2
        )}" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can specify the interval of the ${key} scale (e.g., d3.utcDay), or you can suppress this warning by setting the type of the ${key} scale to "${formatScaleType(
          type2
        )}".`
      );
    else if (values2.some(isTemporalString))
      warn(
        `Warning: some data associated with the ${key} scale are strings that appear to be dates (e.g., YYYY-MM-DD). If these strings represent dates, you should parse them to Date objects. Dates are typically associated with a "utc" or "time" scale rather than a "${formatScaleType(
          type2
        )}" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can suppress this warning by setting the type of the ${key} scale to "${formatScaleType(
          type2
        )}".`
      );
    else if (values2.some(isNumericString))
      warn(
        `Warning: some data associated with the ${key} scale are strings that appear to be numbers. If these strings represent numbers, you should parse or coerce them to numbers. Numbers are typically associated with a "linear" scale rather than a "${formatScaleType(
          type2
        )}" scale. If you want to treat this data as ordinal, you can specify the interval of the ${key} scale (e.g., 1 for integers), or you can suppress this warning by setting the type of the ${key} scale to "${formatScaleType(
          type2
        )}".`
      );
  }
  options.type = type2;
  switch (type2) {
    case "diverging":
    case "diverging-sqrt":
    case "diverging-pow":
    case "diverging-log":
    case "diverging-symlog":
    case "cyclical":
    case "sequential":
    case "linear":
    case "sqrt":
    case "threshold":
    case "quantile":
    case "pow":
    case "log":
    case "symlog":
      options = coerceType(channels, options, coerceNumbers);
      break;
    case "identity":
      switch (registry.get(key)) {
        case position:
          options = coerceType(channels, options, coerceNumbers);
          break;
        case symbol:
          options = coerceType(channels, options, coerceSymbols);
          break;
      }
      break;
    case "utc":
    case "time":
      options = coerceType(channels, options, coerceDates);
      break;
  }
  switch (type2) {
    case "diverging":
      return createScaleDiverging(key, channels, options);
    case "diverging-sqrt":
      return createScaleDivergingSqrt(key, channels, options);
    case "diverging-pow":
      return createScaleDivergingPow(key, channels, options);
    case "diverging-log":
      return createScaleDivergingLog(key, channels, options);
    case "diverging-symlog":
      return createScaleDivergingSymlog(key, channels, options);
    case "categorical":
    case "ordinal":
    case ordinalImplicit:
      return createScaleOrdinal(key, channels, options);
    case "cyclical":
    case "sequential":
    case "linear":
      return createScaleLinear(key, channels, options);
    case "sqrt":
      return createScaleSqrt(key, channels, options);
    case "threshold":
      return createScaleThreshold(key, channels, options);
    case "quantile":
      return createScaleQuantile(key, channels, options);
    case "quantize":
      return createScaleQuantize(key, channels, options);
    case "pow":
      return createScalePow(key, channels, options);
    case "log":
      return createScaleLog(key, channels, options);
    case "symlog":
      return createScaleSymlog(key, channels, options);
    case "utc":
      return createScaleUtc(key, channels, options);
    case "time":
      return createScaleTime(key, channels, options);
    case "point":
      return createScalePoint(key, channels, options);
    case "band":
      return createScaleBand(key, channels, options);
    case "identity":
      return createScaleIdentity(key);
    case void 0:
      return;
    default:
      throw new Error(`unknown scale type: ${type2}`);
  }
}
function formatScaleType(type2) {
  return typeof type2 === "symbol" ? type2.description : type2;
}
function maybeScaleType(type2) {
  return typeof type2 === "string" ? `${type2}`.toLowerCase() : type2;
}
var typeProjection = { toString: () => "projection" };
function inferScaleType(key, channels, { type: type2, domain, range: range3, scheme: scheme28, pivot, projection: projection3 }) {
  type2 = maybeScaleType(type2);
  if (key === "fx" || key === "fy")
    return "band";
  if ((key === "x" || key === "y") && projection3 != null)
    type2 = typeProjection;
  for (const channel of channels) {
    const t = maybeScaleType(channel.type);
    if (t === void 0)
      continue;
    else if (type2 === void 0)
      type2 = t;
    else if (type2 !== t)
      throw new Error(`scale incompatible with channel: ${type2} !== ${t}`);
  }
  if (type2 === typeProjection)
    return;
  if (type2 !== void 0)
    return type2;
  if (domain === void 0 && !channels.some(({ value }) => value !== void 0))
    return;
  const kind = registry.get(key);
  if (kind === radius)
    return "sqrt";
  if (kind === opacity || kind === length3)
    return "linear";
  if (kind === symbol)
    return "ordinal";
  if ((domain || range3 || []).length > 2)
    return asOrdinalType(kind);
  if (domain !== void 0) {
    if (isOrdinal(domain))
      return asOrdinalType(kind);
    if (isTemporal(domain))
      return "utc";
  } else {
    const values2 = channels.map(({ value }) => value).filter((value) => value !== void 0);
    if (values2.some(isOrdinal))
      return asOrdinalType(kind);
    if (values2.some(isTemporal))
      return "utc";
  }
  if (kind === color2) {
    if (pivot != null || isDivergingScheme(scheme28))
      return "diverging";
    if (isCategoricalScheme(scheme28))
      return "categorical";
  }
  return "linear";
}
function asOrdinalType(kind) {
  switch (kind) {
    case position:
      return "point";
    case color2:
      return ordinalImplicit;
    default:
      return "ordinal";
  }
}
function isOrdinalScale({ type: type2 }) {
  return type2 === "ordinal" || type2 === "point" || type2 === "band" || type2 === ordinalImplicit;
}
function isThresholdScale({ type: type2 }) {
  return type2 === "threshold";
}
function isBandScale({ type: type2 }) {
  return type2 === "point" || type2 === "band";
}
function isCollapsed(scale3) {
  if (scale3 === void 0)
    return true;
  const domain = scale3.domain();
  const value = scale3(domain[0]);
  for (let i = 1, n = domain.length; i < n; ++i) {
    if (scale3(domain[i]) - value) {
      return false;
    }
  }
  return true;
}
function coerceType(channels, { domain, ...options }, coerceValues) {
  for (const c4 of channels) {
    if (c4.value !== void 0) {
      if (domain === void 0)
        domain = c4.value?.domain;
      c4.value = coerceValues(c4.value);
    }
  }
  return {
    domain: domain === void 0 ? domain : coerceValues(domain),
    ...options
  };
}
function coerceSymbols(values2) {
  return map2(values2, maybeSymbol);
}
function scale2(options = {}) {
  let scale3;
  for (const key in options) {
    if (!registry.has(key))
      continue;
    if (!isScaleOptions(options[key]))
      continue;
    if (scale3 !== void 0)
      throw new Error("ambiguous scale definition; multiple scales found");
    scale3 = exposeScale(normalizeScale(key, options[key]));
  }
  if (scale3 === void 0)
    throw new Error("invalid scale definition; no scale found");
  return scale3;
}
function exposeScales(scales2) {
  return (key) => {
    if (!registry.has(key = `${key}`))
      throw new Error(`unknown scale: ${key}`);
    return scales2[key];
  };
}
function exposeScale({ scale: scale3, type: type2, domain, range: range3, interpolate, interval: interval2, transform: transform3, percent, pivot }) {
  if (type2 === "identity")
    return { type: "identity", apply: (d) => d, invert: (d) => d };
  const unknown = scale3.unknown ? scale3.unknown() : void 0;
  return {
    type: type2,
    domain: slice3(domain),
    // defensive copy
    ...range3 !== void 0 && { range: slice3(range3) },
    // defensive copy
    ...transform3 !== void 0 && { transform: transform3 },
    ...percent && { percent },
    // only exposed if truthy
    ...unknown !== void 0 && { unknown },
    ...interval2 !== void 0 && { interval: interval2 },
    // quantitative
    ...interpolate !== void 0 && { interpolate },
    ...scale3.clamp && { clamp: scale3.clamp() },
    // diverging (always asymmetric; we never want to apply the symmetric transform twice)
    ...pivot !== void 0 && { pivot, symmetric: false },
    // log, diverging-log
    ...scale3.base && { base: scale3.base() },
    // pow, diverging-pow
    ...scale3.exponent && { exponent: scale3.exponent() },
    // symlog, diverging-symlog
    ...scale3.constant && { constant: scale3.constant() },
    // band, point
    ...scale3.align && { align: scale3.align(), round: scale3.round() },
    ...scale3.padding && (scale3.paddingInner ? { paddingInner: scale3.paddingInner(), paddingOuter: scale3.paddingOuter() } : { padding: scale3.padding() }),
    ...scale3.bandwidth && { bandwidth: scale3.bandwidth(), step: scale3.step() },
    // utilities
    apply: (t) => scale3(t),
    ...scale3.invert && { invert: (t) => scale3.invert(t) }
  };
}

// ../../node_modules/@observablehq/plot/src/memoize.js
function memoize1(compute) {
  let cacheValue, cacheKeys;
  return (...keys) => {
    if (cacheKeys?.length !== keys.length || cacheKeys.some((k3, i) => k3 !== keys[i])) {
      cacheKeys = keys;
      cacheValue = compute(...keys);
    }
    return cacheValue;
  };
}

// ../../node_modules/@observablehq/plot/src/format.js
var numberFormat = memoize1((locale3) => {
  return new Intl.NumberFormat(locale3);
});
var monthFormat = memoize1((locale3, month) => {
  return new Intl.DateTimeFormat(locale3, { timeZone: "UTC", ...month && { month } });
});
var weekdayFormat = memoize1((locale3, weekday) => {
  return new Intl.DateTimeFormat(locale3, { timeZone: "UTC", ...weekday && { weekday } });
});
function formatNumber(locale3 = "en-US") {
  const format3 = numberFormat(locale3);
  return (i) => i != null && !isNaN(i) ? format3.format(i) : void 0;
}
function formatMonth(locale3 = "en-US", format3 = "short") {
  const fmt = monthFormat(locale3, format3);
  return (i) => i != null && !isNaN(i = +new Date(Date.UTC(2e3, +i))) ? fmt.format(i) : void 0;
}
function formatWeekday(locale3 = "en-US", format3 = "short") {
  const fmt = weekdayFormat(locale3, format3);
  return (i) => i != null && !isNaN(i = +new Date(Date.UTC(2001, 0, +i))) ? fmt.format(i) : void 0;
}
function formatIsoDate(date2) {
  return format2(date2, "Invalid Date");
}
function formatAuto(locale3 = "en-US") {
  const number7 = formatNumber(locale3);
  return (v3) => (v3 instanceof Date ? formatIsoDate : typeof v3 === "number" ? number7 : string)(v3);
}
var formatDefault = formatAuto();

// ../../node_modules/@observablehq/plot/src/style.js
var offset = (typeof window !== "undefined" ? window.devicePixelRatio > 1 : typeof it === "undefined") ? 0 : 0.5;
var nextClipId = 0;
function getClipId() {
  return `plot-clip-${++nextClipId}`;
}
function styles(mark2, {
  title,
  href,
  ariaLabel: variaLabel,
  ariaDescription,
  ariaHidden,
  target,
  fill,
  fillOpacity,
  stroke,
  strokeWidth,
  strokeOpacity,
  strokeLinejoin,
  strokeLinecap,
  strokeMiterlimit,
  strokeDasharray,
  strokeDashoffset,
  opacity: opacity2,
  mixBlendMode,
  imageFilter,
  paintOrder,
  pointerEvents,
  shapeRendering,
  channels
}, {
  ariaLabel: cariaLabel,
  fill: defaultFill = "currentColor",
  fillOpacity: defaultFillOpacity,
  stroke: defaultStroke = "none",
  strokeOpacity: defaultStrokeOpacity,
  strokeWidth: defaultStrokeWidth,
  strokeLinecap: defaultStrokeLinecap,
  strokeLinejoin: defaultStrokeLinejoin,
  strokeMiterlimit: defaultStrokeMiterlimit,
  paintOrder: defaultPaintOrder
}) {
  if (defaultFill === null) {
    fill = null;
    fillOpacity = null;
  }
  if (defaultStroke === null) {
    stroke = null;
    strokeOpacity = null;
  }
  if (isNoneish(defaultFill)) {
    if (!isNoneish(defaultStroke) && (!isNoneish(fill) || channels?.fill))
      defaultStroke = "none";
  } else {
    if (isNoneish(defaultStroke) && (!isNoneish(stroke) || channels?.stroke))
      defaultFill = "none";
  }
  const [vfill, cfill] = maybeColorChannel(fill, defaultFill);
  const [vfillOpacity, cfillOpacity] = maybeNumberChannel(fillOpacity, defaultFillOpacity);
  const [vstroke, cstroke] = maybeColorChannel(stroke, defaultStroke);
  const [vstrokeOpacity, cstrokeOpacity] = maybeNumberChannel(strokeOpacity, defaultStrokeOpacity);
  const [vopacity, copacity] = maybeNumberChannel(opacity2);
  if (!isNone(cstroke)) {
    if (strokeWidth === void 0)
      strokeWidth = defaultStrokeWidth;
    if (strokeLinecap === void 0)
      strokeLinecap = defaultStrokeLinecap;
    if (strokeLinejoin === void 0)
      strokeLinejoin = defaultStrokeLinejoin;
    if (strokeMiterlimit === void 0 && !isRound(strokeLinejoin))
      strokeMiterlimit = defaultStrokeMiterlimit;
    if (!isNone(cfill) && paintOrder === void 0)
      paintOrder = defaultPaintOrder;
  }
  const [vstrokeWidth, cstrokeWidth] = maybeNumberChannel(strokeWidth);
  if (defaultFill !== null) {
    mark2.fill = impliedString(cfill, "currentColor");
    mark2.fillOpacity = impliedNumber(cfillOpacity, 1);
  }
  if (defaultStroke !== null) {
    mark2.stroke = impliedString(cstroke, "none");
    mark2.strokeWidth = impliedNumber(cstrokeWidth, 1);
    mark2.strokeOpacity = impliedNumber(cstrokeOpacity, 1);
    mark2.strokeLinejoin = impliedString(strokeLinejoin, "miter");
    mark2.strokeLinecap = impliedString(strokeLinecap, "butt");
    mark2.strokeMiterlimit = impliedNumber(strokeMiterlimit, 4);
    mark2.strokeDasharray = impliedString(strokeDasharray, "none");
    mark2.strokeDashoffset = impliedString(strokeDashoffset, "0");
  }
  mark2.target = string(target);
  mark2.ariaLabel = string(cariaLabel);
  mark2.ariaDescription = string(ariaDescription);
  mark2.ariaHidden = string(ariaHidden);
  mark2.opacity = impliedNumber(copacity, 1);
  mark2.mixBlendMode = impliedString(mixBlendMode, "normal");
  mark2.imageFilter = impliedString(imageFilter, "none");
  mark2.paintOrder = impliedString(paintOrder, "normal");
  mark2.pointerEvents = impliedString(pointerEvents, "auto");
  mark2.shapeRendering = impliedString(shapeRendering, "auto");
  return {
    title: { value: title, optional: true, filter: null },
    href: { value: href, optional: true, filter: null },
    ariaLabel: { value: variaLabel, optional: true, filter: null },
    fill: { value: vfill, scale: "auto", optional: true },
    fillOpacity: { value: vfillOpacity, scale: "auto", optional: true },
    stroke: { value: vstroke, scale: "auto", optional: true },
    strokeOpacity: { value: vstrokeOpacity, scale: "auto", optional: true },
    strokeWidth: { value: vstrokeWidth, optional: true },
    opacity: { value: vopacity, scale: "auto", optional: true }
  };
}
function applyTitle(selection2, L2) {
  if (L2)
    selection2.filter((i) => nonempty(L2[i])).append("title").call(applyText, L2);
}
function applyTitleGroup(selection2, L2) {
  if (L2)
    selection2.filter(([i]) => nonempty(L2[i])).append("title").call(applyTextGroup, L2);
}
function applyText(selection2, T) {
  if (T)
    selection2.text((i) => formatDefault(T[i]));
}
function applyTextGroup(selection2, T) {
  if (T)
    selection2.text(([i]) => formatDefault(T[i]));
}
function applyChannelStyles(selection2, { target, tip: tip2 }, {
  ariaLabel: AL,
  title: T,
  fill: F2,
  fillOpacity: FO,
  stroke: S2,
  strokeOpacity: SO,
  strokeWidth: SW,
  opacity: O2,
  href: H2
}) {
  if (AL)
    applyAttr(selection2, "aria-label", (i) => AL[i]);
  if (F2)
    applyAttr(selection2, "fill", (i) => F2[i]);
  if (FO)
    applyAttr(selection2, "fill-opacity", (i) => FO[i]);
  if (S2)
    applyAttr(selection2, "stroke", (i) => S2[i]);
  if (SO)
    applyAttr(selection2, "stroke-opacity", (i) => SO[i]);
  if (SW)
    applyAttr(selection2, "stroke-width", (i) => SW[i]);
  if (O2)
    applyAttr(selection2, "opacity", (i) => O2[i]);
  if (H2)
    applyHref(selection2, (i) => H2[i], target);
  if (!tip2)
    applyTitle(selection2, T);
}
function applyGroupedChannelStyles(selection2, { target, tip: tip2 }, {
  ariaLabel: AL,
  title: T,
  fill: F2,
  fillOpacity: FO,
  stroke: S2,
  strokeOpacity: SO,
  strokeWidth: SW,
  opacity: O2,
  href: H2
}) {
  if (AL)
    applyAttr(selection2, "aria-label", ([i]) => AL[i]);
  if (F2)
    applyAttr(selection2, "fill", ([i]) => F2[i]);
  if (FO)
    applyAttr(selection2, "fill-opacity", ([i]) => FO[i]);
  if (S2)
    applyAttr(selection2, "stroke", ([i]) => S2[i]);
  if (SO)
    applyAttr(selection2, "stroke-opacity", ([i]) => SO[i]);
  if (SW)
    applyAttr(selection2, "stroke-width", ([i]) => SW[i]);
  if (O2)
    applyAttr(selection2, "opacity", ([i]) => O2[i]);
  if (H2)
    applyHref(selection2, ([i]) => H2[i], target);
  if (!tip2)
    applyTitleGroup(selection2, T);
}
function groupAesthetics({
  ariaLabel: AL,
  title: T,
  fill: F2,
  fillOpacity: FO,
  stroke: S2,
  strokeOpacity: SO,
  strokeWidth: SW,
  opacity: O2,
  href: H2
}, { tip: tip2 }) {
  return [AL, tip2 ? void 0 : T, F2, FO, S2, SO, SW, O2, H2].filter((c4) => c4 !== void 0);
}
function groupZ2(I2, Z3, z2) {
  const G = group(I2, (i) => Z3[i]);
  if (z2 === void 0 && G.size > 1 + I2.length >> 1) {
    warn(
      `Warning: the implicit z channel has high cardinality. This may occur when the fill or stroke channel is associated with quantitative data rather than ordinal or categorical data. You can suppress this warning by setting the z option explicitly; if this data represents a single series, set z to null.`
    );
  }
  return G.values();
}
function* groupIndex(I2, position3, mark2, channels) {
  const { z: z2 } = mark2;
  const { z: Z3 } = channels;
  const A5 = groupAesthetics(channels, mark2);
  const C3 = [...position3, ...A5];
  for (const G of Z3 ? groupZ2(I2, Z3, z2) : [I2]) {
    let Ag;
    let Gg;
    out:
      for (const i of G) {
        for (const c4 of C3) {
          if (!defined(c4[i])) {
            if (Gg)
              Gg.push(-1);
            continue out;
          }
        }
        if (Ag === void 0) {
          if (Gg)
            yield Gg;
          Ag = A5.map((c4) => keyof2(c4[i])), Gg = [i];
          continue;
        }
        Gg.push(i);
        for (let j2 = 0; j2 < A5.length; ++j2) {
          const k3 = keyof2(A5[j2][i]);
          if (k3 !== Ag[j2]) {
            yield Gg;
            Ag = A5.map((c4) => keyof2(c4[i])), Gg = [i];
            continue out;
          }
        }
      }
    if (Gg)
      yield Gg;
  }
}
function applyClip(selection2, mark2, dimensions, context) {
  let clipUrl;
  const { clip = context.clip } = mark2;
  switch (clip) {
    case "frame": {
      const { width: width2, height: height2, marginLeft: marginLeft2, marginRight: marginRight2, marginTop: marginTop2, marginBottom: marginBottom2 } = dimensions;
      const id2 = getClipId();
      clipUrl = `url(#${id2})`;
      selection2 = create3("svg:g", context).call(
        (g2) => g2.append("svg:clipPath").attr("id", id2).append("rect").attr("x", marginLeft2).attr("y", marginTop2).attr("width", width2 - marginRight2 - marginLeft2).attr("height", height2 - marginTop2 - marginBottom2)
      ).each(function() {
        this.appendChild(selection2.node());
        selection2.node = () => this;
      });
      break;
    }
    case "sphere": {
      const { projection: projection3 } = context;
      if (!projection3)
        throw new Error(`the "sphere" clip option requires a projection`);
      const id2 = getClipId();
      clipUrl = `url(#${id2})`;
      selection2.append("clipPath").attr("id", id2).append("path").attr("d", path_default(projection3)({ type: "Sphere" }));
      break;
    }
  }
  applyAttr(selection2, "aria-label", mark2.ariaLabel);
  applyAttr(selection2, "aria-description", mark2.ariaDescription);
  applyAttr(selection2, "aria-hidden", mark2.ariaHidden);
  applyAttr(selection2, "clip-path", clipUrl);
}
function applyIndirectStyles(selection2, mark2, dimensions, context) {
  applyClip(selection2, mark2, dimensions, context);
  applyAttr(selection2, "fill", mark2.fill);
  applyAttr(selection2, "fill-opacity", mark2.fillOpacity);
  applyAttr(selection2, "stroke", mark2.stroke);
  applyAttr(selection2, "stroke-width", mark2.strokeWidth);
  applyAttr(selection2, "stroke-opacity", mark2.strokeOpacity);
  applyAttr(selection2, "stroke-linejoin", mark2.strokeLinejoin);
  applyAttr(selection2, "stroke-linecap", mark2.strokeLinecap);
  applyAttr(selection2, "stroke-miterlimit", mark2.strokeMiterlimit);
  applyAttr(selection2, "stroke-dasharray", mark2.strokeDasharray);
  applyAttr(selection2, "stroke-dashoffset", mark2.strokeDashoffset);
  applyAttr(selection2, "shape-rendering", mark2.shapeRendering);
  applyAttr(selection2, "filter", mark2.imageFilter);
  applyAttr(selection2, "paint-order", mark2.paintOrder);
  const { pointerEvents = context.pointerSticky === false ? "none" : void 0 } = mark2;
  applyAttr(selection2, "pointer-events", pointerEvents);
}
function applyDirectStyles(selection2, mark2) {
  applyStyle(selection2, "mix-blend-mode", mark2.mixBlendMode);
  applyAttr(selection2, "opacity", mark2.opacity);
}
function applyHref(selection2, href, target) {
  selection2.each(function(i) {
    const h2 = href(i);
    if (h2 != null) {
      const a3 = this.ownerDocument.createElementNS(namespaces_default.svg, "a");
      a3.setAttribute("fill", "inherit");
      a3.setAttributeNS(namespaces_default.xlink, "href", h2);
      if (target != null)
        a3.setAttribute("target", target);
      this.parentNode.insertBefore(a3, this).appendChild(this);
    }
  });
}
function applyAttr(selection2, name2, value) {
  if (value != null)
    selection2.attr(name2, value);
}
function applyStyle(selection2, name2, value) {
  if (value != null)
    selection2.style(name2, value);
}
function applyTransform(selection2, mark2, { x: x4, y: y4 }, tx = offset, ty = offset) {
  tx += mark2.dx;
  ty += mark2.dy;
  if (x4?.bandwidth)
    tx += x4.bandwidth() / 2;
  if (y4?.bandwidth)
    ty += y4.bandwidth() / 2;
  if (tx || ty)
    selection2.attr("transform", `translate(${tx},${ty})`);
}
function impliedString(value, impliedValue) {
  if ((value = string(value)) !== impliedValue)
    return value;
}
function impliedNumber(value, impliedValue) {
  if ((value = number5(value)) !== impliedValue)
    return value;
}
var validClassName = /^-?([_a-z]|[\240-\377]|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])([_a-z0-9-]|[\240-\377]|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])*$/i;
function maybeClassName(name2) {
  if (name2 === void 0)
    return "plot-d6a7b5";
  name2 = `${name2}`;
  if (!validClassName.test(name2))
    throw new Error(`invalid class name: ${name2}`);
  return name2;
}
function applyInlineStyles(selection2, style2) {
  if (typeof style2 === "string") {
    selection2.property("style", style2);
  } else if (style2 != null) {
    for (const element of selection2) {
      Object.assign(element.style, style2);
    }
  }
}
function applyFrameAnchor({ frameAnchor }, { width: width2, height: height2, marginTop: marginTop2, marginRight: marginRight2, marginBottom: marginBottom2, marginLeft: marginLeft2 }) {
  return [
    /left$/.test(frameAnchor) ? marginLeft2 : /right$/.test(frameAnchor) ? width2 - marginRight2 : (marginLeft2 + width2 - marginRight2) / 2,
    /^top/.test(frameAnchor) ? marginTop2 : /^bottom/.test(frameAnchor) ? height2 - marginBottom2 : (marginTop2 + height2 - marginBottom2) / 2
  ];
}

// ../../node_modules/@observablehq/plot/src/dimensions.js
function createDimensions(scales2, marks2, options = {}) {
  let marginTopDefault = 0.5 - offset, marginRightDefault = 0.5 + offset, marginBottomDefault = 0.5 + offset, marginLeftDefault = 0.5 - offset;
  for (const { marginTop: marginTop3, marginRight: marginRight3, marginBottom: marginBottom3, marginLeft: marginLeft3 } of marks2) {
    if (marginTop3 > marginTopDefault)
      marginTopDefault = marginTop3;
    if (marginRight3 > marginRightDefault)
      marginRightDefault = marginRight3;
    if (marginBottom3 > marginBottomDefault)
      marginBottomDefault = marginBottom3;
    if (marginLeft3 > marginLeftDefault)
      marginLeftDefault = marginLeft3;
  }
  let {
    margin: margin2,
    marginTop: marginTop2 = margin2 !== void 0 ? margin2 : marginTopDefault,
    marginRight: marginRight2 = margin2 !== void 0 ? margin2 : marginRightDefault,
    marginBottom: marginBottom2 = margin2 !== void 0 ? margin2 : marginBottomDefault,
    marginLeft: marginLeft2 = margin2 !== void 0 ? margin2 : marginLeftDefault
  } = options;
  marginTop2 = +marginTop2;
  marginRight2 = +marginRight2;
  marginBottom2 = +marginBottom2;
  marginLeft2 = +marginLeft2;
  let {
    width: width2 = 640,
    height: height2 = autoHeight(scales2, options, {
      width: width2,
      marginTopDefault,
      marginRightDefault,
      marginBottomDefault,
      marginLeftDefault
    }) + Math.max(0, marginTop2 - marginTopDefault + marginBottom2 - marginBottomDefault)
  } = options;
  width2 = +width2;
  height2 = +height2;
  const dimensions = {
    width: width2,
    height: height2,
    marginTop: marginTop2,
    marginRight: marginRight2,
    marginBottom: marginBottom2,
    marginLeft: marginLeft2
  };
  if (scales2.fx || scales2.fy) {
    let {
      margin: facetMargin2,
      marginTop: facetMarginTop2 = facetMargin2 !== void 0 ? facetMargin2 : marginTop2,
      marginRight: facetMarginRight2 = facetMargin2 !== void 0 ? facetMargin2 : marginRight2,
      marginBottom: facetMarginBottom2 = facetMargin2 !== void 0 ? facetMargin2 : marginBottom2,
      marginLeft: facetMarginLeft2 = facetMargin2 !== void 0 ? facetMargin2 : marginLeft2
    } = options.facet ?? {};
    facetMarginTop2 = +facetMarginTop2;
    facetMarginRight2 = +facetMarginRight2;
    facetMarginBottom2 = +facetMarginBottom2;
    facetMarginLeft2 = +facetMarginLeft2;
    dimensions.facet = {
      marginTop: facetMarginTop2,
      marginRight: facetMarginRight2,
      marginBottom: facetMarginBottom2,
      marginLeft: facetMarginLeft2
    };
  }
  return dimensions;
}
function autoHeight({ x: x4, y: y4, fy, fx }, { projection: projection3, aspectRatio: aspectRatio2 }, { width: width2, marginTopDefault, marginRightDefault, marginBottomDefault, marginLeftDefault }) {
  const nfy = fy ? fy.scale.domain().length : 1;
  const ar = projectionAspectRatio(projection3);
  if (ar) {
    const nfx = fx ? fx.scale.domain().length : 1;
    const far = (1.1 * nfy - 0.1) / (1.1 * nfx - 0.1) * ar;
    const lar = Math.max(0.1, Math.min(10, far));
    return Math.round((width2 - marginLeftDefault - marginRightDefault) * lar + marginTopDefault + marginBottomDefault);
  }
  const ny = y4 ? isOrdinalScale(y4) ? y4.scale.domain().length : Math.max(7, 17 / nfy) : 1;
  if (aspectRatio2 != null) {
    aspectRatio2 = +aspectRatio2;
    if (!(isFinite(aspectRatio2) && aspectRatio2 > 0))
      throw new Error(`invalid aspectRatio: ${aspectRatio2}`);
    const ratio = aspectRatioLength("y", y4) / (aspectRatioLength("x", x4) * aspectRatio2);
    const fxb = fx ? fx.scale.bandwidth() : 1;
    const fyb = fy ? fy.scale.bandwidth() : 1;
    const w = fxb * (width2 - marginLeftDefault - marginRightDefault) - x4.insetLeft - x4.insetRight;
    return (ratio * w + y4.insetTop + y4.insetBottom) / fyb + marginTopDefault + marginBottomDefault;
  }
  return !!(y4 || fy) * Math.max(1, Math.min(60, ny * nfy)) * 20 + !!fx * 30 + 60;
}
function aspectRatioLength(k3, scale3) {
  if (!scale3)
    throw new Error(`aspectRatio requires ${k3} scale`);
  const { type: type2, domain } = scale3;
  let transform3;
  switch (type2) {
    case "linear":
    case "utc":
    case "time":
      transform3 = Number;
      break;
    case "pow": {
      const exponent = scale3.scale.exponent();
      transform3 = (x4) => Math.pow(x4, exponent);
      break;
    }
    case "log":
      transform3 = Math.log;
      break;
    case "point":
    case "band":
      return domain.length;
    default:
      throw new Error(`unsupported ${k3} scale for aspectRatio: ${type2}`);
  }
  const [min5, max4] = extent(domain);
  return Math.abs(transform3(max4) - transform3(min5));
}

// ../../node_modules/@observablehq/plot/src/facet.js
function createFacets(channelsByScale, options) {
  const { fx, fy } = createScales(channelsByScale, options);
  const fxDomain2 = fx?.scale.domain();
  const fyDomain2 = fy?.scale.domain();
  return fxDomain2 && fyDomain2 ? cross(fxDomain2, fyDomain2).map(([x4, y4], i) => ({ x: x4, y: y4, i })) : fxDomain2 ? fxDomain2.map((x4, i) => ({ x: x4, i })) : fyDomain2 ? fyDomain2.map((y4, i) => ({ y: y4, i })) : void 0;
}
function recreateFacets(facets, { x: X3, y: Y3 }) {
  X3 &&= facetIndex(X3);
  Y3 &&= facetIndex(Y3);
  return facets.filter(
    X3 && Y3 ? (f2) => X3.has(f2.x) && Y3.has(f2.y) : X3 ? (f2) => X3.has(f2.x) : (f2) => Y3.has(f2.y)
  ).sort(
    X3 && Y3 ? (a3, b2) => X3.get(a3.x) - X3.get(b2.x) || Y3.get(a3.y) - Y3.get(b2.y) : X3 ? (a3, b2) => X3.get(a3.x) - X3.get(b2.x) : (a3, b2) => Y3.get(a3.y) - Y3.get(b2.y)
  );
}
function facetGroups(data, { fx, fy }) {
  const I2 = range2(data);
  const FX = fx?.value;
  const FY = fy?.value;
  return fx && fy ? rollup(
    I2,
    (G) => (G.fx = FX[G[0]], G.fy = FY[G[0]], G),
    (i) => FX[i],
    (i) => FY[i]
  ) : fx ? rollup(
    I2,
    (G) => (G.fx = FX[G[0]], G),
    (i) => FX[i]
  ) : rollup(
    I2,
    (G) => (G.fy = FY[G[0]], G),
    (i) => FY[i]
  );
}
function facetTranslator(fx, fy, { marginTop: marginTop2, marginLeft: marginLeft2 }) {
  return fx && fy ? ({ x: x4, y: y4 }) => `translate(${fx(x4) - marginLeft2},${fy(y4) - marginTop2})` : fx ? ({ x: x4 }) => `translate(${fx(x4) - marginLeft2},0)` : ({ y: y4 }) => `translate(0,${fy(y4) - marginTop2})`;
}
function facetExclude(index2) {
  const ex = [];
  const e = new Uint32Array(sum3(index2, (d) => d.length));
  for (const i of index2) {
    let n = 0;
    for (const j2 of index2) {
      if (i === j2)
        continue;
      e.set(j2, n);
      n += j2.length;
    }
    ex.push(e.slice(0, n));
  }
  return ex;
}
var facetAnchors = /* @__PURE__ */ new Map([
  ["top", facetAnchorTop],
  ["right", facetAnchorRight],
  ["bottom", facetAnchorBottom],
  ["left", facetAnchorLeft],
  ["top-left", and2(facetAnchorTop, facetAnchorLeft)],
  ["top-right", and2(facetAnchorTop, facetAnchorRight)],
  ["bottom-left", and2(facetAnchorBottom, facetAnchorLeft)],
  ["bottom-right", and2(facetAnchorBottom, facetAnchorRight)],
  ["top-empty", facetAnchorTopEmpty],
  ["right-empty", facetAnchorRightEmpty],
  ["bottom-empty", facetAnchorBottomEmpty],
  ["left-empty", facetAnchorLeftEmpty],
  ["empty", facetAnchorEmpty]
]);
function maybeFacetAnchor(facetAnchor) {
  if (facetAnchor == null)
    return null;
  const anchor = facetAnchors.get(`${facetAnchor}`.toLowerCase());
  if (anchor)
    return anchor;
  throw new Error(`invalid facet anchor: ${facetAnchor}`);
}
var indexCache = /* @__PURE__ */ new WeakMap();
function facetIndex(V2) {
  let I2 = indexCache.get(V2);
  if (!I2)
    indexCache.set(V2, I2 = new InternMap(map2(V2, (v3, i) => [v3, i])));
  return I2;
}
function facetIndexOf(V2, v3) {
  return facetIndex(V2).get(v3);
}
function facetFind(facets, x4, y4) {
  x4 = keyof2(x4);
  y4 = keyof2(y4);
  return facets.find((f2) => Object.is(keyof2(f2.x), x4) && Object.is(keyof2(f2.y), y4));
}
function facetEmpty(facets, x4, y4) {
  return facetFind(facets, x4, y4)?.empty;
}
function facetAnchorTop(facets, { y: Y3 }, { y: y4 }) {
  return Y3 ? facetIndexOf(Y3, y4) === 0 : true;
}
function facetAnchorBottom(facets, { y: Y3 }, { y: y4 }) {
  return Y3 ? facetIndexOf(Y3, y4) === Y3.length - 1 : true;
}
function facetAnchorLeft(facets, { x: X3 }, { x: x4 }) {
  return X3 ? facetIndexOf(X3, x4) === 0 : true;
}
function facetAnchorRight(facets, { x: X3 }, { x: x4 }) {
  return X3 ? facetIndexOf(X3, x4) === X3.length - 1 : true;
}
function facetAnchorTopEmpty(facets, { y: Y3 }, { x: x4, y: y4, empty: empty4 }) {
  if (empty4)
    return false;
  if (!Y3)
    return;
  const i = facetIndexOf(Y3, y4);
  if (i > 0)
    return facetEmpty(facets, x4, Y3[i - 1]);
}
function facetAnchorBottomEmpty(facets, { y: Y3 }, { x: x4, y: y4, empty: empty4 }) {
  if (empty4)
    return false;
  if (!Y3)
    return;
  const i = facetIndexOf(Y3, y4);
  if (i < Y3.length - 1)
    return facetEmpty(facets, x4, Y3[i + 1]);
}
function facetAnchorLeftEmpty(facets, { x: X3 }, { x: x4, y: y4, empty: empty4 }) {
  if (empty4)
    return false;
  if (!X3)
    return;
  const i = facetIndexOf(X3, x4);
  if (i > 0)
    return facetEmpty(facets, X3[i - 1], y4);
}
function facetAnchorRightEmpty(facets, { x: X3 }, { x: x4, y: y4, empty: empty4 }) {
  if (empty4)
    return false;
  if (!X3)
    return;
  const i = facetIndexOf(X3, x4);
  if (i < X3.length - 1)
    return facetEmpty(facets, X3[i + 1], y4);
}
function facetAnchorEmpty(facets, channels, { empty: empty4 }) {
  return empty4;
}
function and2(a3, b2) {
  return function() {
    return a3.apply(null, arguments) && b2.apply(null, arguments);
  };
}
function facetFilter(facets, { channels: { fx, fy }, groups: groups2 }) {
  return fx && fy ? facets.map(({ x: x4, y: y4 }) => groups2.get(x4)?.get(y4) ?? []) : fx ? facets.map(({ x: x4 }) => groups2.get(x4) ?? []) : facets.map(({ y: y4 }) => groups2.get(y4) ?? []);
}

// ../../node_modules/@observablehq/plot/src/mark.js
var Mark = class {
  constructor(data, channels = {}, options = {}, defaults23) {
    const {
      facet = "auto",
      facetAnchor,
      fx,
      fy,
      sort: sort3,
      dx = 0,
      dy = 0,
      margin: margin2 = 0,
      marginTop: marginTop2 = margin2,
      marginRight: marginRight2 = margin2,
      marginBottom: marginBottom2 = margin2,
      marginLeft: marginLeft2 = margin2,
      clip = defaults23?.clip,
      channels: extraChannels,
      tip: tip2,
      render
    } = options;
    this.data = data;
    this.sort = isDomainSort(sort3) ? sort3 : null;
    this.initializer = initializer(options).initializer;
    this.transform = this.initializer ? options.transform : basic(options).transform;
    if (facet === null || facet === false) {
      this.facet = null;
    } else {
      this.facet = keyword(facet === true ? "include" : facet, "facet", ["auto", "include", "exclude", "super"]);
      this.fx = data === singleton && typeof fx === "string" ? [fx] : fx;
      this.fy = data === singleton && typeof fy === "string" ? [fy] : fy;
    }
    this.facetAnchor = maybeFacetAnchor(facetAnchor);
    channels = maybeNamed(channels);
    if (extraChannels !== void 0)
      channels = { ...maybeChannels(extraChannels), ...channels };
    if (defaults23 !== void 0)
      channels = { ...styles(this, options, defaults23), ...channels };
    this.channels = Object.fromEntries(
      Object.entries(channels).map(([name2, channel]) => {
        if (isOptions(channel.value)) {
          const { value, label: label2 = channel.label, scale: scale3 = channel.scale } = channel.value;
          channel = { ...channel, label: label2, scale: scale3, value };
        }
        if (data === singleton && typeof channel.value === "string") {
          const { value } = channel;
          channel = { ...channel, value: [value] };
        }
        return [name2, channel];
      }).filter(([name2, { value, optional: optional2 }]) => {
        if (value != null)
          return true;
        if (optional2)
          return false;
        throw new Error(`missing channel value: ${name2}`);
      })
    );
    this.dx = +dx;
    this.dy = +dy;
    this.marginTop = +marginTop2;
    this.marginRight = +marginRight2;
    this.marginBottom = +marginBottom2;
    this.marginLeft = +marginLeft2;
    this.clip = maybeClip(clip);
    this.tip = maybeTip(tip2);
    if (this.facet === "super") {
      if (fx || fy)
        throw new Error(`super-faceting cannot use fx or fy`);
      for (const name2 in this.channels) {
        const { scale: scale3 } = channels[name2];
        if (scale3 !== "x" && scale3 !== "y")
          continue;
        throw new Error(`super-faceting cannot use x or y`);
      }
    }
    if (render != null) {
      this.render = composeRender(render, this.render);
    }
  }
  initialize(facets, facetChannels, plotOptions) {
    let data = arrayify2(this.data);
    if (facets === void 0 && data != null)
      facets = [range2(data)];
    const originalFacets = facets;
    if (this.transform != null)
      ({ facets, data } = this.transform(data, facets, plotOptions)), data = arrayify2(data);
    if (facets !== void 0)
      facets.original = originalFacets;
    const channels = createChannels(this.channels, data);
    if (this.sort != null)
      channelDomain(data, facets, channels, facetChannels, this.sort);
    return { data, facets, channels };
  }
  filter(index2, channels, values2) {
    for (const name2 in channels) {
      const { filter: filter3 = defined } = channels[name2];
      if (filter3 !== null) {
        const value = values2[name2];
        index2 = index2.filter((i) => filter3(value[i]));
      }
    }
    return index2;
  }
  // If there is a projection, and there are paired x and y channels associated
  // with the x and y scale respectively (and not already in screen coordinates
  // as with an initializer), then apply the projection, replacing the x and y
  // values. Note that the x and y scales themselves dont exist if there is a
  // projection, but whether the channels are associated with scales still
  // determines whether the projection should apply; think of the projection as
  // a combination xy-scale.
  project(channels, values2, context) {
    for (const cx in channels) {
      if (channels[cx].scale === "x" && /^x|x$/.test(cx)) {
        const cy = cx.replace(/^x|x$/, "y");
        if (cy in channels && channels[cy].scale === "y") {
          project(cx, cy, values2, context.projection);
        }
      }
    }
  }
  scale(channels, scales2, context) {
    const values2 = valueObject(channels, scales2);
    if (context.projection)
      this.project(channels, values2, context);
    return values2;
  }
};
function marks(...marks2) {
  marks2.plot = Mark.prototype.plot;
  return marks2;
}
function composeRender(r1, r2) {
  if (r1 == null)
    return r2 === null ? void 0 : r2;
  if (r2 == null)
    return r1 === null ? void 0 : r1;
  if (typeof r1 !== "function")
    throw new TypeError(`invalid render transform: ${r1}`);
  if (typeof r2 !== "function")
    throw new TypeError(`invalid render transform: ${r2}`);
  return function(i, s2, v3, d, c4, next) {
    return r1.call(this, i, s2, v3, d, c4, (i2, s3, v4, d2, c5) => {
      return r2.call(this, i2, s3, v4, d2, c5, next);
    });
  };
}
function maybeChannels(channels) {
  return Object.fromEntries(
    Object.entries(maybeNamed(channels)).map(([name2, channel]) => {
      channel = typeof channel === "string" ? { value: channel, label: name2 } : maybeValue(channel);
      if (channel.filter === void 0 && channel.scale == null)
        channel = { ...channel, filter: null };
      return [name2, channel];
    })
  );
}
function maybeTip(tip2) {
  return tip2 === true ? "xy" : tip2 === false || tip2 == null ? null : typeof tip2 === "string" ? keyword(tip2, "tip", ["x", "y", "xy"]) : tip2;
}
function withTip(options, pointer2) {
  return options?.tip === true ? { ...options, tip: pointer2 } : isObject3(options?.tip) && options.tip.pointer === void 0 ? { ...options, tip: { ...options.tip, pointer: pointer2 } } : options;
}

// ../../node_modules/@observablehq/plot/src/interactions/pointer.js
var states = /* @__PURE__ */ new WeakMap();
function pointerK(kx2, ky2, { x: x4, y: y4, px, py, maxRadius = 40, channels, render, ...options } = {}) {
  maxRadius = +maxRadius;
  if (px != null)
    x4 ??= null, channels = { ...channels, px: { value: px, scale: "x" } };
  if (py != null)
    y4 ??= null, channels = { ...channels, py: { value: py, scale: "y" } };
  return {
    x: x4,
    y: y4,
    channels,
    ...options,
    // Unlike other composed transforms, the render transform must be the
    // outermost render function because it will re-render dynamically in
    // response to pointer events.
    render: composeRender(function(index2, scales2, values2, dimensions, context, next) {
      context = { ...context, pointerSticky: false };
      const svg = context.ownerSVGElement;
      const { data } = context.getMarkState(this);
      let state = states.get(svg);
      if (!state)
        states.set(svg, state = { sticky: false, roots: [], renders: [] });
      let renderIndex = state.renders.push(render2) - 1;
      const { x: x5, y: y5, fx, fy } = scales2;
      let tx = fx ? fx(index2.fx) - dimensions.marginLeft : 0;
      let ty = fy ? fy(index2.fy) - dimensions.marginTop : 0;
      if (x5?.bandwidth)
        tx += x5.bandwidth() / 2;
      if (y5?.bandwidth)
        ty += y5.bandwidth() / 2;
      const faceted = index2.fi != null;
      let facetState;
      if (faceted) {
        let facetStates = state.facetStates;
        if (!facetStates)
          state.facetStates = facetStates = /* @__PURE__ */ new Map();
        facetState = facetStates.get(this);
        if (!facetState)
          facetStates.set(this, facetState = /* @__PURE__ */ new Map());
      }
      const [cx, cy] = applyFrameAnchor(this, dimensions);
      const { px: PX, py: PY } = values2;
      const px2 = PX ? (i2) => PX[i2] : anchorX(values2, cx);
      const py2 = PY ? (i2) => PY[i2] : anchorY(values2, cy);
      let i;
      let g2;
      let s2;
      let f2;
      function update2(ii, ri) {
        if (faceted) {
          if (f2)
            f2 = cancelAnimationFrame(f2);
          if (ii == null)
            facetState.delete(index2.fi);
          else {
            facetState.set(index2.fi, ri);
            f2 = requestAnimationFrame(() => {
              f2 = null;
              for (const [fi, r] of facetState) {
                if (r < ri || r === ri && fi < index2.fi) {
                  ii = null;
                  break;
                }
              }
              render2(ii);
            });
            return;
          }
        }
        render2(ii);
      }
      function render2(ii) {
        if (i === ii && s2 === state.sticky)
          return;
        i = ii;
        s2 = context.pointerSticky = state.sticky;
        const I2 = i == null ? [] : [i];
        if (faceted)
          I2.fx = index2.fx, I2.fy = index2.fy, I2.fi = index2.fi;
        const r = next(I2, scales2, values2, dimensions, context);
        if (g2) {
          if (faceted) {
            const p2 = g2.parentNode;
            const ft = g2.getAttribute("transform");
            const mt = r.getAttribute("transform");
            ft ? r.setAttribute("transform", ft) : r.removeAttribute("transform");
            mt ? p2.setAttribute("transform", mt) : p2.removeAttribute("transform");
            r.removeAttribute("aria-label");
            r.removeAttribute("aria-description");
            r.removeAttribute("aria-hidden");
          }
          g2.replaceWith(r);
        }
        state.roots[renderIndex] = g2 = r;
        if (!(i == null && facetState?.size > 1))
          context.dispatchValue(i == null ? null : data[i]);
        return r;
      }
      function pointermove(event) {
        if (state.sticky || event.pointerType === "mouse" && event.buttons === 1)
          return;
        let [xp, yp] = pointer_default(event);
        xp -= tx, yp -= ty;
        const kpx = xp < dimensions.marginLeft || xp > dimensions.width - dimensions.marginRight ? 1 : kx2;
        const kpy = yp < dimensions.marginTop || yp > dimensions.height - dimensions.marginBottom ? 1 : ky2;
        let ii = null;
        let ri = maxRadius * maxRadius;
        for (const j2 of index2) {
          const dx = kpx * (px2(j2) - xp);
          const dy = kpy * (py2(j2) - yp);
          const rj = dx * dx + dy * dy;
          if (rj <= ri)
            ii = j2, ri = rj;
        }
        if (ii != null && (kx2 !== 1 || ky2 !== 1)) {
          const dx = px2(ii) - xp;
          const dy = py2(ii) - yp;
          ri = dx * dx + dy * dy;
        }
        update2(ii, ri);
      }
      function pointerdown(event) {
        if (event.pointerType !== "mouse")
          return;
        if (i == null)
          return;
        if (state.sticky && state.roots.some((r) => r?.contains(event.target)))
          return;
        if (state.sticky)
          state.sticky = false, state.renders.forEach((r) => r(null));
        else
          state.sticky = true, render2(i);
        event.stopImmediatePropagation();
      }
      function pointerleave(event) {
        if (event.pointerType !== "mouse")
          return;
        if (!state.sticky)
          update2(null);
      }
      svg.addEventListener("pointerenter", pointermove);
      svg.addEventListener("pointermove", pointermove);
      svg.addEventListener("pointerdown", pointerdown);
      svg.addEventListener("pointerleave", pointerleave);
      return render2(null);
    }, render)
  };
}
function pointer(options) {
  return pointerK(1, 1, options);
}
function pointerX(options) {
  return pointerK(1, 0.01, options);
}
function pointerY(options) {
  return pointerK(0.01, 1, options);
}
function anchorX({ x1: X13, x2: X24, x: X3 = X13 }, cx) {
  return X13 && X24 ? (i) => (X13[i] + X24[i]) / 2 : X3 ? (i) => X3[i] : () => cx;
}
function anchorY({ y1: Y13, y2: Y24, y: Y3 = Y13 }, cy) {
  return Y13 && Y24 ? (i) => (Y13[i] + Y24[i]) / 2 : Y3 ? (i) => Y3[i] : () => cy;
}

// ../../node_modules/@observablehq/plot/src/axes.js
function inferFontVariant(scale3) {
  return isOrdinalScale(scale3) && scale3.interval === void 0 ? void 0 : "tabular-nums";
}

// ../../node_modules/@observablehq/plot/src/legends/ramp.js
function legendRamp(color3, options) {
  let {
    label: label2 = color3.label,
    tickSize = 6,
    width: width2 = 240,
    height: height2 = 44 + tickSize,
    marginTop: marginTop2 = 18,
    marginRight: marginRight2 = 0,
    marginBottom: marginBottom2 = 16 + tickSize,
    marginLeft: marginLeft2 = 0,
    style: style2,
    ticks: ticks2 = (width2 - marginLeft2 - marginRight2) / 64,
    tickFormat: tickFormat2,
    fontVariant = inferFontVariant(color3),
    round: round2 = true,
    opacity: opacity2,
    className
  } = options;
  const context = createContext(options);
  className = maybeClassName(className);
  opacity2 = maybeNumberChannel(opacity2)[1];
  if (tickFormat2 === null)
    tickFormat2 = () => null;
  const svg = create3("svg", context).attr("class", `${className}-ramp`).attr("font-family", "system-ui, sans-serif").attr("font-size", 10).attr("width", width2).attr("height", height2).attr("viewBox", `0 0 ${width2} ${height2}`).call(
    (svg2) => (
      // Warning: if you edit this, change defaultClassName.
      svg2.append("style").text(
        `:where(.${className}-ramp) {
  display: block;
  height: auto;
  height: intrinsic;
  max-width: 100%;
  overflow: visible;
}
:where(.${className}-ramp text) {
  white-space: pre;
}`
      )
    )
  ).call(applyInlineStyles, style2);
  let tickAdjust = (g2) => g2.selectAll(".tick line").attr("y1", marginTop2 + marginBottom2 - height2);
  let x4;
  const applyRange = round2 ? (x5, range4) => x5.rangeRound(range4) : (x5, range4) => x5.range(range4);
  const { type: type2, domain, range: range3, interpolate, scale: scale3, pivot } = color3;
  if (interpolate) {
    const interpolator = range3 === void 0 ? interpolate : piecewise(interpolate.length === 1 ? interpolatePiecewise(interpolate) : interpolate, range3);
    x4 = applyRange(
      scale3.copy(),
      quantize_default(
        number_default(marginLeft2, width2 - marginRight2),
        Math.min(domain.length + (pivot !== void 0), range3 === void 0 ? Infinity : range3.length)
      )
    );
    const n = 256;
    const canvas = context.document.createElement("canvas");
    canvas.width = n;
    canvas.height = 1;
    const context2 = canvas.getContext("2d");
    for (let i = 0, j2 = n - 1; i < n; ++i) {
      context2.fillStyle = interpolator(i / j2);
      context2.fillRect(i, 0, 1, 1);
    }
    svg.append("image").attr("opacity", opacity2).attr("x", marginLeft2).attr("y", marginTop2).attr("width", width2 - marginLeft2 - marginRight2).attr("height", height2 - marginTop2 - marginBottom2).attr("preserveAspectRatio", "none").attr("xlink:href", canvas.toDataURL());
  } else if (type2 === "threshold") {
    const thresholds = domain;
    const thresholdFormat = tickFormat2 === void 0 ? (d) => d : typeof tickFormat2 === "string" ? format(tickFormat2) : tickFormat2;
    x4 = applyRange(linear2().domain([-1, range3.length - 1]), [marginLeft2, width2 - marginRight2]);
    svg.append("g").attr("fill-opacity", opacity2).selectAll().data(range3).enter().append("rect").attr("x", (d, i) => x4(i - 1)).attr("y", marginTop2).attr("width", (d, i) => x4(i) - x4(i - 1)).attr("height", height2 - marginTop2 - marginBottom2).attr("fill", (d) => d);
    ticks2 = map2(thresholds, (_2, i) => i);
    tickFormat2 = (i) => thresholdFormat(thresholds[i], i);
  } else {
    x4 = applyRange(band().domain(domain), [marginLeft2, width2 - marginRight2]);
    svg.append("g").attr("fill-opacity", opacity2).selectAll().data(domain).enter().append("rect").attr("x", x4).attr("y", marginTop2).attr("width", Math.max(0, x4.bandwidth() - 1)).attr("height", height2 - marginTop2 - marginBottom2).attr("fill", scale3);
    tickAdjust = () => {
    };
  }
  svg.append("g").attr("transform", `translate(0,${height2 - marginBottom2})`).call(
    axisBottom(x4).ticks(Array.isArray(ticks2) ? null : ticks2, typeof tickFormat2 === "string" ? tickFormat2 : void 0).tickFormat(typeof tickFormat2 === "function" ? tickFormat2 : void 0).tickSize(tickSize).tickValues(Array.isArray(ticks2) ? ticks2 : null)
  ).attr("font-size", null).attr("font-family", null).attr("font-variant", impliedString(fontVariant, "normal")).call(tickAdjust).call((g2) => g2.select(".domain").remove());
  if (label2 !== void 0) {
    svg.append("text").attr("x", marginLeft2).attr("y", marginTop2 - 6).attr("fill", "currentColor").attr("font-weight", "bold").text(label2);
  }
  return svg.node();
}

// ../../node_modules/@observablehq/plot/src/math.js
var radians3 = Math.PI / 180;

// ../../node_modules/@observablehq/plot/src/marker.js
function markers(mark2, { marker, markerStart = marker, markerMid = marker, markerEnd = marker } = {}) {
  mark2.markerStart = maybeMarker(markerStart);
  mark2.markerMid = maybeMarker(markerMid);
  mark2.markerEnd = maybeMarker(markerEnd);
}
function maybeMarker(marker) {
  if (marker == null || marker === false)
    return null;
  if (marker === true)
    return markerCircleFill;
  if (typeof marker === "function")
    return marker;
  switch (`${marker}`.toLowerCase()) {
    case "none":
      return null;
    case "arrow":
      return markerArrow("auto");
    case "arrow-reverse":
      return markerArrow("auto-start-reverse");
    case "dot":
      return markerDot;
    case "circle":
    case "circle-fill":
      return markerCircleFill;
    case "circle-stroke":
      return markerCircleStroke;
    case "tick":
      return markerTick("auto");
    case "tick-x":
      return markerTick(90);
    case "tick-y":
      return markerTick(0);
  }
  throw new Error(`invalid marker: ${marker}`);
}
function markerArrow(orient) {
  return (color3, context) => create3("svg:marker", context).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("orient", orient).attr("fill", "none").attr("stroke", color3).attr("stroke-width", 1.5).attr("stroke-linecap", "round").attr("stroke-linejoin", "round").call((marker) => marker.append("path").attr("d", "M-1.5,-3l3,3l-3,3")).node();
}
function markerDot(color3, context) {
  return create3("svg:marker", context).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", color3).attr("stroke", "none").call((marker) => marker.append("circle").attr("r", 2.5)).node();
}
function markerCircleFill(color3, context) {
  return create3("svg:marker", context).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", color3).attr("stroke", "var(--plot-background)").attr("stroke-width", 1.5).call((marker) => marker.append("circle").attr("r", 3)).node();
}
function markerCircleStroke(color3, context) {
  return create3("svg:marker", context).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", "var(--plot-background)").attr("stroke", color3).attr("stroke-width", 1.5).call((marker) => marker.append("circle").attr("r", 3)).node();
}
function markerTick(orient) {
  return (color3, context) => create3("svg:marker", context).attr("viewBox", "-3 -3 6 6").attr("markerWidth", 6).attr("markerHeight", 6).attr("orient", orient).attr("stroke", color3).call((marker) => marker.append("path").attr("d", "M0,-3v6")).node();
}
var nextMarkerId = 0;
function applyMarkers(path2, mark2, { stroke: S2 }, context) {
  return applyMarkersColor(path2, mark2, S2 && ((i) => S2[i]), context);
}
function applyGroupedMarkers(path2, mark2, { stroke: S2 }, context) {
  return applyMarkersColor(path2, mark2, S2 && (([i]) => S2[i]), context);
}
function applyMarkersColor(path2, { markerStart, markerMid, markerEnd, stroke }, strokeof = () => stroke, context) {
  const iriByMarkerColor = /* @__PURE__ */ new Map();
  function applyMarker(marker) {
    return function(i) {
      const color3 = strokeof(i);
      let iriByColor = iriByMarkerColor.get(marker);
      if (!iriByColor)
        iriByMarkerColor.set(marker, iriByColor = /* @__PURE__ */ new Map());
      let iri = iriByColor.get(color3);
      if (!iri) {
        const node = this.parentNode.insertBefore(marker(color3, context), this);
        const id2 = `plot-marker-${++nextMarkerId}`;
        node.setAttribute("id", id2);
        iriByColor.set(color3, iri = `url(#${id2})`);
      }
      return iri;
    };
  }
  if (markerStart)
    path2.attr("marker-start", applyMarker(markerStart));
  if (markerMid)
    path2.attr("marker-mid", applyMarker(markerMid));
  if (markerEnd)
    path2.attr("marker-end", applyMarker(markerEnd));
}

// ../../node_modules/@observablehq/plot/src/transforms/inset.js
function maybeInsetX({ inset: inset2, insetLeft, insetRight, ...options } = {}) {
  [insetLeft, insetRight] = maybeInset(inset2, insetLeft, insetRight);
  return { inset: inset2, insetLeft, insetRight, ...options };
}
function maybeInsetY({ inset: inset2, insetTop, insetBottom, ...options } = {}) {
  [insetTop, insetBottom] = maybeInset(inset2, insetTop, insetBottom);
  return { inset: inset2, insetTop, insetBottom, ...options };
}
function maybeInset(inset2, inset1, inset22) {
  return inset2 === void 0 && inset1 === void 0 && inset22 === void 0 ? offset ? [1, 0] : [0.5, 0.5] : [inset1, inset22];
}

// ../../node_modules/@observablehq/plot/src/transforms/interval.js
function maybeIntervalValue(value, { interval: interval2 }) {
  value = { ...maybeValue(value) };
  value.interval = maybeInterval(value.interval === void 0 ? interval2 : value.interval);
  return value;
}
function maybeIntervalK(k3, maybeInsetK, options, trivial) {
  const { [k3]: v3, [`${k3}1`]: v1, [`${k3}2`]: v22 } = options;
  const { value, interval: interval2 } = maybeIntervalValue(v3, options);
  if (value == null || interval2 == null && !trivial)
    return options;
  const label2 = labelof(v3);
  if (interval2 == null) {
    let V2;
    const kv = { transform: (data) => V2 || (V2 = valueof(data, value)), label: label2 };
    return {
      ...options,
      [k3]: void 0,
      [`${k3}1`]: v1 === void 0 ? kv : v1,
      [`${k3}2`]: v22 === void 0 && !(v1 === v22 && trivial) ? kv : v22
    };
  }
  let D1, V1;
  function transform3(data) {
    if (V1 !== void 0 && data === D1)
      return V1;
    return V1 = map2(valueof(D1 = data, value), (v4) => interval2.floor(v4));
  }
  return maybeInsetK({
    ...options,
    [k3]: void 0,
    [`${k3}1`]: v1 === void 0 ? { transform: transform3, label: label2 } : v1,
    [`${k3}2`]: v22 === void 0 ? { transform: (data) => transform3(data).map((v4) => interval2.offset(v4)), label: label2 } : v22
  });
}
function maybeIntervalMidK(k3, maybeInsetK, options) {
  const { [k3]: v3 } = options;
  const { value, interval: interval2 } = maybeIntervalValue(v3, options);
  if (value == null || interval2 == null)
    return options;
  return maybeInsetK({
    ...options,
    [k3]: {
      label: labelof(v3),
      transform: (data) => {
        const V1 = map2(valueof(data, value), (v4) => interval2.floor(v4));
        const V2 = V1.map((v4) => interval2.offset(v4));
        return V1.map(
          isTemporal(V1) ? (v1, v22) => v1 == null || isNaN(v1 = +v1) || (v22 = V2[v22], v22 == null) || isNaN(v22 = +v22) ? void 0 : new Date((v1 + v22) / 2) : (v1, v22) => v1 == null || (v22 = V2[v22], v22 == null) ? NaN : (+v1 + +v22) / 2
        );
      }
    }
  });
}
function maybeTrivialIntervalX(options = {}) {
  return maybeIntervalK("x", maybeInsetX, options, true);
}
function maybeTrivialIntervalY(options = {}) {
  return maybeIntervalK("y", maybeInsetY, options, true);
}
function maybeIntervalX(options = {}) {
  return maybeIntervalK("x", maybeInsetX, options);
}
function maybeIntervalY(options = {}) {
  return maybeIntervalK("y", maybeInsetY, options);
}
function maybeIntervalMidX(options = {}) {
  return maybeIntervalMidK("x", maybeInsetX, options);
}
function maybeIntervalMidY(options = {}) {
  return maybeIntervalMidK("y", maybeInsetY, options);
}

// ../../node_modules/@observablehq/plot/src/marks/rule.js
var defaults = {
  ariaLabel: "rule",
  fill: null,
  stroke: "currentColor"
};
var RuleX = class extends Mark {
  constructor(data, options = {}) {
    const { x: x4, y1: y12, y2: y22, inset: inset2 = 0, insetTop = inset2, insetBottom = inset2 } = options;
    super(
      data,
      {
        x: { value: x4, scale: "x", optional: true },
        y1: { value: y12, scale: "y", optional: true },
        y2: { value: y22, scale: "y", optional: true }
      },
      withTip(options, "x"),
      defaults
    );
    this.insetTop = number5(insetTop);
    this.insetBottom = number5(insetBottom);
    markers(this, options);
  }
  render(index2, scales2, channels, dimensions, context) {
    const { x: x4, y: y4 } = scales2;
    const { x: X3, y1: Y13, y2: Y24 } = channels;
    const { width: width2, height: height2, marginTop: marginTop2, marginRight: marginRight2, marginLeft: marginLeft2, marginBottom: marginBottom2 } = dimensions;
    const { insetTop, insetBottom } = this;
    return create3("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X3 && x4 }, offset, 0).call(
      (g2) => g2.selectAll().data(index2).enter().append("line").call(applyDirectStyles, this).attr("x1", X3 ? (i) => X3[i] : (marginLeft2 + width2 - marginRight2) / 2).attr("x2", X3 ? (i) => X3[i] : (marginLeft2 + width2 - marginRight2) / 2).attr("y1", Y13 && !isCollapsed(y4) ? (i) => Y13[i] + insetTop : marginTop2 + insetTop).attr(
        "y2",
        Y24 && !isCollapsed(y4) ? y4.bandwidth ? (i) => Y24[i] + y4.bandwidth() - insetBottom : (i) => Y24[i] - insetBottom : height2 - marginBottom2 - insetBottom
      ).call(applyChannelStyles, this, channels).call(applyMarkers, this, channels, context)
    ).node();
  }
};
var RuleY = class extends Mark {
  constructor(data, options = {}) {
    const { x1: x12, x2: x22, y: y4, inset: inset2 = 0, insetRight = inset2, insetLeft = inset2 } = options;
    super(
      data,
      {
        y: { value: y4, scale: "y", optional: true },
        x1: { value: x12, scale: "x", optional: true },
        x2: { value: x22, scale: "x", optional: true }
      },
      withTip(options, "y"),
      defaults
    );
    this.insetRight = number5(insetRight);
    this.insetLeft = number5(insetLeft);
    markers(this, options);
  }
  render(index2, scales2, channels, dimensions, context) {
    const { x: x4, y: y4 } = scales2;
    const { y: Y3, x1: X13, x2: X24 } = channels;
    const { width: width2, height: height2, marginTop: marginTop2, marginRight: marginRight2, marginLeft: marginLeft2, marginBottom: marginBottom2 } = dimensions;
    const { insetLeft, insetRight } = this;
    return create3("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { y: Y3 && y4 }, 0, offset).call(
      (g2) => g2.selectAll().data(index2).enter().append("line").call(applyDirectStyles, this).attr("x1", X13 && !isCollapsed(x4) ? (i) => X13[i] + insetLeft : marginLeft2 + insetLeft).attr(
        "x2",
        X24 && !isCollapsed(x4) ? x4.bandwidth ? (i) => X24[i] + x4.bandwidth() - insetRight : (i) => X24[i] - insetRight : width2 - marginRight2 - insetRight
      ).attr("y1", Y3 ? (i) => Y3[i] : (marginTop2 + height2 - marginBottom2) / 2).attr("y2", Y3 ? (i) => Y3[i] : (marginTop2 + height2 - marginBottom2) / 2).call(applyChannelStyles, this, channels).call(applyMarkers, this, channels, context)
    ).node();
  }
};
function ruleX(data, options) {
  let { x: x4 = identity7, y: y4, y1: y12, y2: y22, ...rest } = maybeIntervalY(options);
  [y12, y22] = maybeOptionalZero(y4, y12, y22);
  return new RuleX(data, { ...rest, x: x4, y1: y12, y2: y22 });
}
function ruleY(data, options) {
  let { y: y4 = identity7, x: x4, x1: x12, x2: x22, ...rest } = maybeIntervalX(options);
  [x12, x22] = maybeOptionalZero(x4, x12, x22);
  return new RuleY(data, { ...rest, y: y4, x1: x12, x2: x22 });
}
function maybeOptionalZero(x4, x12, x22) {
  if (x4 == null) {
    if (x12 === void 0) {
      if (x22 !== void 0)
        return [0, x22];
    } else {
      if (x22 === void 0)
        return [0, x12];
    }
  } else if (x12 === void 0) {
    return x22 === void 0 ? [0, x4] : [x4, x22];
  } else if (x22 === void 0) {
    return [x4, x12];
  }
  return [x12, x22];
}

// ../../node_modules/@observablehq/plot/src/template.js
function template(strings, ...parts) {
  let n = parts.length;
  for (let j2 = 0, copy4 = true; j2 < n; ++j2) {
    if (typeof parts[j2] !== "function") {
      if (copy4) {
        strings = strings.slice();
        copy4 = false;
      }
      strings.splice(j2, 2, strings[j2] + parts[j2] + strings[j2 + 1]);
      parts.splice(j2, 1);
      --j2, --n;
    }
  }
  return (i) => {
    let s2 = strings[0];
    for (let j2 = 0; j2 < n; ++j2) {
      s2 += parts[j2](i) + strings[j2 + 1];
    }
    return s2;
  };
}

// ../../node_modules/@observablehq/plot/src/marks/text.js
var defaults2 = {
  ariaLabel: "text",
  strokeLinejoin: "round",
  strokeWidth: 3,
  paintOrder: "stroke"
};
var softHyphen = "\xAD";
var Text = class extends Mark {
  constructor(data, options = {}) {
    const {
      x: x4,
      y: y4,
      text: text3 = isIterable3(data) && isTextual(data) ? identity7 : indexOf,
      frameAnchor,
      textAnchor = /right$/i.test(frameAnchor) ? "end" : /left$/i.test(frameAnchor) ? "start" : "middle",
      lineAnchor = /^top/i.test(frameAnchor) ? "top" : /^bottom/i.test(frameAnchor) ? "bottom" : "middle",
      lineHeight = 1,
      lineWidth = Infinity,
      textOverflow,
      monospace,
      fontFamily = monospace ? "ui-monospace, monospace" : void 0,
      fontSize,
      fontStyle,
      fontVariant,
      fontWeight,
      rotate
    } = options;
    const [vrotate, crotate] = maybeNumberChannel(rotate, 0);
    const [vfontSize, cfontSize] = maybeFontSizeChannel(fontSize);
    super(
      data,
      {
        x: { value: x4, scale: "x", optional: true },
        y: { value: y4, scale: "y", optional: true },
        fontSize: { value: vfontSize, optional: true },
        rotate: { value: numberChannel(vrotate), optional: true },
        text: { value: text3, filter: nonempty, optional: true }
      },
      options,
      defaults2
    );
    this.rotate = crotate;
    this.textAnchor = impliedString(textAnchor, "middle");
    this.lineAnchor = keyword(lineAnchor, "lineAnchor", ["top", "middle", "bottom"]);
    this.lineHeight = +lineHeight;
    this.lineWidth = +lineWidth;
    this.textOverflow = maybeTextOverflow(textOverflow);
    this.monospace = !!monospace;
    this.fontFamily = string(fontFamily);
    this.fontSize = cfontSize;
    this.fontStyle = string(fontStyle);
    this.fontVariant = string(fontVariant);
    this.fontWeight = string(fontWeight);
    this.frameAnchor = maybeFrameAnchor(frameAnchor);
    if (!(this.lineWidth >= 0))
      throw new Error(`invalid lineWidth: ${lineWidth}`);
    this.splitLines = splitter2(this);
    this.clipLine = clipper(this);
  }
  render(index2, scales2, channels, dimensions, context) {
    const { x: x4, y: y4 } = scales2;
    const { x: X3, y: Y3, rotate: R2, text: T, title: TL, fontSize: FS } = channels;
    const { rotate } = this;
    const [cx, cy] = applyFrameAnchor(this, dimensions);
    return create3("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyIndirectTextStyles, this, T, dimensions).call(applyTransform, this, { x: X3 && x4, y: Y3 && y4 }).call(
      (g2) => g2.selectAll().data(index2).enter().append("text").call(applyDirectStyles, this).call(applyMultilineText, this, T, TL).attr(
        "transform",
        template`translate(${X3 ? (i) => X3[i] : cx},${Y3 ? (i) => Y3[i] : cy})${R2 ? (i) => ` rotate(${R2[i]})` : rotate ? ` rotate(${rotate})` : ``}`
      ).call(applyAttr, "font-size", FS && ((i) => FS[i])).call(applyChannelStyles, this, channels)
    ).node();
  }
};
function maybeTextOverflow(textOverflow) {
  return textOverflow == null ? null : keyword(textOverflow, "textOverflow", [
    "clip",
    // shorthand for clip-end
    "ellipsis",
    //  ellipsis-end
    "clip-start",
    "clip-end",
    "ellipsis-start",
    "ellipsis-middle",
    "ellipsis-end"
  ]).replace(/^(clip|ellipsis)$/, "$1-end");
}
function applyMultilineText(selection2, mark2, T, TL) {
  if (!T)
    return;
  const { lineAnchor, lineHeight, textOverflow, splitLines, clipLine } = mark2;
  selection2.each(function(i) {
    const lines = splitLines(formatDefault(T[i]) ?? "").map(clipLine);
    const n = lines.length;
    const y4 = lineAnchor === "top" ? 0.71 : lineAnchor === "bottom" ? 1 - n : (164 - n * 100) / 200;
    if (n > 1) {
      let m2 = 0;
      for (let i2 = 0; i2 < n; ++i2) {
        ++m2;
        if (!lines[i2])
          continue;
        const tspan = this.ownerDocument.createElementNS(namespaces_default.svg, "tspan");
        tspan.setAttribute("x", 0);
        if (i2 === m2 - 1)
          tspan.setAttribute("y", `${(y4 + i2) * lineHeight}em`);
        else
          tspan.setAttribute("dy", `${m2 * lineHeight}em`);
        tspan.textContent = lines[i2];
        this.appendChild(tspan);
        m2 = 0;
      }
    } else {
      if (y4)
        this.setAttribute("y", `${y4 * lineHeight}em`);
      this.textContent = lines[0];
    }
    if (textOverflow && !TL && lines[0] !== T[i]) {
      const title = this.ownerDocument.createElementNS(namespaces_default.svg, "title");
      title.textContent = T[i];
      this.appendChild(title);
    }
  });
}
function text(data, { x: x4, y: y4, ...options } = {}) {
  if (options.frameAnchor === void 0)
    [x4, y4] = maybeTuple(x4, y4);
  return new Text(data, { ...options, x: x4, y: y4 });
}
function textX(data, { x: x4 = identity7, ...options } = {}) {
  return new Text(data, maybeIntervalMidY({ ...options, x: x4 }));
}
function textY(data, { y: y4 = identity7, ...options } = {}) {
  return new Text(data, maybeIntervalMidX({ ...options, y: y4 }));
}
function applyIndirectTextStyles(selection2, mark2, T) {
  applyAttr(selection2, "text-anchor", mark2.textAnchor);
  applyAttr(selection2, "font-family", mark2.fontFamily);
  applyAttr(selection2, "font-size", mark2.fontSize);
  applyAttr(selection2, "font-style", mark2.fontStyle);
  applyAttr(selection2, "font-variant", mark2.fontVariant === void 0 ? inferFontVariant2(T) : mark2.fontVariant);
  applyAttr(selection2, "font-weight", mark2.fontWeight);
}
function inferFontVariant2(T) {
  return T && (isNumeric(T) || isTemporal(T)) ? "tabular-nums" : void 0;
}
var fontSizes = /* @__PURE__ */ new Set([
  // global keywords
  "inherit",
  "initial",
  "revert",
  "unset",
  // absolute keywords
  "xx-small",
  "x-small",
  "small",
  "medium",
  "large",
  "x-large",
  "xx-large",
  "xxx-large",
  // relative keywords
  "larger",
  "smaller"
]);
function maybeFontSizeChannel(fontSize) {
  if (fontSize == null || typeof fontSize === "number")
    return [void 0, fontSize];
  if (typeof fontSize !== "string")
    return [fontSize, void 0];
  fontSize = fontSize.trim().toLowerCase();
  return fontSizes.has(fontSize) || /^[+-]?\d*\.?\d+(e[+-]?\d+)?(\w*|%)$/.test(fontSize) ? [void 0, fontSize] : [fontSize, void 0];
}
function lineWrap(input3, maxWidth, widthof2) {
  const lines = [];
  let lineStart, lineEnd = 0;
  for (const [wordStart, wordEnd, required2] of lineBreaks(input3)) {
    if (lineStart === void 0)
      lineStart = wordStart;
    if (lineEnd > lineStart && widthof2(input3, lineStart, wordEnd) > maxWidth) {
      lines.push(input3.slice(lineStart, lineEnd) + (input3[lineEnd - 1] === softHyphen ? "-" : ""));
      lineStart = wordStart;
    }
    if (required2) {
      lines.push(input3.slice(lineStart, wordEnd));
      lineStart = void 0;
      continue;
    }
    lineEnd = wordEnd;
  }
  return lines;
}
function* lineBreaks(input3) {
  let i = 0, j2 = 0;
  const n = input3.length;
  while (j2 < n) {
    let k3 = 1;
    switch (input3[j2]) {
      case softHyphen:
      case "-":
        ++j2;
        yield [i, j2, false];
        i = j2;
        break;
      case " ":
        yield [i, j2, false];
        while (input3[++j2] === " ")
          ;
        i = j2;
        break;
      case "\r":
        if (input3[j2 + 1] === "\n")
          ++k3;
      case "\n":
        yield [i, j2, true];
        j2 += k3;
        i = j2;
        break;
      default:
        ++j2;
        break;
    }
  }
  yield [i, j2, true];
}
var defaultWidthMap = {
  a: 56,
  b: 63,
  c: 57,
  d: 63,
  e: 58,
  f: 37,
  g: 62,
  h: 60,
  i: 26,
  j: 26,
  k: 55,
  l: 26,
  m: 88,
  n: 60,
  o: 60,
  p: 62,
  q: 62,
  r: 39,
  s: 54,
  t: 38,
  u: 60,
  v: 55,
  w: 79,
  x: 54,
  y: 55,
  z: 55,
  A: 69,
  B: 67,
  C: 73,
  D: 74,
  E: 61,
  F: 58,
  G: 76,
  H: 75,
  I: 28,
  J: 55,
  K: 67,
  L: 58,
  M: 89,
  N: 75,
  O: 78,
  P: 65,
  Q: 78,
  R: 67,
  S: 65,
  T: 65,
  U: 75,
  V: 69,
  W: 98,
  X: 69,
  Y: 67,
  Z: 67,
  0: 64,
  1: 48,
  2: 62,
  3: 64,
  4: 66,
  5: 63,
  6: 65,
  7: 58,
  8: 65,
  9: 65,
  " ": 29,
  "!": 32,
  '"': 49,
  "'": 31,
  "(": 39,
  ")": 39,
  ",": 31,
  "-": 48,
  ".": 31,
  "/": 32,
  ":": 31,
  ";": 31,
  "?": 52,
  "\u2018": 31,
  "\u2019": 31,
  "\u201C": 47,
  "\u201D": 47,
  "\u2026": 82
};
function defaultWidth(text3, start2 = 0, end = text3.length) {
  let sum5 = 0;
  for (let i = start2; i < end; i = readCharacter(text3, i)) {
    sum5 += defaultWidthMap[text3[i]] ?? (isPictographic(text3, i) ? 120 : defaultWidthMap.e);
  }
  return sum5;
}
function monospaceWidth(text3, start2 = 0, end = text3.length) {
  let sum5 = 0;
  for (let i = start2; i < end; i = readCharacter(text3, i)) {
    sum5 += isPictographic(text3, i) ? 126 : 63;
  }
  return sum5;
}
function splitter2({ monospace, lineWidth, textOverflow }) {
  if (textOverflow != null || lineWidth == Infinity)
    return (text3) => text3.split(/\r\n?|\n/g);
  const widthof2 = monospace ? monospaceWidth : defaultWidth;
  const maxWidth = lineWidth * 100;
  return (text3) => lineWrap(text3, maxWidth, widthof2);
}
function clipper({ monospace, lineWidth, textOverflow }) {
  if (textOverflow == null || lineWidth == Infinity)
    return (text3) => text3;
  const widthof2 = monospace ? monospaceWidth : defaultWidth;
  const maxWidth = lineWidth * 100;
  switch (textOverflow) {
    case "clip-start":
      return (text3) => clipStart(text3, maxWidth, widthof2, "");
    case "clip-end":
      return (text3) => clipEnd(text3, maxWidth, widthof2, "");
    case "ellipsis-start":
      return (text3) => clipStart(text3, maxWidth, widthof2, ellipsis);
    case "ellipsis-middle":
      return (text3) => clipMiddle(text3, maxWidth, widthof2, ellipsis);
    case "ellipsis-end":
      return (text3) => clipEnd(text3, maxWidth, widthof2, ellipsis);
  }
}
var ellipsis = "\u2026";
function cut(text3, width2, widthof2, inset2) {
  const I2 = [];
  let w = 0;
  for (let i = 0, j2 = 0, n = text3.length; i < n; i = j2) {
    j2 = readCharacter(text3, i);
    const l = widthof2(text3, i, j2);
    if (w + l > width2) {
      w += inset2;
      while (w > width2 && i > 0)
        j2 = i, i = I2.pop(), w -= widthof2(text3, i, j2);
      return [i, width2 - w];
    }
    w += l;
    I2.push(i);
  }
  return [-1, 0];
}
function clipEnd(text3, width2, widthof2, ellipsis2) {
  text3 = text3.trim();
  const e = widthof2(ellipsis2);
  const [i] = cut(text3, width2, widthof2, e);
  return i < 0 ? text3 : text3.slice(0, i).trimEnd() + ellipsis2;
}
function clipMiddle(text3, width2, widthof2, ellipsis2) {
  text3 = text3.trim();
  const w = widthof2(text3);
  if (w <= width2)
    return text3;
  const e = widthof2(ellipsis2) / 2;
  const [i, ei] = cut(text3, width2 / 2, widthof2, e);
  const [j2] = cut(text3, w - width2 / 2 - ei + e, widthof2, -e);
  return j2 < 0 ? ellipsis2 : text3.slice(0, i).trimEnd() + ellipsis2 + text3.slice(readCharacter(text3, j2)).trimStart();
}
function clipStart(text3, width2, widthof2, ellipsis2) {
  text3 = text3.trim();
  const w = widthof2(text3);
  if (w <= width2)
    return text3;
  const e = widthof2(ellipsis2);
  const [j2] = cut(text3, w - width2 + e, widthof2, -e);
  return j2 < 0 ? ellipsis2 : ellipsis2 + text3.slice(readCharacter(text3, j2)).trimStart();
}
var reCombiner = /[\p{Combining_Mark}\p{Emoji_Modifier}]+/uy;
var rePictographic = /\p{Extended_Pictographic}/uy;
function readCharacter(text3, i) {
  i += isSurrogatePair(text3, i) ? 2 : 1;
  if (isCombiner(text3, i))
    i = reCombiner.lastIndex;
  if (isZeroWidthJoiner(text3, i))
    return readCharacter(text3, i + 1);
  return i;
}
function isAscii(text3, i) {
  return text3.charCodeAt(i) < 128;
}
function isSurrogatePair(text3, i) {
  const hi = text3.charCodeAt(i);
  if (hi >= 55296 && hi < 56320) {
    const lo = text3.charCodeAt(i + 1);
    return lo >= 56320 && lo < 57344;
  }
  return false;
}
function isZeroWidthJoiner(text3, i) {
  return text3.charCodeAt(i) === 8205;
}
function isCombiner(text3, i) {
  return isAscii(text3, i) ? false : (reCombiner.lastIndex = i, reCombiner.test(text3));
}
function isPictographic(text3, i) {
  return isAscii(text3, i) ? false : (rePictographic.lastIndex = i, rePictographic.test(text3));
}

// ../../node_modules/@observablehq/plot/src/marks/vector.js
var defaults3 = {
  ariaLabel: "vector",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 1.5,
  strokeLinejoin: "round",
  strokeLinecap: "round"
};
var defaultRadius = 3.5;
var wingRatio = defaultRadius * 5;
var shapeArrow = {
  draw(context, l, r) {
    const wing = l * r / wingRatio;
    context.moveTo(0, 0);
    context.lineTo(0, -l);
    context.moveTo(-wing, wing - l);
    context.lineTo(0, -l);
    context.lineTo(wing, wing - l);
  }
};
var shapeSpike = {
  draw(context, l, r) {
    context.moveTo(-r, 0);
    context.lineTo(0, -l);
    context.lineTo(r, 0);
  }
};
var shapes = /* @__PURE__ */ new Map([
  ["arrow", shapeArrow],
  ["spike", shapeSpike]
]);
function isShapeObject(value) {
  return value && typeof value.draw === "function";
}
function maybeShape(shape) {
  if (isShapeObject(shape))
    return shape;
  const value = shapes.get(`${shape}`.toLowerCase());
  if (value)
    return value;
  throw new Error(`invalid shape: ${shape}`);
}
var Vector3 = class extends Mark {
  constructor(data, options = {}) {
    const { x: x4, y: y4, r = defaultRadius, length: length4, rotate, shape = shapeArrow, anchor = "middle", frameAnchor } = options;
    const [vl, cl] = maybeNumberChannel(length4, 12);
    const [vr, cr] = maybeNumberChannel(rotate, 0);
    super(
      data,
      {
        x: { value: x4, scale: "x", optional: true },
        y: { value: y4, scale: "y", optional: true },
        length: { value: vl, scale: "length", optional: true },
        rotate: { value: vr, optional: true }
      },
      options,
      defaults3
    );
    this.r = +r;
    this.length = cl;
    this.rotate = cr;
    this.shape = maybeShape(shape);
    this.anchor = keyword(anchor, "anchor", ["start", "middle", "end"]);
    this.frameAnchor = maybeFrameAnchor(frameAnchor);
  }
  render(index2, scales2, channels, dimensions, context) {
    const { x: x4, y: y4 } = scales2;
    const { x: X3, y: Y3, length: L2, rotate: A5 } = channels;
    const { length: length4, rotate, anchor, shape, r } = this;
    const [cx, cy] = applyFrameAnchor(this, dimensions);
    return create3("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X3 && x4, y: Y3 && y4 }).call(
      (g2) => g2.selectAll().data(index2).enter().append("path").call(applyDirectStyles, this).attr(
        "transform",
        template`translate(${X3 ? (i) => X3[i] : cx},${Y3 ? (i) => Y3[i] : cy})${A5 ? (i) => ` rotate(${A5[i]})` : rotate ? ` rotate(${rotate})` : ``}${anchor === "start" ? `` : anchor === "end" ? L2 ? (i) => ` translate(0,${L2[i]})` : ` translate(0,${length4})` : L2 ? (i) => ` translate(0,${L2[i] / 2})` : ` translate(0,${length4 / 2})`}`
      ).attr(
        "d",
        L2 ? (i) => {
          const p2 = pathRound();
          shape.draw(p2, L2[i], r);
          return p2;
        } : (() => {
          const p2 = pathRound();
          shape.draw(p2, length4, r);
          return p2;
        })()
      ).call(applyChannelStyles, this, channels)
    ).node();
  }
};
function vector(data, options = {}) {
  let { x: x4, y: y4, ...rest } = options;
  if (options.frameAnchor === void 0)
    [x4, y4] = maybeTuple(x4, y4);
  return new Vector3(data, { ...rest, x: x4, y: y4 });
}
function vectorX(data, options = {}) {
  const { x: x4 = identity7, ...rest } = options;
  return new Vector3(data, { ...rest, x: x4 });
}
function vectorY(data, options = {}) {
  const { y: y4 = identity7, ...rest } = options;
  return new Vector3(data, { ...rest, y: y4 });
}
function spike(data, options = {}) {
  const {
    shape = shapeSpike,
    stroke = defaults3.stroke,
    strokeWidth = 1,
    fill = stroke,
    fillOpacity = 0.3,
    anchor = "start",
    ...rest
  } = options;
  return vector(data, { ...rest, shape, stroke, strokeWidth, fill, fillOpacity, anchor });
}

// ../../node_modules/@observablehq/plot/src/marks/axis.js
function maybeData(data, options) {
  if (arguments.length < 2 && !isIterable3(data))
    options = data, data = null;
  if (options === void 0)
    options = {};
  return [data, options];
}
function maybeAnchor2({ anchor } = {}, anchors) {
  return anchor === void 0 ? anchors[0] : keyword(anchor, "anchor", anchors);
}
function anchorY2(options) {
  return maybeAnchor2(options, ["left", "right"]);
}
function anchorFy(options) {
  return maybeAnchor2(options, ["right", "left"]);
}
function anchorX2(options) {
  return maybeAnchor2(options, ["bottom", "top"]);
}
function anchorFx(options) {
  return maybeAnchor2(options, ["top", "bottom"]);
}
function axisY() {
  const [data, options] = maybeData(...arguments);
  return axisKy("y", anchorY2(options), data, options);
}
function axisFy() {
  const [data, options] = maybeData(...arguments);
  return axisKy("fy", anchorFy(options), data, options);
}
function axisX() {
  const [data, options] = maybeData(...arguments);
  return axisKx("x", anchorX2(options), data, options);
}
function axisFx() {
  const [data, options] = maybeData(...arguments);
  return axisKx("fx", anchorFx(options), data, options);
}
function axisKy(k3, anchor, data, {
  color: color3 = "currentColor",
  opacity: opacity2 = 1,
  stroke = color3,
  strokeOpacity = opacity2,
  strokeWidth = 1,
  fill = color3,
  fillOpacity = opacity2,
  textAnchor,
  textStroke,
  textStrokeOpacity,
  textStrokeWidth,
  tickSize = k3 === "y" ? 6 : 0,
  tickPadding,
  tickRotate,
  x: x4,
  margin: margin2,
  marginTop: marginTop2 = margin2 === void 0 ? 20 : margin2,
  marginRight: marginRight2 = margin2 === void 0 ? anchor === "right" ? 40 : 0 : margin2,
  marginBottom: marginBottom2 = margin2 === void 0 ? 20 : margin2,
  marginLeft: marginLeft2 = margin2 === void 0 ? anchor === "left" ? 40 : 0 : margin2,
  label: label2,
  labelAnchor,
  labelArrow,
  labelOffset,
  ...options
}) {
  tickSize = number5(tickSize);
  tickPadding = number5(tickPadding);
  tickRotate = number5(tickRotate);
  if (labelAnchor !== void 0)
    labelAnchor = keyword(labelAnchor, "labelAnchor", ["center", "top", "bottom"]);
  labelArrow = maybeLabelArrow(labelArrow);
  return marks(
    tickSize && !isNoneish(stroke) ? axisTickKy(k3, anchor, data, {
      stroke,
      strokeOpacity,
      strokeWidth,
      tickSize,
      tickPadding,
      tickRotate,
      x: x4,
      ...options
    }) : null,
    !isNoneish(fill) ? axisTextKy(k3, anchor, data, {
      fill,
      fillOpacity,
      stroke: textStroke,
      strokeOpacity: textStrokeOpacity,
      strokeWidth: textStrokeWidth,
      textAnchor,
      tickSize,
      tickPadding,
      tickRotate,
      x: x4,
      marginTop: marginTop2,
      marginRight: marginRight2,
      marginBottom: marginBottom2,
      marginLeft: marginLeft2,
      ...options
    }) : null,
    !isNoneish(fill) && label2 !== null ? text(
      [],
      labelOptions({ fill, fillOpacity, ...options }, function(data2, facets, channels, scales2, dimensions) {
        const scale3 = scales2[k3];
        const { marginTop: marginTop3, marginRight: marginRight3, marginBottom: marginBottom3, marginLeft: marginLeft3 } = k3 === "y" && dimensions.inset || dimensions;
        const cla = labelAnchor ?? (scale3.bandwidth ? "center" : "top");
        const clo = labelOffset ?? (anchor === "right" ? marginRight3 : marginLeft3) - 3;
        if (cla === "center") {
          this.textAnchor = void 0;
          this.lineAnchor = anchor === "right" ? "bottom" : "top";
          this.frameAnchor = anchor;
          this.rotate = -90;
        } else {
          this.textAnchor = anchor === "right" ? "end" : "start";
          this.lineAnchor = cla;
          this.frameAnchor = `${cla}-${anchor}`;
          this.rotate = 0;
        }
        this.dy = cla === "top" ? 3 - marginTop3 : cla === "bottom" ? marginBottom3 - 3 : 0;
        this.dx = anchor === "right" ? clo : -clo;
        this.ariaLabel = `${k3}-axis label`;
        return {
          facets: [[0]],
          channels: { text: { value: [formatAxisLabel(k3, scale3, { anchor, label: label2, labelAnchor: cla, labelArrow })] } }
        };
      })
    ) : null
  );
}
function axisKx(k3, anchor, data, {
  color: color3 = "currentColor",
  opacity: opacity2 = 1,
  stroke = color3,
  strokeOpacity = opacity2,
  strokeWidth = 1,
  fill = color3,
  fillOpacity = opacity2,
  textAnchor,
  textStroke,
  textStrokeOpacity,
  textStrokeWidth,
  tickSize = k3 === "x" ? 6 : 0,
  tickPadding,
  tickRotate,
  y: y4,
  margin: margin2,
  marginTop: marginTop2 = margin2 === void 0 ? anchor === "top" ? 30 : 0 : margin2,
  marginRight: marginRight2 = margin2 === void 0 ? 20 : margin2,
  marginBottom: marginBottom2 = margin2 === void 0 ? anchor === "bottom" ? 30 : 0 : margin2,
  marginLeft: marginLeft2 = margin2 === void 0 ? 20 : margin2,
  label: label2,
  labelAnchor,
  labelArrow,
  labelOffset,
  ...options
}) {
  tickSize = number5(tickSize);
  tickPadding = number5(tickPadding);
  tickRotate = number5(tickRotate);
  if (labelAnchor !== void 0)
    labelAnchor = keyword(labelAnchor, "labelAnchor", ["center", "left", "right"]);
  labelArrow = maybeLabelArrow(labelArrow);
  return marks(
    tickSize && !isNoneish(stroke) ? axisTickKx(k3, anchor, data, {
      stroke,
      strokeOpacity,
      strokeWidth,
      tickSize,
      tickPadding,
      tickRotate,
      y: y4,
      ...options
    }) : null,
    !isNoneish(fill) ? axisTextKx(k3, anchor, data, {
      fill,
      fillOpacity,
      stroke: textStroke,
      strokeOpacity: textStrokeOpacity,
      strokeWidth: textStrokeWidth,
      textAnchor,
      tickSize,
      tickPadding,
      tickRotate,
      y: y4,
      marginTop: marginTop2,
      marginRight: marginRight2,
      marginBottom: marginBottom2,
      marginLeft: marginLeft2,
      ...options
    }) : null,
    !isNoneish(fill) && label2 !== null ? text(
      [],
      labelOptions({ fill, fillOpacity, ...options }, function(data2, facets, channels, scales2, dimensions) {
        const scale3 = scales2[k3];
        const { marginTop: marginTop3, marginRight: marginRight3, marginBottom: marginBottom3, marginLeft: marginLeft3 } = k3 === "x" && dimensions.inset || dimensions;
        const cla = labelAnchor ?? (scale3.bandwidth ? "center" : "right");
        const clo = labelOffset ?? (anchor === "top" ? marginTop3 : marginBottom3) - 3;
        if (cla === "center") {
          this.frameAnchor = anchor;
          this.textAnchor = void 0;
        } else {
          this.frameAnchor = `${anchor}-${cla}`;
          this.textAnchor = cla === "right" ? "end" : "start";
        }
        this.lineAnchor = anchor;
        this.dy = anchor === "top" ? -clo : clo;
        this.dx = cla === "right" ? marginRight3 - 3 : cla === "left" ? 3 - marginLeft3 : 0;
        this.ariaLabel = `${k3}-axis label`;
        return {
          facets: [[0]],
          channels: { text: { value: [formatAxisLabel(k3, scale3, { anchor, label: label2, labelAnchor: cla, labelArrow })] } }
        };
      })
    ) : null
  );
}
function axisTickKy(k3, anchor, data, {
  strokeWidth = 1,
  strokeLinecap = null,
  strokeLinejoin = null,
  facetAnchor = anchor + (k3 === "y" ? "-empty" : ""),
  frameAnchor = anchor,
  tickSize,
  inset: inset2 = 0,
  insetLeft = inset2,
  insetRight = inset2,
  dx = 0,
  y: y4 = k3 === "y" ? void 0 : null,
  ...options
}) {
  return axisMark(
    vectorY,
    k3,
    data,
    {
      ariaLabel: `${k3}-axis tick`,
      ariaHidden: true
    },
    {
      strokeWidth,
      strokeLinecap,
      strokeLinejoin,
      facetAnchor,
      frameAnchor,
      y: y4,
      ...options,
      dx: anchor === "left" ? +dx - offset + +insetLeft : +dx + offset - insetRight,
      anchor: "start",
      length: tickSize,
      shape: anchor === "left" ? shapeTickLeft : shapeTickRight
    }
  );
}
function axisTickKx(k3, anchor, data, {
  strokeWidth = 1,
  strokeLinecap = null,
  strokeLinejoin = null,
  facetAnchor = anchor + (k3 === "x" ? "-empty" : ""),
  frameAnchor = anchor,
  tickSize,
  inset: inset2 = 0,
  insetTop = inset2,
  insetBottom = inset2,
  dy = 0,
  x: x4 = k3 === "x" ? void 0 : null,
  ...options
}) {
  return axisMark(
    vectorX,
    k3,
    data,
    {
      ariaLabel: `${k3}-axis tick`,
      ariaHidden: true
    },
    {
      strokeWidth,
      strokeLinejoin,
      strokeLinecap,
      facetAnchor,
      frameAnchor,
      x: x4,
      ...options,
      dy: anchor === "bottom" ? +dy - offset - insetBottom : +dy + offset + +insetTop,
      anchor: "start",
      length: tickSize,
      shape: anchor === "bottom" ? shapeTickBottom : shapeTickTop
    }
  );
}
function axisTextKy(k3, anchor, data, {
  facetAnchor = anchor + (k3 === "y" ? "-empty" : ""),
  frameAnchor = anchor,
  tickSize,
  tickRotate = 0,
  tickPadding = Math.max(3, 9 - tickSize) + (Math.abs(tickRotate) > 60 ? 4 * Math.cos(tickRotate * radians3) : 0),
  text: text3,
  textAnchor = Math.abs(tickRotate) > 60 ? "middle" : anchor === "left" ? "end" : "start",
  lineAnchor = tickRotate > 60 ? "top" : tickRotate < -60 ? "bottom" : "middle",
  fontVariant,
  inset: inset2 = 0,
  insetLeft = inset2,
  insetRight = inset2,
  dx = 0,
  y: y4 = k3 === "y" ? void 0 : null,
  ...options
}) {
  return axisMark(
    textY,
    k3,
    data,
    { ariaLabel: `${k3}-axis tick label` },
    {
      facetAnchor,
      frameAnchor,
      text: text3,
      textAnchor,
      lineAnchor,
      fontVariant,
      rotate: tickRotate,
      y: y4,
      ...options,
      dx: anchor === "left" ? +dx - tickSize - tickPadding + +insetLeft : +dx + +tickSize + +tickPadding - insetRight
    },
    function(scale3, data2, ticks2, tickFormat2, channels) {
      if (fontVariant === void 0)
        this.fontVariant = inferFontVariant3(scale3);
      if (text3 === void 0)
        channels.text = inferTextChannel(scale3, data2, ticks2, tickFormat2, anchor);
    }
  );
}
function axisTextKx(k3, anchor, data, {
  facetAnchor = anchor + (k3 === "x" ? "-empty" : ""),
  frameAnchor = anchor,
  tickSize,
  tickRotate = 0,
  tickPadding = Math.max(3, 9 - tickSize) + (Math.abs(tickRotate) >= 10 ? 4 * Math.cos(tickRotate * radians3) : 0),
  text: text3,
  textAnchor = Math.abs(tickRotate) >= 10 ? tickRotate < 0 ^ anchor === "bottom" ? "start" : "end" : "middle",
  lineAnchor = Math.abs(tickRotate) >= 10 ? "middle" : anchor === "bottom" ? "top" : "bottom",
  fontVariant,
  inset: inset2 = 0,
  insetTop = inset2,
  insetBottom = inset2,
  dy = 0,
  x: x4 = k3 === "x" ? void 0 : null,
  ...options
}) {
  return axisMark(
    textX,
    k3,
    data,
    { ariaLabel: `${k3}-axis tick label` },
    {
      facetAnchor,
      frameAnchor,
      text: text3 === void 0 ? null : text3,
      textAnchor,
      lineAnchor,
      fontVariant,
      rotate: tickRotate,
      x: x4,
      ...options,
      dy: anchor === "bottom" ? +dy + +tickSize + +tickPadding - insetBottom : +dy - tickSize - tickPadding + +insetTop
    },
    function(scale3, data2, ticks2, tickFormat2, channels) {
      if (fontVariant === void 0)
        this.fontVariant = inferFontVariant3(scale3);
      if (text3 === void 0)
        channels.text = inferTextChannel(scale3, data2, ticks2, tickFormat2, anchor);
    }
  );
}
function gridY() {
  const [data, options] = maybeData(...arguments);
  return gridKy("y", anchorY2(options), data, options);
}
function gridFy() {
  const [data, options] = maybeData(...arguments);
  return gridKy("fy", anchorFy(options), data, options);
}
function gridX() {
  const [data, options] = maybeData(...arguments);
  return gridKx("x", anchorX2(options), data, options);
}
function gridFx() {
  const [data, options] = maybeData(...arguments);
  return gridKx("fx", anchorFx(options), data, options);
}
function gridKy(k3, anchor, data, {
  y: y4 = k3 === "y" ? void 0 : null,
  x: x4 = null,
  x1: x12 = anchor === "left" ? x4 : null,
  x2: x22 = anchor === "right" ? x4 : null,
  ...options
}) {
  return axisMark(ruleY, k3, data, { ariaLabel: `${k3}-grid`, ariaHidden: true }, { y: y4, x1: x12, x2: x22, ...gridDefaults(options) });
}
function gridKx(k3, anchor, data, {
  x: x4 = k3 === "x" ? void 0 : null,
  y: y4 = null,
  y1: y12 = anchor === "top" ? y4 : null,
  y2: y22 = anchor === "bottom" ? y4 : null,
  ...options
}) {
  return axisMark(ruleX, k3, data, { ariaLabel: `${k3}-grid`, ariaHidden: true }, { x: x4, y1: y12, y2: y22, ...gridDefaults(options) });
}
function gridDefaults({
  color: color3 = "currentColor",
  opacity: opacity2 = 0.1,
  stroke = color3,
  strokeOpacity = opacity2,
  strokeWidth = 1,
  ...options
}) {
  return { stroke, strokeOpacity, strokeWidth, ...options };
}
function labelOptions({
  fill,
  fillOpacity,
  fontFamily,
  fontSize,
  fontStyle,
  fontVariant,
  fontWeight,
  monospace,
  pointerEvents,
  shapeRendering,
  clip = false
}, initializer2) {
  [, fill] = maybeColorChannel(fill);
  [, fillOpacity] = maybeNumberChannel(fillOpacity);
  return {
    facet: "super",
    x: null,
    y: null,
    fill,
    fillOpacity,
    fontFamily,
    fontSize,
    fontStyle,
    fontVariant,
    fontWeight,
    monospace,
    pointerEvents,
    shapeRendering,
    clip,
    initializer: initializer2
  };
}
function axisMark(mark2, k3, data, properties, options, initialize) {
  let channels;
  function axisInitializer(data2, facets, _channels, scales2, dimensions, context) {
    const initializeFacets = data2 == null && (k3 === "fx" || k3 === "fy");
    const { [k3]: scale3 } = scales2;
    if (!scale3)
      throw new Error(`missing scale: ${k3}`);
    const domain = scale3.domain();
    let { interval: interval2, ticks: ticks2, tickFormat: tickFormat2, tickSpacing = k3 === "x" ? 80 : 35 } = options;
    if (typeof ticks2 === "string" && hasTemporalDomain(scale3))
      interval2 = ticks2, ticks2 = void 0;
    if (ticks2 === void 0)
      ticks2 = maybeRangeInterval(interval2, scale3.type) ?? inferTickCount(scale3, tickSpacing);
    if (data2 == null) {
      if (isIterable3(ticks2)) {
        data2 = arrayify2(ticks2);
      } else if (isInterval(ticks2)) {
        data2 = inclusiveRange(ticks2, ...extent(domain));
      } else if (scale3.interval) {
        let interval3 = scale3.interval;
        if (scale3.ticks) {
          const [min5, max4] = extent(domain);
          const n = (max4 - min5) / interval3[intervalDuration];
          interval3 = generalizeTimeInterval(interval3, n / ticks2) ?? interval3;
          data2 = inclusiveRange(interval3, min5, max4);
        } else {
          data2 = domain;
          const n = data2.length;
          interval3 = generalizeTimeInterval(interval3, n / ticks2) ?? interval3;
          if (interval3 !== scale3.interval)
            data2 = inclusiveRange(interval3, ...extent(data2));
        }
        if (interval3 === scale3.interval) {
          const n = Math.round(data2.length / ticks2);
          if (n > 1)
            data2 = data2.filter((d, i) => i % n === 0);
        }
      } else if (scale3.ticks) {
        data2 = scale3.ticks(ticks2);
      } else {
        data2 = domain;
      }
      if (!scale3.ticks && data2.length && data2 !== domain) {
        const domainSet = new InternSet(domain);
        data2 = data2.filter((d) => domainSet.has(d));
        if (!data2.length)
          warn(`Warning: the ${k3}-axis ticks appear to not align with the scale domain, resulting in no ticks. Try different ticks?`);
      }
      if (k3 === "y" || k3 === "x") {
        facets = [range2(data2)];
      } else {
        channels[k3] = { scale: k3, value: identity7 };
      }
    }
    initialize?.call(this, scale3, data2, ticks2, tickFormat2, channels);
    const initializedChannels = Object.fromEntries(
      Object.entries(channels).map(([name2, channel]) => {
        return [name2, { ...channel, value: valueof(data2, channel.value) }];
      })
    );
    if (initializeFacets)
      facets = context.filterFacets(data2, initializedChannels);
    return { data: data2, facets, channels: initializedChannels };
  }
  const basicInitializer = initializer(options).initializer;
  const m2 = mark2(data, initializer({ ...options, initializer: axisInitializer }, basicInitializer));
  if (data == null) {
    channels = m2.channels;
    m2.channels = {};
  } else {
    channels = {};
  }
  if (properties !== void 0)
    Object.assign(m2, properties);
  if (m2.clip === void 0)
    m2.clip = false;
  return m2;
}
function inferTickCount(scale3, tickSpacing) {
  const [min5, max4] = extent(scale3.range());
  return (max4 - min5) / tickSpacing;
}
function inferTextChannel(scale3, data, ticks2, tickFormat2, anchor) {
  return { value: inferTickFormat(scale3, data, ticks2, tickFormat2, anchor) };
}
function inferTickFormat(scale3, data, ticks2, tickFormat2, anchor) {
  return typeof tickFormat2 === "function" ? tickFormat2 : tickFormat2 === void 0 && data && isTemporal(data) ? inferTimeFormat(scale3.type, data, anchor) ?? formatDefault : scale3.tickFormat ? scale3.tickFormat(typeof ticks2 === "number" ? ticks2 : null, tickFormat2) : tickFormat2 === void 0 ? formatDefault : typeof tickFormat2 === "string" ? (isTemporal(scale3.domain()) ? utcFormat : format)(tickFormat2) : constant(tickFormat2);
}
function inclusiveRange(interval2, min5, max4) {
  return interval2.range(min5, interval2.offset(interval2.floor(max4)));
}
var shapeTickBottom = {
  draw(context, l) {
    context.moveTo(0, 0);
    context.lineTo(0, l);
  }
};
var shapeTickTop = {
  draw(context, l) {
    context.moveTo(0, 0);
    context.lineTo(0, -l);
  }
};
var shapeTickLeft = {
  draw(context, l) {
    context.moveTo(0, 0);
    context.lineTo(-l, 0);
  }
};
var shapeTickRight = {
  draw(context, l) {
    context.moveTo(0, 0);
    context.lineTo(l, 0);
  }
};
function inferFontVariant3(scale3) {
  return scale3.bandwidth && !scale3.interval ? void 0 : "tabular-nums";
}
function formatAxisLabel(k3, scale3, { anchor, label: label2 = scale3.label, labelAnchor, labelArrow } = {}) {
  if (label2 == null || label2.inferred && hasTemporalDomain(scale3) && /^(date|time|year)$/i.test(label2))
    return;
  label2 = String(label2);
  if (labelArrow === "auto")
    labelArrow = (!scale3.bandwidth || scale3.interval) && !/[]/.test(label2);
  if (!labelArrow)
    return label2;
  if (labelArrow === true) {
    const order = inferScaleOrder(scale3);
    if (order)
      labelArrow = /x$/.test(k3) || labelAnchor === "center" ? /x$/.test(k3) === order < 0 ? "left" : "right" : order < 0 ? "up" : "down";
  }
  switch (labelArrow) {
    case "left":
      return `\u2190 ${label2}`;
    case "right":
      return `${label2} \u2192`;
    case "up":
      return anchor === "right" ? `${label2} \u2191` : `\u2191 ${label2}`;
    case "down":
      return anchor === "right" ? `${label2} \u2193` : `\u2193 ${label2}`;
  }
  return label2;
}
function maybeLabelArrow(labelArrow = "auto") {
  return isNoneish(labelArrow) ? false : typeof labelArrow === "boolean" ? labelArrow : keyword(labelArrow, "labelArrow", ["auto", "up", "right", "down", "left"]);
}
function hasTemporalDomain(scale3) {
  return isTemporal(scale3.domain());
}

// ../../node_modules/@observablehq/plot/src/legends/swatches.js
function maybeScale(scale3, key) {
  if (key == null)
    return key;
  const s2 = scale3(key);
  if (!s2)
    throw new Error(`scale not found: ${key}`);
  return s2;
}
function legendSwatches(color3, { opacity: opacity2, ...options } = {}) {
  if (!isOrdinalScale(color3) && !isThresholdScale(color3))
    throw new Error(`swatches legend requires ordinal or threshold color scale (not ${color3.type})`);
  return legendItems(
    color3,
    options,
    (selection2, scale3, width2, height2) => selection2.append("svg").attr("width", width2).attr("height", height2).attr("fill", scale3.scale).attr("fill-opacity", maybeNumberChannel(opacity2)[1]).append("rect").attr("width", "100%").attr("height", "100%")
  );
}
function legendSymbols(symbol2, {
  fill = symbol2.hint?.fill !== void 0 ? symbol2.hint.fill : "none",
  fillOpacity = 1,
  stroke = symbol2.hint?.stroke !== void 0 ? symbol2.hint.stroke : isNoneish(fill) ? "currentColor" : "none",
  strokeOpacity = 1,
  strokeWidth = 1.5,
  r = 4.5,
  ...options
} = {}, scale3) {
  const [vf, cf] = maybeColorChannel(fill);
  const [vs, cs] = maybeColorChannel(stroke);
  const sf = maybeScale(scale3, vf);
  const ss = maybeScale(scale3, vs);
  const size = r * r * Math.PI;
  fillOpacity = maybeNumberChannel(fillOpacity)[1];
  strokeOpacity = maybeNumberChannel(strokeOpacity)[1];
  strokeWidth = maybeNumberChannel(strokeWidth)[1];
  return legendItems(
    symbol2,
    options,
    (selection2, scale4, width2, height2) => selection2.append("svg").attr("viewBox", "-8 -8 16 16").attr("width", width2).attr("height", height2).attr("fill", vf === "color" ? (d) => sf.scale(d) : cf).attr("fill-opacity", fillOpacity).attr("stroke", vs === "color" ? (d) => ss.scale(d) : cs).attr("stroke-opacity", strokeOpacity).attr("stroke-width", strokeWidth).append("path").attr("d", (d) => {
      const p2 = pathRound();
      symbol2.scale(d).draw(p2, size);
      return p2;
    })
  );
}
function legendItems(scale3, options = {}, swatch) {
  let {
    columns,
    tickFormat: tickFormat2,
    fontVariant = inferFontVariant(scale3),
    // TODO label,
    swatchSize = 15,
    swatchWidth = swatchSize,
    swatchHeight = swatchSize,
    marginLeft: marginLeft2 = 0,
    className,
    style: style2,
    width: width2
  } = options;
  const context = createContext(options);
  className = maybeClassName(className);
  tickFormat2 = inferTickFormat(scale3.scale, scale3.domain, void 0, tickFormat2);
  const swatches = create3("div", context).attr(
    "class",
    `${className}-swatches ${className}-swatches-${columns != null ? "columns" : "wrap"}`
  );
  let extraStyle;
  if (columns != null) {
    extraStyle = `:where(.${className}-swatches-columns .${className}-swatch) {
  display: flex;
  align-items: center;
  break-inside: avoid;
  padding-bottom: 1px;
}
:where(.${className}-swatches-columns .${className}-swatch::before) {
  flex-shrink: 0;
}
:where(.${className}-swatches-columns .${className}-swatch-label) {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}`;
    swatches.style("columns", columns).selectAll().data(scale3.domain).enter().append("div").attr("class", `${className}-swatch`).call(swatch, scale3, swatchWidth, swatchHeight).call(
      (item) => item.append("div").attr("class", `${className}-swatch-label`).attr("title", tickFormat2).text(tickFormat2)
    );
  } else {
    extraStyle = `:where(.${className}-swatches-wrap) {
  display: flex;
  align-items: center;
  min-height: 33px;
  flex-wrap: wrap;
}
:where(.${className}-swatches-wrap .${className}-swatch) {
  display: inline-flex;
  align-items: center;
  margin-right: 1em;
}`;
    swatches.selectAll().data(scale3.domain).enter().append("span").attr("class", `${className}-swatch`).call(swatch, scale3, swatchWidth, swatchHeight).append(function() {
      return this.ownerDocument.createTextNode(tickFormat2.apply(this, arguments));
    });
  }
  return swatches.call(
    (div) => div.insert("style", "*").text(
      `:where(.${className}-swatches) {
  font-family: system-ui, sans-serif;
  font-size: 10px;
  margin-bottom: 0.5em;
}
:where(.${className}-swatch > svg) {
  margin-right: 0.5em;
  overflow: visible;
}
${extraStyle}`
    )
  ).style("margin-left", marginLeft2 ? `${+marginLeft2}px` : null).style("width", width2 === void 0 ? null : `${+width2}px`).style("font-variant", impliedString(fontVariant, "normal")).call(applyInlineStyles, style2).node();
}

// ../../node_modules/@observablehq/plot/src/legends.js
var legendRegistry = /* @__PURE__ */ new Map([
  ["symbol", legendSymbols],
  ["color", legendColor],
  ["opacity", legendOpacity]
]);
function legend(options = {}) {
  for (const [key, value] of legendRegistry) {
    const scale3 = options[key];
    if (isScaleOptions(scale3)) {
      const context = createContext(options);
      let hint;
      if (key === "symbol") {
        const { fill, stroke = fill === void 0 && isScaleOptions(options.color) ? "color" : void 0 } = options;
        hint = { fill, stroke };
      }
      return value(
        normalizeScale(key, scale3, hint),
        legendOptions(context, scale3, options),
        (key2) => isScaleOptions(options[key2]) ? normalizeScale(key2, options[key2]) : null
      );
    }
  }
  throw new Error("unknown legend type; no scale found");
}
function exposeLegends(scales2, context, defaults23 = {}) {
  return (key, options) => {
    if (!legendRegistry.has(key))
      throw new Error(`unknown legend type: ${key}`);
    if (!(key in scales2))
      return;
    return legendRegistry.get(key)(scales2[key], legendOptions(context, defaults23[key], options), (key2) => scales2[key2]);
  };
}
function legendOptions({ className, ...context }, { label: label2, ticks: ticks2, tickFormat: tickFormat2 } = {}, options) {
  return inherit2(options, { className, ...context }, { label: label2, ticks: ticks2, tickFormat: tickFormat2 });
}
function legendColor(color3, { legend: legend3 = true, ...options }) {
  if (legend3 === true)
    legend3 = color3.type === "ordinal" ? "swatches" : "ramp";
  if (color3.domain === void 0)
    return;
  switch (`${legend3}`.toLowerCase()) {
    case "swatches":
      return legendSwatches(color3, options);
    case "ramp":
      return legendRamp(color3, options);
    default:
      throw new Error(`unknown legend type: ${legend3}`);
  }
}
function legendOpacity({ type: type2, interpolate, ...scale3 }, { legend: legend3 = true, color: color3 = rgb(0, 0, 0), ...options }) {
  if (!interpolate)
    throw new Error(`${type2} opacity scales are not supported`);
  if (legend3 === true)
    legend3 = "ramp";
  if (`${legend3}`.toLowerCase() !== "ramp")
    throw new Error(`${legend3} opacity legends are not supported`);
  return legendColor({ type: type2, ...scale3, interpolate: interpolateOpacity(color3) }, { legend: legend3, ...options });
}
function interpolateOpacity(color3) {
  const { r, g: g2, b: b2 } = rgb(color3) || rgb(0, 0, 0);
  return (t) => `rgba(${r},${g2},${b2},${t})`;
}
function createLegends(scales2, context, options) {
  const legends = [];
  for (const [key, value] of legendRegistry) {
    const o = options[key];
    if (o?.legend && key in scales2) {
      const legend3 = value(scales2[key], legendOptions(context, scales2[key], o), (key2) => scales2[key2]);
      if (legend3 != null)
        legends.push(legend3);
    }
  }
  return legends;
}

// ../../node_modules/@observablehq/plot/src/marks/frame.js
var defaults4 = {
  ariaLabel: "frame",
  fill: "none",
  stroke: "currentColor",
  clip: false
};
var lineDefaults = {
  ariaLabel: "frame",
  fill: null,
  stroke: "currentColor",
  strokeLinecap: "square",
  clip: false
};
var Frame = class extends Mark {
  constructor(options = {}) {
    const {
      anchor = null,
      inset: inset2 = 0,
      insetTop = inset2,
      insetRight = inset2,
      insetBottom = inset2,
      insetLeft = inset2,
      rx,
      ry
    } = options;
    super(singleton, void 0, options, anchor == null ? defaults4 : lineDefaults);
    this.anchor = maybeKeyword(anchor, "anchor", ["top", "right", "bottom", "left"]);
    this.insetTop = number5(insetTop);
    this.insetRight = number5(insetRight);
    this.insetBottom = number5(insetBottom);
    this.insetLeft = number5(insetLeft);
    this.rx = number5(rx);
    this.ry = number5(ry);
  }
  render(index2, scales2, channels, dimensions, context) {
    const { marginTop: marginTop2, marginRight: marginRight2, marginBottom: marginBottom2, marginLeft: marginLeft2, width: width2, height: height2 } = dimensions;
    const { anchor, insetTop, insetRight, insetBottom, insetLeft, rx, ry } = this;
    const x12 = marginLeft2 + insetLeft;
    const x22 = width2 - marginRight2 - insetRight;
    const y12 = marginTop2 + insetTop;
    const y22 = height2 - marginBottom2 - insetBottom;
    return create3(anchor ? "svg:line" : "svg:rect", context).datum(0).call(applyIndirectStyles, this, dimensions, context).call(applyDirectStyles, this).call(applyChannelStyles, this, channels).call(applyTransform, this, {}).call(
      anchor === "left" ? (line3) => line3.attr("x1", x12).attr("x2", x12).attr("y1", y12).attr("y2", y22) : anchor === "right" ? (line3) => line3.attr("x1", x22).attr("x2", x22).attr("y1", y12).attr("y2", y22) : anchor === "top" ? (line3) => line3.attr("x1", x12).attr("x2", x22).attr("y1", y12).attr("y2", y12) : anchor === "bottom" ? (line3) => line3.attr("x1", x12).attr("x2", x22).attr("y1", y22).attr("y2", y22) : (rect3) => rect3.attr("x", x12).attr("y", y12).attr("width", x22 - x12).attr("height", y22 - y12).attr("rx", rx).attr("ry", ry)
    ).node();
  }
};
function frame2(options) {
  return new Frame(options);
}

// ../../node_modules/@observablehq/plot/src/marks/tip.js
var defaults5 = {
  ariaLabel: "tip",
  fill: "var(--plot-background)",
  stroke: "currentColor"
};
var ignoreChannels = /* @__PURE__ */ new Set(["geometry", "href", "src", "ariaLabel", "scales"]);
var Tip = class extends Mark {
  constructor(data, options = {}) {
    if (options.tip)
      options = { ...options, tip: false };
    if (options.title === void 0 && isIterable3(data) && isTextual(data))
      options = { ...options, title: identity7 };
    const {
      x: x4,
      y: y4,
      x1: x12,
      x2: x22,
      y1: y12,
      y2: y22,
      anchor,
      preferredAnchor = "bottom",
      monospace,
      fontFamily = monospace ? "ui-monospace, monospace" : void 0,
      fontSize,
      fontStyle,
      fontVariant,
      fontWeight,
      lineHeight = 1,
      lineWidth = 20,
      frameAnchor,
      format: format3,
      textAnchor = "start",
      textOverflow,
      textPadding = 8,
      title,
      pointerSize = 12,
      pathFilter = "drop-shadow(0 3px 4px rgba(0,0,0,0.2))"
    } = options;
    super(
      data,
      {
        x: { value: x12 != null && x22 != null ? null : x4, scale: "x", optional: true },
        // ignore midpoint
        y: { value: y12 != null && y22 != null ? null : y4, scale: "y", optional: true },
        // ignore midpoint
        x1: { value: x12, scale: "x", optional: x22 == null },
        y1: { value: y12, scale: "y", optional: y22 == null },
        x2: { value: x22, scale: "x", optional: x12 == null },
        y2: { value: y22, scale: "y", optional: y12 == null },
        title: { value: title, optional: true }
        // filter: defined
      },
      options,
      defaults5
    );
    this.anchor = maybeAnchor(anchor, "anchor");
    this.preferredAnchor = maybeAnchor(preferredAnchor, "preferredAnchor");
    this.frameAnchor = maybeFrameAnchor(frameAnchor);
    this.textAnchor = impliedString(textAnchor, "middle");
    this.textPadding = +textPadding;
    this.pointerSize = +pointerSize;
    this.pathFilter = string(pathFilter);
    this.lineHeight = +lineHeight;
    this.lineWidth = +lineWidth;
    this.textOverflow = maybeTextOverflow(textOverflow);
    this.monospace = !!monospace;
    this.fontFamily = string(fontFamily);
    this.fontSize = number5(fontSize);
    this.fontStyle = string(fontStyle);
    this.fontVariant = string(fontVariant);
    this.fontWeight = string(fontWeight);
    for (const key in defaults5)
      if (key in this.channels)
        this[key] = defaults5[key];
    this.splitLines = splitter2(this);
    this.clipLine = clipper(this);
    this.format = { ...format3 };
  }
  render(index2, scales2, values2, dimensions, context) {
    const mark2 = this;
    const { x: x4, y: y4, fx, fy } = scales2;
    const { ownerSVGElement: svg, document: document2 } = context;
    const { anchor, monospace, lineHeight, lineWidth } = this;
    const { textPadding: r, pointerSize: m2, pathFilter } = this;
    const { marginTop: marginTop2, marginLeft: marginLeft2 } = dimensions;
    const { x1: X13, y1: Y13, x2: X24, y2: Y24, x: X3 = X13 ?? X24, y: Y3 = Y13 ?? Y24 } = values2;
    const ox2 = fx ? fx(index2.fx) - marginLeft2 : 0;
    const oy2 = fy ? fy(index2.fy) - marginTop2 : 0;
    const [cx, cy] = applyFrameAnchor(this, dimensions);
    const px = anchorX(values2, cx);
    const py = anchorY(values2, cy);
    const widthof2 = monospace ? monospaceWidth : defaultWidth;
    const ee2 = widthof2(ellipsis);
    let sources, format3;
    if ("title" in values2) {
      sources = values2.channels;
      format3 = formatTitle;
    } else {
      sources = getSourceChannels.call(this, values2, scales2);
      format3 = formatChannels;
    }
    const g2 = create3("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyIndirectTextStyles, this).call(applyTransform, this, { x: X3 && x4, y: Y3 && y4 }).call(
      (g3) => g3.selectAll().data(index2).enter().append("g").attr("transform", (i) => `translate(${Math.round(px(i))},${Math.round(py(i))})`).call(applyDirectStyles, this).call((g4) => g4.append("path").attr("filter", pathFilter)).call(
        (g4) => g4.append("text").each(function(i) {
          const that = select_default2(this);
          this.setAttribute("fill", "currentColor");
          this.setAttribute("fill-opacity", 1);
          this.setAttribute("stroke", "none");
          const lines = format3.call(mark2, i, index2, sources, scales2, values2);
          if (typeof lines === "string") {
            for (const line3 of mark2.splitLines(lines)) {
              renderLine(that, { value: mark2.clipLine(line3) });
            }
          } else {
            const labels = /* @__PURE__ */ new Set();
            for (const line3 of lines) {
              const { label: label2 = "" } = line3;
              if (label2 && labels.has(label2))
                continue;
              else
                labels.add(label2);
              renderLine(that, line3);
            }
          }
        })
      )
    );
    function renderLine(selection2, { label: label2, value, color: color3, opacity: opacity2 }) {
      label2 ??= "", value ??= "";
      const swatch = color3 != null || opacity2 != null;
      let title;
      let w = lineWidth * 100;
      const [j2] = cut(label2, w, widthof2, ee2);
      if (j2 >= 0) {
        label2 = label2.slice(0, j2).trimEnd() + ellipsis;
        title = value.trim();
        value = "";
      } else {
        if (label2 || !value && !swatch)
          value = " " + value;
        const [k3] = cut(value, w - widthof2(label2), widthof2, ee2);
        if (k3 >= 0) {
          title = value.trim();
          value = value.slice(0, k3).trimEnd() + ellipsis;
        }
      }
      const line3 = selection2.append("tspan").attr("x", 0).attr("dy", `${lineHeight}em`).text("\u200B");
      if (label2)
        line3.append("tspan").attr("font-weight", "bold").text(label2);
      if (value)
        line3.append(() => document2.createTextNode(value));
      if (swatch)
        line3.append("tspan").text(" \u25A0").attr("fill", color3).attr("fill-opacity", opacity2).style("user-select", "none");
      if (title)
        line3.append("title").text(title);
    }
    function postrender() {
      const { width: width2, height: height2 } = dimensions.facet ?? dimensions;
      g2.selectChildren().each(function(i) {
        let { x: tx, width: w, height: h2 } = this.getBBox();
        w = Math.round(w), h2 = Math.round(h2);
        let a3 = anchor;
        if (a3 === void 0) {
          const x5 = px(i) + ox2;
          const y5 = py(i) + oy2;
          const fitLeft = x5 + w + m2 + r * 2 < width2;
          const fitRight = x5 - w - m2 - r * 2 > 0;
          const fitTop = y5 + h2 + m2 + r * 2 < height2;
          const fitBottom = y5 - h2 - m2 - r * 2 > 0;
          a3 = fitLeft && fitRight ? fitTop && fitBottom ? mark2.preferredAnchor : fitBottom ? "bottom" : "top" : fitTop && fitBottom ? fitLeft ? "left" : "right" : (fitLeft || fitRight) && (fitTop || fitBottom) ? `${fitBottom ? "bottom" : "top"}-${fitLeft ? "left" : "right"}` : mark2.preferredAnchor;
        }
        const path2 = this.firstChild;
        const text3 = this.lastChild;
        path2.setAttribute("d", getPath(a3, m2, r, w, h2));
        if (tx)
          for (const t of text3.childNodes)
            t.setAttribute("x", -tx);
        text3.setAttribute("y", `${+getLineOffset(a3, text3.childNodes.length, lineHeight).toFixed(6)}em`);
        text3.setAttribute("transform", `translate(${getTextTranslate(a3, m2, r, w, h2)})`);
      });
      g2.attr("visibility", null);
    }
    if (index2.length) {
      g2.attr("visibility", "hidden");
      if (svg.isConnected)
        Promise.resolve().then(postrender);
      else if (typeof requestAnimationFrame !== "undefined")
        requestAnimationFrame(postrender);
    }
    return g2.node();
  }
};
function tip(data, { x: x4, y: y4, ...options } = {}) {
  if (options.frameAnchor === void 0)
    [x4, y4] = maybeTuple(x4, y4);
  return new Tip(data, { ...options, x: x4, y: y4 });
}
function getLineOffset(anchor, length4, lineHeight) {
  return /^top(?:-|$)/.test(anchor) ? 0.94 - lineHeight : /^bottom(?:-|$)/ ? -0.29 - length4 * lineHeight : length4 / 2 * lineHeight;
}
function getTextTranslate(anchor, m2, r, width2, height2) {
  switch (anchor) {
    case "middle":
      return [-width2 / 2, height2 / 2];
    case "top-left":
      return [r, m2 + r];
    case "top":
      return [-width2 / 2, m2 / 2 + r];
    case "top-right":
      return [-width2 - r, m2 + r];
    case "right":
      return [-m2 / 2 - width2 - r, height2 / 2];
    case "bottom-left":
      return [r, -m2 - r];
    case "bottom":
      return [-width2 / 2, -m2 / 2 - r];
    case "bottom-right":
      return [-width2 - r, -m2 - r];
    case "left":
      return [r + m2 / 2, height2 / 2];
  }
}
function getPath(anchor, m2, r, width2, height2) {
  const w = width2 + r * 2;
  const h2 = height2 + r * 2;
  switch (anchor) {
    case "middle":
      return `M${-w / 2},${-h2 / 2}h${w}v${h2}h${-w}z`;
    case "top-left":
      return `M0,0l${m2},${m2}h${w - m2}v${h2}h${-w}z`;
    case "top":
      return `M0,0l${m2 / 2},${m2 / 2}h${(w - m2) / 2}v${h2}h${-w}v${-h2}h${(w - m2) / 2}z`;
    case "top-right":
      return `M0,0l${-m2},${m2}h${m2 - w}v${h2}h${w}z`;
    case "right":
      return `M0,0l${-m2 / 2},${-m2 / 2}v${m2 / 2 - h2 / 2}h${-w}v${h2}h${w}v${m2 / 2 - h2 / 2}z`;
    case "bottom-left":
      return `M0,0l${m2},${-m2}h${w - m2}v${-h2}h${-w}z`;
    case "bottom":
      return `M0,0l${m2 / 2},${-m2 / 2}h${(w - m2) / 2}v${-h2}h${-w}v${h2}h${(w - m2) / 2}z`;
    case "bottom-right":
      return `M0,0l${-m2},${-m2}h${m2 - w}v${-h2}h${w}z`;
    case "left":
      return `M0,0l${m2 / 2},${-m2 / 2}v${m2 / 2 - h2 / 2}h${w}v${h2}h${-w}v${m2 / 2 - h2 / 2}z`;
  }
}
function getSourceChannels({ channels }, scales2) {
  const sources = {};
  let format3 = this.format;
  format3 = maybeExpandPairedFormat(format3, channels, "x");
  format3 = maybeExpandPairedFormat(format3, channels, "y");
  this.format = format3;
  for (const key in format3) {
    const value = format3[key];
    if (value === null || value === false) {
      continue;
    } else if (key === "fx" || key === "fy") {
      sources[key] = true;
    } else {
      const source = getSource(channels, key);
      if (source)
        sources[key] = source;
    }
  }
  for (const key in channels) {
    if (key in sources || key in format3 || ignoreChannels.has(key))
      continue;
    const source = getSource(channels, key);
    if (source)
      sources[key] = source;
  }
  if (this.facet) {
    if (scales2.fx && !("fx" in format3))
      sources.fx = true;
    if (scales2.fy && !("fy" in format3))
      sources.fy = true;
  }
  for (const key in sources) {
    const format4 = this.format[key];
    if (typeof format4 === "string") {
      const value = sources[key]?.value ?? scales2[key]?.domain() ?? [];
      this.format[key] = (isTemporal(value) ? utcFormat : format)(format4);
    } else if (format4 === void 0 || format4 === true) {
      const scale3 = scales2[key];
      this.format[key] = scale3?.bandwidth ? inferTickFormat(scale3, scale3.domain()) : formatDefault;
    }
  }
  return sources;
}
function maybeExpandPairedFormat(format3, channels, key) {
  if (!(key in format3))
    return format3;
  const key1 = `${key}1`;
  const key2 = `${key}2`;
  if ((key1 in format3 || !(key1 in channels)) && (key2 in format3 || !(key2 in channels)))
    return format3;
  const entries = Object.entries(format3);
  const value = format3[key];
  entries.splice(entries.findIndex(([name2]) => name2 === key) + 1, 0, [key1, value], [key2, value]);
  return Object.fromEntries(entries);
}
function formatTitle(i, index2, { title }) {
  return formatDefault(title.value[i], i);
}
function* formatChannels(i, index2, channels, scales2, values2) {
  for (const key in channels) {
    if (key === "fx" || key === "fy") {
      yield {
        label: formatLabel(scales2, channels, key),
        value: this.format[key](index2[key], i)
      };
      continue;
    }
    if (key === "x1" && "x2" in channels)
      continue;
    if (key === "y1" && "y2" in channels)
      continue;
    const channel = channels[key];
    if (key === "x2" && "x1" in channels) {
      yield {
        label: formatPairLabel(scales2, channels, "x"),
        value: formatPair(this.format.x2, channels.x1, channel, i)
      };
    } else if (key === "y2" && "y1" in channels) {
      yield {
        label: formatPairLabel(scales2, channels, "y"),
        value: formatPair(this.format.y2, channels.y1, channel, i)
      };
    } else {
      const value = channel.value[i];
      const scale3 = channel.scale;
      if (!defined(value) && scale3 == null)
        continue;
      yield {
        label: formatLabel(scales2, channels, key),
        value: this.format[key](value, i),
        color: scale3 === "color" ? values2[key][i] : null,
        opacity: scale3 === "opacity" ? values2[key][i] : null
      };
    }
  }
}
function formatPair(formatValue, c1, c22, i) {
  return c22.hint?.length ? `${formatValue(c22.value[i] - c1.value[i], i)}` : `${formatValue(c1.value[i], i)}\u2013${formatValue(c22.value[i], i)}`;
}
function formatPairLabel(scales2, channels, key) {
  const l1 = formatLabel(scales2, channels, `${key}1`, key);
  const l2 = formatLabel(scales2, channels, `${key}2`, key);
  return l1 === l2 ? l1 : `${l1}\u2013${l2}`;
}
function formatLabel(scales2, channels, key, defaultLabel = key) {
  const channel = channels[key];
  const scale3 = scales2[channel?.scale ?? key];
  return String(scale3?.label ?? channel?.label ?? defaultLabel);
}

// ../../node_modules/@observablehq/plot/src/plot.js
function plot(options = {}) {
  const { facet, style: style2, title, subtitle, caption, ariaLabel, ariaDescription } = options;
  const className = maybeClassName(options.className);
  const marks2 = options.marks === void 0 ? [] : flatMarks(options.marks);
  marks2.push(...inferTips(marks2));
  const topFacetState = maybeTopFacet(facet, options);
  const facetStateByMark = /* @__PURE__ */ new Map();
  for (const mark2 of marks2) {
    const facetState = maybeMarkFacet(mark2, topFacetState, options);
    if (facetState)
      facetStateByMark.set(mark2, facetState);
  }
  const channelsByScale = /* @__PURE__ */ new Map();
  if (topFacetState)
    addScaleChannels(channelsByScale, [topFacetState], options);
  addScaleChannels(channelsByScale, facetStateByMark, options);
  const axes = flatMarks(inferAxes(marks2, channelsByScale, options));
  for (const mark2 of axes) {
    const facetState = maybeMarkFacet(mark2, topFacetState, options);
    if (facetState)
      facetStateByMark.set(mark2, facetState);
  }
  marks2.unshift(...axes);
  let facets = createFacets(channelsByScale, options);
  if (facets !== void 0) {
    const topFacetsIndex = topFacetState ? facetFilter(facets, topFacetState) : void 0;
    for (const mark2 of marks2) {
      if (mark2.facet === null || mark2.facet === "super")
        continue;
      const facetState = facetStateByMark.get(mark2);
      if (facetState === void 0)
        continue;
      facetState.facetsIndex = mark2.fx != null || mark2.fy != null ? facetFilter(facets, facetState) : topFacetsIndex;
    }
    const nonEmpty = /* @__PURE__ */ new Set();
    for (const { facetsIndex } of facetStateByMark.values()) {
      facetsIndex?.forEach((index2, i) => {
        if (index2?.length > 0) {
          nonEmpty.add(i);
        }
      });
    }
    facets.forEach(
      0 < nonEmpty.size && nonEmpty.size < facets.length ? (f2, i) => f2.empty = !nonEmpty.has(i) : (f2) => f2.empty = false
    );
    for (const mark2 of marks2) {
      if (mark2.facet === "exclude") {
        const facetState = facetStateByMark.get(mark2);
        if (facetState !== void 0)
          facetState.facetsIndex = facetExclude(facetState.facetsIndex);
      }
    }
  }
  for (const key of registry.keys()) {
    if (isScaleOptions(options[key]) && key !== "fx" && key !== "fy") {
      channelsByScale.set(key, []);
    }
  }
  const stateByMark = /* @__PURE__ */ new Map();
  for (const mark2 of marks2) {
    if (stateByMark.has(mark2))
      throw new Error("duplicate mark; each mark must be unique");
    const { facetsIndex, channels: facetChannels } = facetStateByMark.get(mark2) ?? {};
    const { data, facets: facets2, channels } = mark2.initialize(facetsIndex, facetChannels, options);
    applyScaleTransforms(channels, options);
    stateByMark.set(mark2, { data, facets: facets2, channels });
  }
  const scaleDescriptors = createScales(addScaleChannels(channelsByScale, stateByMark, options), options);
  const dimensions = createDimensions(scaleDescriptors, marks2, options);
  autoScaleRange(scaleDescriptors, dimensions);
  const scales2 = createScaleFunctions(scaleDescriptors);
  const { fx, fy } = scales2;
  const subdimensions = fx || fy ? innerDimensions(scaleDescriptors, dimensions) : dimensions;
  const superdimensions = fx || fy ? actualDimensions(scales2, dimensions) : dimensions;
  const context = createContext(options);
  const document2 = context.document;
  const svg = creator_default("svg").call(document2.documentElement);
  let figure = svg;
  context.ownerSVGElement = svg;
  context.className = className;
  context.projection = createProjection(options, subdimensions);
  context.filterFacets = (data, channels) => {
    return facetFilter(facets, { channels, groups: facetGroups(data, channels) });
  };
  context.getMarkState = (mark2) => {
    const state = stateByMark.get(mark2);
    const facetState = facetStateByMark.get(mark2);
    return { ...state, channels: { ...state.channels, ...facetState?.channels } };
  };
  context.dispatchValue = (value) => {
    if (figure.value === value)
      return;
    figure.value = value;
    figure.dispatchEvent(new Event("input", { bubbles: true }));
  };
  const newByScale = /* @__PURE__ */ new Set();
  for (const [mark2, state] of stateByMark) {
    if (mark2.initializer != null) {
      const dimensions2 = mark2.facet === "super" ? superdimensions : subdimensions;
      const update2 = mark2.initializer(state.data, state.facets, state.channels, scales2, dimensions2, context);
      if (update2.data !== void 0) {
        state.data = update2.data;
      }
      if (update2.facets !== void 0) {
        state.facets = update2.facets;
      }
      if (update2.channels !== void 0) {
        const { fx: fx2, fy: fy2, ...channels } = update2.channels;
        inferChannelScales(channels);
        Object.assign(state.channels, channels);
        for (const channel of Object.values(channels)) {
          const { scale: scale3 } = channel;
          if (scale3 != null && !isPosition(registry.get(scale3))) {
            applyScaleTransform(channel, options);
            newByScale.add(scale3);
          }
        }
        if (fx2 != null || fy2 != null)
          facetStateByMark.set(mark2, true);
      }
    }
  }
  if (newByScale.size) {
    const newChannelsByScale = /* @__PURE__ */ new Map();
    addScaleChannels(newChannelsByScale, stateByMark, options, (key) => newByScale.has(key));
    addScaleChannels(channelsByScale, stateByMark, options, (key) => newByScale.has(key));
    const newScaleDescriptors = inheritScaleLabels(createScales(newChannelsByScale, options), scaleDescriptors);
    const { scales: newExposedScales, ...newScales } = createScaleFunctions(newScaleDescriptors);
    Object.assign(scaleDescriptors, newScaleDescriptors);
    Object.assign(scales2, newScales);
    Object.assign(scales2.scales, newExposedScales);
  }
  let facetDomains, facetTranslate;
  if (facets !== void 0) {
    facetDomains = { x: fx?.domain(), y: fy?.domain() };
    facets = recreateFacets(facets, facetDomains);
    facetTranslate = facetTranslator(fx, fy, dimensions);
  }
  for (const [mark2, state] of stateByMark) {
    state.values = mark2.scale(state.channels, scales2, context);
  }
  const { width: width2, height: height2 } = dimensions;
  select_default2(svg).attr("class", className).attr("fill", "currentColor").attr("font-family", "system-ui, sans-serif").attr("font-size", 10).attr("text-anchor", "middle").attr("width", width2).attr("height", height2).attr("viewBox", `0 0 ${width2} ${height2}`).attr("aria-label", ariaLabel).attr("aria-description", ariaDescription).call(
    (svg2) => (
      // Warning: if you edit this, change defaultClassName.
      svg2.append("style").text(
        `:where(.${className}) {
  --plot-background: white;
  display: block;
  height: auto;
  height: intrinsic;
  max-width: 100%;
}
:where(.${className} text),
:where(.${className} tspan) {
  white-space: pre;
}`
      )
    )
  ).call(applyInlineStyles, style2);
  for (const mark2 of marks2) {
    const { channels, values: values2, facets: indexes2 } = stateByMark.get(mark2);
    if (facets === void 0 || mark2.facet === "super") {
      let index2 = null;
      if (indexes2) {
        index2 = indexes2[0];
        index2 = mark2.filter(index2, channels, values2);
        if (index2.length === 0)
          continue;
      }
      const node = mark2.render(index2, scales2, values2, superdimensions, context);
      if (node == null)
        continue;
      svg.appendChild(node);
    } else {
      let g2;
      for (const f2 of facets) {
        if (!(mark2.facetAnchor?.(facets, facetDomains, f2) ?? !f2.empty))
          continue;
        let index2 = null;
        if (indexes2) {
          const faceted = facetStateByMark.has(mark2);
          index2 = indexes2[faceted ? f2.i : 0];
          index2 = mark2.filter(index2, channels, values2);
          if (index2.length === 0)
            continue;
          if (!faceted && index2 === indexes2[0])
            index2 = subarray(index2);
          index2.fx = f2.x, index2.fy = f2.y, index2.fi = f2.i;
        }
        const node = mark2.render(index2, scales2, values2, subdimensions, context);
        if (node == null)
          continue;
        (g2 ??= select_default2(svg).append("g")).append(() => node).datum(f2);
        for (const name2 of ["aria-label", "aria-description", "aria-hidden", "transform"]) {
          if (node.hasAttribute(name2)) {
            g2.attr(name2, node.getAttribute(name2));
            node.removeAttribute(name2);
          }
        }
      }
      g2?.selectChildren().attr("transform", facetTranslate);
    }
  }
  const legends = createLegends(scaleDescriptors, context, options);
  const { figure: figured = title != null || subtitle != null || caption != null || legends.length > 0 } = options;
  if (figured) {
    figure = document2.createElement("figure");
    figure.className = `${className}-figure`;
    figure.style.maxWidth = "initial";
    if (title != null)
      figure.append(createTitleElement(document2, title, "h2"));
    if (subtitle != null)
      figure.append(createTitleElement(document2, subtitle, "h3"));
    figure.append(...legends, svg);
    if (caption != null)
      figure.append(createFigcaption(document2, caption));
  }
  figure.scale = exposeScales(scales2.scales);
  figure.legend = exposeLegends(scaleDescriptors, context, options);
  const w = consumeWarnings();
  if (w > 0) {
    select_default2(svg).append("text").attr("x", width2).attr("y", 20).attr("dy", "-1em").attr("text-anchor", "end").attr("font-family", "initial").text("\u26A0\uFE0F").append("title").text(`${w.toLocaleString("en-US")} warning${w === 1 ? "" : "s"}. Please check the console.`);
  }
  return figure;
}
function createTitleElement(document2, contents, tag) {
  if (contents.ownerDocument)
    return contents;
  const e = document2.createElement(tag);
  e.append(contents);
  return e;
}
function createFigcaption(document2, caption) {
  const e = document2.createElement("figcaption");
  e.append(caption);
  return e;
}
function plotThis({ marks: marks2 = [], ...options } = {}) {
  return plot({ ...options, marks: [...marks2, this] });
}
Mark.prototype.plot = plotThis;
function flatMarks(marks2) {
  return marks2.flat(Infinity).filter((mark2) => mark2 != null).map(markify);
}
function markify(mark2) {
  return typeof mark2.render === "function" ? mark2 : new Render(mark2);
}
var Render = class extends Mark {
  constructor(render) {
    if (typeof render !== "function")
      throw new TypeError("invalid mark; missing render function");
    super();
    this.render = render;
  }
  render() {
  }
};
function applyScaleTransforms(channels, options) {
  for (const name2 in channels)
    applyScaleTransform(channels[name2], options);
  return channels;
}
function applyScaleTransform(channel, options) {
  const { scale: scale3, transform: t = true } = channel;
  if (scale3 == null || !t)
    return;
  const {
    type: type2,
    percent,
    interval: interval2,
    transform: transform3 = percent ? (x4) => x4 * 100 : maybeIntervalTransform(interval2, type2)
  } = options[scale3] ?? {};
  if (transform3 == null)
    return;
  channel.value = map2(channel.value, transform3);
  channel.transform = false;
}
function inferChannelScales(channels) {
  for (const name2 in channels) {
    inferChannelScale(name2, channels[name2]);
  }
}
function addScaleChannels(channelsByScale, stateByMark, options, filter3 = yes) {
  for (const { channels } of stateByMark.values()) {
    for (const name2 in channels) {
      const channel = channels[name2];
      const { scale: scale3 } = channel;
      if (scale3 != null && filter3(scale3)) {
        if (scale3 === "projection") {
          if (!hasProjection(options)) {
            const gx = options.x?.domain === void 0;
            const gy = options.y?.domain === void 0;
            if (gx || gy) {
              const [x4, y4] = getGeometryChannels(channel);
              if (gx)
                addScaleChannel(channelsByScale, "x", x4);
              if (gy)
                addScaleChannel(channelsByScale, "y", y4);
            }
          }
        } else {
          addScaleChannel(channelsByScale, scale3, channel);
        }
      }
    }
  }
  return channelsByScale;
}
function addScaleChannel(channelsByScale, scale3, channel) {
  const scaleChannels = channelsByScale.get(scale3);
  if (scaleChannels !== void 0)
    scaleChannels.push(channel);
  else
    channelsByScale.set(scale3, [channel]);
}
function maybeTopFacet(facet, options) {
  if (facet == null)
    return;
  const { x: x4, y: y4 } = facet;
  if (x4 == null && y4 == null)
    return;
  const data = arrayify2(facet.data);
  if (data == null)
    throw new Error("missing facet data");
  const channels = {};
  if (x4 != null)
    channels.fx = createChannel(data, { value: x4, scale: "fx" });
  if (y4 != null)
    channels.fy = createChannel(data, { value: y4, scale: "fy" });
  applyScaleTransforms(channels, options);
  const groups2 = facetGroups(data, channels);
  return { channels, groups: groups2, data: facet.data };
}
function maybeMarkFacet(mark2, topFacetState, options) {
  if (mark2.facet === null || mark2.facet === "super")
    return;
  const { fx, fy } = mark2;
  if (fx != null || fy != null) {
    const data2 = arrayify2(mark2.data ?? fx ?? fy);
    if (data2 === void 0)
      throw new Error(`missing facet data in ${mark2.ariaLabel}`);
    if (data2 === null)
      return;
    const channels2 = {};
    if (fx != null)
      channels2.fx = createChannel(data2, { value: fx, scale: "fx" });
    if (fy != null)
      channels2.fy = createChannel(data2, { value: fy, scale: "fy" });
    applyScaleTransforms(channels2, options);
    return { channels: channels2, groups: facetGroups(data2, channels2) };
  }
  if (topFacetState === void 0)
    return;
  const { channels, groups: groups2, data } = topFacetState;
  if (mark2.facet !== "auto" || mark2.data === data)
    return { channels, groups: groups2 };
  if (data.length > 0 && (groups2.size > 1 || groups2.size === 1 && channels.fx && channels.fy && [...groups2][0][1].size > 1) && arrayify2(mark2.data)?.length === data.length) {
    warn(
      `Warning: the ${mark2.ariaLabel} mark appears to use faceted data, but isn\u2019t faceted. The mark data has the same length as the facet data and the mark facet option is "auto", but the mark data and facet data are distinct. If this mark should be faceted, set the mark facet option to true; otherwise, suppress this warning by setting the mark facet option to false.`
    );
  }
}
function derive(mark2, options = {}) {
  return initializer({ ...options, x: null, y: null }, (data, facets, channels, scales2, dimensions, context) => {
    return context.getMarkState(mark2);
  });
}
function inferTips(marks2) {
  const tips = [];
  for (const mark2 of marks2) {
    let tipOptions = mark2.tip;
    if (tipOptions) {
      if (tipOptions === true)
        tipOptions = {};
      else if (typeof tipOptions === "string")
        tipOptions = { pointer: tipOptions };
      let { pointer: p2, preferredAnchor: a3 } = tipOptions;
      p2 = /^x$/i.test(p2) ? pointerX : /^y$/i.test(p2) ? pointerY : pointer;
      tipOptions = p2(derive(mark2, tipOptions));
      tipOptions.title = null;
      if (a3 === void 0)
        tipOptions.preferredAnchor = p2 === pointerY ? "left" : "bottom";
      const t = tip(mark2.data, tipOptions);
      t.facet = mark2.facet;
      t.facetAnchor = mark2.facetAnchor;
      tips.push(t);
    }
  }
  return tips;
}
function inferAxes(marks2, channelsByScale, options) {
  let {
    projection: projection3,
    x: x4 = {},
    y: y4 = {},
    fx = {},
    fy = {},
    axis: axis3,
    grid: grid2,
    facet = {},
    facet: { axis: facetAxis = axis3, grid: facetGrid2 } = facet,
    x: { axis: xAxis2 = axis3, grid: xGrid2 = xAxis2 === null ? null : grid2 } = x4,
    y: { axis: yAxis2 = axis3, grid: yGrid2 = yAxis2 === null ? null : grid2 } = y4,
    fx: { axis: fxAxis2 = facetAxis, grid: fxGrid2 = fxAxis2 === null ? null : facetGrid2 } = fx,
    fy: { axis: fyAxis2 = facetAxis, grid: fyGrid2 = fyAxis2 === null ? null : facetGrid2 } = fy
  } = options;
  if (projection3 || !isScaleOptions(x4) && !hasPositionChannel("x", marks2))
    xAxis2 = xGrid2 = null;
  if (projection3 || !isScaleOptions(y4) && !hasPositionChannel("y", marks2))
    yAxis2 = yGrid2 = null;
  if (!channelsByScale.has("fx"))
    fxAxis2 = fxGrid2 = null;
  if (!channelsByScale.has("fy"))
    fyAxis2 = fyGrid2 = null;
  if (xAxis2 === void 0)
    xAxis2 = !hasAxis(marks2, "x");
  if (yAxis2 === void 0)
    yAxis2 = !hasAxis(marks2, "y");
  if (fxAxis2 === void 0)
    fxAxis2 = !hasAxis(marks2, "fx");
  if (fyAxis2 === void 0)
    fyAxis2 = !hasAxis(marks2, "fy");
  if (xAxis2 === true)
    xAxis2 = "bottom";
  if (yAxis2 === true)
    yAxis2 = "left";
  if (fxAxis2 === true)
    fxAxis2 = xAxis2 === "top" || xAxis2 === null ? "bottom" : "top";
  if (fyAxis2 === true)
    fyAxis2 = yAxis2 === "right" || yAxis2 === null ? "left" : "right";
  const axes = [];
  maybeGrid(axes, fyGrid2, gridFy, fy);
  maybeAxis(axes, fyAxis2, axisFy, "right", "left", facet, fy);
  maybeGrid(axes, fxGrid2, gridFx, fx);
  maybeAxis(axes, fxAxis2, axisFx, "top", "bottom", facet, fx);
  maybeGrid(axes, yGrid2, gridY, y4);
  maybeAxis(axes, yAxis2, axisY, "left", "right", options, y4);
  maybeGrid(axes, xGrid2, gridX, x4);
  maybeAxis(axes, xAxis2, axisX, "bottom", "top", options, x4);
  return axes;
}
function maybeAxis(axes, axis3, axisType, primary, secondary, defaults23, options) {
  if (!axis3)
    return;
  const both = isBoth(axis3);
  options = axisOptions(both ? primary : axis3, defaults23, options);
  const { line: line3 } = options;
  if ((axisType === axisY || axisType === axisX) && line3 && !isNone(line3))
    axes.push(frame2(lineOptions(options)));
  axes.push(axisType(options));
  if (both)
    axes.push(axisType({ ...options, anchor: secondary, label: null }));
}
function maybeGrid(axes, grid2, gridType, options) {
  if (!grid2 || isNone(grid2))
    return;
  axes.push(gridType(gridOptions(grid2, options)));
}
function isBoth(value) {
  return /^\s*both\s*$/i.test(value);
}
function axisOptions(anchor, defaults23, {
  line: line3 = defaults23.line,
  ticks: ticks2,
  tickSize,
  tickSpacing,
  tickPadding,
  tickFormat: tickFormat2,
  tickRotate,
  fontVariant,
  ariaLabel,
  ariaDescription,
  label: label2 = defaults23.label,
  labelAnchor,
  labelArrow = defaults23.labelArrow,
  labelOffset
}) {
  return {
    anchor,
    line: line3,
    ticks: ticks2,
    tickSize,
    tickSpacing,
    tickPadding,
    tickFormat: tickFormat2,
    tickRotate,
    fontVariant,
    ariaLabel,
    ariaDescription,
    label: label2,
    labelAnchor,
    labelArrow,
    labelOffset
  };
}
function lineOptions(options) {
  const { anchor, line: line3 } = options;
  return { anchor, facetAnchor: anchor + "-empty", stroke: line3 === true ? void 0 : line3 };
}
function gridOptions(grid2, {
  stroke = isColor(grid2) ? grid2 : void 0,
  ticks: ticks2 = isGridTicks(grid2) ? grid2 : void 0,
  tickSpacing,
  ariaLabel,
  ariaDescription
}) {
  return {
    stroke,
    ticks: ticks2,
    tickSpacing,
    ariaLabel,
    ariaDescription
  };
}
function isGridTicks(grid2) {
  switch (typeof grid2) {
    case "number":
      return true;
    case "string":
      return !isColor(grid2);
  }
  return isIterable3(grid2) || typeof grid2?.range === "function";
}
function hasAxis(marks2, k3) {
  const prefix2 = `${k3}-axis `;
  return marks2.some((m2) => m2.ariaLabel?.startsWith(prefix2));
}
function hasPositionChannel(k3, marks2) {
  for (const mark2 of marks2) {
    for (const key in mark2.channels) {
      const { scale: scale3 } = mark2.channels[key];
      if (scale3 === k3 || scale3 === "projection") {
        return true;
      }
    }
  }
  return false;
}
function inheritScaleLabels(newScales, scales2) {
  for (const key in newScales) {
    const newScale = newScales[key];
    const scale3 = scales2[key];
    if (newScale.label === void 0 && scale3) {
      newScale.label = scale3.label;
    }
  }
  return newScales;
}
function actualDimensions({ fx, fy }, dimensions) {
  const { marginTop: marginTop2, marginRight: marginRight2, marginBottom: marginBottom2, marginLeft: marginLeft2, width: width2, height: height2 } = outerDimensions(dimensions);
  const fxr = fx && outerRange(fx);
  const fyr = fy && outerRange(fy);
  return {
    marginTop: fy ? fyr[0] : marginTop2,
    marginRight: fx ? width2 - fxr[1] : marginRight2,
    marginBottom: fy ? height2 - fyr[1] : marginBottom2,
    marginLeft: fx ? fxr[0] : marginLeft2,
    // Some marks, namely the x- and y-axis labels, want to know what the
    // desired (rather than actual) margins are for positioning.
    inset: {
      marginTop: dimensions.marginTop,
      marginRight: dimensions.marginRight,
      marginBottom: dimensions.marginBottom,
      marginLeft: dimensions.marginLeft
    },
    width: width2,
    height: height2
  };
}
function outerRange(scale3) {
  const domain = scale3.domain();
  let x12 = scale3(domain[0]);
  let x22 = scale3(domain[domain.length - 1]);
  if (x22 < x12)
    [x12, x22] = [x22, x12];
  return [x12, x22 + scale3.bandwidth()];
}

// ../../node_modules/@observablehq/plot/src/curve.js
var curves = /* @__PURE__ */ new Map([
  ["basis", basis_default2],
  ["basis-closed", basisClosed_default2],
  ["basis-open", basisOpen_default],
  ["bundle", bundle_default],
  ["bump-x", bumpX],
  ["bump-y", bumpY],
  ["cardinal", cardinal_default],
  ["cardinal-closed", cardinalClosed_default],
  ["cardinal-open", cardinalOpen_default],
  ["catmull-rom", catmullRom_default],
  ["catmull-rom-closed", catmullRomClosed_default],
  ["catmull-rom-open", catmullRomOpen_default],
  ["linear", linear_default],
  ["linear-closed", linearClosed_default],
  ["monotone-x", monotoneX],
  ["monotone-y", monotoneY],
  ["natural", natural_default],
  ["step", step_default],
  ["step-after", stepAfter],
  ["step-before", stepBefore]
]);
function maybeCurve(curve = linear_default, tension) {
  if (typeof curve === "function")
    return curve;
  const c4 = curves.get(`${curve}`.toLowerCase());
  if (!c4)
    throw new Error(`unknown curve: ${curve}`);
  if (tension !== void 0) {
    if ("beta" in c4) {
      return c4.beta(tension);
    } else if ("tension" in c4) {
      return c4.tension(tension);
    } else if ("alpha" in c4) {
      return c4.alpha(tension);
    }
  }
  return c4;
}
function maybeCurveAuto(curve = curveAuto, tension) {
  return typeof curve !== "function" && `${curve}`.toLowerCase() === "auto" ? curveAuto : maybeCurve(curve, tension);
}
function curveAuto(context) {
  return linear_default(context);
}

// ../../node_modules/@observablehq/plot/src/transforms/bin.js
function binX(outputs = { y: "count" }, options = {}) {
  [outputs, options] = mergeOptions(outputs, options);
  const { x: x4, y: y4 } = options;
  return binn(maybeBinValue(x4, options, identity7), null, null, y4, outputs, maybeInsetX(options));
}
function binY(outputs = { x: "count" }, options = {}) {
  [outputs, options] = mergeOptions(outputs, options);
  const { x: x4, y: y4 } = options;
  return binn(null, maybeBinValue(y4, options, identity7), x4, null, outputs, maybeInsetY(options));
}
function bin(outputs = { fill: "count" }, options = {}) {
  [outputs, options] = mergeOptions(outputs, options);
  const { x: x4, y: y4 } = maybeBinValueTuple(options);
  return binn(x4, y4, null, null, outputs, maybeInsetX(maybeInsetY(options)));
}
function maybeDenseInterval(bin3, k3, options = {}) {
  if (options?.interval == null)
    return options;
  const { reduce = reduceFirst } = options;
  const outputs = { filter: null };
  if (options[k3] != null)
    outputs[k3] = reduce;
  if (options[`${k3}1`] != null)
    outputs[`${k3}1`] = reduce;
  if (options[`${k3}2`] != null)
    outputs[`${k3}2`] = reduce;
  return bin3(outputs, options);
}
function maybeDenseIntervalX(options = {}) {
  return maybeDenseInterval(binX, "y", withTip(options, "x"));
}
function maybeDenseIntervalY(options = {}) {
  return maybeDenseInterval(binY, "x", withTip(options, "y"));
}
function binn(bx, by, gx, gy, {
  data: reduceData = reduceIdentity,
  // TODO avoid materializing when unused?
  filter: filter3 = reduceCount,
  // return only non-empty bins by default
  sort: sort3,
  reverse: reverse3,
  ...outputs
  // output channel definitions
} = {}, inputs = {}) {
  bx = maybeBin(bx);
  by = maybeBin(by);
  outputs = maybeBinOutputs(outputs, inputs);
  reduceData = maybeBinReduce(reduceData, identity7);
  sort3 = sort3 == null ? void 0 : maybeBinOutput("sort", sort3, inputs);
  filter3 = filter3 == null ? void 0 : maybeBinEvaluator("filter", filter3, inputs);
  if (gx != null && hasOutput(outputs, "x", "x1", "x2"))
    gx = null;
  if (gy != null && hasOutput(outputs, "y", "y1", "y2"))
    gy = null;
  const [BX1, setBX1] = maybeColumn(bx);
  const [BX2, setBX2] = maybeColumn(bx);
  const [BY1, setBY1] = maybeColumn(by);
  const [BY2, setBY2] = maybeColumn(by);
  const [k3, gk] = gx != null ? [gx, "x"] : gy != null ? [gy, "y"] : [];
  const [GK, setGK] = maybeColumn(k3);
  const {
    x: x4,
    y: y4,
    z: z2,
    fill,
    stroke,
    x1: x12,
    x2: x22,
    // consumed if x is an output
    y1: y12,
    y2: y22,
    // consumed if y is an output
    domain,
    cumulative,
    thresholds,
    interval: interval2,
    ...options
  } = inputs;
  const [GZ, setGZ] = maybeColumn(z2);
  const [vfill] = maybeColorChannel(fill);
  const [vstroke] = maybeColorChannel(stroke);
  const [GF, setGF] = maybeColumn(vfill);
  const [GS, setGS] = maybeColumn(vstroke);
  return {
    ..."z" in inputs && { z: GZ || z2 },
    ..."fill" in inputs && { fill: GF || fill },
    ..."stroke" in inputs && { stroke: GS || stroke },
    ...basic(options, (data, facets, plotOptions) => {
      const K3 = maybeApplyInterval(valueof(data, k3), plotOptions?.[gk]);
      const Z3 = valueof(data, z2);
      const F2 = valueof(data, vfill);
      const S2 = valueof(data, vstroke);
      const G = maybeSubgroup(outputs, { z: Z3, fill: F2, stroke: S2 });
      const groupFacets = [];
      const groupData = [];
      const GK2 = K3 && setGK([]);
      const GZ2 = Z3 && setGZ([]);
      const GF2 = F2 && setGF([]);
      const GS2 = S2 && setGS([]);
      const BX12 = bx && setBX1([]);
      const BX22 = bx && setBX2([]);
      const BY12 = by && setBY1([]);
      const BY22 = by && setBY2([]);
      const bin3 = bing(bx, by, data);
      let i = 0;
      for (const o of outputs)
        o.initialize(data);
      if (sort3)
        sort3.initialize(data);
      if (filter3)
        filter3.initialize(data);
      for (const facet of facets) {
        const groupFacet = [];
        for (const o of outputs)
          o.scope("facet", facet);
        if (sort3)
          sort3.scope("facet", facet);
        if (filter3)
          filter3.scope("facet", facet);
        for (const [f2, I2] of maybeGroup(facet, G)) {
          for (const [k4, g2] of maybeGroup(I2, K3)) {
            for (const [b2, extent4] of bin3(g2)) {
              if (G)
                extent4.z = f2;
              if (filter3 && !filter3.reduce(b2, extent4))
                continue;
              groupFacet.push(i++);
              groupData.push(reduceData.reduceIndex(b2, data, extent4));
              if (K3)
                GK2.push(k4);
              if (Z3)
                GZ2.push(G === Z3 ? f2 : Z3[(b2.length > 0 ? b2 : g2)[0]]);
              if (F2)
                GF2.push(G === F2 ? f2 : F2[(b2.length > 0 ? b2 : g2)[0]]);
              if (S2)
                GS2.push(G === S2 ? f2 : S2[(b2.length > 0 ? b2 : g2)[0]]);
              if (BX12)
                BX12.push(extent4.x1), BX22.push(extent4.x2);
              if (BY12)
                BY12.push(extent4.y1), BY22.push(extent4.y2);
              for (const o of outputs)
                o.reduce(b2, extent4);
              if (sort3)
                sort3.reduce(b2, extent4);
            }
          }
        }
        groupFacets.push(groupFacet);
      }
      maybeSort(groupFacets, sort3, reverse3);
      return { data: groupData, facets: groupFacets };
    }),
    ...!hasOutput(outputs, "x") && (BX1 ? { x1: BX1, x2: BX2, x: mid(BX1, BX2) } : { x: x4, x1: x12, x2: x22 }),
    ...!hasOutput(outputs, "y") && (BY1 ? { y1: BY1, y2: BY2, y: mid(BY1, BY2) } : { y: y4, y1: y12, y2: y22 }),
    ...GK && { [gk]: GK },
    ...Object.fromEntries(outputs.map(({ name: name2, output }) => [name2, output]))
  };
}
function mergeOptions({ cumulative, domain, thresholds, interval: interval2, ...outputs }, options) {
  return [outputs, { cumulative, domain, thresholds, interval: interval2, ...options }];
}
function maybeBinValue(value, { cumulative, domain, thresholds, interval: interval2 }, defaultValue) {
  value = { ...maybeValue(value) };
  if (value.domain === void 0)
    value.domain = domain;
  if (value.cumulative === void 0)
    value.cumulative = cumulative;
  if (value.thresholds === void 0)
    value.thresholds = thresholds;
  if (value.interval === void 0)
    value.interval = interval2;
  if (value.value === void 0)
    value.value = defaultValue;
  value.thresholds = maybeThresholds(value.thresholds, value.interval);
  return value;
}
function maybeBinValueTuple(options) {
  let { x: x4, y: y4 } = options;
  x4 = maybeBinValue(x4, options);
  y4 = maybeBinValue(y4, options);
  [x4.value, y4.value] = maybeTuple(x4.value, y4.value);
  return { x: x4, y: y4 };
}
function maybeBin(options) {
  if (options == null)
    return;
  const { value, cumulative, domain = extent, thresholds } = options;
  const bin3 = (data) => {
    let V2 = valueof(data, value);
    let T;
    if (isTemporal(V2) || isTimeThresholds(thresholds)) {
      V2 = map2(V2, coerceDate, Float64Array);
      let [min5, max4] = typeof domain === "function" ? domain(V2) : domain;
      let t = typeof thresholds === "function" && !isInterval(thresholds) ? thresholds(V2, min5, max4) : thresholds;
      if (typeof t === "number")
        t = utcTickInterval(min5, max4, t);
      if (isInterval(t)) {
        if (domain === extent) {
          min5 = t.floor(min5);
          max4 = t.offset(t.floor(max4));
        }
        t = t.range(min5, t.offset(max4));
      }
      T = t;
    } else {
      V2 = coerceNumbers(V2);
      let [min5, max4] = typeof domain === "function" ? domain(V2) : domain;
      let t = typeof thresholds === "function" && !isInterval(thresholds) ? thresholds(V2, min5, max4) : thresholds;
      if (typeof t === "number") {
        if (domain === extent) {
          let step = tickIncrement(min5, max4, t);
          if (isFinite(step)) {
            if (step > 0) {
              let r0 = Math.round(min5 / step);
              let r1 = Math.round(max4 / step);
              if (!(r0 * step <= min5))
                --r0;
              if (!(r1 * step > max4))
                ++r1;
              let n = r1 - r0 + 1;
              t = new Float64Array(n);
              for (let i = 0; i < n; ++i)
                t[i] = (r0 + i) * step;
            } else if (step < 0) {
              step = -step;
              let r0 = Math.round(min5 * step);
              let r1 = Math.round(max4 * step);
              if (!(r0 / step <= min5))
                --r0;
              if (!(r1 / step > max4))
                ++r1;
              let n = r1 - r0 + 1;
              t = new Float64Array(n);
              for (let i = 0; i < n; ++i)
                t[i] = (r0 + i) / step;
            } else {
              t = [min5];
            }
          } else {
            t = [min5];
          }
        } else {
          t = ticks(min5, max4, t);
        }
      } else if (isInterval(t)) {
        if (domain === extent) {
          min5 = t.floor(min5);
          max4 = t.offset(t.floor(max4));
        }
        t = t.range(min5, t.offset(max4));
      }
      T = t;
    }
    const E3 = [];
    if (T.length === 1)
      E3.push([T[0], T[0]]);
    else
      for (let i = 1; i < T.length; ++i)
        E3.push([T[i - 1], T[i]]);
    E3.bin = (cumulative < 0 ? bin1cn : cumulative > 0 ? bin1cp : bin1)(E3, T, V2);
    return E3;
  };
  bin3.label = labelof(value);
  return bin3;
}
function maybeThresholds(thresholds, interval2, defaultThresholds = thresholdAuto) {
  if (thresholds === void 0) {
    return interval2 === void 0 ? defaultThresholds : maybeRangeInterval(interval2);
  }
  if (typeof thresholds === "string") {
    switch (thresholds.toLowerCase()) {
      case "freedman-diaconis":
        return thresholdFreedmanDiaconis;
      case "scott":
        return thresholdScott;
      case "sturges":
        return thresholdSturges;
      case "auto":
        return thresholdAuto;
    }
    return maybeUtcInterval(thresholds);
  }
  return thresholds;
}
function maybeBinOutputs(outputs, inputs) {
  return maybeOutputs(outputs, inputs, maybeBinOutput);
}
function maybeBinOutput(name2, reduce, inputs) {
  return maybeOutput(name2, reduce, inputs, maybeBinEvaluator);
}
function maybeBinEvaluator(name2, reduce, inputs) {
  return maybeEvaluator(name2, reduce, inputs, maybeBinReduce);
}
function maybeBinReduce(reduce, value) {
  return maybeReduce(reduce, value, maybeBinReduceFallback);
}
function maybeBinReduceFallback(reduce) {
  switch (`${reduce}`.toLowerCase()) {
    case "x":
      return reduceX2;
    case "x1":
      return reduceX1;
    case "x2":
      return reduceX22;
    case "y":
      return reduceY2;
    case "y1":
      return reduceY1;
    case "y2":
      return reduceY22;
    case "z":
      return reduceZ;
  }
  throw new Error(`invalid bin reduce: ${reduce}`);
}
function thresholdAuto(values2, min5, max4) {
  return Math.min(200, thresholdScott(values2, min5, max4));
}
function isTimeThresholds(t) {
  return isTimeInterval(t) || isIterable3(t) && isTemporal(t);
}
function bing(bx, by, data) {
  const EX = bx?.(data);
  const EY = by?.(data);
  return EX && EY ? function* (I2) {
    const X3 = EX.bin(I2);
    for (const [ix, [x12, x22]] of EX.entries()) {
      const Y3 = EY.bin(X3[ix]);
      for (const [iy, [y12, y22]] of EY.entries()) {
        yield [Y3[iy], { data, x1: x12, y1: y12, x2: x22, y2: y22 }];
      }
    }
  } : EX ? function* (I2) {
    const X3 = EX.bin(I2);
    for (const [i, [x12, x22]] of EX.entries()) {
      yield [X3[i], { data, x1: x12, x2: x22 }];
    }
  } : function* (I2) {
    const Y3 = EY.bin(I2);
    for (const [i, [y12, y22]] of EY.entries()) {
      yield [Y3[i], { data, y1: y12, y2: y22 }];
    }
  };
}
function bin1(E3, T, V2) {
  T = coerceNumbers(T);
  return (I2) => {
    const B3 = E3.map(() => []);
    for (const i of I2)
      B3[bisect_default(T, V2[i]) - 1]?.push(i);
    return B3;
  };
}
function bin1cp(E3, T, V2) {
  const bin3 = bin1(E3, T, V2);
  return (I2) => {
    const B3 = bin3(I2);
    for (let i = 1, n = B3.length; i < n; ++i) {
      const C3 = B3[i - 1];
      const b2 = B3[i];
      for (const j2 of C3)
        b2.push(j2);
    }
    return B3;
  };
}
function bin1cn(E3, T, V2) {
  const bin3 = bin1(E3, T, V2);
  return (I2) => {
    const B3 = bin3(I2);
    for (let i = B3.length - 2; i >= 0; --i) {
      const C3 = B3[i + 1];
      const b2 = B3[i];
      for (const j2 of C3)
        b2.push(j2);
    }
    return B3;
  };
}
function mid1(x12, x22) {
  const m2 = (+x12 + +x22) / 2;
  return x12 instanceof Date ? new Date(m2) : m2;
}
var reduceX2 = {
  reduceIndex(I2, X3, { x1: x12, x2: x22 }) {
    return mid1(x12, x22);
  }
};
var reduceY2 = {
  reduceIndex(I2, X3, { y1: y12, y2: y22 }) {
    return mid1(y12, y22);
  }
};
var reduceX1 = {
  reduceIndex(I2, X3, { x1: x12 }) {
    return x12;
  }
};
var reduceX22 = {
  reduceIndex(I2, X3, { x2: x22 }) {
    return x22;
  }
};
var reduceY1 = {
  reduceIndex(I2, X3, { y1: y12 }) {
    return y12;
  }
};
var reduceY22 = {
  reduceIndex(I2, X3, { y2: y22 }) {
    return y22;
  }
};

// ../../node_modules/@observablehq/plot/src/transforms/identity.js
function maybeIdentityX(options = {}) {
  return hasX(options) ? options : { ...options, x: identity7 };
}
function maybeIdentityY(options = {}) {
  return hasY(options) ? options : { ...options, y: identity7 };
}

// ../../node_modules/@observablehq/plot/src/transforms/exclusiveFacets.js
function exclusiveFacets(data, facets) {
  if (facets.length === 1)
    return { data, facets };
  const n = data.length;
  const O2 = new Uint8Array(n);
  let overlaps = 0;
  for (const facet of facets) {
    for (const i of facet) {
      if (O2[i])
        ++overlaps;
      O2[i] = 1;
    }
  }
  if (overlaps === 0)
    return { data, facets };
  data = slice3(data);
  const R2 = data[reindex] = new Uint32Array(n + overlaps);
  facets = facets.map((facet) => slice3(facet, Uint32Array));
  let j2 = n;
  O2.fill(0);
  for (const facet of facets) {
    for (let k3 = 0, m2 = facet.length; k3 < m2; ++k3) {
      const i = facet[k3];
      if (O2[i])
        facet[k3] = j2, data[j2] = data[i], R2[j2] = i, ++j2;
      else
        R2[i] = i;
      O2[i] = 1;
    }
  }
  return { data, facets };
}

// ../../node_modules/@observablehq/plot/src/transforms/stack.js
function stackX(stackOptions = {}, options = {}) {
  if (arguments.length === 1)
    [stackOptions, options] = mergeOptions2(stackOptions);
  const { y1: y12, y: y4 = y12, x: x4, ...rest } = options;
  const [transform3, Y3, x12, x22] = stack(y4, x4, "y", "x", stackOptions, rest);
  return { ...transform3, y1: y12, y: Y3, x1: x12, x2: x22, x: mid(x12, x22) };
}
function stackX1(stackOptions = {}, options = {}) {
  if (arguments.length === 1)
    [stackOptions, options] = mergeOptions2(stackOptions);
  const { y1: y12, y: y4 = y12, x: x4 } = options;
  const [transform3, Y3, X3] = stack(y4, x4, "y", "x", stackOptions, options);
  return { ...transform3, y1: y12, y: Y3, x: X3 };
}
function stackX2(stackOptions = {}, options = {}) {
  if (arguments.length === 1)
    [stackOptions, options] = mergeOptions2(stackOptions);
  const { y1: y12, y: y4 = y12, x: x4 } = options;
  const [transform3, Y3, , X3] = stack(y4, x4, "y", "x", stackOptions, options);
  return { ...transform3, y1: y12, y: Y3, x: X3 };
}
function stackY(stackOptions = {}, options = {}) {
  if (arguments.length === 1)
    [stackOptions, options] = mergeOptions2(stackOptions);
  const { x1: x12, x: x4 = x12, y: y4, ...rest } = options;
  const [transform3, X3, y12, y22] = stack(x4, y4, "x", "y", stackOptions, rest);
  return { ...transform3, x1: x12, x: X3, y1: y12, y2: y22, y: mid(y12, y22) };
}
function stackY1(stackOptions = {}, options = {}) {
  if (arguments.length === 1)
    [stackOptions, options] = mergeOptions2(stackOptions);
  const { x1: x12, x: x4 = x12, y: y4 } = options;
  const [transform3, X3, Y3] = stack(x4, y4, "x", "y", stackOptions, options);
  return { ...transform3, x1: x12, x: X3, y: Y3 };
}
function stackY2(stackOptions = {}, options = {}) {
  if (arguments.length === 1)
    [stackOptions, options] = mergeOptions2(stackOptions);
  const { x1: x12, x: x4 = x12, y: y4 } = options;
  const [transform3, X3, , Y3] = stack(x4, y4, "x", "y", stackOptions, options);
  return { ...transform3, x1: x12, x: X3, y: Y3 };
}
function maybeStackX({ x: x4, x1: x12, x2: x22, ...options } = {}) {
  options = withTip(options, "y");
  if (x12 === void 0 && x22 === void 0)
    return stackX({ x: x4, ...options });
  [x12, x22] = maybeZero(x4, x12, x22);
  return { ...options, x1: x12, x2: x22 };
}
function maybeStackY({ y: y4, y1: y12, y2: y22, ...options } = {}) {
  options = withTip(options, "x");
  if (y12 === void 0 && y22 === void 0)
    return stackY({ y: y4, ...options });
  [y12, y22] = maybeZero(y4, y12, y22);
  return { ...options, y1: y12, y2: y22 };
}
function mergeOptions2(options) {
  const { offset: offset2, order, reverse: reverse3, ...rest } = options;
  return [{ offset: offset2, order, reverse: reverse3 }, rest];
}
var lengthy = { length: true };
function stack(x4, y4 = one2, kx2, ky2, { offset: offset2, order, reverse: reverse3 }, options) {
  if (y4 === null)
    throw new Error(`stack requires ${ky2}`);
  const z2 = maybeZ(options);
  const [X3, setX] = maybeColumn(x4);
  const [Y13, setY1] = column2(y4);
  const [Y24, setY2] = column2(y4);
  Y13.hint = Y24.hint = lengthy;
  offset2 = maybeOffset(offset2);
  order = maybeOrder2(order, offset2, ky2);
  return [
    basic(options, (data, facets, plotOptions) => {
      ({ data, facets } = exclusiveFacets(data, facets));
      const X4 = x4 == null ? void 0 : setX(maybeApplyInterval(valueof(data, x4), plotOptions?.[kx2]));
      const Y3 = valueof(data, y4, Float64Array);
      const Z3 = valueof(data, z2);
      const compare = order && order(data, X4, Y3, Z3);
      const n = data.length;
      const Y14 = setY1(new Float64Array(n));
      const Y25 = setY2(new Float64Array(n));
      const facetstacks = [];
      for (const facet of facets) {
        const stacks = X4 ? Array.from(group(facet, (i) => X4[i]).values()) : [facet];
        if (compare)
          for (const stack2 of stacks)
            stack2.sort(compare);
        for (const stack2 of stacks) {
          let yn = 0;
          let yp = 0;
          if (reverse3)
            stack2.reverse();
          for (const i of stack2) {
            const y5 = Y3[i];
            if (y5 < 0)
              yn = Y25[i] = (Y14[i] = yn) + y5;
            else if (y5 > 0)
              yp = Y25[i] = (Y14[i] = yp) + y5;
            else
              Y25[i] = Y14[i] = yp;
          }
        }
        facetstacks.push(stacks);
      }
      if (offset2)
        offset2(facetstacks, Y14, Y25, Z3);
      return { data, facets };
    }),
    X3,
    Y13,
    Y24
  ];
}
function maybeOffset(offset2) {
  if (offset2 == null)
    return;
  if (typeof offset2 === "function")
    return offset2;
  switch (`${offset2}`.toLowerCase()) {
    case "expand":
    case "normalize":
      return offsetExpand;
    case "center":
    case "silhouette":
      return offsetCenter;
    case "wiggle":
      return offsetWiggle;
  }
  throw new Error(`unknown offset: ${offset2}`);
}
function extent2(stack2, Y24) {
  let min5 = 0, max4 = 0;
  for (const i of stack2) {
    const y4 = Y24[i];
    if (y4 < min5)
      min5 = y4;
    if (y4 > max4)
      max4 = y4;
  }
  return [min5, max4];
}
function offsetExpand(facetstacks, Y13, Y24) {
  for (const stacks of facetstacks) {
    for (const stack2 of stacks) {
      const [yn, yp] = extent2(stack2, Y24);
      for (const i of stack2) {
        const m2 = 1 / (yp - yn || 1);
        Y13[i] = m2 * (Y13[i] - yn);
        Y24[i] = m2 * (Y24[i] - yn);
      }
    }
  }
}
function offsetCenter(facetstacks, Y13, Y24) {
  for (const stacks of facetstacks) {
    for (const stack2 of stacks) {
      const [yn, yp] = extent2(stack2, Y24);
      for (const i of stack2) {
        const m2 = (yp + yn) / 2;
        Y13[i] -= m2;
        Y24[i] -= m2;
      }
    }
    offsetZero(stacks, Y13, Y24);
  }
  offsetCenterFacets(facetstacks, Y13, Y24);
}
function offsetWiggle(facetstacks, Y13, Y24, Z3) {
  for (const stacks of facetstacks) {
    const prev = new InternMap();
    let y4 = 0;
    for (const stack2 of stacks) {
      let j2 = -1;
      const Fi = stack2.map((i) => Math.abs(Y24[i] - Y13[i]));
      const Df = stack2.map((i) => {
        j2 = Z3 ? Z3[i] : ++j2;
        const value = Y24[i] - Y13[i];
        const diff = prev.has(j2) ? value - prev.get(j2) : 0;
        prev.set(j2, value);
        return diff;
      });
      const Cf1 = [0, ...cumsum(Df)];
      for (const i of stack2) {
        Y13[i] += y4;
        Y24[i] += y4;
      }
      const s1 = sum3(Fi);
      if (s1)
        y4 -= sum3(Fi, (d, i) => (Df[i] / 2 + Cf1[i]) * d) / s1;
    }
    offsetZero(stacks, Y13, Y24);
  }
  offsetCenterFacets(facetstacks, Y13, Y24);
}
function offsetZero(stacks, Y13, Y24) {
  const m2 = min2(stacks, (stack2) => min2(stack2, (i) => Y13[i]));
  for (const stack2 of stacks) {
    for (const i of stack2) {
      Y13[i] -= m2;
      Y24[i] -= m2;
    }
  }
}
function offsetCenterFacets(facetstacks, Y13, Y24) {
  const n = facetstacks.length;
  if (n === 1)
    return;
  const facets = facetstacks.map((stacks) => stacks.flat());
  const m2 = facets.map((I2) => (min2(I2, (i) => Y13[i]) + max2(I2, (i) => Y24[i])) / 2);
  const m0 = min2(m2);
  for (let j2 = 0; j2 < n; j2++) {
    const p2 = m0 - m2[j2];
    for (const i of facets[j2]) {
      Y13[i] += p2;
      Y24[i] += p2;
    }
  }
}
function maybeOrder2(order, offset2, ky2) {
  if (order === void 0 && offset2 === offsetWiggle)
    return orderInsideOut(ascendingDefined2);
  if (order == null)
    return;
  if (typeof order === "string") {
    const negate2 = order.startsWith("-");
    const compare = negate2 ? descendingDefined : ascendingDefined2;
    switch ((negate2 ? order.slice(1) : order).toLowerCase()) {
      case "value":
      case ky2:
        return orderY(compare);
      case "z":
        return orderZ(compare);
      case "sum":
        return orderSum(compare);
      case "appearance":
        return orderAppearance(compare);
      case "inside-out":
        return orderInsideOut(compare);
    }
    return orderAccessor(field(order));
  }
  if (typeof order === "function")
    return (order.length === 1 ? orderAccessor : orderComparator)(order);
  if (Array.isArray(order))
    return orderGiven(order);
  throw new Error(`invalid order: ${order}`);
}
function orderY(compare) {
  return (data, X3, Y3) => (i, j2) => compare(Y3[i], Y3[j2]);
}
function orderZ(compare) {
  return (data, X3, Y3, Z3) => (i, j2) => compare(Z3[i], Z3[j2]);
}
function orderSum(compare) {
  return orderZDomain(
    compare,
    (data, X3, Y3, Z3) => groupSort(
      range2(data),
      (I2) => sum3(I2, (i) => Y3[i]),
      (i) => Z3[i]
    )
  );
}
function orderAppearance(compare) {
  return orderZDomain(
    compare,
    (data, X3, Y3, Z3) => groupSort(
      range2(data),
      (I2) => X3[greatest(I2, (i) => Y3[i])],
      (i) => Z3[i]
    )
  );
}
function orderInsideOut(compare) {
  return orderZDomain(compare, (data, X3, Y3, Z3) => {
    const I2 = range2(data);
    const K3 = groupSort(
      I2,
      (I3) => X3[greatest(I3, (i) => Y3[i])],
      (i) => Z3[i]
    );
    const sums = rollup(
      I2,
      (I3) => sum3(I3, (i) => Y3[i]),
      (i) => Z3[i]
    );
    const Kp = [], Kn = [];
    let s2 = 0;
    for (const k3 of K3) {
      if (s2 < 0) {
        s2 += sums.get(k3);
        Kp.push(k3);
      } else {
        s2 -= sums.get(k3);
        Kn.push(k3);
      }
    }
    return Kn.reverse().concat(Kp);
  });
}
function orderAccessor(f2) {
  return (data) => {
    const O2 = valueof(data, f2);
    return (i, j2) => ascendingDefined2(O2[i], O2[j2]);
  };
}
function orderComparator(f2) {
  return (data) => (i, j2) => f2(data[i], data[j2]);
}
function orderGiven(domain) {
  return orderZDomain(ascendingDefined2, () => domain);
}
function orderZDomain(compare, domain) {
  return (data, X3, Y3, Z3) => {
    if (!Z3)
      throw new Error("missing channel: z");
    const map4 = new InternMap(domain(data, X3, Y3, Z3).map((d, i) => [d, i]));
    return (i, j2) => compare(map4.get(Z3[i]), map4.get(Z3[j2]));
  };
}

// ../../node_modules/@observablehq/plot/src/marks/area.js
var defaults6 = {
  ariaLabel: "area",
  strokeWidth: 1,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeMiterlimit: 1
};
var Area = class extends Mark {
  constructor(data, options = {}) {
    const { x1: x12, y1: y12, x2: x22, y2: y22, z: z2, curve, tension } = options;
    super(
      data,
      {
        x1: { value: x12, scale: "x" },
        y1: { value: y12, scale: "y" },
        x2: { value: x22, scale: "x", optional: true },
        y2: { value: y22, scale: "y", optional: true },
        z: { value: maybeZ(options), optional: true }
      },
      options,
      defaults6
    );
    this.z = z2;
    this.curve = maybeCurve(curve, tension);
  }
  filter(index2) {
    return index2;
  }
  render(index2, scales2, channels, dimensions, context) {
    const { x1: X13, y1: Y13, x2: X24 = X13, y2: Y24 = Y13 } = channels;
    return create3("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales2, 0, 0).call(
      (g2) => g2.selectAll().data(groupIndex(index2, [X13, Y13, X24, Y24], this, channels)).enter().append("path").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, channels).attr(
        "d",
        area_default3().curve(this.curve).defined((i) => i >= 0).x0((i) => X13[i]).y0((i) => Y13[i]).x1((i) => X24[i]).y1((i) => Y24[i])
      )
    ).node();
  }
};
function area(data, options) {
  if (options === void 0)
    return areaY(data, { x: first2, y: second2 });
  return new Area(data, options);
}
function areaX(data, options) {
  const { y: y4 = indexOf, ...rest } = maybeDenseIntervalY(options);
  return new Area(data, maybeStackX(maybeIdentityX({ ...rest, y1: y4, y2: void 0 })));
}
function areaY(data, options) {
  const { x: x4 = indexOf, ...rest } = maybeDenseIntervalX(options);
  return new Area(data, maybeStackY(maybeIdentityY({ ...rest, x1: x4, x2: void 0 })));
}

// ../../node_modules/@observablehq/plot/src/marks/link.js
var defaults7 = {
  ariaLabel: "link",
  fill: "none",
  stroke: "currentColor",
  strokeMiterlimit: 1
};
var Link = class extends Mark {
  constructor(data, options = {}) {
    const { x1: x12, y1: y12, x2: x22, y2: y22, curve, tension } = options;
    super(
      data,
      {
        x1: { value: x12, scale: "x" },
        y1: { value: y12, scale: "y" },
        x2: { value: x22, scale: "x", optional: true },
        y2: { value: y22, scale: "y", optional: true }
      },
      options,
      defaults7
    );
    this.curve = maybeCurveAuto(curve, tension);
    markers(this, options);
  }
  project(channels, values2, context) {
    if (this.curve !== curveAuto) {
      super.project(channels, values2, context);
    }
  }
  render(index2, scales2, channels, dimensions, context) {
    const { x1: X13, y1: Y13, x2: X24 = X13, y2: Y24 = Y13 } = channels;
    const { curve } = this;
    return create3("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales2).call(
      (g2) => g2.selectAll().data(index2).enter().append("path").call(applyDirectStyles, this).attr(
        "d",
        curve === curveAuto && context.projection ? sphereLink(context.projection, X13, Y13, X24, Y24) : (i) => {
          const p2 = pathRound();
          const c4 = curve(p2);
          c4.lineStart();
          c4.point(X13[i], Y13[i]);
          c4.point(X24[i], Y24[i]);
          c4.lineEnd();
          return p2;
        }
      ).call(applyChannelStyles, this, channels).call(applyMarkers, this, channels, context)
    ).node();
  }
};
function sphereLink(projection3, X13, Y13, X24, Y24) {
  const path2 = path_default(projection3);
  X13 = coerceNumbers(X13);
  Y13 = coerceNumbers(Y13);
  X24 = coerceNumbers(X24);
  Y24 = coerceNumbers(Y24);
  return (i) => path2({
    type: "LineString",
    coordinates: [
      [X13[i], Y13[i]],
      [X24[i], Y24[i]]
    ]
  });
}
function link2(data, { x: x4, x1: x12, x2: x22, y: y4, y1: y12, y2: y22, ...options } = {}) {
  [x12, x22] = maybeSameValue(x4, x12, x22);
  [y12, y22] = maybeSameValue(y4, y12, y22);
  return new Link(data, { ...options, x1: x12, x2: x22, y1: y12, y2: y22 });
}
function maybeSameValue(x4, x12, x22) {
  if (x4 === void 0) {
    if (x12 === void 0) {
      if (x22 !== void 0)
        return [x22];
    } else {
      if (x22 === void 0)
        return [x12];
    }
  } else if (x12 === void 0) {
    return x22 === void 0 ? [x4] : [x4, x22];
  } else if (x22 === void 0) {
    return [x4, x12];
  }
  return [x12, x22];
}

// ../../node_modules/@observablehq/plot/src/marks/arrow.js
var defaults8 = {
  ariaLabel: "arrow",
  fill: "none",
  stroke: "currentColor",
  strokeLinecap: "round",
  strokeMiterlimit: 1,
  strokeWidth: 1.5
};
var Arrow = class extends Mark {
  constructor(data, options = {}) {
    const {
      x1: x12,
      y1: y12,
      x2: x22,
      y2: y22,
      bend = 0,
      headAngle = 60,
      headLength = 8,
      // Disable the arrow with headLength = 0; or, use Plot.link.
      inset: inset2 = 0,
      insetStart = inset2,
      insetEnd = inset2,
      sweep
    } = options;
    super(
      data,
      {
        x1: { value: x12, scale: "x" },
        y1: { value: y12, scale: "y" },
        x2: { value: x22, scale: "x", optional: true },
        y2: { value: y22, scale: "y", optional: true }
      },
      options,
      defaults8
    );
    this.bend = bend === true ? 22.5 : Math.max(-90, Math.min(90, bend));
    this.headAngle = +headAngle;
    this.headLength = +headLength;
    this.insetStart = +insetStart;
    this.insetEnd = +insetEnd;
    this.sweep = maybeSweep(sweep);
  }
  render(index2, scales2, channels, dimensions, context) {
    const { x1: X13, y1: Y13, x2: X24 = X13, y2: Y24 = Y13, SW } = channels;
    const { strokeWidth, bend, headAngle, headLength, insetStart, insetEnd } = this;
    const sw = SW ? (i) => SW[i] : constant(strokeWidth === void 0 ? 1 : strokeWidth);
    const wingAngle = headAngle * radians3 / 2;
    const wingScale = headLength / 1.5;
    return create3("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales2).call(
      (g2) => g2.selectAll().data(index2).enter().append("path").call(applyDirectStyles, this).attr("d", (i) => {
        let x12 = X13[i], y12 = Y13[i], x22 = X24[i], y22 = Y24[i];
        const lineLength = Math.hypot(x22 - x12, y22 - y12);
        if (lineLength <= insetStart + insetEnd)
          return null;
        let lineAngle = Math.atan2(y22 - y12, x22 - x12);
        const headLength2 = Math.min(wingScale * sw(i), lineLength / 3);
        const bendAngle = this.sweep(x12, y12, x22, y22) * bend * radians3;
        const r = Math.hypot(lineLength / Math.tan(bendAngle), lineLength) / 2;
        if (insetStart || insetEnd) {
          if (r < 1e5) {
            const sign3 = Math.sign(bendAngle);
            const [cx, cy] = pointPointCenter([x12, y12], [x22, y22], r, sign3);
            if (insetStart) {
              [x12, y12] = circleCircleIntersect([cx, cy, r], [x12, y12, insetStart], -sign3 * Math.sign(insetStart));
            }
            if (insetEnd) {
              const [x5, y5] = circleCircleIntersect([cx, cy, r], [x22, y22, insetEnd], sign3 * Math.sign(insetEnd));
              lineAngle += Math.atan2(y5 - cy, x5 - cx) - Math.atan2(y22 - cy, x22 - cx);
              x22 = x5, y22 = y5;
            }
          } else {
            const dx = x22 - x12, dy = y22 - y12, d = Math.hypot(dx, dy);
            if (insetStart)
              x12 += dx / d * insetStart, y12 += dy / d * insetStart;
            if (insetEnd)
              x22 -= dx / d * insetEnd, y22 -= dy / d * insetEnd;
          }
        }
        const endAngle = lineAngle + bendAngle;
        const leftAngle = endAngle + wingAngle;
        const rightAngle = endAngle - wingAngle;
        const x32 = x22 - headLength2 * Math.cos(leftAngle);
        const y32 = y22 - headLength2 * Math.sin(leftAngle);
        const x4 = x22 - headLength2 * Math.cos(rightAngle);
        const y4 = y22 - headLength2 * Math.sin(rightAngle);
        const a3 = r < 1e5 ? `A${r},${r} 0,0,${bendAngle > 0 ? 1 : 0} ` : `L`;
        const h2 = headLength2 ? `M${x32},${y32}L${x22},${y22}L${x4},${y4}` : "";
        return `M${x12},${y12}${a3}${x22},${y22}${h2}`;
      }).call(applyChannelStyles, this, channels)
    ).node();
  }
};
function maybeSweep(sweep = 1) {
  if (typeof sweep === "number")
    return constant(Math.sign(sweep));
  if (typeof sweep === "function")
    return (x12, y12, x22, y22) => Math.sign(sweep(x12, y12, x22, y22));
  switch (keyword(sweep, "sweep", ["+x", "-x", "+y", "-y"])) {
    case "+x":
      return (x12, y12, x22) => ascending(x12, x22);
    case "-x":
      return (x12, y12, x22) => descending(x12, x22);
    case "+y":
      return (x12, y12, x22, y22) => ascending(y12, y22);
    case "-y":
      return (x12, y12, x22, y22) => descending(y12, y22);
  }
}
function pointPointCenter([ax, ay], [bx, by], r, sign3) {
  const dx = bx - ax, dy = by - ay, d = Math.hypot(dx, dy);
  const k3 = sign3 * Math.sqrt(r * r - d * d / 4) / d;
  return [(ax + bx) / 2 - dy * k3, (ay + by) / 2 + dx * k3];
}
function circleCircleIntersect([ax, ay, ar], [bx, by, br], sign3) {
  const dx = bx - ax, dy = by - ay, d = Math.hypot(dx, dy);
  const x4 = (dx * dx + dy * dy - br * br + ar * ar) / (2 * d);
  const y4 = sign3 * Math.sqrt(ar * ar - x4 * x4);
  return [ax + (dx * x4 + dy * y4) / d, ay + (dy * x4 - dx * y4) / d];
}
function arrow(data, { x: x4, x1: x12, x2: x22, y: y4, y1: y12, y2: y22, ...options } = {}) {
  [x12, x22] = maybeSameValue(x4, x12, x22);
  [y12, y22] = maybeSameValue(y4, y12, y22);
  return new Arrow(data, { ...options, x1: x12, x2: x22, y1: y12, y2: y22 });
}

// ../../node_modules/@observablehq/plot/src/marks/bar.js
var AbstractBar = class extends Mark {
  constructor(data, channels, options = {}, defaults23) {
    super(data, channels, options, defaults23);
    const { inset: inset2 = 0, insetTop = inset2, insetRight = inset2, insetBottom = inset2, insetLeft = inset2, rx, ry } = options;
    this.insetTop = number5(insetTop);
    this.insetRight = number5(insetRight);
    this.insetBottom = number5(insetBottom);
    this.insetLeft = number5(insetLeft);
    this.rx = impliedString(rx, "auto");
    this.ry = impliedString(ry, "auto");
  }
  render(index2, scales2, channels, dimensions, context) {
    const { rx, ry } = this;
    return create3("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(this._transform, this, scales2).call(
      (g2) => g2.selectAll().data(index2).enter().append("rect").call(applyDirectStyles, this).attr("x", this._x(scales2, channels, dimensions)).attr("width", this._width(scales2, channels, dimensions)).attr("y", this._y(scales2, channels, dimensions)).attr("height", this._height(scales2, channels, dimensions)).call(applyAttr, "rx", rx).call(applyAttr, "ry", ry).call(applyChannelStyles, this, channels)
    ).node();
  }
  _x(scales2, { x: X3 }, { marginLeft: marginLeft2 }) {
    const { insetLeft } = this;
    return X3 ? (i) => X3[i] + insetLeft : marginLeft2 + insetLeft;
  }
  _y(scales2, { y: Y3 }, { marginTop: marginTop2 }) {
    const { insetTop } = this;
    return Y3 ? (i) => Y3[i] + insetTop : marginTop2 + insetTop;
  }
  _width({ x: x4 }, { x: X3 }, { marginRight: marginRight2, marginLeft: marginLeft2, width: width2 }) {
    const { insetLeft, insetRight } = this;
    const bandwidth = X3 && x4 ? x4.bandwidth() : width2 - marginRight2 - marginLeft2;
    return Math.max(0, bandwidth - insetLeft - insetRight);
  }
  _height({ y: y4 }, { y: Y3 }, { marginTop: marginTop2, marginBottom: marginBottom2, height: height2 }) {
    const { insetTop, insetBottom } = this;
    const bandwidth = Y3 && y4 ? y4.bandwidth() : height2 - marginTop2 - marginBottom2;
    return Math.max(0, bandwidth - insetTop - insetBottom);
  }
};
var defaults9 = {
  ariaLabel: "bar"
};
var BarX = class extends AbstractBar {
  constructor(data, options = {}) {
    const { x1: x12, x2: x22, y: y4 } = options;
    super(
      data,
      {
        x1: { value: x12, scale: "x" },
        x2: { value: x22, scale: "x" },
        y: { value: y4, scale: "y", type: "band", optional: true }
      },
      options,
      defaults9
    );
  }
  _transform(selection2, mark2, { x: x4 }) {
    selection2.call(applyTransform, mark2, { x: x4 }, 0, 0);
  }
  _x({ x: x4 }, { x1: X13, x2: X24 }, { marginLeft: marginLeft2 }) {
    const { insetLeft } = this;
    return isCollapsed(x4) ? marginLeft2 + insetLeft : (i) => Math.min(X13[i], X24[i]) + insetLeft;
  }
  _width({ x: x4 }, { x1: X13, x2: X24 }, { marginRight: marginRight2, marginLeft: marginLeft2, width: width2 }) {
    const { insetLeft, insetRight } = this;
    return isCollapsed(x4) ? width2 - marginRight2 - marginLeft2 - insetLeft - insetRight : (i) => Math.max(0, Math.abs(X24[i] - X13[i]) - insetLeft - insetRight);
  }
};
var BarY = class extends AbstractBar {
  constructor(data, options = {}) {
    const { x: x4, y1: y12, y2: y22 } = options;
    super(
      data,
      {
        y1: { value: y12, scale: "y" },
        y2: { value: y22, scale: "y" },
        x: { value: x4, scale: "x", type: "band", optional: true }
      },
      options,
      defaults9
    );
  }
  _transform(selection2, mark2, { y: y4 }) {
    selection2.call(applyTransform, mark2, { y: y4 }, 0, 0);
  }
  _y({ y: y4 }, { y1: Y13, y2: Y24 }, { marginTop: marginTop2 }) {
    const { insetTop } = this;
    return isCollapsed(y4) ? marginTop2 + insetTop : (i) => Math.min(Y13[i], Y24[i]) + insetTop;
  }
  _height({ y: y4 }, { y1: Y13, y2: Y24 }, { marginTop: marginTop2, marginBottom: marginBottom2, height: height2 }) {
    const { insetTop, insetBottom } = this;
    return isCollapsed(y4) ? height2 - marginTop2 - marginBottom2 - insetTop - insetBottom : (i) => Math.max(0, Math.abs(Y24[i] - Y13[i]) - insetTop - insetBottom);
  }
};
function barX(data, options = {}) {
  if (!hasXY(options))
    options = { ...options, y: indexOf, x2: identity7 };
  return new BarX(data, maybeStackX(maybeIntervalX(maybeIdentityX(options))));
}
function barY(data, options = {}) {
  if (!hasXY(options))
    options = { ...options, x: indexOf, y2: identity7 };
  return new BarY(data, maybeStackY(maybeIntervalY(maybeIdentityY(options))));
}

// ../../node_modules/@observablehq/plot/src/marks/cell.js
var defaults10 = {
  ariaLabel: "cell"
};
var Cell = class extends AbstractBar {
  constructor(data, { x: x4, y: y4, ...options } = {}) {
    super(
      data,
      {
        x: { value: x4, scale: "x", type: "band", optional: true },
        y: { value: y4, scale: "y", type: "band", optional: true }
      },
      options,
      defaults10
    );
  }
  _transform(selection2, mark2) {
    selection2.call(applyTransform, mark2, {}, 0, 0);
  }
};
function cell(data, { x: x4, y: y4, ...options } = {}) {
  [x4, y4] = maybeTuple(x4, y4);
  return new Cell(data, { ...options, x: x4, y: y4 });
}
function cellX(data, { x: x4 = indexOf, fill, stroke, ...options } = {}) {
  if (fill === void 0 && maybeColorChannel(stroke)[0] === void 0)
    fill = identity7;
  return new Cell(data, { ...options, x: x4, fill, stroke });
}
function cellY(data, { y: y4 = indexOf, fill, stroke, ...options } = {}) {
  if (fill === void 0 && maybeColorChannel(stroke)[0] === void 0)
    fill = identity7;
  return new Cell(data, { ...options, y: y4, fill, stroke });
}

// ../../node_modules/@observablehq/plot/src/marks/dot.js
var defaults11 = {
  ariaLabel: "dot",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 1.5
};
function withDefaultSort(options) {
  return options.sort === void 0 && options.reverse === void 0 ? sort2({ channel: "-r" }, options) : options;
}
var Dot = class extends Mark {
  constructor(data, options = {}) {
    const { x: x4, y: y4, r, rotate, symbol: symbol2 = circle_default2, frameAnchor } = options;
    const [vrotate, crotate] = maybeNumberChannel(rotate, 0);
    const [vsymbol, csymbol] = maybeSymbolChannel(symbol2);
    const [vr, cr] = maybeNumberChannel(r, vsymbol == null ? 3 : 4.5);
    super(
      data,
      {
        x: { value: x4, scale: "x", optional: true },
        y: { value: y4, scale: "y", optional: true },
        r: { value: vr, scale: "r", filter: positive, optional: true },
        rotate: { value: vrotate, optional: true },
        symbol: { value: vsymbol, scale: "auto", optional: true }
      },
      withDefaultSort(options),
      defaults11
    );
    this.r = cr;
    this.rotate = crotate;
    this.symbol = csymbol;
    this.frameAnchor = maybeFrameAnchor(frameAnchor);
    const { channels } = this;
    const { symbol: symbolChannel } = channels;
    if (symbolChannel) {
      const { fill: fillChannel, stroke: strokeChannel } = channels;
      symbolChannel.hint = {
        fill: fillChannel ? fillChannel.value === symbolChannel.value ? "color" : "currentColor" : this.fill ?? "currentColor",
        stroke: strokeChannel ? strokeChannel.value === symbolChannel.value ? "color" : "currentColor" : this.stroke ?? "none"
      };
    }
  }
  render(index2, scales2, channels, dimensions, context) {
    const { x: x4, y: y4 } = scales2;
    const { x: X3, y: Y3, r: R2, rotate: A5, symbol: S2 } = channels;
    const { r, rotate, symbol: symbol2 } = this;
    const [cx, cy] = applyFrameAnchor(this, dimensions);
    const circle3 = symbol2 === circle_default2;
    const size = R2 ? void 0 : r * r * Math.PI;
    if (negative(r))
      index2 = [];
    return create3("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X3 && x4, y: Y3 && y4 }).call(
      (g2) => g2.selectAll().data(index2).enter().append(circle3 ? "circle" : "path").call(applyDirectStyles, this).call(
        circle3 ? (selection2) => {
          selection2.attr("cx", X3 ? (i) => X3[i] : cx).attr("cy", Y3 ? (i) => Y3[i] : cy).attr("r", R2 ? (i) => R2[i] : r);
        } : (selection2) => {
          selection2.attr(
            "transform",
            template`translate(${X3 ? (i) => X3[i] : cx},${Y3 ? (i) => Y3[i] : cy})${A5 ? (i) => ` rotate(${A5[i]})` : rotate ? ` rotate(${rotate})` : ``}`
          ).attr(
            "d",
            R2 && S2 ? (i) => {
              const p2 = pathRound();
              S2[i].draw(p2, R2[i] * R2[i] * Math.PI);
              return p2;
            } : R2 ? (i) => {
              const p2 = pathRound();
              symbol2.draw(p2, R2[i] * R2[i] * Math.PI);
              return p2;
            } : S2 ? (i) => {
              const p2 = pathRound();
              S2[i].draw(p2, size);
              return p2;
            } : (() => {
              const p2 = pathRound();
              symbol2.draw(p2, size);
              return p2;
            })()
          );
        }
      ).call(applyChannelStyles, this, channels)
    ).node();
  }
};
function dot(data, { x: x4, y: y4, ...options } = {}) {
  if (options.frameAnchor === void 0)
    [x4, y4] = maybeTuple(x4, y4);
  return new Dot(data, { ...options, x: x4, y: y4 });
}
function dotX(data, { x: x4 = identity7, ...options } = {}) {
  return new Dot(data, maybeIntervalMidY({ ...options, x: x4 }));
}
function dotY(data, { y: y4 = identity7, ...options } = {}) {
  return new Dot(data, maybeIntervalMidX({ ...options, y: y4 }));
}
function circle(data, options) {
  return dot(data, { ...options, symbol: "circle" });
}
function hexagon(data, options) {
  return dot(data, { ...options, symbol: "hexagon" });
}

// ../../node_modules/@observablehq/plot/src/marks/line.js
var defaults12 = {
  ariaLabel: "line",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 1.5,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeMiterlimit: 1
};
var Line = class extends Mark {
  constructor(data, options = {}) {
    const { x: x4, y: y4, z: z2, curve, tension } = options;
    super(
      data,
      {
        x: { value: x4, scale: "x" },
        y: { value: y4, scale: "y" },
        z: { value: maybeZ(options), optional: true }
      },
      options,
      defaults12
    );
    this.z = z2;
    this.curve = maybeCurveAuto(curve, tension);
    markers(this, options);
  }
  filter(index2) {
    return index2;
  }
  project(channels, values2, context) {
    if (this.curve !== curveAuto) {
      super.project(channels, values2, context);
    }
  }
  render(index2, scales2, channels, dimensions, context) {
    const { x: X3, y: Y3 } = channels;
    const { curve } = this;
    return create3("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales2).call(
      (g2) => g2.selectAll().data(groupIndex(index2, [X3, Y3], this, channels)).enter().append("path").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, channels).call(applyGroupedMarkers, this, channels, context).attr(
        "d",
        curve === curveAuto && context.projection ? sphereLine(context.projection, X3, Y3) : line_default2().curve(curve).defined((i) => i >= 0).x((i) => X3[i]).y((i) => Y3[i])
      )
    ).node();
  }
};
function sphereLine(projection3, X3, Y3) {
  const path2 = path_default(projection3);
  X3 = coerceNumbers(X3);
  Y3 = coerceNumbers(Y3);
  return (I2) => {
    let line3 = [];
    const lines = [line3];
    for (const i of I2) {
      if (i === -1) {
        line3 = [];
        lines.push(line3);
      } else {
        line3.push([X3[i], Y3[i]]);
      }
    }
    return path2({ type: "MultiLineString", coordinates: lines });
  };
}
function line(data, { x: x4, y: y4, ...options } = {}) {
  [x4, y4] = maybeTuple(x4, y4);
  return new Line(data, { ...options, x: x4, y: y4 });
}
function lineX(data, { x: x4 = identity7, y: y4 = indexOf, ...options } = {}) {
  return new Line(data, maybeDenseIntervalY({ ...options, x: x4, y: y4 }));
}
function lineY(data, { x: x4 = indexOf, y: y4 = identity7, ...options } = {}) {
  return new Line(data, maybeDenseIntervalX({ ...options, x: x4, y: y4 }));
}

// ../../node_modules/@observablehq/plot/src/marks/rect.js
var defaults13 = {
  ariaLabel: "rect"
};
var Rect = class extends Mark {
  constructor(data, options = {}) {
    const {
      x1: x12,
      y1: y12,
      x2: x22,
      y2: y22,
      inset: inset2 = 0,
      insetTop = inset2,
      insetRight = inset2,
      insetBottom = inset2,
      insetLeft = inset2,
      rx,
      ry
    } = options;
    super(
      data,
      {
        x1: { value: x12, scale: "x", type: x12 != null && x22 == null ? "band" : void 0, optional: true },
        y1: { value: y12, scale: "y", type: y12 != null && y22 == null ? "band" : void 0, optional: true },
        x2: { value: x22, scale: "x", optional: true },
        y2: { value: y22, scale: "y", optional: true }
      },
      options,
      defaults13
    );
    this.insetTop = number5(insetTop);
    this.insetRight = number5(insetRight);
    this.insetBottom = number5(insetBottom);
    this.insetLeft = number5(insetLeft);
    this.rx = impliedString(rx, "auto");
    this.ry = impliedString(ry, "auto");
  }
  render(index2, scales2, channels, dimensions, context) {
    const { x: x4, y: y4 } = scales2;
    const { x1: X13, y1: Y13, x2: X24, y2: Y24 } = channels;
    const { marginTop: marginTop2, marginRight: marginRight2, marginBottom: marginBottom2, marginLeft: marginLeft2, width: width2, height: height2 } = dimensions;
    const { projection: projection3 } = context;
    const { insetTop, insetRight, insetBottom, insetLeft, rx, ry } = this;
    const bx = (x4?.bandwidth ? x4.bandwidth() : 0) - insetLeft - insetRight;
    const by = (y4?.bandwidth ? y4.bandwidth() : 0) - insetTop - insetBottom;
    return create3("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, {}, 0, 0).call(
      (g2) => g2.selectAll().data(index2).enter().append("rect").call(applyDirectStyles, this).attr(
        "x",
        X13 && (projection3 || !isCollapsed(x4)) ? X24 ? (i) => Math.min(X13[i], X24[i]) + insetLeft : (i) => X13[i] + insetLeft : marginLeft2 + insetLeft
      ).attr(
        "y",
        Y13 && (projection3 || !isCollapsed(y4)) ? Y24 ? (i) => Math.min(Y13[i], Y24[i]) + insetTop : (i) => Y13[i] + insetTop : marginTop2 + insetTop
      ).attr(
        "width",
        X13 && (projection3 || !isCollapsed(x4)) ? X24 ? (i) => Math.max(0, Math.abs(X24[i] - X13[i]) + bx) : bx : width2 - marginRight2 - marginLeft2 - insetRight - insetLeft
      ).attr(
        "height",
        Y13 && (projection3 || !isCollapsed(y4)) ? Y24 ? (i) => Math.max(0, Math.abs(Y13[i] - Y24[i]) + by) : by : height2 - marginTop2 - marginBottom2 - insetTop - insetBottom
      ).call(applyAttr, "rx", rx).call(applyAttr, "ry", ry).call(applyChannelStyles, this, channels)
    ).node();
  }
};
function rect(data, options) {
  return new Rect(data, maybeTrivialIntervalX(maybeTrivialIntervalY(options)));
}
function rectX(data, options = {}) {
  if (!hasXY(options))
    options = { ...options, y: indexOf, x2: identity7, interval: 1 };
  return new Rect(data, maybeStackX(maybeTrivialIntervalY(maybeIdentityX(options))));
}
function rectY(data, options = {}) {
  if (!hasXY(options))
    options = { ...options, x: indexOf, y2: identity7, interval: 1 };
  return new Rect(data, maybeStackY(maybeTrivialIntervalX(maybeIdentityY(options))));
}

// ../../node_modules/@observablehq/plot/src/marks/auto.js
function autoSpec(data, options) {
  options = normalizeOptions(options);
  const { x: x4, y: y4, color: color3, size } = options;
  const X3 = materializeValue(data, x4);
  const Y3 = materializeValue(data, y4);
  const C3 = materializeValue(data, color3);
  const S2 = materializeValue(data, size);
  let {
    fx,
    fy,
    x: { value: xValue, reduce: xReduce, zero: xZero2, ...xOptions },
    y: { value: yValue, reduce: yReduce, zero: yZero2, ...yOptions },
    color: { value: colorValue, color: colorColor, reduce: colorReduce },
    size: { value: sizeValue, reduce: sizeReduce },
    // TODO constant radius?
    mark: mark2
  } = options;
  if (xReduce === void 0)
    xReduce = yReduce == null && xValue == null && sizeValue == null && yValue != null ? "count" : null;
  if (yReduce === void 0)
    yReduce = xReduce == null && yValue == null && sizeValue == null && xValue != null ? "count" : null;
  if (sizeReduce === void 0 && sizeValue == null && colorReduce == null && xReduce == null && yReduce == null && (xValue == null || isOrdinal(X3)) && (yValue == null || isOrdinal(Y3))) {
    sizeReduce = "count";
  }
  if (xZero2 === void 0)
    xZero2 = isZeroReducer(xReduce) ? true : void 0;
  if (yZero2 === void 0)
    yZero2 = isZeroReducer(yReduce) ? true : void 0;
  if (xValue == null && yValue == null)
    throw new Error("must specify x or y");
  if (xReduce != null && yValue == null)
    throw new Error("reducing x requires y");
  if (yReduce != null && xValue == null)
    throw new Error("reducing y requires x");
  if (mark2 === void 0) {
    mark2 = sizeValue != null || sizeReduce != null ? "dot" : isZeroReducer(xReduce) || isZeroReducer(yReduce) || colorReduce != null ? "bar" : xValue != null && yValue != null ? isOrdinal(X3) || isOrdinal(Y3) || xReduce == null && yReduce == null && !isMonotonic(X3) && !isMonotonic(Y3) ? "dot" : "line" : xValue != null || yValue != null ? "rule" : null;
  }
  let Z3;
  let colorMode;
  let markImpl;
  switch (mark2) {
    case "dot":
      markImpl = dot;
      colorMode = "stroke";
      break;
    case "line":
      markImpl = X3 && Y3 || xReduce != null || yReduce != null ? yZero2 || yReduce != null || X3 && isMonotonic(X3) ? lineY : xZero2 || xReduce != null || Y3 && isMonotonic(Y3) ? lineX : line : X3 ? lineX : lineY;
      colorMode = "stroke";
      if (isHighCardinality(C3))
        Z3 = null;
      break;
    case "area":
      markImpl = !(yZero2 || yReduce != null) && (xZero2 || xReduce != null || Y3 && isMonotonic(Y3)) ? areaX : areaY;
      colorMode = "fill";
      if (isHighCardinality(C3))
        Z3 = null;
      break;
    case "rule":
      markImpl = X3 ? ruleX : ruleY;
      colorMode = "stroke";
      break;
    case "bar":
      markImpl = xReduce != null ? isOrdinal(Y3) ? isSelectReducer(xReduce) && X3 && isOrdinal(X3) ? cell : barX : rectX : yReduce != null ? isOrdinal(X3) ? isSelectReducer(yReduce) && Y3 && isOrdinal(Y3) ? cell : barY : rectY : colorReduce != null || sizeReduce != null ? X3 && isOrdinal(X3) && Y3 && isOrdinal(Y3) ? cell : X3 && isOrdinal(X3) ? barY : Y3 && isOrdinal(Y3) ? barX : rect : X3 && isNumeric(X3) && !(Y3 && isNumeric(Y3)) ? barX : Y3 && isNumeric(Y3) && !(X3 && isNumeric(X3)) ? barY : cell;
      colorMode = "fill";
      break;
    default:
      throw new Error(`invalid mark: ${mark2}`);
  }
  let markOptions2 = {
    fx,
    fy,
    x: X3 ?? void 0,
    // treat null x as undefined for implicit stack
    y: Y3 ?? void 0,
    // treat null y as undefined for implicit stack
    [colorMode]: C3 ?? colorColor,
    z: Z3,
    r: S2 ?? void 0,
    // treat null size as undefined for default constant radius
    tip: true
  };
  let transformImpl;
  let transformOptions = { [colorMode]: colorReduce ?? void 0, r: sizeReduce ?? void 0 };
  if (xReduce != null && yReduce != null) {
    throw new Error(`cannot reduce both x and y`);
  } else if (yReduce != null) {
    transformOptions.y = yReduce;
    transformImpl = isOrdinal(X3) ? groupX : binX;
  } else if (xReduce != null) {
    transformOptions.x = xReduce;
    transformImpl = isOrdinal(Y3) ? groupY : binY;
  } else if (colorReduce != null || sizeReduce != null) {
    if (X3 && Y3) {
      transformImpl = isOrdinal(X3) && isOrdinal(Y3) ? group2 : isOrdinal(X3) ? binY : isOrdinal(Y3) ? binX : bin;
    } else if (X3) {
      transformImpl = isOrdinal(X3) ? groupX : binX;
    } else if (Y3) {
      transformImpl = isOrdinal(Y3) ? groupY : binY;
    }
  }
  if (transformImpl === bin || transformImpl === binX)
    markOptions2.x = { value: X3, ...xOptions };
  if (transformImpl === bin || transformImpl === binY)
    markOptions2.y = { value: Y3, ...yOptions };
  if (xZero2 === void 0)
    xZero2 = X3 && !(transformImpl === bin || transformImpl === binX) && (markImpl === barX || markImpl === areaX || markImpl === rectX || markImpl === ruleY);
  if (yZero2 === void 0)
    yZero2 = Y3 && !(transformImpl === bin || transformImpl === binY) && (markImpl === barY || markImpl === areaY || markImpl === rectY || markImpl === ruleX);
  return {
    fx: fx ?? null,
    fy: fy ?? null,
    x: {
      value: xValue ?? null,
      reduce: xReduce ?? null,
      zero: !!xZero2,
      ...xOptions
    },
    y: {
      value: yValue ?? null,
      reduce: yReduce ?? null,
      zero: !!yZero2,
      ...yOptions
    },
    color: {
      value: colorValue ?? null,
      reduce: colorReduce ?? null,
      ...colorColor !== void 0 && { color: colorColor }
    },
    size: {
      value: sizeValue ?? null,
      reduce: sizeReduce ?? null
    },
    mark: mark2,
    markImpl: implNames[markImpl],
    markOptions: markOptions2,
    transformImpl: implNames[transformImpl],
    transformOptions,
    colorMode
  };
}
function auto(data, options) {
  const spec = autoSpec(data, options);
  const {
    fx,
    fy,
    x: { zero: xZero2 },
    y: { zero: yZero2 },
    markOptions: markOptions2,
    transformOptions,
    colorMode
  } = spec;
  const markImpl = impls[spec.markImpl];
  const transformImpl = impls[spec.transformImpl];
  const frames = fx != null || fy != null ? frame2({ strokeOpacity: 0.1 }) : null;
  const rules = [xZero2 ? ruleX([0]) : null, yZero2 ? ruleY([0]) : null];
  const mark2 = markImpl(data, transformImpl ? transformImpl(transformOptions, markOptions2) : markOptions2);
  return colorMode === "stroke" ? marks(frames, rules, mark2) : marks(frames, mark2, rules);
}
function isMonotonic(values2) {
  let previous;
  let previousOrder;
  for (const value of values2) {
    if (value == null)
      continue;
    if (previous === void 0) {
      previous = value;
      continue;
    }
    const order = Math.sign(ascending(previous, value));
    if (!order)
      continue;
    if (previousOrder !== void 0 && order !== previousOrder)
      return false;
    previous = value;
    previousOrder = order;
  }
  return true;
}
function normalizeOptions({ x: x4, y: y4, color: color3, size, fx, fy, mark: mark2 } = {}) {
  if (!isOptions(x4))
    x4 = makeOptions(x4);
  if (!isOptions(y4))
    y4 = makeOptions(y4);
  if (!isOptions(color3))
    color3 = isColor(color3) ? { color: color3 } : makeOptions(color3);
  if (!isOptions(size))
    size = makeOptions(size);
  if (isOptions(fx))
    ({ value: fx } = makeOptions(fx));
  if (isOptions(fy))
    ({ value: fy } = makeOptions(fy));
  if (mark2 != null)
    mark2 = `${mark2}`.toLowerCase();
  return { x: x4, y: y4, color: color3, size, fx, fy, mark: mark2 };
}
function materializeValue(data, options) {
  const V2 = valueof(data, options.value);
  if (V2)
    V2.label = labelof(options.value);
  return V2;
}
function makeOptions(value) {
  return isReducer(value) ? { reduce: value } : { value };
}
function isZeroReducer(reduce) {
  return /^(?:distinct|count|sum|proportion)$/i.test(reduce);
}
function isSelectReducer(reduce) {
  return /^(?:first|last|mode)$/i.test(reduce);
}
function isReducer(reduce) {
  if (reduce == null)
    return false;
  if (typeof reduce.reduceIndex === "function")
    return true;
  if (typeof reduce.reduce === "function" && isObject3(reduce))
    return true;
  if (/^p\d{2}$/i.test(reduce))
    return true;
  switch (`${reduce}`.toLowerCase()) {
    case "first":
    case "last":
    case "count":
    case "distinct":
    case "sum":
    case "proportion":
    case "proportion-facet":
    case "deviation":
    case "min":
    case "min-index":
    case "max":
    case "max-index":
    case "mean":
    case "median":
    case "variance":
    case "mode":
      return true;
  }
  return false;
}
function isHighCardinality(value) {
  return value ? new InternSet(value).size > value.length >> 1 : false;
}
var impls = {
  dot,
  line,
  lineX,
  lineY,
  areaX,
  areaY,
  ruleX,
  ruleY,
  barX,
  barY,
  rect,
  rectX,
  rectY,
  cell,
  bin,
  binX,
  binY,
  group: group2,
  groupX,
  groupY
};
var implNames = Object.fromEntries(Object.entries(impls).map(([name2, impl]) => [impl, name2]));

// ../../node_modules/@observablehq/plot/src/transforms/map.js
function mapX(mapper, options = {}) {
  let { x: x4, x1: x12, x2: x22 } = options;
  if (x4 === void 0 && x12 === void 0 && x22 === void 0)
    options = { ...options, x: x4 = identity7 };
  const outputs = {};
  if (x4 != null)
    outputs.x = mapper;
  if (x12 != null)
    outputs.x1 = mapper;
  if (x22 != null)
    outputs.x2 = mapper;
  return map3(outputs, options);
}
function mapY(mapper, options = {}) {
  let { y: y4, y1: y12, y2: y22 } = options;
  if (y4 === void 0 && y12 === void 0 && y22 === void 0)
    options = { ...options, y: y4 = identity7 };
  const outputs = {};
  if (y4 != null)
    outputs.y = mapper;
  if (y12 != null)
    outputs.y1 = mapper;
  if (y22 != null)
    outputs.y2 = mapper;
  return map3(outputs, options);
}
function map3(outputs = {}, options = {}) {
  const z2 = maybeZ(options);
  const channels = Object.entries(outputs).map(([key, map4]) => {
    const input3 = maybeInput(key, options);
    if (input3 == null)
      throw new Error(`missing channel: ${key}`);
    const [output, setOutput] = column2(input3);
    return { key, input: input3, output, setOutput, map: maybeMap(map4) };
  });
  return {
    ...basic(options, (data, facets) => {
      const Z3 = valueof(data, z2);
      const X3 = channels.map(({ input: input3 }) => valueof(data, input3));
      const MX = channels.map(({ setOutput }) => setOutput(new Array(data.length)));
      for (const facet of facets) {
        for (const I2 of Z3 ? group(facet, (i) => Z3[i]).values() : [facet]) {
          channels.forEach(({ map: map4 }, i) => map4.mapIndex(I2, X3[i], MX[i]));
        }
      }
      return { data, facets };
    }),
    ...Object.fromEntries(channels.map(({ key, output }) => [key, output]))
  };
}
function maybeMap(map4) {
  if (map4 == null)
    throw new Error("missing map");
  if (typeof map4.mapIndex === "function")
    return map4;
  if (typeof map4.map === "function" && isObject3(map4))
    return mapMap(map4);
  if (typeof map4 === "function")
    return mapFunction(taker(map4));
  switch (`${map4}`.toLowerCase()) {
    case "cumsum":
      return mapCumsum;
    case "rank":
      return mapFunction((I2, V2) => rank2(I2, (i) => V2[i]));
    case "quantile":
      return mapFunction((I2, V2) => rankQuantile(I2, (i) => V2[i]));
  }
  throw new Error(`invalid map: ${map4}`);
}
function mapMap(map4) {
  console.warn("deprecated map interface; implement mapIndex instead.");
  return { mapIndex: map4.map.bind(map4) };
}
function rankQuantile(I2, f2) {
  const n = count2(I2, f2) - 1;
  return rank2(I2, f2).map((r) => r / n);
}
function mapFunction(f2) {
  return {
    mapIndex(I2, S2, T) {
      const M3 = f2(I2, S2);
      if (M3.length !== I2.length)
        throw new Error("map function returned a mismatched length");
      for (let i = 0, n = I2.length; i < n; ++i)
        T[I2[i]] = M3[i];
    }
  };
}
var mapCumsum = {
  mapIndex(I2, S2, T) {
    let sum5 = 0;
    for (const i of I2)
      T[i] = sum5 += S2[i];
  }
};

// ../../node_modules/@observablehq/plot/src/transforms/window.js
function windowX(windowOptions = {}, options) {
  if (arguments.length === 1)
    options = windowOptions;
  return mapX(window2(windowOptions), options);
}
function windowY(windowOptions = {}, options) {
  if (arguments.length === 1)
    options = windowOptions;
  return mapY(window2(windowOptions), options);
}
function window2(options = {}) {
  if (typeof options === "number")
    options = { k: options };
  let { k: k3, reduce, shift, anchor, strict } = options;
  if (anchor === void 0 && shift !== void 0) {
    anchor = maybeShift(shift);
    warn(`Warning: the shift option is deprecated; please use anchor "${anchor}" instead.`);
  }
  if (!((k3 = Math.floor(k3)) > 0))
    throw new Error(`invalid k: ${k3}`);
  return maybeReduce2(reduce)(k3, maybeAnchor3(anchor, k3), strict);
}
function maybeAnchor3(anchor = "middle", k3) {
  switch (`${anchor}`.toLowerCase()) {
    case "middle":
      return k3 - 1 >> 1;
    case "start":
      return 0;
    case "end":
      return k3 - 1;
  }
  throw new Error(`invalid anchor: ${anchor}`);
}
function maybeShift(shift) {
  switch (`${shift}`.toLowerCase()) {
    case "centered":
      return "middle";
    case "leading":
      return "start";
    case "trailing":
      return "end";
  }
  throw new Error(`invalid shift: ${shift}`);
}
function maybeReduce2(reduce = "mean") {
  if (typeof reduce === "string") {
    if (/^p\d{2}$/i.test(reduce))
      return reduceAccessor2(percentile(reduce));
    switch (reduce.toLowerCase()) {
      case "deviation":
        return reduceAccessor2(deviation);
      case "max":
        return reduceArray((I2, V2) => max2(I2, (i) => V2[i]));
      case "mean":
        return reduceMean;
      case "median":
        return reduceAccessor2(median2);
      case "min":
        return reduceArray((I2, V2) => min2(I2, (i) => V2[i]));
      case "mode":
        return reduceArray((I2, V2) => mode2(I2, (i) => V2[i]));
      case "sum":
        return reduceSum2;
      case "variance":
        return reduceAccessor2(variance2);
      case "difference":
        return reduceDifference;
      case "ratio":
        return reduceRatio;
      case "first":
        return reduceFirst2;
      case "last":
        return reduceLast2;
    }
  }
  if (typeof reduce !== "function")
    throw new Error(`invalid reduce: ${reduce}`);
  return reduceArray(taker(reduce));
}
function reduceAccessor2(f2) {
  return (k3, s2, strict) => strict ? {
    mapIndex(I2, S2, T) {
      const v3 = (i) => S2[i] == null ? NaN : +S2[i];
      let nans = 0;
      for (let i = 0; i < k3 - 1; ++i)
        if (isNaN(v3(i)))
          ++nans;
      for (let i = 0, n = I2.length - k3 + 1; i < n; ++i) {
        if (isNaN(v3(i + k3 - 1)))
          ++nans;
        T[I2[i + s2]] = nans === 0 ? f2(subarray(I2, i, i + k3), v3) : NaN;
        if (isNaN(v3(i)))
          --nans;
      }
    }
  } : {
    mapIndex(I2, S2, T) {
      const v3 = (i) => S2[i] == null ? NaN : +S2[i];
      for (let i = -s2; i < 0; ++i) {
        T[I2[i + s2]] = f2(subarray(I2, 0, i + k3), v3);
      }
      for (let i = 0, n = I2.length - s2; i < n; ++i) {
        T[I2[i + s2]] = f2(subarray(I2, i, i + k3), v3);
      }
    }
  };
}
function reduceArray(f2) {
  return (k3, s2, strict) => strict ? {
    mapIndex(I2, S2, T) {
      let count4 = 0;
      for (let i = 0; i < k3 - 1; ++i)
        count4 += defined(S2[I2[i]]);
      for (let i = 0, n = I2.length - k3 + 1; i < n; ++i) {
        count4 += defined(S2[I2[i + k3 - 1]]);
        if (count4 === k3)
          T[I2[i + s2]] = f2(subarray(I2, i, i + k3), S2);
        count4 -= defined(S2[I2[i]]);
      }
    }
  } : {
    mapIndex(I2, S2, T) {
      for (let i = -s2; i < 0; ++i) {
        T[I2[i + s2]] = f2(subarray(I2, 0, i + k3), S2);
      }
      for (let i = 0, n = I2.length - s2; i < n; ++i) {
        T[I2[i + s2]] = f2(subarray(I2, i, i + k3), S2);
      }
    }
  };
}
function reduceSum2(k3, s2, strict) {
  return strict ? {
    mapIndex(I2, S2, T) {
      let nans = 0;
      let sum5 = 0;
      for (let i = 0; i < k3 - 1; ++i) {
        const v3 = S2[I2[i]];
        if (v3 === null || isNaN(v3))
          ++nans;
        else
          sum5 += +v3;
      }
      for (let i = 0, n = I2.length - k3 + 1; i < n; ++i) {
        const a3 = S2[I2[i]];
        const b2 = S2[I2[i + k3 - 1]];
        if (b2 === null || isNaN(b2))
          ++nans;
        else
          sum5 += +b2;
        T[I2[i + s2]] = nans === 0 ? sum5 : NaN;
        if (a3 === null || isNaN(a3))
          --nans;
        else
          sum5 -= +a3;
      }
    }
  } : {
    mapIndex(I2, S2, T) {
      let sum5 = 0;
      const n = I2.length;
      for (let i = 0, j2 = Math.min(n, k3 - s2 - 1); i < j2; ++i) {
        sum5 += +S2[I2[i]] || 0;
      }
      for (let i = -s2, j2 = n - s2; i < j2; ++i) {
        sum5 += +S2[I2[i + k3 - 1]] || 0;
        T[I2[i + s2]] = sum5;
        sum5 -= +S2[I2[i]] || 0;
      }
    }
  };
}
function reduceMean(k3, s2, strict) {
  if (strict) {
    const sum5 = reduceSum2(k3, s2, strict);
    return {
      mapIndex(I2, S2, T) {
        sum5.mapIndex(I2, S2, T);
        for (let i = 0, n = I2.length - k3 + 1; i < n; ++i) {
          T[I2[i + s2]] /= k3;
        }
      }
    };
  } else {
    return {
      mapIndex(I2, S2, T) {
        let sum5 = 0;
        let count4 = 0;
        const n = I2.length;
        for (let i = 0, j2 = Math.min(n, k3 - s2 - 1); i < j2; ++i) {
          let v3 = S2[I2[i]];
          if (v3 !== null && !isNaN(v3 = +v3))
            sum5 += v3, ++count4;
        }
        for (let i = -s2, j2 = n - s2; i < j2; ++i) {
          let a3 = S2[I2[i + k3 - 1]];
          let b2 = S2[I2[i]];
          if (a3 !== null && !isNaN(a3 = +a3))
            sum5 += a3, ++count4;
          T[I2[i + s2]] = sum5 / count4;
          if (b2 !== null && !isNaN(b2 = +b2))
            sum5 -= b2, --count4;
        }
      }
    };
  }
}
function firstDefined(S2, I2, i, k3) {
  for (let j2 = i + k3; i < j2; ++i) {
    const v3 = S2[I2[i]];
    if (defined(v3))
      return v3;
  }
}
function lastDefined(S2, I2, i, k3) {
  for (let j2 = i + k3 - 1; j2 >= i; --j2) {
    const v3 = S2[I2[j2]];
    if (defined(v3))
      return v3;
  }
}
function firstNumber(S2, I2, i, k3) {
  for (let j2 = i + k3; i < j2; ++i) {
    let v3 = S2[I2[i]];
    if (v3 !== null && !isNaN(v3 = +v3))
      return v3;
  }
}
function lastNumber(S2, I2, i, k3) {
  for (let j2 = i + k3 - 1; j2 >= i; --j2) {
    let v3 = S2[I2[j2]];
    if (v3 !== null && !isNaN(v3 = +v3))
      return v3;
  }
}
function reduceDifference(k3, s2, strict) {
  return strict ? {
    mapIndex(I2, S2, T) {
      for (let i = 0, n = I2.length - k3; i < n; ++i) {
        const a3 = S2[I2[i]];
        const b2 = S2[I2[i + k3 - 1]];
        T[I2[i + s2]] = a3 === null || b2 === null ? NaN : b2 - a3;
      }
    }
  } : {
    mapIndex(I2, S2, T) {
      for (let i = -s2, n = I2.length - k3 + s2 + 1; i < n; ++i) {
        T[I2[i + s2]] = lastNumber(S2, I2, i, k3) - firstNumber(S2, I2, i, k3);
      }
    }
  };
}
function reduceRatio(k3, s2, strict) {
  return strict ? {
    mapIndex(I2, S2, T) {
      for (let i = 0, n = I2.length - k3; i < n; ++i) {
        const a3 = S2[I2[i]];
        const b2 = S2[I2[i + k3 - 1]];
        T[I2[i + s2]] = a3 === null || b2 === null ? NaN : b2 / a3;
      }
    }
  } : {
    mapIndex(I2, S2, T) {
      for (let i = -s2, n = I2.length - k3 + s2 + 1; i < n; ++i) {
        T[I2[i + s2]] = lastNumber(S2, I2, i, k3) / firstNumber(S2, I2, i, k3);
      }
    }
  };
}
function reduceFirst2(k3, s2, strict) {
  return strict ? {
    mapIndex(I2, S2, T) {
      for (let i = 0, n = I2.length - k3; i < n; ++i) {
        T[I2[i + s2]] = S2[I2[i]];
      }
    }
  } : {
    mapIndex(I2, S2, T) {
      for (let i = -s2, n = I2.length - k3 + s2 + 1; i < n; ++i) {
        T[I2[i + s2]] = firstDefined(S2, I2, i, k3);
      }
    }
  };
}
function reduceLast2(k3, s2, strict) {
  return strict ? {
    mapIndex(I2, S2, T) {
      for (let i = 0, n = I2.length - k3; i < n; ++i) {
        T[I2[i + s2]] = S2[I2[i + k3 - 1]];
      }
    }
  } : {
    mapIndex(I2, S2, T) {
      for (let i = -s2, n = I2.length - k3 + s2 + 1; i < n; ++i) {
        T[I2[i + s2]] = lastDefined(S2, I2, i, k3);
      }
    }
  };
}

// ../../node_modules/@observablehq/plot/src/marks/bollinger.js
var defaults14 = {
  n: 20,
  k: 2,
  color: "currentColor",
  opacity: 0.2,
  strict: true,
  anchor: "end"
};
function bollingerX(data, {
  x: x4 = identity7,
  y: y4,
  k: k3 = defaults14.k,
  color: color3 = defaults14.color,
  opacity: opacity2 = defaults14.opacity,
  fill = color3,
  fillOpacity = opacity2,
  stroke = color3,
  strokeOpacity,
  strokeWidth,
  ...options
} = {}) {
  return marks(
    isNoneish(fill) ? null : areaX(
      data,
      map3(
        { x1: bollinger({ k: -k3, ...options }), x2: bollinger({ k: k3, ...options }) },
        { x1: x4, x2: x4, y: y4, fill, fillOpacity, ...options }
      )
    ),
    isNoneish(stroke) ? null : lineX(data, map3({ x: bollinger(options) }, { x: x4, y: y4, stroke, strokeOpacity, strokeWidth, ...options }))
  );
}
function bollingerY(data, {
  x: x4,
  y: y4 = identity7,
  k: k3 = defaults14.k,
  color: color3 = defaults14.color,
  opacity: opacity2 = defaults14.opacity,
  fill = color3,
  fillOpacity = opacity2,
  stroke = color3,
  strokeOpacity,
  strokeWidth,
  ...options
} = {}) {
  return marks(
    isNoneish(fill) ? null : areaY(
      data,
      map3(
        { y1: bollinger({ k: -k3, ...options }), y2: bollinger({ k: k3, ...options }) },
        { x: x4, y1: y4, y2: y4, fill, fillOpacity, ...options }
      )
    ),
    isNoneish(stroke) ? null : lineY(data, map3({ y: bollinger(options) }, { x: x4, y: y4, stroke, strokeOpacity, strokeWidth, ...options }))
  );
}
function bollinger({ n = defaults14.n, k: k3 = 0, strict = defaults14.strict, anchor = defaults14.anchor } = {}) {
  return window2({ k: n, reduce: (Y3) => mean2(Y3) + k3 * (deviation(Y3) || 0), strict, anchor });
}

// ../../node_modules/@observablehq/plot/src/marks/tick.js
var defaults15 = {
  ariaLabel: "tick",
  fill: null,
  stroke: "currentColor"
};
var AbstractTick = class extends Mark {
  constructor(data, channels, options) {
    super(data, channels, options, defaults15);
    markers(this, options);
  }
  render(index2, scales2, channels, dimensions, context) {
    return create3("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(this._transform, this, scales2).call(
      (g2) => g2.selectAll().data(index2).enter().append("line").call(applyDirectStyles, this).attr("x1", this._x1(scales2, channels, dimensions)).attr("x2", this._x2(scales2, channels, dimensions)).attr("y1", this._y1(scales2, channels, dimensions)).attr("y2", this._y2(scales2, channels, dimensions)).call(applyChannelStyles, this, channels).call(applyMarkers, this, channels, context)
    ).node();
  }
};
var TickX = class extends AbstractTick {
  constructor(data, options = {}) {
    const { x: x4, y: y4, inset: inset2 = 0, insetTop = inset2, insetBottom = inset2 } = options;
    super(
      data,
      {
        x: { value: x4, scale: "x" },
        y: { value: y4, scale: "y", type: "band", optional: true }
      },
      options
    );
    this.insetTop = number5(insetTop);
    this.insetBottom = number5(insetBottom);
  }
  _transform(selection2, mark2, { x: x4 }) {
    selection2.call(applyTransform, mark2, { x: x4 }, offset, 0);
  }
  _x1(scales2, { x: X3 }) {
    return (i) => X3[i];
  }
  _x2(scales2, { x: X3 }) {
    return (i) => X3[i];
  }
  _y1({ y: y4 }, { y: Y3 }, { marginTop: marginTop2 }) {
    const { insetTop } = this;
    return Y3 && y4 ? (i) => Y3[i] + insetTop : marginTop2 + insetTop;
  }
  _y2({ y: y4 }, { y: Y3 }, { height: height2, marginBottom: marginBottom2 }) {
    const { insetBottom } = this;
    return Y3 && y4 ? (i) => Y3[i] + y4.bandwidth() - insetBottom : height2 - marginBottom2 - insetBottom;
  }
};
var TickY = class extends AbstractTick {
  constructor(data, options = {}) {
    const { x: x4, y: y4, inset: inset2 = 0, insetRight = inset2, insetLeft = inset2 } = options;
    super(
      data,
      {
        y: { value: y4, scale: "y" },
        x: { value: x4, scale: "x", type: "band", optional: true }
      },
      options
    );
    this.insetRight = number5(insetRight);
    this.insetLeft = number5(insetLeft);
  }
  _transform(selection2, mark2, { y: y4 }) {
    selection2.call(applyTransform, mark2, { y: y4 }, 0, offset);
  }
  _x1({ x: x4 }, { x: X3 }, { marginLeft: marginLeft2 }) {
    const { insetLeft } = this;
    return X3 && x4 ? (i) => X3[i] + insetLeft : marginLeft2 + insetLeft;
  }
  _x2({ x: x4 }, { x: X3 }, { width: width2, marginRight: marginRight2 }) {
    const { insetRight } = this;
    return X3 && x4 ? (i) => X3[i] + x4.bandwidth() - insetRight : width2 - marginRight2 - insetRight;
  }
  _y1(scales2, { y: Y3 }) {
    return (i) => Y3[i];
  }
  _y2(scales2, { y: Y3 }) {
    return (i) => Y3[i];
  }
};
function tickX(data, { x: x4 = identity7, ...options } = {}) {
  return new TickX(data, { ...options, x: x4 });
}
function tickY(data, { y: y4 = identity7, ...options } = {}) {
  return new TickY(data, { ...options, y: y4 });
}

// ../../node_modules/@observablehq/plot/src/marks/box.js
function boxX(data, {
  x: x4 = identity7,
  y: y4 = null,
  fill = "#ccc",
  fillOpacity,
  stroke = "currentColor",
  strokeOpacity,
  strokeWidth = 2,
  sort: sort3,
  ...options
} = {}) {
  const group3 = y4 != null ? groupY : groupZ;
  return marks(
    ruleY(data, group3({ x1: loqr1, x2: hiqr2 }, { x: x4, y: y4, stroke, strokeOpacity, ...options })),
    barX(data, group3({ x1: "p25", x2: "p75" }, { x: x4, y: y4, fill, fillOpacity, ...options })),
    tickX(data, group3({ x: "p50" }, { x: x4, y: y4, stroke, strokeOpacity, strokeWidth, sort: sort3, ...options })),
    dot(data, map3({ x: oqr }, { x: x4, y: y4, z: y4, stroke, strokeOpacity, ...options }))
  );
}
function boxY(data, {
  y: y4 = identity7,
  x: x4 = null,
  fill = "#ccc",
  fillOpacity,
  stroke = "currentColor",
  strokeOpacity,
  strokeWidth = 2,
  sort: sort3,
  ...options
} = {}) {
  const group3 = x4 != null ? groupX : groupZ;
  return marks(
    ruleX(data, group3({ y1: loqr1, y2: hiqr2 }, { x: x4, y: y4, stroke, strokeOpacity, ...options })),
    barY(data, group3({ y1: "p25", y2: "p75" }, { x: x4, y: y4, fill, fillOpacity, ...options })),
    tickY(data, group3({ y: "p50" }, { x: x4, y: y4, stroke, strokeOpacity, strokeWidth, sort: sort3, ...options })),
    dot(data, map3({ y: oqr }, { x: x4, y: y4, z: x4, stroke, strokeOpacity, ...options }))
  );
}
function oqr(values2) {
  const r1 = loqr1(values2);
  const r2 = hiqr2(values2);
  return values2.map((v3) => v3 < r1 || v3 > r2 ? v3 : NaN);
}
function loqr1(values2) {
  const lo = quartile1(values2) * 2.5 - quartile3(values2) * 1.5;
  return min2(values2, (d) => d >= lo ? d : NaN);
}
function hiqr2(values2) {
  const hi = quartile3(values2) * 2.5 - quartile1(values2) * 1.5;
  return max2(values2, (d) => d <= hi ? d : NaN);
}
function quartile1(values2) {
  return quantile2(values2, 0.25);
}
function quartile3(values2) {
  return quantile2(values2, 0.75);
}

// ../../node_modules/@observablehq/plot/src/marks/raster.js
var defaults16 = {
  ariaLabel: "raster",
  stroke: null,
  pixelSize: 1
};
function number6(input3, name2) {
  const x4 = +input3;
  if (isNaN(x4))
    throw new Error(`invalid ${name2}: ${input3}`);
  return x4;
}
function integer(input3, name2) {
  const x4 = Math.floor(input3);
  if (isNaN(x4))
    throw new Error(`invalid ${name2}: ${input3}`);
  return x4;
}
var AbstractRaster = class extends Mark {
  constructor(data, channels, options = {}, defaults23) {
    let {
      width: width2,
      height: height2,
      x: x4,
      y: y4,
      x1: x12 = x4 == null ? 0 : void 0,
      y1: y12 = y4 == null ? 0 : void 0,
      x2: x22 = x4 == null ? width2 : void 0,
      y2: y22 = y4 == null ? height2 : void 0,
      pixelSize = defaults23.pixelSize,
      blur: blur3 = 0,
      interpolate
    } = options;
    if (width2 != null)
      width2 = integer(width2, "width");
    if (height2 != null)
      height2 = integer(height2, "height");
    if (x12 != null)
      x12 = number6(x12, "x1");
    if (y12 != null)
      y12 = number6(y12, "y1");
    if (x22 != null)
      x22 = number6(x22, "x2");
    if (y22 != null)
      y22 = number6(y22, "y2");
    if (x4 == null && (x12 == null || x22 == null))
      throw new Error("missing x");
    if (y4 == null && (y12 == null || y22 == null))
      throw new Error("missing y");
    if (data != null && width2 != null && height2 != null) {
      if (x4 === void 0 && x12 != null && x22 != null)
        x4 = denseX(x12, x22, width2, height2);
      if (y4 === void 0 && y12 != null && y22 != null)
        y4 = denseY(y12, y22, width2, height2);
    }
    super(
      data,
      {
        x: { value: x4, scale: "x", optional: true },
        y: { value: y4, scale: "y", optional: true },
        x1: { value: x12 == null ? null : [x12], scale: "x", optional: true, filter: null },
        y1: { value: y12 == null ? null : [y12], scale: "y", optional: true, filter: null },
        x2: { value: x22 == null ? null : [x22], scale: "x", optional: true, filter: null },
        y2: { value: y22 == null ? null : [y22], scale: "y", optional: true, filter: null },
        ...channels
      },
      options,
      defaults23
    );
    this.width = width2;
    this.height = height2;
    this.pixelSize = number6(pixelSize, "pixelSize");
    this.blur = number6(blur3, "blur");
    this.interpolate = x4 == null || y4 == null ? null : maybeInterpolate(interpolate);
  }
};
var Raster = class extends AbstractRaster {
  constructor(data, options = {}) {
    const { imageRendering } = options;
    if (data == null) {
      const { fill, fillOpacity } = options;
      if (maybeNumberChannel(fillOpacity)[0] !== void 0)
        options = sampler("fillOpacity", options);
      if (maybeColorChannel(fill)[0] !== void 0)
        options = sampler("fill", options);
    }
    super(data, void 0, options, defaults16);
    this.imageRendering = impliedString(imageRendering, "auto");
  }
  // Ignore the color scale, so the fill channel is returned unscaled.
  scale(channels, { color: color3, ...scales2 }, context) {
    return super.scale(channels, scales2, context);
  }
  render(index2, scales2, values2, dimensions, context) {
    const color3 = scales2[values2.channels.fill?.scale] ?? ((x4) => x4);
    const { x: X3, y: Y3 } = values2;
    const { document: document2 } = context;
    const [x12, y12, x22, y22] = renderBounds(values2, dimensions, context);
    const dx = x22 - x12;
    const dy = y22 - y12;
    const { pixelSize: k3, width: w = Math.round(Math.abs(dx) / k3), height: h2 = Math.round(Math.abs(dy) / k3) } = this;
    const n = w * h2;
    let { fill: F2, fillOpacity: FO } = values2;
    let offset2 = 0;
    if (this.interpolate) {
      const kx2 = w / dx;
      const ky2 = h2 / dy;
      const IX = map2(X3, (x4) => (x4 - x12) * kx2, Float64Array);
      const IY = map2(Y3, (y4) => (y4 - y12) * ky2, Float64Array);
      if (F2)
        F2 = this.interpolate(index2, w, h2, IX, IY, F2);
      if (FO)
        FO = this.interpolate(index2, w, h2, IX, IY, FO);
    } else if (this.data == null && index2)
      offset2 = index2.fi * n;
    const canvas = document2.createElement("canvas");
    canvas.width = w;
    canvas.height = h2;
    const context2d = canvas.getContext("2d");
    const image3 = context2d.createImageData(w, h2);
    const imageData3 = image3.data;
    let { r, g: g2, b: b2 } = rgb(this.fill) ?? { r: 0, g: 0, b: 0 };
    let a3 = (this.fillOpacity ?? 1) * 255;
    for (let i = 0; i < n; ++i) {
      const j2 = i << 2;
      if (F2) {
        const fi = color3(F2[i + offset2]);
        if (fi == null) {
          imageData3[j2 + 3] = 0;
          continue;
        }
        ({ r, g: g2, b: b2 } = rgb(fi));
      }
      if (FO)
        a3 = FO[i + offset2] * 255;
      imageData3[j2 + 0] = r;
      imageData3[j2 + 1] = g2;
      imageData3[j2 + 2] = b2;
      imageData3[j2 + 3] = a3;
    }
    if (this.blur > 0)
      blurImage(image3, this.blur);
    context2d.putImageData(image3, 0, 0);
    return create3("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales2).call(
      (g3) => g3.append("image").attr("transform", `translate(${x12},${y12}) scale(${Math.sign(x22 - x12)},${Math.sign(y22 - y12)})`).attr("width", Math.abs(dx)).attr("height", Math.abs(dy)).attr("preserveAspectRatio", "none").call(applyAttr, "image-rendering", this.imageRendering).call(applyDirectStyles, this).attr("xlink:href", canvas.toDataURL())
    ).node();
  }
};
function maybeTuples(k3, data, options) {
  if (arguments.length < 3)
    options = data, data = null;
  let { x: x4, y: y4, [k3]: z2, ...rest } = options;
  if (x4 === void 0 && y4 === void 0 && isTuples(data)) {
    x4 = first2, y4 = second2;
    if (z2 === void 0)
      z2 = third;
  }
  return [data, { ...rest, x: x4, y: y4, [k3]: z2 }];
}
function raster() {
  const [data, options] = maybeTuples("fill", ...arguments);
  return new Raster(
    data,
    data == null || options.fill !== void 0 || options.fillOpacity !== void 0 ? options : { ...options, fill: identity7 }
  );
}
function renderBounds({ x1: x12, y1: y12, x2: x22, y2: y22 }, dimensions, { projection: projection3 }) {
  const { width: width2, height: height2, marginTop: marginTop2, marginRight: marginRight2, marginBottom: marginBottom2, marginLeft: marginLeft2 } = dimensions;
  return [
    x12 && projection3 == null ? x12[0] : marginLeft2,
    y12 && projection3 == null ? y12[0] : marginTop2,
    x22 && projection3 == null ? x22[0] : width2 - marginRight2,
    y22 && projection3 == null ? y22[0] : height2 - marginBottom2
  ];
}
function rasterBounds({ x1: x12, y1: y12, x2: x22, y2: y22 }, scales2, dimensions, context) {
  const channels = {};
  if (x12)
    channels.x1 = x12;
  if (y12)
    channels.y1 = y12;
  if (x22)
    channels.x2 = x22;
  if (y22)
    channels.y2 = y22;
  return renderBounds(valueObject(channels, scales2), dimensions, context);
}
function sampler(name2, options = {}) {
  const { [name2]: value } = options;
  if (typeof value !== "function")
    throw new Error(`invalid ${name2}: not a function`);
  return initializer({ ...options, [name2]: void 0 }, function(data, facets, channels, scales2, dimensions, context) {
    const { x: x4, y: y4 } = scales2;
    if (!x4)
      throw new Error("missing scale: x");
    if (!y4)
      throw new Error("missing scale: y");
    const [x12, y12, x22, y22] = rasterBounds(channels, scales2, dimensions, context);
    const dx = x22 - x12;
    const dy = y22 - y12;
    const { pixelSize: k3 } = this;
    const { width: w = Math.round(Math.abs(dx) / k3), height: h2 = Math.round(Math.abs(dy) / k3) } = options;
    const V2 = new Array(w * h2 * (facets ? facets.length : 1));
    const kx2 = dx / w;
    const ky2 = dy / h2;
    let i = 0;
    for (const facet of facets ?? [void 0]) {
      for (let yi = 0.5; yi < h2; ++yi) {
        for (let xi = 0.5; xi < w; ++xi, ++i) {
          V2[i] = value(x4.invert(x12 + xi * kx2), y4.invert(y12 + yi * ky2), facet);
        }
      }
    }
    return { data: V2, facets, channels: { [name2]: { value: V2, scale: "auto" } } };
  });
}
function maybeInterpolate(interpolate) {
  if (typeof interpolate === "function")
    return interpolate;
  if (interpolate == null)
    return interpolateNone;
  switch (`${interpolate}`.toLowerCase()) {
    case "none":
      return interpolateNone;
    case "nearest":
      return interpolateNearest;
    case "barycentric":
      return interpolatorBarycentric();
    case "random-walk":
      return interpolatorRandomWalk();
  }
  throw new Error(`invalid interpolate: ${interpolate}`);
}
function interpolateNone(index2, width2, height2, X3, Y3, V2) {
  const W2 = new Array(width2 * height2);
  for (const i of index2) {
    if (X3[i] < 0 || X3[i] >= width2 || Y3[i] < 0 || Y3[i] >= height2)
      continue;
    W2[Math.floor(Y3[i]) * width2 + Math.floor(X3[i])] = V2[i];
  }
  return W2;
}
function interpolatorBarycentric({ random = lcg(42) } = {}) {
  return (index2, width2, height2, X3, Y3, V2) => {
    const { points: points2, triangles, hull: hull3 } = Delaunay.from(
      index2,
      (i) => X3[i],
      (i) => Y3[i]
    );
    const W2 = new V2.constructor(width2 * height2).fill(NaN);
    const S2 = new Uint8Array(width2 * height2);
    const mix = mixer(V2, random);
    for (let i = 0; i < triangles.length; i += 3) {
      const ta = triangles[i];
      const tb = triangles[i + 1];
      const tc = triangles[i + 2];
      const Ax = points2[2 * ta];
      const Bx = points2[2 * tb];
      const Cx = points2[2 * tc];
      const Ay = points2[2 * ta + 1];
      const By = points2[2 * tb + 1];
      const Cy = points2[2 * tc + 1];
      const x12 = Math.min(Ax, Bx, Cx);
      const x22 = Math.max(Ax, Bx, Cx);
      const y12 = Math.min(Ay, By, Cy);
      const y22 = Math.max(Ay, By, Cy);
      const z2 = (By - Cy) * (Ax - Cx) + (Ay - Cy) * (Cx - Bx);
      if (!z2)
        continue;
      const va = V2[index2[ta]];
      const vb = V2[index2[tb]];
      const vc = V2[index2[tc]];
      for (let x4 = Math.floor(x12); x4 < x22; ++x4) {
        for (let y4 = Math.floor(y12); y4 < y22; ++y4) {
          if (x4 < 0 || x4 >= width2 || y4 < 0 || y4 >= height2)
            continue;
          const xp = x4 + 0.5;
          const yp = y4 + 0.5;
          const ga = ((By - Cy) * (xp - Cx) + (yp - Cy) * (Cx - Bx)) / z2;
          if (ga < 0)
            continue;
          const gb = ((Cy - Ay) * (xp - Cx) + (yp - Cy) * (Ax - Cx)) / z2;
          if (gb < 0)
            continue;
          const gc = 1 - ga - gb;
          if (gc < 0)
            continue;
          const i2 = x4 + width2 * y4;
          W2[i2] = mix(va, ga, vb, gb, vc, gc, x4, y4);
          S2[i2] = 1;
        }
      }
    }
    extrapolateBarycentric(W2, S2, X3, Y3, V2, width2, height2, hull3, index2, mix);
    return W2;
  };
}
function extrapolateBarycentric(W2, S2, X3, Y3, V2, width2, height2, hull3, index2, mix) {
  X3 = Float64Array.from(hull3, (i) => X3[index2[i]]);
  Y3 = Float64Array.from(hull3, (i) => Y3[index2[i]]);
  V2 = Array.from(hull3, (i) => V2[index2[i]]);
  const n = X3.length;
  const rays = Array.from({ length: n }, (_2, j2) => ray(j2, X3, Y3));
  let k3 = 0;
  for (let y4 = 0; y4 < height2; ++y4) {
    const yp = y4 + 0.5;
    for (let x4 = 0; x4 < width2; ++x4) {
      const i = x4 + width2 * y4;
      if (!S2[i]) {
        const xp = x4 + 0.5;
        for (let l = 0; l < n; ++l) {
          const j2 = (n + k3 + (l % 2 ? (l + 1) / 2 : -l / 2)) % n;
          if (rays[j2](xp, yp)) {
            const t = segmentProject(X3.at(j2 - 1), Y3.at(j2 - 1), X3[j2], Y3[j2], xp, yp);
            W2[i] = mix(V2.at(j2 - 1), t, V2[j2], 1 - t, V2[j2], 0, x4, y4);
            k3 = j2;
            break;
          }
        }
      }
    }
  }
}
function segmentProject(x12, y12, x22, y22, x4, y4) {
  const dx = x22 - x12;
  const dy = y22 - y12;
  const a3 = dx * (x22 - x4) + dy * (y22 - y4);
  const b2 = dx * (x4 - x12) + dy * (y4 - y12);
  return a3 > 0 && b2 > 0 ? a3 / (a3 + b2) : +(a3 > b2);
}
function cross2(xa, ya, xb, yb) {
  return xa * yb - xb * ya;
}
function ray(j2, X3, Y3) {
  const n = X3.length;
  const xc = X3.at(j2 - 2);
  const yc = Y3.at(j2 - 2);
  const xa = X3.at(j2 - 1);
  const ya = Y3.at(j2 - 1);
  const xb = X3[j2];
  const yb = Y3[j2];
  const xd = X3.at(j2 + 1 - n);
  const yd = Y3.at(j2 + 1 - n);
  const dxab = xa - xb;
  const dyab = ya - yb;
  const dxca = xc - xa;
  const dyca = yc - ya;
  const dxbd = xb - xd;
  const dybd = yb - yd;
  const hab = Math.hypot(dxab, dyab);
  const hca = Math.hypot(dxca, dyca);
  const hbd = Math.hypot(dxbd, dybd);
  return (x4, y4) => {
    const dxa = x4 - xa;
    const dya = y4 - ya;
    const dxb = x4 - xb;
    const dyb = y4 - yb;
    return cross2(dxa, dya, dxb, dyb) > -1e-6 && cross2(dxa, dya, dxab, dyab) * hca - cross2(dxa, dya, dxca, dyca) * hab > -1e-6 && cross2(dxb, dyb, dxbd, dybd) * hab - cross2(dxb, dyb, dxab, dyab) * hbd <= 0;
  };
}
function interpolateNearest(index2, width2, height2, X3, Y3, V2) {
  const W2 = new V2.constructor(width2 * height2);
  const delaunay = Delaunay.from(
    index2,
    (i) => X3[i],
    (i) => Y3[i]
  );
  let iy, ix;
  for (let y4 = 0.5, k3 = 0; y4 < height2; ++y4) {
    ix = iy;
    for (let x4 = 0.5; x4 < width2; ++x4, ++k3) {
      ix = delaunay.find(x4, y4, ix);
      if (x4 === 0.5)
        iy = ix;
      W2[k3] = V2[index2[ix]];
    }
  }
  return W2;
}
function interpolatorRandomWalk({ random = lcg(42), minDistance = 0.5, maxSteps = 2 } = {}) {
  return (index2, width2, height2, X3, Y3, V2) => {
    const W2 = new V2.constructor(width2 * height2);
    const delaunay = Delaunay.from(
      index2,
      (i) => X3[i],
      (i) => Y3[i]
    );
    let iy, ix, iw;
    for (let y4 = 0.5, k3 = 0; y4 < height2; ++y4) {
      ix = iy;
      for (let x4 = 0.5; x4 < width2; ++x4, ++k3) {
        let cx = x4;
        let cy = y4;
        iw = ix = delaunay.find(cx, cy, ix);
        if (x4 === 0.5)
          iy = ix;
        let distance;
        let step = 0;
        while ((distance = Math.hypot(X3[index2[iw]] - cx, Y3[index2[iw]] - cy)) > minDistance && step < maxSteps) {
          const angle = random(x4, y4, step) * 2 * Math.PI;
          cx += Math.cos(angle) * distance;
          cy += Math.sin(angle) * distance;
          iw = delaunay.find(cx, cy, iw);
          ++step;
        }
        W2[k3] = V2[index2[iw]];
      }
    }
    return W2;
  };
}
function blend(a3, ca3, b2, cb, c4, cc2) {
  return ca3 * a3 + cb * b2 + cc2 * c4;
}
function pick(random) {
  return (a3, ca3, b2, cb, c4, cc2, x4, y4) => {
    const u4 = random(x4, y4);
    return u4 < ca3 ? a3 : u4 < ca3 + cb ? b2 : c4;
  };
}
function mixer(F2, random) {
  return isNumeric(F2) || isTemporal(F2) ? blend : pick(random);
}
function denseX(x12, x22, width2) {
  return {
    transform(data) {
      const n = data.length;
      const X3 = new Float64Array(n);
      const kx2 = (x22 - x12) / width2;
      const x06 = x12 + kx2 / 2;
      for (let i = 0; i < n; ++i)
        X3[i] = i % width2 * kx2 + x06;
      return X3;
    }
  };
}
function denseY(y12, y22, width2, height2) {
  return {
    transform(data) {
      const n = data.length;
      const Y3 = new Float64Array(n);
      const ky2 = (y22 - y12) / height2;
      const y06 = y12 + ky2 / 2;
      for (let i = 0; i < n; ++i)
        Y3[i] = Math.floor(i / width2) % height2 * ky2 + y06;
      return Y3;
    }
  };
}

// ../../node_modules/@observablehq/plot/src/marks/contour.js
var defaults17 = {
  ariaLabel: "contour",
  fill: "none",
  stroke: "currentColor",
  strokeMiterlimit: 1,
  pixelSize: 2
};
var Contour = class extends AbstractRaster {
  constructor(data, { smooth = true, value, ...options } = {}) {
    const channels = styles({}, options, defaults17);
    if (value === void 0) {
      for (const key in channels) {
        if (channels[key].value != null) {
          if (value !== void 0)
            throw new Error("ambiguous contour value");
          value = options[key];
          options[key] = "value";
        }
      }
    }
    if (value != null) {
      const v3 = { transform: (D4) => D4.map((d) => d.value), label: labelof(value) };
      for (const key in channels) {
        if (options[key] === "value") {
          options[key] = v3;
        }
      }
    }
    if (data == null) {
      if (value == null)
        throw new Error("missing contour value");
      options = sampler("value", { value, ...options });
      value = null;
    } else {
      let { interpolate } = options;
      if (value === void 0)
        value = identity7;
      if (interpolate === void 0)
        options.interpolate = "nearest";
    }
    super(data, { value: { value, optional: true } }, contourGeometry(options), defaults17);
    const contourChannels = { geometry: { value: identity7 } };
    for (const key in this.channels) {
      const channel = this.channels[key];
      const { scale: scale3 } = channel;
      if (scale3 === "x" || scale3 === "y" || key === "value")
        continue;
      contourChannels[key] = channel;
      delete this.channels[key];
    }
    this.contourChannels = contourChannels;
    this.smooth = !!smooth;
  }
  filter(index2, { x: x4, y: y4, value, ...channels }, values2) {
    return super.filter(index2, channels, values2);
  }
  render(index2, scales2, channels, dimensions, context) {
    const { geometry: G } = channels;
    const path2 = path_default();
    return create3("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales2).call((g2) => {
      g2.selectAll().data(index2).enter().append("path").call(applyDirectStyles, this).attr("d", (i) => path2(G[i])).call(applyChannelStyles, this, channels);
    }).node();
  }
};
function contourGeometry({ thresholds, interval: interval2, ...options }) {
  thresholds = maybeThresholds(thresholds, interval2, thresholdSturges);
  return initializer(options, function(data, facets, channels, scales2, dimensions, context) {
    const [x12, y12, x22, y22] = rasterBounds(channels, scales2, dimensions, context);
    const dx = x22 - x12;
    const dy = y22 - y12;
    const { pixelSize: k3, width: w = Math.round(Math.abs(dx) / k3), height: h2 = Math.round(Math.abs(dy) / k3) } = this;
    const kx2 = w / dx;
    const ky2 = h2 / dy;
    const V2 = channels.value.value;
    const VV = [];
    if (this.interpolate) {
      const { x: X3, y: Y3 } = applyPosition(channels, scales2, context);
      const IX = map2(X3, (x4) => (x4 - x12) * kx2, Float64Array);
      const IY = map2(Y3, (y4) => (y4 - y12) * ky2, Float64Array);
      const ichannels = [channels.x, channels.y, channels.value];
      const ivalues = [IX, IY, V2];
      for (const facet of facets) {
        const index2 = this.filter(facet, ichannels, ivalues);
        VV.push(this.interpolate(index2, w, h2, IX, IY, V2));
      }
    } else if (facets) {
      const n = w * h2;
      const m2 = facets.length;
      for (let i = 0; i < m2; ++i)
        VV.push(V2.slice(i * n, i * n + n));
    } else {
      VV.push(V2);
    }
    if (this.blur > 0)
      for (const V3 of VV)
        blur2({ data: V3, width: w, height: h2 }, this.blur);
    const T = maybeTicks(thresholds, V2, ...finiteExtent(VV));
    if (T === null)
      throw new Error(`unsupported thresholds: ${thresholds}`);
    const { contour: contour3 } = contours_default().size([w, h2]).smooth(this.smooth);
    const contourData = [];
    const contourFacets = [];
    for (const V3 of VV) {
      contourFacets.push(range(contourData.length, contourData.push(...map2(T, (t) => contour3(V3, t)))));
    }
    for (const { coordinates } of contourData) {
      for (const rings of coordinates) {
        for (const ring of rings) {
          for (const point6 of ring) {
            point6[0] = point6[0] / kx2 + x12;
            point6[1] = point6[1] / ky2 + y12;
          }
        }
      }
    }
    return {
      data: contourData,
      facets: contourFacets,
      channels: createChannels(this.contourChannels, contourData)
    };
  });
}
function maybeTicks(thresholds, V2, min5, max4) {
  if (typeof thresholds?.range === "function")
    return thresholds.range(thresholds.floor(min5), max4);
  if (typeof thresholds === "function")
    thresholds = thresholds(V2, min5, max4);
  if (typeof thresholds !== "number")
    return arrayify2(thresholds);
  const tz = ticks(...nice(min5, max4, thresholds), thresholds);
  while (tz[tz.length - 1] >= max4)
    tz.pop();
  while (tz[1] < min5)
    tz.shift();
  return tz;
}
function contour() {
  return new Contour(...maybeTuples("value", ...arguments));
}
function finiteExtent(VV) {
  return [min2(VV, (V2) => min2(V2, finite3)), max2(VV, (V2) => max2(V2, finite3))];
}
function finite3(x4) {
  return isFinite(x4) ? x4 : NaN;
}

// ../../node_modules/@observablehq/plot/src/marks/crosshair.js
function crosshair(data, options) {
  return crosshairK(pointer, data, options);
}
function crosshairX(data, options = {}) {
  return crosshairK(pointerX, data, options);
}
function crosshairY(data, options = {}) {
  return crosshairK(pointerY, data, options);
}
function crosshairK(pointer2, data, options = {}) {
  const { x: x4, y: y4, maxRadius } = options;
  const p2 = pointer2({ px: x4, py: y4, maxRadius });
  const M3 = [];
  if (x4 != null)
    M3.push(ruleX(data, ruleOptions("x", { ...p2, inset: -6 }, options)));
  if (y4 != null)
    M3.push(ruleY(data, ruleOptions("y", { ...p2, inset: -6 }, options)));
  if (x4 != null)
    M3.push(text(data, textOptions("x", { ...p2, dy: 9, frameAnchor: "bottom", lineAnchor: "top" }, options)));
  if (y4 != null)
    M3.push(text(data, textOptions("y", { ...p2, dx: -9, frameAnchor: "left", textAnchor: "end" }, options)));
  for (const m2 of M3)
    m2.ariaLabel = `crosshair ${m2.ariaLabel}`;
  return marks(...M3);
}
function markOptions(k3, { channels: pointerChannels, ...pointerOptions }, { facet, facetAnchor, fx, fy, [k3]: p2, channels, transform: transform3, initializer: initializer2 }) {
  return {
    ...pointerOptions,
    facet,
    facetAnchor,
    fx,
    fy,
    [k3]: p2,
    channels: { ...pointerChannels, ...channels },
    transform: transform3,
    initializer: pxpy(k3, initializer2)
  };
}
function pxpy(k3, i) {
  if (i == null)
    return i;
  return function(data, facets, { x: x12, y: y12, px, py, ...c1 }, ...args) {
    const { channels: { x: x4, y: y4, ...c4 } = {}, ...rest } = i.call(this, data, facets, { ...c1, x: px, y: py }, ...args);
    return {
      channels: {
        ...c4,
        ...x4 && { px: x4, ...k3 === "x" && { x: x4 } },
        ...y4 && { py: y4, ...k3 === "y" && { y: y4 } }
      },
      ...rest
    };
  };
}
function ruleOptions(k3, pointerOptions, options) {
  const {
    color: color3 = "currentColor",
    opacity: opacity2 = 0.2,
    ruleStroke: stroke = color3,
    ruleStrokeOpacity: strokeOpacity = opacity2,
    ruleStrokeWidth: strokeWidth
  } = options;
  return {
    ...markOptions(k3, pointerOptions, options),
    stroke,
    strokeOpacity,
    strokeWidth
  };
}
function textOptions(k3, pointerOptions, options) {
  const {
    color: color3 = "currentColor",
    textFill: fill = color3,
    textFillOpacity: fillOpacity,
    textStroke: stroke = "var(--plot-background)",
    textStrokeOpacity: strokeOpacity,
    textStrokeWidth: strokeWidth = 5
  } = options;
  return {
    ...markOptions(k3, pointerOptions, textChannel(k3, options)),
    fill,
    fillOpacity,
    stroke,
    strokeOpacity,
    strokeWidth
  };
}
function textChannel(source, options) {
  return initializer(options, (data, facets, channels) => {
    return { channels: { text: { value: getSource(channels, source)?.value } } };
  });
}

// ../../node_modules/@observablehq/plot/src/marks/delaunay.js
var delaunayLinkDefaults = {
  ariaLabel: "delaunay link",
  fill: "none",
  stroke: "currentColor",
  strokeMiterlimit: 1
};
var delaunayMeshDefaults = {
  ariaLabel: "delaunay mesh",
  fill: null,
  stroke: "currentColor",
  strokeOpacity: 0.2
};
var hullDefaults = {
  ariaLabel: "hull",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 1.5,
  strokeMiterlimit: 1
};
var voronoiDefaults = {
  ariaLabel: "voronoi",
  fill: "none",
  stroke: "currentColor",
  strokeMiterlimit: 1
};
var voronoiMeshDefaults = {
  ariaLabel: "voronoi mesh",
  fill: null,
  stroke: "currentColor",
  strokeOpacity: 0.2
};
var DelaunayLink = class extends Mark {
  constructor(data, options = {}) {
    const { x: x4, y: y4, z: z2, curve, tension } = options;
    super(
      data,
      {
        x: { value: x4, scale: "x", optional: true },
        y: { value: y4, scale: "y", optional: true },
        z: { value: z2, optional: true }
      },
      options,
      delaunayLinkDefaults
    );
    this.curve = maybeCurve(curve, tension);
    markers(this, options);
  }
  render(index2, scales2, channels, dimensions, context) {
    const { x: x4, y: y4 } = scales2;
    const { x: X3, y: Y3, z: Z3 } = channels;
    const { curve } = this;
    const [cx, cy] = applyFrameAnchor(this, dimensions);
    const xi = X3 ? (i) => X3[i] : constant(cx);
    const yi = Y3 ? (i) => Y3[i] : constant(cy);
    const mark2 = this;
    function links(index3) {
      let i = -1;
      const newIndex = [];
      const newChannels = {};
      for (const k3 in channels)
        newChannels[k3] = [];
      const X13 = [];
      const X24 = [];
      const Y13 = [];
      const Y24 = [];
      function link4(ti, tj) {
        ti = index3[ti];
        tj = index3[tj];
        newIndex.push(++i);
        X13[i] = xi(ti);
        Y13[i] = yi(ti);
        X24[i] = xi(tj);
        Y24[i] = yi(tj);
        for (const k3 in channels)
          newChannels[k3].push(channels[k3][tj]);
      }
      const { halfedges, hull: hull3, triangles } = Delaunay.from(index3, xi, yi);
      for (let i2 = 0; i2 < halfedges.length; ++i2) {
        const j2 = halfedges[i2];
        if (j2 > i2)
          link4(triangles[i2], triangles[j2]);
      }
      for (let i2 = 0; i2 < hull3.length; ++i2) {
        link4(hull3[i2], hull3[(i2 + 1) % hull3.length]);
      }
      select_default2(this).selectAll().data(newIndex).enter().append("path").call(applyDirectStyles, mark2).attr("d", (i2) => {
        const p2 = pathRound();
        const c4 = curve(p2);
        c4.lineStart();
        c4.point(X13[i2], Y13[i2]);
        c4.point(X24[i2], Y24[i2]);
        c4.lineEnd();
        return p2;
      }).call(applyChannelStyles, mark2, newChannels).call(applyMarkers, mark2, newChannels, context);
    }
    return create3("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X3 && x4, y: Y3 && y4 }).call(
      Z3 ? (g2) => g2.selectAll().data(group(index2, (i) => Z3[i]).values()).enter().append("g").each(links) : (g2) => g2.datum(index2).each(links)
    ).node();
  }
};
var AbstractDelaunayMark = class extends Mark {
  constructor(data, options = {}, defaults23, zof = ({ z: z2 }) => z2) {
    const { x: x4, y: y4 } = options;
    super(
      data,
      {
        x: { value: x4, scale: "x", optional: true },
        y: { value: y4, scale: "y", optional: true },
        z: { value: zof(options), optional: true }
      },
      options,
      defaults23
    );
  }
  render(index2, scales2, channels, dimensions, context) {
    const { x: x4, y: y4 } = scales2;
    const { x: X3, y: Y3, z: Z3 } = channels;
    const [cx, cy] = applyFrameAnchor(this, dimensions);
    const xi = X3 ? (i) => X3[i] : constant(cx);
    const yi = Y3 ? (i) => Y3[i] : constant(cy);
    const mark2 = this;
    function mesh(index3) {
      const delaunay = Delaunay.from(index3, xi, yi);
      select_default2(this).append("path").datum(index3[0]).call(applyDirectStyles, mark2).attr("d", mark2._render(delaunay, dimensions)).call(applyChannelStyles, mark2, channels);
    }
    return create3("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X3 && x4, y: Y3 && y4 }).call(
      Z3 ? (g2) => g2.selectAll().data(group(index2, (i) => Z3[i]).values()).enter().append("g").each(mesh) : (g2) => g2.datum(index2).each(mesh)
    ).node();
  }
};
var DelaunayMesh = class extends AbstractDelaunayMark {
  constructor(data, options = {}) {
    super(data, options, delaunayMeshDefaults);
    this.fill = "none";
  }
  _render(delaunay) {
    return delaunay.render();
  }
};
var Hull = class extends AbstractDelaunayMark {
  constructor(data, options = {}) {
    super(data, options, hullDefaults, maybeZ);
  }
  _render(delaunay) {
    return delaunay.renderHull();
  }
};
var Voronoi2 = class extends Mark {
  constructor(data, options = {}) {
    const { x: x4, y: y4, z: z2 } = options;
    super(
      data,
      {
        x: { value: x4, scale: "x", optional: true },
        y: { value: y4, scale: "y", optional: true },
        z: { value: z2, optional: true }
      },
      options,
      voronoiDefaults
    );
  }
  render(index2, scales2, channels, dimensions, context) {
    const { x: x4, y: y4 } = scales2;
    const { x: X3, y: Y3, z: Z3 } = channels;
    const [cx, cy] = applyFrameAnchor(this, dimensions);
    const xi = X3 ? (i) => X3[i] : constant(cx);
    const yi = Y3 ? (i) => Y3[i] : constant(cy);
    const mark2 = this;
    function cells(index3) {
      const delaunay = Delaunay.from(index3, xi, yi);
      const voronoi3 = voronoiof(delaunay, dimensions);
      select_default2(this).selectAll().data(index3).enter().append("path").call(applyDirectStyles, mark2).attr("d", (_2, i) => voronoi3.renderCell(i)).call(applyChannelStyles, mark2, channels);
    }
    return create3("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X3 && x4, y: Y3 && y4 }).call(
      Z3 ? (g2) => g2.selectAll().data(group(index2, (i) => Z3[i]).values()).enter().append("g").each(cells) : (g2) => g2.datum(index2).each(cells)
    ).node();
  }
};
var VoronoiMesh = class extends AbstractDelaunayMark {
  constructor(data, options) {
    super(data, options, voronoiMeshDefaults);
    this.fill = "none";
  }
  _render(delaunay, dimensions) {
    return voronoiof(delaunay, dimensions).render();
  }
};
function voronoiof(delaunay, dimensions) {
  const { width: width2, height: height2, marginTop: marginTop2, marginRight: marginRight2, marginBottom: marginBottom2, marginLeft: marginLeft2 } = dimensions;
  return delaunay.voronoi([marginLeft2, marginTop2, width2 - marginRight2, height2 - marginBottom2]);
}
function delaunayMark(DelaunayMark, data, { x: x4, y: y4, ...options } = {}) {
  [x4, y4] = maybeTuple(x4, y4);
  return new DelaunayMark(data, { ...options, x: x4, y: y4 });
}
function delaunayLink(data, options) {
  return delaunayMark(DelaunayLink, data, options);
}
function delaunayMesh(data, options) {
  return delaunayMark(DelaunayMesh, data, options);
}
function hull(data, options) {
  return delaunayMark(Hull, data, options);
}
function voronoi(data, options) {
  return delaunayMark(Voronoi2, data, options);
}
function voronoiMesh(data, options) {
  return delaunayMark(VoronoiMesh, data, options);
}

// ../../node_modules/@observablehq/plot/src/marks/density.js
var defaults18 = {
  ariaLabel: "density",
  fill: "none",
  stroke: "currentColor",
  strokeMiterlimit: 1
};
var Density = class extends Mark {
  constructor(data, { x: x4, y: y4, z: z2, weight, fill, stroke, ...options } = {}) {
    const fillDensity = isDensity(fill) && (fill = "currentColor", true);
    const strokeDensity = isDensity(stroke) && (stroke = "currentColor", true);
    super(
      data,
      {
        x: { value: x4, scale: "x", optional: true },
        y: { value: y4, scale: "y", optional: true },
        z: { value: maybeZ({ z: z2, fill, stroke }), optional: true },
        weight: { value: weight, optional: true }
      },
      densityInitializer({ ...options, fill, stroke }, fillDensity, strokeDensity),
      defaults18
    );
    if (fillDensity)
      this.fill = void 0;
    if (strokeDensity)
      this.stroke = void 0;
    this.z = z2;
  }
  filter(index2) {
    return index2;
  }
  render(index2, scales2, channels, dimensions, context) {
    const { contours } = channels;
    const path2 = path_default();
    return create3("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, {}).call(
      (g2) => g2.selectAll().data(index2).enter().append("path").call(applyDirectStyles, this).call(applyChannelStyles, this, channels).attr("d", (i) => path2(contours[i]))
    ).node();
  }
};
function density(data, { x: x4, y: y4, ...options } = {}) {
  [x4, y4] = maybeTuple(x4, y4);
  return new Density(data, { ...options, x: x4, y: y4 });
}
var dropChannels = /* @__PURE__ */ new Set(["x", "y", "z", "weight"]);
function densityInitializer(options, fillDensity, strokeDensity) {
  const k3 = 100;
  let { bandwidth, thresholds } = options;
  bandwidth = bandwidth === void 0 ? 20 : +bandwidth;
  thresholds = thresholds === void 0 ? 20 : typeof thresholds?.[Symbol.iterator] === "function" ? coerceNumbers(thresholds) : +thresholds;
  return initializer(options, function(data, facets, channels, scales2, dimensions, context) {
    const W2 = channels.weight ? coerceNumbers(channels.weight.value) : null;
    const Z3 = channels.z?.value;
    const { z: z2 } = this;
    const [cx, cy] = applyFrameAnchor(this, dimensions);
    const { width: width2, height: height2 } = dimensions;
    const { x: X3, y: Y3 } = applyPosition(channels, scales2, context);
    const newChannels = Object.fromEntries(
      Object.entries(channels).filter(([key]) => !dropChannels.has(key)).map(([key, channel]) => [key, { ...channel, value: [] }])
    );
    const FD = fillDensity && [];
    const SD = strokeDensity && [];
    const density3 = density_default().x(X3 ? (i) => X3[i] : cx).y(Y3 ? (i) => Y3[i] : cy).weight(W2 ? (i) => W2[i] : 1).size([width2, height2]).bandwidth(bandwidth);
    const facetsContours = [];
    for (const facet of facets) {
      const facetContours = [];
      facetsContours.push(facetContours);
      for (const index2 of Z3 ? groupZ2(facet, Z3, z2) : [facet]) {
        const contour3 = density3.contours(index2);
        facetContours.push([index2, contour3]);
      }
    }
    let T = thresholds;
    if (!(T instanceof TypedArray)) {
      let maxValue = 0;
      for (const facetContours of facetsContours) {
        for (const [, contour3] of facetContours) {
          const max4 = contour3.max;
          if (max4 > maxValue)
            maxValue = max4;
        }
      }
      T = Float64Array.from({ length: thresholds - 1 }, (_2, i) => maxValue * k3 * (i + 1) / thresholds);
    }
    const newFacets = [];
    const contours = [];
    for (const facetContours of facetsContours) {
      const newFacet = [];
      newFacets.push(newFacet);
      for (const [index2, contour3] of facetContours) {
        for (const t of T) {
          newFacet.push(contours.length);
          contours.push(contour3(t / k3));
          if (FD)
            FD.push(t);
          if (SD)
            SD.push(t);
          for (const key in newChannels) {
            newChannels[key].value.push(channels[key].value[index2[0]]);
          }
        }
      }
    }
    if (FD)
      FD.push(0);
    if (SD)
      SD.push(0);
    return {
      data,
      facets: newFacets,
      channels: {
        ...newChannels,
        ...FD && { fill: { value: FD, scale: "color" } },
        ...SD && { stroke: { value: SD, scale: "color" } },
        contours: { value: contours }
      }
    };
  });
}
function isDensity(value) {
  return /^density$/i.test(value);
}

// ../../node_modules/@observablehq/plot/src/marks/difference.js
function differenceY(data, {
  x1: x12,
  x2: x22,
  y1: y12,
  y2: y22,
  x: x4 = x12 === void 0 && x22 === void 0 ? indexOf : void 0,
  y: y4 = y12 === void 0 && y22 === void 0 ? identity7 : void 0,
  fill,
  // ignored
  positiveFill = "#3ca951",
  negativeFill = "#4269d0",
  fillOpacity = 1,
  positiveFillOpacity = fillOpacity,
  negativeFillOpacity = fillOpacity,
  stroke,
  strokeOpacity,
  z: z2 = maybeColorChannel(stroke)[0],
  clip,
  // optional additional clip for area
  tip: tip2,
  render,
  ...options
} = {}) {
  [x12, x22] = memoTuple(x4, x12, x22);
  [y12, y22] = memoTuple(y4, y12, y22);
  if (x12 === x22 && y12 === y22)
    y12 = memo(0);
  ({ tip: tip2 } = withTip({ tip: tip2 }, "x"));
  return marks(
    !isNoneish(positiveFill) ? Object.assign(
      area(data, {
        x1: x12,
        x2: x22,
        y1: y12,
        y2: y22,
        z: z2,
        fill: positiveFill,
        fillOpacity: positiveFillOpacity,
        render: composeRender(render, clipDifferenceY(true)),
        clip,
        ...options
      }),
      { ariaLabel: "positive difference" }
    ) : null,
    !isNoneish(negativeFill) ? Object.assign(
      area(data, {
        x1: x12,
        x2: x22,
        y1: y12,
        y2: y22,
        z: z2,
        fill: negativeFill,
        fillOpacity: negativeFillOpacity,
        render: composeRender(render, clipDifferenceY(false)),
        clip,
        ...options
      }),
      { ariaLabel: "negative difference" }
    ) : null,
    line(data, {
      x: x22,
      y: y22,
      z: z2,
      stroke,
      strokeOpacity,
      tip: tip2,
      clip: true,
      ...options
    })
  );
}
function memoTuple(x4, x12, x22) {
  if (x12 === void 0 && x22 === void 0) {
    x12 = x22 = memo(x4);
  } else if (x12 === void 0) {
    x22 = memo(x22);
    x12 = x4 === void 0 ? x22 : memo(x4);
  } else if (x22 === void 0) {
    x12 = memo(x12);
    x22 = x4 === void 0 ? x12 : memo(x4);
  } else {
    x12 = memo(x12);
    x22 = memo(x22);
  }
  return [x12, x22];
}
function memo(v3) {
  let V2;
  const { value, label: label2 = labelof(value) } = maybeValue(v3);
  return { transform: (data) => V2 || (V2 = valueof(data, value)), label: label2 };
}
function clipDifferenceY(positive2) {
  return (index2, scales2, channels, dimensions, context, next) => {
    const { x1: x12, x2: x22 } = channels;
    const { height: height2 } = dimensions;
    const y12 = new Float32Array(x12.length);
    const y22 = new Float32Array(x22.length);
    (positive2 === inferScaleOrder(scales2.y) < 0 ? y12 : y22).fill(height2);
    const oc = next(index2, scales2, { ...channels, x2: x12, y2: y22 }, dimensions, context);
    const og = next(index2, scales2, { ...channels, x1: x22, y1: y12 }, dimensions, context);
    const c4 = oc.querySelector("g") ?? oc;
    const g2 = og.querySelector("g") ?? og;
    for (let i = 0; c4.firstChild; i += 2) {
      const id2 = getClipId();
      const clipPath = create3("svg:clipPath", context).attr("id", id2).node();
      clipPath.appendChild(c4.firstChild);
      g2.childNodes[i].setAttribute("clip-path", `url(#${id2})`);
      g2.insertBefore(clipPath, g2.childNodes[i]);
    }
    return og;
  };
}

// ../../node_modules/@observablehq/plot/src/marks/geo.js
var defaults19 = {
  ariaLabel: "geo",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 1,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeMiterlimit: 1
};
var Geo = class extends Mark {
  constructor(data, options = {}) {
    const [vr, cr] = maybeNumberChannel(options.r, 3);
    super(
      data,
      {
        geometry: { value: options.geometry, scale: "projection" },
        r: { value: vr, scale: "r", filter: positive, optional: true }
      },
      withDefaultSort(options),
      defaults19
    );
    this.r = cr;
  }
  render(index2, scales2, channels, dimensions, context) {
    const { geometry: G, r: R2 } = channels;
    const path2 = path_default(context.projection ?? scaleProjection2(scales2));
    const { r } = this;
    if (negative(r))
      index2 = [];
    else if (r !== void 0)
      path2.pointRadius(r);
    return create3("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales2).call((g2) => {
      g2.selectAll().data(index2).enter().append("path").call(applyDirectStyles, this).attr("d", R2 ? (i) => path2.pointRadius(R2[i])(G[i]) : (i) => path2(G[i])).call(applyChannelStyles, this, channels);
    }).node();
  }
};
function scaleProjection2({ x: X3, y: Y3 }) {
  if (X3 || Y3) {
    X3 ??= (x4) => x4;
    Y3 ??= (y4) => y4;
    return transform_default({
      point(x4, y4) {
        this.stream.point(X3(x4), Y3(y4));
      }
    });
  }
}
function geo(data, { geometry = identity7, ...options } = {}) {
  switch (data?.type) {
    case "FeatureCollection":
      data = data.features;
      break;
    case "GeometryCollection":
      data = data.geometries;
      break;
    case "Feature":
    case "LineString":
    case "MultiLineString":
    case "MultiPoint":
    case "MultiPolygon":
    case "Point":
    case "Polygon":
    case "Sphere":
      data = [data];
      break;
  }
  return new Geo(data, { geometry, ...options });
}
function sphere({ strokeWidth = 1.5, ...options } = {}) {
  return geo({ type: "Sphere" }, { strokeWidth, ...options });
}
function graticule2({ strokeOpacity = 0.1, ...options } = {}) {
  return geo(graticule10(), { strokeOpacity, ...options });
}

// ../../node_modules/@observablehq/plot/src/transforms/hexbin.js
var ox = 0.5;
var oy = 0;
function hexbin(outputs = { fill: "count" }, { binWidth, ...options } = {}) {
  const { z: z2 } = options;
  binWidth = binWidth === void 0 ? 20 : number5(binWidth);
  outputs = maybeGroupOutputs(outputs, options);
  if (hasOutput(outputs, "fill"))
    options.channels = { ...options.channels, fill: { value: [] } };
  if (options.symbol === void 0)
    options.symbol = "hexagon";
  if (options.r === void 0 && !hasOutput(outputs, "r"))
    options.r = binWidth / 2;
  return initializer(options, (data, facets, channels, scales2, _2, context) => {
    let { x: X3, y: Y3, z: Z3, fill: F2, stroke: S2, symbol: Q2 } = channels;
    if (X3 === void 0)
      throw new Error("missing channel: x");
    if (Y3 === void 0)
      throw new Error("missing channel: y");
    ({ x: X3, y: Y3 } = applyPosition(channels, scales2, context));
    Z3 = Z3 ? Z3.value : valueof(data, z2);
    F2 = F2?.value;
    S2 = S2?.value;
    Q2 = Q2?.value;
    const G = maybeSubgroup(outputs, { z: Z3, fill: F2, stroke: S2, symbol: Q2 });
    const GZ = Z3 && [];
    const GF = F2 && [];
    const GS = S2 && [];
    const GQ = Q2 && [];
    const binFacets = [];
    const BX = [];
    const BY = [];
    let i = -1;
    for (const o of outputs)
      o.initialize(data);
    for (const facet of facets) {
      const binFacet = [];
      for (const o of outputs)
        o.scope("facet", facet);
      for (const [f2, I2] of maybeGroup(facet, G)) {
        for (const { index: b2, extent: extent4 } of hbin(data, I2, X3, Y3, binWidth)) {
          binFacet.push(++i);
          BX.push(extent4.x);
          BY.push(extent4.y);
          if (Z3)
            GZ.push(G === Z3 ? f2 : Z3[b2[0]]);
          if (F2)
            GF.push(G === F2 ? f2 : F2[b2[0]]);
          if (S2)
            GS.push(G === S2 ? f2 : S2[b2[0]]);
          if (Q2)
            GQ.push(G === Q2 ? f2 : Q2[b2[0]]);
          for (const o of outputs)
            o.reduce(b2, extent4);
        }
      }
      binFacets.push(binFacet);
    }
    const sx = channels.x.scale;
    const sy = channels.y.scale;
    const binChannels = {
      x: { value: BX, source: scales2[sx] ? { value: map2(BX, scales2[sx].invert), scale: sx } : null },
      y: { value: BY, source: scales2[sy] ? { value: map2(BY, scales2[sy].invert), scale: sy } : null },
      ...Z3 && { z: { value: GZ } },
      ...F2 && { fill: { value: GF, scale: "auto" } },
      ...S2 && { stroke: { value: GS, scale: "auto" } },
      ...Q2 && { symbol: { value: GQ, scale: "auto" } },
      ...Object.fromEntries(
        outputs.map(({ name: name2, output }) => [
          name2,
          {
            scale: "auto",
            label: output.label,
            radius: name2 === "r" ? binWidth / 2 : void 0,
            value: output.transform()
          }
        ])
      )
    };
    return { data, facets: binFacets, channels: binChannels };
  });
}
function hbin(data, I2, X3, Y3, dx) {
  const dy = dx * (1.5 / sqrt35);
  const bins2 = /* @__PURE__ */ new Map();
  for (const i of I2) {
    let px = X3[i], py = Y3[i];
    if (isNaN(px) || isNaN(py))
      continue;
    let pj = Math.round(py = (py - oy) / dy), pi5 = Math.round(px = (px - ox) / dx - (pj & 1) / 2), py1 = py - pj;
    if (Math.abs(py1) * 3 > 1) {
      let px1 = px - pi5, pi22 = pi5 + (px < pi5 ? -1 : 1) / 2, pj2 = pj + (py < pj ? -1 : 1), px2 = px - pi22, py2 = py - pj2;
      if (px1 * px1 + py1 * py1 > px2 * px2 + py2 * py2)
        pi5 = pi22 + (pj & 1 ? 1 : -1) / 2, pj = pj2;
    }
    const key = `${pi5},${pj}`;
    let bin3 = bins2.get(key);
    if (bin3 === void 0) {
      bin3 = { index: [], extent: { data, x: (pi5 + (pj & 1) / 2) * dx + ox, y: pj * dy + oy } };
      bins2.set(key, bin3);
    }
    bin3.index.push(i);
  }
  return bins2.values();
}

// ../../node_modules/@observablehq/plot/src/marks/hexgrid.js
var defaults20 = {
  ariaLabel: "hexgrid",
  fill: "none",
  stroke: "currentColor",
  strokeOpacity: 0.1
};
function hexgrid(options) {
  return new Hexgrid(options);
}
var Hexgrid = class extends Mark {
  constructor({ binWidth = 20, clip = true, ...options } = {}) {
    super(singleton, void 0, { clip, ...options }, defaults20);
    this.binWidth = number5(binWidth);
  }
  render(index2, scales2, channels, dimensions, context) {
    const { binWidth } = this;
    const { marginTop: marginTop2, marginRight: marginRight2, marginBottom: marginBottom2, marginLeft: marginLeft2, width: width2, height: height2 } = dimensions;
    const x06 = marginLeft2 - ox, x12 = width2 - marginRight2 - ox, y06 = marginTop2 - oy, y12 = height2 - marginBottom2 - oy, rx = binWidth / 2, ry = rx * sqrt4_3, hy = ry / 2, wx = rx * 2, wy = ry * 1.5, i0 = Math.floor(x06 / wx), i1 = Math.ceil(x12 / wx), j0 = Math.floor((y06 + hy) / wy), j1 = Math.ceil((y12 - hy) / wy) + 1, path2 = `m0,${round(-ry)}l${round(rx)},${round(hy)}v${round(ry)}l${round(-rx)},${round(hy)}`;
    let d = path2;
    for (let j2 = j0; j2 < j1; ++j2) {
      for (let i = i0; i < i1; ++i) {
        d += `M${round(i * wx + (j2 & 1) * rx)},${round(j2 * wy)}${path2}`;
      }
    }
    return create3("svg:g", context).datum(0).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, {}, offset + ox, offset + oy).call((g2) => g2.append("path").call(applyDirectStyles, this).call(applyChannelStyles, this, channels).attr("d", d)).node();
  }
};
function round(x4) {
  return Math.round(x4 * 1e3) / 1e3;
}

// ../../node_modules/@observablehq/plot/src/marks/image.js
var defaults21 = {
  ariaLabel: "image",
  fill: null,
  stroke: null
};
function isPath(string2) {
  return /^\.*\//.test(string2);
}
function isUrl(string2) {
  return /^(blob|data|file|http|https):/i.test(string2);
}
function maybePathChannel(value) {
  return typeof value === "string" && (isPath(value) || isUrl(value)) ? [void 0, value] : [value, void 0];
}
var Image = class extends Mark {
  constructor(data, options = {}) {
    let { x: x4, y: y4, r, width: width2, height: height2, rotate, src, preserveAspectRatio, crossOrigin, frameAnchor, imageRendering } = options;
    if (r == null)
      r = void 0;
    if (r === void 0 && width2 === void 0 && height2 === void 0)
      width2 = height2 = 16;
    else if (width2 === void 0 && height2 !== void 0)
      width2 = height2;
    else if (height2 === void 0 && width2 !== void 0)
      height2 = width2;
    const [vs, cs] = maybePathChannel(src);
    const [vr, cr] = maybeNumberChannel(r);
    const [vw, cw] = maybeNumberChannel(width2, cr !== void 0 ? cr * 2 : void 0);
    const [vh, ch] = maybeNumberChannel(height2, cr !== void 0 ? cr * 2 : void 0);
    const [va, ca3] = maybeNumberChannel(rotate, 0);
    super(
      data,
      {
        x: { value: x4, scale: "x", optional: true },
        y: { value: y4, scale: "y", optional: true },
        r: { value: vr, scale: "r", filter: positive, optional: true },
        width: { value: vw, filter: positive, optional: true },
        height: { value: vh, filter: positive, optional: true },
        rotate: { value: va, optional: true },
        src: { value: vs, optional: true }
      },
      withDefaultSort(options),
      defaults21
    );
    this.src = cs;
    this.width = cw;
    this.rotate = ca3;
    this.height = ch;
    this.r = cr;
    this.preserveAspectRatio = impliedString(preserveAspectRatio, "xMidYMid");
    this.crossOrigin = string(crossOrigin);
    this.frameAnchor = maybeFrameAnchor(frameAnchor);
    this.imageRendering = impliedString(imageRendering, "auto");
  }
  render(index2, scales2, channels, dimensions, context) {
    const { x: x4, y: y4 } = scales2;
    const { x: X3, y: Y3, width: W2, height: H2, r: R2, rotate: A5, src: S2 } = channels;
    const { r, width: width2, height: height2, rotate } = this;
    const [cx, cy] = applyFrameAnchor(this, dimensions);
    return create3("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X3 && x4, y: Y3 && y4 }).call(
      (g2) => g2.selectAll().data(index2).enter().append("image").call(applyDirectStyles, this).attr("x", position2(X3, W2, R2, cx, width2, r)).attr("y", position2(Y3, H2, R2, cy, height2, r)).attr("width", W2 ? (i) => W2[i] : width2 !== void 0 ? width2 : R2 ? (i) => R2[i] * 2 : r * 2).attr("height", H2 ? (i) => H2[i] : height2 !== void 0 ? height2 : R2 ? (i) => R2[i] * 2 : r * 2).attr("transform", A5 ? (i) => `rotate(${A5[i]})` : rotate ? `rotate(${rotate})` : null).attr("transform-origin", A5 || rotate ? template`${X3 ? (i) => X3[i] : cx}px ${Y3 ? (i) => Y3[i] : cy}px` : null).call(applyAttr, "href", S2 ? (i) => S2[i] : this.src).call(applyAttr, "preserveAspectRatio", this.preserveAspectRatio).call(applyAttr, "crossorigin", this.crossOrigin).call(applyAttr, "image-rendering", this.imageRendering).call(applyAttr, "clip-path", R2 ? (i) => `circle(${R2[i]}px)` : r !== void 0 ? `circle(${r}px)` : null).call(applyChannelStyles, this, channels)
    ).node();
  }
};
function position2(X3, W2, R2, x4, w, r) {
  return W2 && X3 ? (i) => X3[i] - W2[i] / 2 : W2 ? (i) => x4 - W2[i] / 2 : X3 && w !== void 0 ? (i) => X3[i] - w / 2 : w !== void 0 ? x4 - w / 2 : R2 && X3 ? (i) => X3[i] - R2[i] : R2 ? (i) => x4 - R2[i] : X3 ? (i) => X3[i] - r : x4 - r;
}
function image(data, { x: x4, y: y4, ...options } = {}) {
  if (options.frameAnchor === void 0)
    [x4, y4] = maybeTuple(x4, y4);
  return new Image(data, { ...options, x: x4, y: y4 });
}

// ../../node_modules/@observablehq/plot/src/stats.js
function ibetainv(p2, a3, b2) {
  var EPS2 = 1e-8;
  var a1 = a3 - 1;
  var b1 = b2 - 1;
  var j2 = 0;
  var lna, lnb, pp, t, u4, err, x4, al, h2, w, afac;
  if (p2 <= 0)
    return 0;
  if (p2 >= 1)
    return 1;
  if (a3 >= 1 && b2 >= 1) {
    pp = p2 < 0.5 ? p2 : 1 - p2;
    t = Math.sqrt(-2 * Math.log(pp));
    x4 = (2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t;
    if (p2 < 0.5)
      x4 = -x4;
    al = (x4 * x4 - 3) / 6;
    h2 = 2 / (1 / (2 * a3 - 1) + 1 / (2 * b2 - 1));
    w = x4 * Math.sqrt(al + h2) / h2 - (1 / (2 * b2 - 1) - 1 / (2 * a3 - 1)) * (al + 5 / 6 - 2 / (3 * h2));
    x4 = a3 / (a3 + b2 * Math.exp(2 * w));
  } else {
    lna = Math.log(a3 / (a3 + b2));
    lnb = Math.log(b2 / (a3 + b2));
    t = Math.exp(a3 * lna) / a3;
    u4 = Math.exp(b2 * lnb) / b2;
    w = t + u4;
    if (p2 < t / w)
      x4 = Math.pow(a3 * w * p2, 1 / a3);
    else
      x4 = 1 - Math.pow(b2 * w * (1 - p2), 1 / b2);
  }
  afac = -gammaln(a3) - gammaln(b2) + gammaln(a3 + b2);
  for (; j2 < 10; j2++) {
    if (x4 === 0 || x4 === 1)
      return x4;
    err = ibeta(x4, a3, b2) - p2;
    t = Math.exp(a1 * Math.log(x4) + b1 * Math.log(1 - x4) + afac);
    u4 = err / t;
    x4 -= t = u4 / (1 - 0.5 * Math.min(1, u4 * (a1 / x4 - b1 / (1 - x4))));
    if (x4 <= 0)
      x4 = 0.5 * (x4 + t);
    if (x4 >= 1)
      x4 = 0.5 * (x4 + t + 1);
    if (Math.abs(t) < EPS2 * x4 && j2 > 0)
      break;
  }
  return x4;
}
function ibeta(x4, a3, b2) {
  var bt = x4 === 0 || x4 === 1 ? 0 : Math.exp(gammaln(a3 + b2) - gammaln(a3) - gammaln(b2) + a3 * Math.log(x4) + b2 * Math.log(1 - x4));
  if (x4 < 0 || x4 > 1)
    return false;
  if (x4 < (a3 + 1) / (a3 + b2 + 2))
    return bt * betacf(x4, a3, b2) / a3;
  return 1 - bt * betacf(1 - x4, b2, a3) / b2;
}
function betacf(x4, a3, b2) {
  var fpmin = 1e-30;
  var m2 = 1;
  var qab = a3 + b2;
  var qap = a3 + 1;
  var qam = a3 - 1;
  var c4 = 1;
  var d = 1 - qab * x4 / qap;
  var m22, aa2, del, h2;
  if (Math.abs(d) < fpmin)
    d = fpmin;
  d = 1 / d;
  h2 = d;
  for (; m2 <= 100; m2++) {
    m22 = 2 * m2;
    aa2 = m2 * (b2 - m2) * x4 / ((qam + m22) * (a3 + m22));
    d = 1 + aa2 * d;
    if (Math.abs(d) < fpmin)
      d = fpmin;
    c4 = 1 + aa2 / c4;
    if (Math.abs(c4) < fpmin)
      c4 = fpmin;
    d = 1 / d;
    h2 *= d * c4;
    aa2 = -(a3 + m2) * (qab + m2) * x4 / ((a3 + m22) * (qap + m22));
    d = 1 + aa2 * d;
    if (Math.abs(d) < fpmin)
      d = fpmin;
    c4 = 1 + aa2 / c4;
    if (Math.abs(c4) < fpmin)
      c4 = fpmin;
    d = 1 / d;
    del = d * c4;
    h2 *= del;
    if (Math.abs(del - 1) < 3e-7)
      break;
  }
  return h2;
}
function gammaln(x4) {
  var j2 = 0;
  var cof = [
    76.18009172947146,
    -86.5053203294167,
    24.01409824083091,
    -1.231739572450155,
    0.001208650973866179,
    -5395239384953e-18
  ];
  var ser = 1.000000000190015;
  var xx, y4, tmp3;
  tmp3 = (y4 = xx = x4) + 5.5;
  tmp3 -= (xx + 0.5) * Math.log(tmp3);
  for (; j2 < 6; j2++)
    ser += cof[j2] / ++y4;
  return Math.log(2.506628274631 * ser / xx) - tmp3;
}
function qt(p2, dof) {
  var x4 = ibetainv(2 * Math.min(p2, 1 - p2), 0.5 * dof, 0.5);
  x4 = Math.sqrt(dof * (1 - x4) / x4);
  return p2 > 0.5 ? x4 : -x4;
}

// ../../node_modules/@observablehq/plot/src/marks/linearRegression.js
var defaults22 = {
  ariaLabel: "linear-regression",
  fill: "currentColor",
  fillOpacity: 0.1,
  stroke: "currentColor",
  strokeWidth: 1.5,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeMiterlimit: 1
};
var LinearRegression = class extends Mark {
  constructor(data, options = {}) {
    const { x: x4, y: y4, z: z2, ci = 0.95, precision = 4 } = options;
    super(
      data,
      {
        x: { value: x4, scale: "x" },
        y: { value: y4, scale: "y" },
        z: { value: maybeZ(options), optional: true }
      },
      options,
      defaults22
    );
    this.z = z2;
    this.ci = +ci;
    this.precision = +precision;
    if (!(0 <= this.ci && this.ci < 1))
      throw new Error(`invalid ci; not in [0, 1): ${ci}`);
    if (!(this.precision > 0))
      throw new Error(`invalid precision: ${precision}`);
  }
  render(index2, scales2, channels, dimensions, context) {
    const { x: X3, y: Y3, z: Z3 } = channels;
    const { ci } = this;
    return create3("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales2).call(
      (g2) => g2.selectAll().data(Z3 ? groupZ2(index2, Z3, this.z) : [index2]).enter().call(
        (enter) => enter.append("path").attr("fill", "none").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, { ...channels, fill: null, fillOpacity: null }).attr("d", (I2) => this._renderLine(I2, X3, Y3)).call(
          ci && !isNone(this.fill) ? (path2) => path2.select(pathBefore).attr("stroke", "none").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, {
            ...channels,
            stroke: null,
            strokeOpacity: null,
            strokeWidth: null
          }).attr("d", (I2) => this._renderBand(I2, X3, Y3)) : () => {
          }
        )
      )
    ).node();
  }
};
function pathBefore() {
  return this.parentNode.insertBefore(this.ownerDocument.createElementNS(namespaces_default.svg, "path"), this);
}
var LinearRegressionX = class extends LinearRegression {
  constructor(data, options) {
    super(data, options);
  }
  _renderBand(I2, X3, Y3) {
    const { ci, precision } = this;
    const [y12, y22] = extent(I2, (i) => Y3[i]);
    const f2 = linearRegressionF(I2, Y3, X3);
    const g2 = confidenceIntervalF(I2, Y3, X3, (1 - ci) / 2, f2);
    return area_default3().y((y4) => y4).x0((y4) => g2(y4, -1)).x1((y4) => g2(y4, 1))(range(y12, y22 - precision / 2, precision).concat(y22));
  }
  _renderLine(I2, X3, Y3) {
    const [y12, y22] = extent(I2, (i) => Y3[i]);
    const f2 = linearRegressionF(I2, Y3, X3);
    return `M${f2(y12)},${y12}L${f2(y22)},${y22}`;
  }
};
var LinearRegressionY = class extends LinearRegression {
  constructor(data, options) {
    super(data, options);
  }
  _renderBand(I2, X3, Y3) {
    const { ci, precision } = this;
    const [x12, x22] = extent(I2, (i) => X3[i]);
    const f2 = linearRegressionF(I2, X3, Y3);
    const g2 = confidenceIntervalF(I2, X3, Y3, (1 - ci) / 2, f2);
    return area_default3().x((x4) => x4).y0((x4) => g2(x4, -1)).y1((x4) => g2(x4, 1))(range(x12, x22 - precision / 2, precision).concat(x22));
  }
  _renderLine(I2, X3, Y3) {
    const [x12, x22] = extent(I2, (i) => X3[i]);
    const f2 = linearRegressionF(I2, X3, Y3);
    return `M${x12},${f2(x12)}L${x22},${f2(x22)}`;
  }
};
function linearRegressionX(data, { y: y4 = indexOf, x: x4 = identity7, stroke, fill = isNoneish(stroke) ? "currentColor" : stroke, ...options } = {}) {
  return new LinearRegressionX(data, maybeDenseIntervalY({ ...options, x: x4, y: y4, fill, stroke }));
}
function linearRegressionY(data, { x: x4 = indexOf, y: y4 = identity7, stroke, fill = isNoneish(stroke) ? "currentColor" : stroke, ...options } = {}) {
  return new LinearRegressionY(data, maybeDenseIntervalX({ ...options, x: x4, y: y4, fill, stroke }));
}
function linearRegressionF(I2, X3, Y3) {
  let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
  for (const i of I2) {
    const xi = X3[i];
    const yi = Y3[i];
    sumX += xi;
    sumY += yi;
    sumXY += xi * yi;
    sumX2 += xi * xi;
  }
  const n = I2.length;
  const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
  const intercept = (sumY - slope * sumX) / n;
  return (x4) => slope * x4 + intercept;
}
function confidenceIntervalF(I2, X3, Y3, p2, f2) {
  const mean3 = sum3(I2, (i) => X3[i]) / I2.length;
  let a3 = 0, b2 = 0;
  for (const i of I2) {
    a3 += (X3[i] - mean3) ** 2;
    b2 += (Y3[i] - f2(X3[i])) ** 2;
  }
  const sy = Math.sqrt(b2 / (I2.length - 2));
  const t = qt(p2, I2.length - 2);
  return (x4, k3) => {
    const Y4 = f2(x4);
    const se2 = sy * Math.sqrt(1 / I2.length + (x4 - mean3) ** 2 / a3);
    return Y4 + k3 * t * se2;
  };
}

// ../../node_modules/@observablehq/plot/src/transforms/tree.js
function treeNode({
  path: path2 = identity7,
  // the delimited path
  delimiter,
  // how the path is separated
  frameAnchor,
  treeLayout = tree_default,
  treeSort,
  treeSeparation,
  treeAnchor,
  treeFilter,
  ...options
} = {}) {
  treeAnchor = maybeTreeAnchor(treeAnchor);
  treeSort = maybeTreeSort(treeSort);
  if (treeFilter != null)
    treeFilter = maybeNodeValue(treeFilter);
  if (frameAnchor === void 0)
    frameAnchor = treeAnchor.frameAnchor;
  const normalize4 = normalizer(delimiter);
  const outputs = treeOutputs(options, maybeNodeValue);
  const [X3, setX] = column2();
  const [Y3, setY] = column2();
  return {
    x: X3,
    y: Y3,
    frameAnchor,
    ...basic(options, (data, facets) => {
      const P2 = normalize4(valueof(data, path2));
      const X4 = setX([]);
      const Y4 = setY([]);
      let treeIndex = -1;
      const treeData = [];
      const treeFacets = [];
      const rootof = stratify_default().path((i) => P2[i]);
      const layout = treeLayout();
      if (layout.nodeSize)
        layout.nodeSize([1, 1]);
      if (layout.separation && treeSeparation !== void 0)
        layout.separation(treeSeparation ?? one2);
      for (const o of outputs)
        o[output_values] = o[output_setValues]([]);
      for (const facet of facets) {
        const treeFacet = [];
        const root2 = rootof(facet.filter((i) => P2[i] != null)).each((node) => node.data = data[node.data]);
        if (treeSort != null)
          root2.sort(treeSort);
        layout(root2);
        for (const node of root2.descendants()) {
          if (treeFilter != null && !treeFilter(node))
            continue;
          treeFacet.push(++treeIndex);
          treeData[treeIndex] = node.data;
          treeAnchor.position(node, treeIndex, X4, Y4);
          for (const o of outputs)
            o[output_values][treeIndex] = o[output_evaluate](node);
        }
        treeFacets.push(treeFacet);
      }
      return { data: treeData, facets: treeFacets };
    }),
    ...Object.fromEntries(outputs)
  };
}
function treeLink({
  path: path2 = identity7,
  // the delimited path
  delimiter,
  // how the path is separated
  curve = "bump-x",
  stroke = "#555",
  strokeWidth = 1.5,
  strokeOpacity = 0.5,
  treeLayout = tree_default,
  treeSort,
  treeSeparation,
  treeAnchor,
  treeFilter,
  ...options
} = {}) {
  treeAnchor = maybeTreeAnchor(treeAnchor);
  treeSort = maybeTreeSort(treeSort);
  if (treeFilter != null)
    treeFilter = maybeLinkValue(treeFilter);
  options = { curve, stroke, strokeWidth, strokeOpacity, ...options };
  const normalize4 = normalizer(delimiter);
  const outputs = treeOutputs(options, maybeLinkValue);
  const [X13, setX1] = column2();
  const [X24, setX2] = column2();
  const [Y13, setY1] = column2();
  const [Y24, setY2] = column2();
  return {
    x1: X13,
    x2: X24,
    y1: Y13,
    y2: Y24,
    ...basic(options, (data, facets) => {
      const P2 = normalize4(valueof(data, path2));
      const X14 = setX1([]);
      const X25 = setX2([]);
      const Y14 = setY1([]);
      const Y25 = setY2([]);
      let treeIndex = -1;
      const treeData = [];
      const treeFacets = [];
      const rootof = stratify_default().path((i) => P2[i]);
      const layout = treeLayout();
      if (layout.nodeSize)
        layout.nodeSize([1, 1]);
      if (layout.separation && treeSeparation !== void 0)
        layout.separation(treeSeparation ?? one2);
      for (const o of outputs)
        o[output_values] = o[output_setValues]([]);
      for (const facet of facets) {
        const treeFacet = [];
        const root2 = rootof(facet.filter((i) => P2[i] != null)).each((node) => node.data = data[node.data]);
        if (treeSort != null)
          root2.sort(treeSort);
        layout(root2);
        for (const { source, target } of root2.links()) {
          if (treeFilter != null && !treeFilter(target, source))
            continue;
          treeFacet.push(++treeIndex);
          treeData[treeIndex] = target.data;
          treeAnchor.position(source, treeIndex, X14, Y14);
          treeAnchor.position(target, treeIndex, X25, Y25);
          for (const o of outputs)
            o[output_values][treeIndex] = o[output_evaluate](target, source);
        }
        treeFacets.push(treeFacet);
      }
      return { data: treeData, facets: treeFacets };
    }),
    ...Object.fromEntries(outputs)
  };
}
function maybeTreeAnchor(anchor = "left") {
  switch (`${anchor}`.trim().toLowerCase()) {
    case "left":
      return treeAnchorLeft;
    case "right":
      return treeAnchorRight;
  }
  throw new Error(`invalid tree anchor: ${anchor}`);
}
var treeAnchorLeft = {
  frameAnchor: "left",
  dx: 6,
  position({ x: x4, y: y4 }, i, X3, Y3) {
    X3[i] = y4;
    Y3[i] = -x4;
  }
};
var treeAnchorRight = {
  frameAnchor: "right",
  dx: -6,
  position({ x: x4, y: y4 }, i, X3, Y3) {
    X3[i] = -y4;
    Y3[i] = -x4;
  }
};
function maybeTreeSort(sort3) {
  return sort3 == null || typeof sort3 === "function" ? sort3 : `${sort3}`.trim().toLowerCase().startsWith("node:") ? nodeSort(maybeNodeValue(sort3)) : nodeSort(nodeData(sort3));
}
function nodeSort(value) {
  return (a3, b2) => ascendingDefined2(value(a3), value(b2));
}
function nodeData(field2) {
  return (node) => node.data?.[field2];
}
function normalizer(delimiter = "/") {
  delimiter = `${delimiter}`;
  if (delimiter === "/")
    return (P2) => P2;
  if (delimiter.length !== 1)
    throw new Error("delimiter must be exactly one character");
  const delimiterCode = delimiter.charCodeAt(0);
  return (P2) => P2.map((p2) => slashDelimiter(p2, delimiterCode));
}
var CODE_BACKSLASH = 92;
var CODE_SLASH = 47;
function slashDelimiter(input3, delimiterCode) {
  if (delimiterCode === CODE_BACKSLASH)
    throw new Error("delimiter cannot be backslash");
  let afterBackslash = false;
  for (let i = 0, n = input3.length; i < n; ++i) {
    switch (input3.charCodeAt(i)) {
      case CODE_BACKSLASH:
        if (!afterBackslash) {
          afterBackslash = true;
          continue;
        }
        break;
      case delimiterCode:
        if (afterBackslash) {
          input3 = input3.slice(0, i - 1) + input3.slice(i), --i, --n;
        } else {
          input3 = input3.slice(0, i) + "/" + input3.slice(i + 1);
        }
        break;
      case CODE_SLASH:
        if (afterBackslash) {
          input3 = input3.slice(0, i) + "\\\\" + input3.slice(i), i += 2, n += 2;
        } else {
          input3 = input3.slice(0, i) + "\\" + input3.slice(i), ++i, ++n;
        }
        break;
    }
    afterBackslash = false;
  }
  return input3;
}
function slashUnescape(input3) {
  let afterBackslash = false;
  for (let i = 0, n = input3.length; i < n; ++i) {
    switch (input3.charCodeAt(i)) {
      case CODE_BACKSLASH:
        if (!afterBackslash) {
          afterBackslash = true;
          continue;
        }
      case CODE_SLASH:
        if (afterBackslash) {
          input3 = input3.slice(0, i - 1) + input3.slice(i), --i, --n;
        }
        break;
    }
    afterBackslash = false;
  }
  return input3;
}
function isNodeValue(option) {
  return isObject3(option) && typeof option.node === "function";
}
function isLinkValue(option) {
  return isObject3(option) && typeof option.link === "function";
}
function maybeNodeValue(value) {
  if (isNodeValue(value))
    return value.node;
  value = `${value}`.trim().toLowerCase();
  if (!value.startsWith("node:"))
    return;
  switch (value) {
    case "node:name":
      return nodeName;
    case "node:path":
      return nodePath;
    case "node:internal":
      return nodeInternal;
    case "node:external":
      return nodeExternal;
    case "node:depth":
      return nodeDepth;
    case "node:height":
      return nodeHeight;
  }
  throw new Error(`invalid node value: ${value}`);
}
function maybeLinkValue(value) {
  if (isNodeValue(value))
    return value.node;
  if (isLinkValue(value))
    return value.link;
  value = `${value}`.trim().toLowerCase();
  if (!value.startsWith("node:") && !value.startsWith("parent:"))
    return;
  switch (value) {
    case "parent:name":
      return parentValue(nodeName);
    case "parent:path":
      return parentValue(nodePath);
    case "parent:depth":
      return parentValue(nodeDepth);
    case "parent:height":
      return parentValue(nodeHeight);
    case "node:name":
      return nodeName;
    case "node:path":
      return nodePath;
    case "node:internal":
      return nodeInternal;
    case "node:external":
      return nodeExternal;
    case "node:depth":
      return nodeDepth;
    case "node:height":
      return nodeHeight;
  }
  throw new Error(`invalid link value: ${value}`);
}
function nodePath(node) {
  return node.id;
}
function nodeName(node) {
  return nameof(node.id);
}
function nodeDepth(node) {
  return node.depth;
}
function nodeHeight(node) {
  return node.height;
}
function nodeInternal(node) {
  return !!node.children;
}
function nodeExternal(node) {
  return !node.children;
}
function parentValue(evaluate) {
  return (child, parent) => parent == null ? void 0 : evaluate(parent);
}
function nameof(path2) {
  let i = path2.length;
  while (--i > 0)
    if (slash2(path2, i))
      break;
  return slashUnescape(path2.slice(i + 1));
}
function slash2(path2, i) {
  if (path2[i] === "/") {
    let k3 = 0;
    while (i > 0 && path2[--i] === "\\")
      ++k3;
    if ((k3 & 1) === 0)
      return true;
  }
  return false;
}
var output_setValues = 2;
var output_evaluate = 3;
var output_values = 4;
function treeOutputs(options, maybeTreeValue) {
  const outputs = [];
  for (const name2 in options) {
    const value = options[name2];
    const treeValue = maybeTreeValue(value);
    if (treeValue !== void 0) {
      outputs.push([name2, ...column2(value), treeValue]);
    }
  }
  return outputs;
}

// ../../node_modules/@observablehq/plot/src/marks/tree.js
function tree(data, {
  fill,
  stroke,
  strokeWidth,
  strokeOpacity,
  strokeLinejoin,
  strokeLinecap,
  strokeMiterlimit,
  strokeDasharray,
  strokeDashoffset,
  marker,
  markerStart = marker,
  markerEnd = marker,
  dot: dotDot = isNoneish(markerStart) && isNoneish(markerEnd),
  text: textText = "node:name",
  textStroke = "var(--plot-background)",
  title = "node:path",
  dx,
  dy,
  textAnchor,
  treeLayout = tree_default,
  textLayout = treeLayout === tree_default || treeLayout === cluster_default ? "mirrored" : "normal",
  tip: tip2,
  ...options
} = {}) {
  if (dx === void 0)
    dx = maybeTreeAnchor(options.treeAnchor).dx;
  if (textAnchor !== void 0)
    throw new Error("textAnchor is not a configurable tree option");
  textLayout = keyword(textLayout, "textLayout", ["mirrored", "normal"]);
  function treeText(textOptions2) {
    return text(
      data,
      treeNode({
        treeLayout,
        text: textText,
        fill: fill === void 0 ? "currentColor" : fill,
        stroke: textStroke,
        dx,
        dy,
        title,
        ...textOptions2,
        ...options
      })
    );
  }
  return marks(
    link2(
      data,
      treeLink({
        treeLayout,
        markerStart,
        markerEnd,
        stroke: stroke !== void 0 ? stroke : fill === void 0 ? "node:internal" : fill,
        strokeWidth,
        strokeOpacity,
        strokeLinejoin,
        strokeLinecap,
        strokeMiterlimit,
        strokeDasharray,
        strokeDashoffset,
        ...options
      })
    ),
    dotDot ? dot(data, treeNode({ treeLayout, fill: fill === void 0 ? "node:internal" : fill, title, tip: tip2, ...options })) : null,
    textText != null ? textLayout === "mirrored" ? [
      treeText({ textAnchor: "start", treeFilter: "node:external" }),
      treeText({ textAnchor: "end", treeFilter: "node:internal", dx: -dx })
    ] : treeText() : null
  );
}
function cluster(data, options) {
  return tree(data, { ...options, treeLayout: cluster_default });
}

// ../../node_modules/@observablehq/plot/src/transforms/centroid.js
function centroid2({ geometry = identity7, ...options } = {}) {
  return initializer({ ...options, x: null, y: null }, (data, facets, channels, scales2, dimensions, { projection: projection3 }) => {
    const G = valueof(data, geometry);
    const n = G.length;
    const X3 = new Float64Array(n);
    const Y3 = new Float64Array(n);
    const path2 = path_default(projection3);
    for (let i = 0; i < n; ++i)
      [X3[i], Y3[i]] = path2.centroid(G[i]);
    return {
      data,
      facets,
      channels: {
        x: { value: X3, scale: projection3 == null ? "x" : null, source: null },
        y: { value: Y3, scale: projection3 == null ? "y" : null, source: null }
      }
    };
  });
}
function geoCentroid({ geometry = identity7, ...options } = {}) {
  let C3;
  return {
    ...options,
    x: { transform: (data) => Float64Array.from(C3 = valueof(valueof(data, geometry), centroid_default), ([x4]) => x4) },
    y: { transform: () => Float64Array.from(C3, ([, y4]) => y4) }
  };
}

// ../../node_modules/@observablehq/plot/src/transforms/dodge.js
var import_interval_tree_1d = __toESM(require_interval_tree(), 1);
var anchorXLeft = ({ marginLeft: marginLeft2 }) => [1, marginLeft2];
var anchorXRight = ({ width: width2, marginRight: marginRight2 }) => [-1, width2 - marginRight2];
var anchorXMiddle = ({ width: width2, marginLeft: marginLeft2, marginRight: marginRight2 }) => [0, (marginLeft2 + width2 - marginRight2) / 2];
var anchorYTop = ({ marginTop: marginTop2 }) => [1, marginTop2];
var anchorYBottom = ({ height: height2, marginBottom: marginBottom2 }) => [-1, height2 - marginBottom2];
var anchorYMiddle = ({ height: height2, marginTop: marginTop2, marginBottom: marginBottom2 }) => [0, (marginTop2 + height2 - marginBottom2) / 2];
function maybeAnchor4(anchor) {
  return typeof anchor === "string" ? { anchor } : anchor;
}
function dodgeX(dodgeOptions = {}, options = {}) {
  if (arguments.length === 1)
    [dodgeOptions, options] = mergeOptions3(dodgeOptions);
  let { anchor = "left", padding: padding2 = 1, r = options.r } = maybeAnchor4(dodgeOptions);
  switch (`${anchor}`.toLowerCase()) {
    case "left":
      anchor = anchorXLeft;
      break;
    case "right":
      anchor = anchorXRight;
      break;
    case "middle":
      anchor = anchorXMiddle;
      break;
    default:
      throw new Error(`unknown dodge anchor: ${anchor}`);
  }
  return dodge("x", "y", anchor, number5(padding2), r, options);
}
function dodgeY(dodgeOptions = {}, options = {}) {
  if (arguments.length === 1)
    [dodgeOptions, options] = mergeOptions3(dodgeOptions);
  let { anchor = "bottom", padding: padding2 = 1, r = options.r } = maybeAnchor4(dodgeOptions);
  switch (`${anchor}`.toLowerCase()) {
    case "top":
      anchor = anchorYTop;
      break;
    case "bottom":
      anchor = anchorYBottom;
      break;
    case "middle":
      anchor = anchorYMiddle;
      break;
    default:
      throw new Error(`unknown dodge anchor: ${anchor}`);
  }
  return dodge("y", "x", anchor, number5(padding2), r, options);
}
function mergeOptions3(options) {
  const { anchor, padding: padding2, ...rest } = options;
  const { r } = rest;
  return [{ anchor, padding: padding2, r }, rest];
}
function dodge(y4, x4, anchor, padding2, r, options) {
  if (r != null && typeof r !== "number") {
    let { channels, sort: sort3, reverse: reverse3 } = options;
    channels = maybeNamed(channels);
    if (channels?.r === void 0)
      options = { ...options, channels: { ...channels, r: { value: r, scale: "r" } } };
    if (sort3 === void 0 && reverse3 === void 0)
      options.sort = { channel: "-r" };
  }
  return initializer(options, function(data, facets, channels, scales2, dimensions, context) {
    let { [x4]: X3, r: R2 } = channels;
    if (!channels[x4])
      throw new Error(`missing channel: ${x4}`);
    ({ [x4]: X3 } = applyPosition(channels, scales2, context));
    const cr = R2 ? void 0 : r !== void 0 ? number5(r) : this.r !== void 0 ? this.r : 3;
    if (R2)
      R2 = valueof(R2.value, scales2[R2.scale] || identity7, Float64Array);
    let [ky2, ty] = anchor(dimensions);
    const compare = ky2 ? compareAscending : compareSymmetric;
    const Y3 = new Float64Array(X3.length);
    const radius2 = R2 ? (i) => R2[i] : () => cr;
    for (let I2 of facets) {
      const tree2 = (0, import_interval_tree_1d.default)();
      I2 = I2.filter(R2 ? (i) => finite2(X3[i]) && positive(R2[i]) : (i) => finite2(X3[i]));
      const intervals = new Float64Array(2 * I2.length + 2);
      for (const i of I2) {
        const ri = radius2(i);
        const y06 = ky2 ? ri + padding2 : 0;
        const l = X3[i] - ri;
        const h2 = X3[i] + ri;
        let k3 = 2;
        tree2.queryInterval(l - padding2, h2 + padding2, ([, , j2]) => {
          const yj = Y3[j2] - y06;
          const dx = X3[i] - X3[j2];
          const dr = padding2 + (R2 ? R2[i] + R2[j2] : 2 * cr);
          const dy = Math.sqrt(dr * dr - dx * dx);
          intervals[k3++] = yj - dy;
          intervals[k3++] = yj + dy;
        });
        let candidates = intervals.slice(0, k3);
        if (ky2)
          candidates = candidates.filter((y5) => y5 >= 0);
        out:
          for (const y5 of candidates.sort(compare)) {
            for (let j2 = 0; j2 < k3; j2 += 2) {
              if (intervals[j2] + 1e-6 < y5 && y5 < intervals[j2 + 1] - 1e-6) {
                continue out;
              }
            }
            Y3[i] = y5 + y06;
            break;
          }
        tree2.insert([l, h2, i]);
      }
    }
    if (!ky2)
      ky2 = 1;
    for (const I2 of facets) {
      for (const i of I2) {
        Y3[i] = Y3[i] * ky2 + ty;
      }
    }
    return {
      data,
      facets,
      channels: {
        [y4]: { value: Y3, source: null },
        // dont show in tooltip
        [x4]: { value: X3, source: channels[x4] },
        ...R2 && { r: { value: R2, source: channels.r } }
      }
    };
  });
}
function compareSymmetric(a3, b2) {
  return Math.abs(a3) - Math.abs(b2);
}
function compareAscending(a3, b2) {
  return a3 - b2;
}

// ../../node_modules/@observablehq/plot/src/transforms/normalize.js
function normalizeX(basis2, options) {
  if (arguments.length === 1)
    ({ basis: basis2, ...options } = basis2);
  return mapX(normalize3(basis2), options);
}
function normalizeY(basis2, options) {
  if (arguments.length === 1)
    ({ basis: basis2, ...options } = basis2);
  return mapY(normalize3(basis2), options);
}
function normalize3(basis2) {
  if (basis2 === void 0)
    return normalizeFirst;
  if (typeof basis2 === "function")
    return normalizeBasis(taker(basis2));
  if (/^p\d{2}$/i.test(basis2))
    return normalizeAccessor(percentile(basis2));
  switch (`${basis2}`.toLowerCase()) {
    case "deviation":
      return normalizeDeviation;
    case "first":
      return normalizeFirst;
    case "last":
      return normalizeLast;
    case "max":
      return normalizeMax;
    case "mean":
      return normalizeMean;
    case "median":
      return normalizeMedian;
    case "min":
      return normalizeMin;
    case "sum":
      return normalizeSum;
    case "extent":
      return normalizeExtent;
  }
  throw new Error(`invalid basis: ${basis2}`);
}
function normalizeBasis(basis2) {
  return {
    mapIndex(I2, S2, T) {
      const b2 = +basis2(I2, S2);
      for (const i of I2) {
        T[i] = S2[i] === null ? NaN : S2[i] / b2;
      }
    }
  };
}
function normalizeAccessor(f2) {
  return normalizeBasis((I2, S2) => f2(I2, (i) => S2[i]));
}
var normalizeExtent = {
  mapIndex(I2, S2, T) {
    const [s1, s2] = extent(I2, (i) => S2[i]);
    const d = s2 - s1;
    for (const i of I2) {
      T[i] = S2[i] === null ? NaN : (S2[i] - s1) / d;
    }
  }
};
var normalizeFirst = normalizeBasis((I2, S2) => {
  for (let i = 0; i < I2.length; ++i) {
    const s2 = S2[I2[i]];
    if (defined(s2))
      return s2;
  }
});
var normalizeLast = normalizeBasis((I2, S2) => {
  for (let i = I2.length - 1; i >= 0; --i) {
    const s2 = S2[I2[i]];
    if (defined(s2))
      return s2;
  }
});
var normalizeDeviation = {
  mapIndex(I2, S2, T) {
    const m2 = mean2(I2, (i) => S2[i]);
    const d = deviation(I2, (i) => S2[i]);
    for (const i of I2) {
      T[i] = S2[i] === null ? NaN : d ? (S2[i] - m2) / d : 0;
    }
  }
};
var normalizeMax = normalizeAccessor(max2);
var normalizeMean = normalizeAccessor(mean2);
var normalizeMedian = normalizeAccessor(median2);
var normalizeMin = normalizeAccessor(min2);
var normalizeSum = normalizeAccessor(sum3);

// ../../node_modules/@observablehq/plot/src/transforms/shift.js
function shiftX(interval2, options) {
  return shiftK("x", interval2, options);
}
function shiftK(x4, interval2, options = {}) {
  let offset2;
  let k3 = 1;
  if (typeof interval2 === "number") {
    k3 = interval2;
    offset2 = (x5, k4) => +x5 + k4;
  } else {
    if (typeof interval2 === "string") {
      const sign3 = interval2.startsWith("-") ? -1 : 1;
      [interval2, k3] = parseTimeInterval(interval2.replace(/^[+-]/, ""));
      k3 *= sign3;
    }
    interval2 = maybeInterval(interval2);
    offset2 = (x5, k4) => interval2.offset(x5, k4);
  }
  const x12 = `${x4}1`;
  const x22 = `${x4}2`;
  const mapped = map3(
    {
      [x12]: (D4) => D4.map((d) => offset2(d, k3)),
      [x22]: (D4) => D4
    },
    options
  );
  const t = mapped[x22].transform;
  mapped[x22].transform = () => {
    const V2 = t();
    const [x06, x13] = extent(V2);
    V2.domain = k3 < 0 ? [x06, offset2(x13, k3)] : [offset2(x06, k3), x13];
    return V2;
  };
  return mapped;
}

// ../../node_modules/@observablehq/plot/src/transforms/select.js
function select(selector, options = {}) {
  if (typeof selector === "string") {
    switch (selector.toLowerCase()) {
      case "first":
        return selectFirst(options);
      case "last":
        return selectLast(options);
    }
  }
  if (typeof selector === "function") {
    return selectChannel(null, selector, options);
  }
  let key, value;
  for (key in selector) {
    if (value !== void 0)
      throw new Error("ambiguous selector; multiple inputs");
    value = maybeSelector(selector[key]);
  }
  if (value === void 0)
    throw new Error(`invalid selector: ${selector}`);
  return selectChannel(key, value, options);
}
function maybeSelector(selector) {
  if (typeof selector === "function")
    return selector;
  switch (`${selector}`.toLowerCase()) {
    case "min":
      return selectorMin;
    case "max":
      return selectorMax;
  }
  throw new Error(`unknown selector: ${selector}`);
}
function selectFirst(options) {
  return selectChannel(null, selectorFirst, options);
}
function selectLast(options) {
  return selectChannel(null, selectorLast, options);
}
function selectMinX(options) {
  return selectChannel("x", selectorMin, options);
}
function selectMinY(options) {
  return selectChannel("y", selectorMin, options);
}
function selectMaxX(options) {
  return selectChannel("x", selectorMax, options);
}
function selectMaxY(options) {
  return selectChannel("y", selectorMax, options);
}
function* selectorFirst(I2) {
  yield I2[0];
}
function* selectorLast(I2) {
  yield I2[I2.length - 1];
}
function* selectorMin(I2, X3) {
  yield least(I2, (i) => X3[i]);
}
function* selectorMax(I2, X3) {
  yield greatest(I2, (i) => X3[i]);
}
function selectChannel(v3, selector, options) {
  if (v3 != null) {
    if (options[v3] == null)
      throw new Error(`missing channel: ${v3}`);
    v3 = options[v3];
  }
  const z2 = maybeZ(options);
  return basic(options, (data, facets) => {
    const Z3 = valueof(data, z2);
    const V2 = valueof(data, v3);
    const selectFacets = [];
    for (const facet of facets) {
      const selectFacet = [];
      for (const I2 of Z3 ? group(facet, (i) => Z3[i]).values() : [facet]) {
        for (const i of selector(I2, V2)) {
          selectFacet.push(i);
        }
      }
      selectFacets.push(selectFacet);
    }
    return { data, facets: selectFacets };
  });
}

// ../plot/src/plot-attributes.js
var attributeMap = /* @__PURE__ */ new Map([
  ["style", "style"],
  ["width", "width"],
  ["height", "height"],
  ["margin", "margin"],
  ["marginLeft", "marginLeft"],
  ["marginRight", "marginRight"],
  ["marginTop", "marginTop"],
  ["marginBottom", "marginBottom"],
  ["align", "align"],
  ["aspectRatio", "aspectRatio"],
  ["axis", "axis"],
  ["inset", "inset"],
  ["grid", "grid"],
  ["label", "label"],
  ["padding", "padding"],
  ["xScale", "x.type"],
  ["xDomain", "x.domain"],
  ["xRange", "x.range"],
  ["xNice", "x.nice"],
  ["xInset", "x.inset"],
  ["xInsetLeft", "x.insetLeft"],
  ["xInsetRight", "x.insetRight"],
  ["xClamp", "x.clamp"],
  ["xRound", "x.round"],
  ["xAlign", "x.align"],
  ["xPadding", "x.padding"],
  ["xPaddingInner", "x.paddingInner"],
  ["xPaddingOuter", "x.paddingOuter"],
  ["xAxis", "x.axis"],
  ["xTicks", "x.ticks"],
  ["xTickSize", "x.tickSize"],
  ["xTickSpacing", "x.tickSpacing"],
  ["xTickPadding", "x.tickPadding"],
  ["xTickFormat", "x.tickFormat"],
  ["xTickRotate", "x.tickRotate"],
  ["xGrid", "x.grid"],
  ["xLine", "x.line"],
  ["xLabel", "x.label"],
  ["xLabelAnchor", "x.labelAnchor"],
  ["xLabelOffset", "x.labelOffset"],
  ["xFontVariant", "x.fontVariant"],
  ["xAriaLabel", "x.ariaLabel"],
  ["xAriaDescription", "x.ariaDescription"],
  ["xReverse", "x.reverse"],
  ["xZero", "x.zero"],
  ["xBase", "x.base"],
  ["xExponent", "x.exponent"],
  ["xConstant", "x.constant"],
  ["yScale", "y.type"],
  ["yDomain", "y.domain"],
  ["yRange", "y.range"],
  ["yNice", "y.nice"],
  ["yInset", "y.inset"],
  ["yInsetTop", "y.insetTop"],
  ["yInsetBottom", "y.insetBottom"],
  ["yClamp", "y.clamp"],
  ["yRound", "y.round"],
  ["yAlign", "y.align"],
  ["yPadding", "y.padding"],
  ["yPaddingInner", "y.paddingInner"],
  ["yPaddingOuter", "y.paddingOuter"],
  ["yAxis", "y.axis"],
  ["yTicks", "y.ticks"],
  ["yTickSize", "y.tickSize"],
  ["yTickSpacing", "y.tickSpacing"],
  ["yTickPadding", "y.tickPadding"],
  ["yTickFormat", "y.tickFormat"],
  ["yTickRotate", "y.tickRotate"],
  ["yGrid", "y.grid"],
  ["yLine", "y.line"],
  ["yLabel", "y.label"],
  ["yLabelAnchor", "y.labelAnchor"],
  ["yLabelOffset", "y.labelOffset"],
  ["yFontVariant", "y.fontVariant"],
  ["yAriaLabel", "y.ariaLabel"],
  ["yAriaDescription", "y.ariaDescription"],
  ["yReverse", "y.reverse"],
  ["yZero", "y.zero"],
  ["yBase", "y.base"],
  ["yExponent", "y.exponent"],
  ["yConstant", "y.constant"],
  ["facetMargin", "facet.margin"],
  ["facetMarginTop", "facet.marginTop"],
  ["facetMarginBottom", "facet.marginBottom"],
  ["facetMarginLeft", "facet.marginLeft"],
  ["facetMarginRight", "facet.marginRight"],
  ["facetGrid", "facet.grid"],
  ["facetLabel", "facet.label"],
  ["fxDomain", "fx.domain"],
  ["fxRange", "fx.range"],
  ["fxNice", "fx.nice"],
  ["fxInset", "fx.inset"],
  ["fxInsetLeft", "fx.insetLeft"],
  ["fxInsetRight", "fx.insetRight"],
  ["fxRound", "fx.round"],
  ["fxAlign", "fx.align"],
  ["fxPadding", "fx.padding"],
  ["fxPaddingInner", "fx.paddingInner"],
  ["fxPaddingOuter", "fx.paddingOuter"],
  ["fxAxis", "fx.axis"],
  ["fxTicks", "fx.ticks"],
  ["fxTickSize", "fx.tickSize"],
  ["fxTickSpacing", "fx.tickSpacing"],
  ["fxTickPadding", "fx.tickPadding"],
  ["fxTickFormat", "fx.tickFormat"],
  ["fxTickRotate", "fx.tickRotate"],
  ["fxGrid", "fx.grid"],
  ["fxLine", "fx.line"],
  ["fxLabel", "fx.label"],
  ["fxLabelAnchor", "fx.labelAnchor"],
  ["fxLabelOffset", "fx.labelOffset"],
  ["fxFontVariant", "fx.fontVariant"],
  ["fxAriaLabel", "fx.ariaLabel"],
  ["fxAriaDescription", "fx.ariaDescription"],
  ["fxReverse", "fx.reverse"],
  ["fyDomain", "fy.domain"],
  ["fyRange", "fy.range"],
  ["fyNice", "fy.mice"],
  ["fyInset", "fy,inset"],
  ["fyInsetTop", "fy.insetTop"],
  ["fyInsetBottom", "fy.insetBottom"],
  ["fyRound", "fy.round"],
  ["fyAlign", "fy.align"],
  ["fyPadding", "fy.padding"],
  ["fyPaddingInner", "fy.paddingInner"],
  ["fyPaddingOuter", "fy.paddingOuter"],
  ["fyAxis", "fy.axis"],
  ["fyTicks", "fy.ticks"],
  ["fyTickSize", "fy.tickSize"],
  ["fyTickSpacing", "fy.tickSpacing"],
  ["fyTickPadding", "fy.tickPadding"],
  ["fyTickFormat", "fy.tickFormat"],
  ["fyTickRotate", "fy.tickRotate"],
  ["fyGrid", "fy.grid"],
  ["fyLine", "fy.line"],
  ["fyLabel", "fy.label"],
  ["fyLabelAnchor", "fy.labelAnchor"],
  ["fyLabelOffset", "fy.labelOffset"],
  ["fyFontVariant", "fy.fontVariant"],
  ["fyAriaLabel", "fy.ariaLabel"],
  ["fyAriaDescription", "fy.ariaDescription"],
  ["fyReverse", "fy.reverse"],
  ["colorScale", "color.type"],
  ["colorDomain", "color.domain"],
  ["colorRange", "color.range"],
  ["colorClamp", "color.clamp"],
  ["colorN", "color.n"],
  ["colorNice", "color.nice"],
  ["colorScheme", "color.scheme"],
  ["colorInterpolate", "color.interpolate"],
  ["colorPivot", "color.pivot"],
  ["colorSymmetric", "color.symmetric"],
  ["colorLabel", "color.label"],
  ["colorReverse", "color.reverse"],
  ["colorZero", "color.zero"],
  ["colorTickFormat", "color.tickFormat"],
  ["colorBase", "color.base"],
  ["colorExponent", "color.exponent"],
  ["colorConstant", "color.constant"],
  ["opacityScale", "opacity.type"],
  ["opacityDomain", "opacity.domain"],
  ["opacityRange", "opacity.range"],
  ["opacityClamp", "opacity.clamp"],
  ["opacityNice", "opacity.nice"],
  ["opacityLabel", "opacity.label"],
  ["opacityReverse", "opacity.reverse"],
  ["opacityZero", "opacity.zero"],
  ["opacityTickFormat", "opacity.tickFormat"],
  ["opacityBase", "opacity.base"],
  ["opacityExponent", "opacity.exponent"],
  ["opacityConstant", "opacity.constant"],
  ["symbolScale", "symbol.type"],
  ["symbolDomain", "symbol.domain"],
  ["symbolRange", "symbol.range"],
  ["rScale", "r.type"],
  ["rDomain", "r.domain"],
  ["rRange", "r.range"],
  ["rClamp", "r.clamp"],
  ["rNice", "r.nice"],
  ["rZero", "r.zero"],
  ["rBase", "r.base"],
  ["rExponent", "r.exponent"],
  ["rConstant", "r.constant"],
  ["lengthScale", "length.type"],
  ["lengthDomain", "length.domain"],
  ["lengthRange", "length.range"],
  ["lengthClamp", "length.clamp"],
  ["lengthNice", "length.nice"],
  ["lengthZero", "length.zero"],
  ["lengthBase", "length.base"],
  ["lengthExponent", "length.exponent"],
  ["lengthConstant", "length.constant"],
  ["projectionType", "projection.type"],
  ["projectionParallels", "projection.parallels"],
  ["projectionPrecision", "projection.precision"],
  ["projectionRotate", "projection.rotate"],
  ["projectionDomain", "projection.domain"],
  ["projectionInset", "projection.inset"],
  ["projectionInsetLeft", "projection.insetLeft"],
  ["projectionInsetRight", "projection.insetRight"],
  ["projectionInsetTop", "projection.insetTop"],
  ["projectionInsetBottom", "projection.insetBottom"],
  ["projectionClip", "projection.clip"]
]);
function setProperty(object, path2, value) {
  for (let i = 0; i < path2.length; ++i) {
    const key = path2[i];
    if (i === path2.length - 1) {
      object[key] = value;
    } else {
      object = object[key] || (object[key] = {});
    }
  }
}
function setAttributes(attributes2, spec, symbols3) {
  for (const key in attributes2) {
    const specKey = attributeMap.get(key);
    if (specKey == null) {
      throw new Error(`Unrecognized plot attribute: ${key}`);
    }
    const value = attributes2[key];
    if (typeof value === "symbol") {
      symbols3.push(key);
    } else if (value !== void 0) {
      setProperty(spec, specKey.split("."), value);
    }
  }
}

// ../plot/src/plot-renderer.js
var OPTIONS_ONLY_MARKS = /* @__PURE__ */ new Set([
  "frame",
  "hexgrid",
  "sphere",
  "graticule"
]);
async function plotRenderer(plot3) {
  const spec = { marks: [] };
  const symbols3 = [];
  const { attributes: attributes2, marks: marks2 } = plot3;
  setAttributes(attributes2, spec, symbols3);
  const indices = [];
  for (const mark2 of marks2) {
    for (const { type: type2, data, options } of mark2.plotSpecs()) {
      if (OPTIONS_ONLY_MARKS.has(type2)) {
        spec.marks.push(src_exports[type2](options));
      } else if (isArrowTable(data)) {
        const opts = Object.fromEntries(
          Object.entries(options).map(([k3, v3]) => {
            let val = v3;
            if (typeof v3 === "string") {
              val = data.getChild(v3) ?? v3;
            } else if (typeof v3 === "object") {
              const value = data.getChild(v3.value);
              val = value ? { value } : v3;
            }
            return [k3, val];
          })
        );
        spec.marks.push(src_exports[type2]({ length: data.numRows }, opts));
      } else {
        spec.marks.push(src_exports[type2](data, options));
      }
      indices.push(mark2.index);
    }
  }
  inferLabels(spec, plot3);
  const svg = plot(spec);
  annotatePlot(svg, indices);
  setSymbolAttributes(plot3, svg, attributes2, symbols3);
  for (const interactor2 of plot3.interactors) {
    await interactor2.init(svg);
  }
  return svg;
}
function setSymbolAttributes(plot3, svg, attributes2, symbols3) {
  symbols3.forEach((key) => {
    const value = attributes2[key];
    if (value === Fixed) {
      if (!key.endsWith("Domain")) {
        throw new Error(`Unsupported fixed attribute: ${key}`);
      }
      const type2 = key.slice(0, -"Domain".length);
      const scale3 = svg.scale(type2);
      if (scale3?.domain) {
        plot3.setAttribute(key, attributes2[`${type2}Reverse`] ? scale3.domain.slice().reverse() : scale3.domain);
      }
    } else {
      throw new Error(`Unrecognized symbol: ${value}`);
    }
  });
}
function inferLabels(spec, plot3) {
  const { marks: marks2 } = plot3;
  inferLabel("x", spec, marks2);
  inferLabel("y", spec, marks2);
  inferLabel("fx", spec, marks2);
  inferLabel("fy", spec, marks2);
}
function inferLabel(key, spec, marks2) {
  const scale3 = spec[key] || {};
  if (scale3.axis === null || scale3.label !== void 0)
    return;
  const fields = marks2.map((mark2) => mark2.channelField(key)?.field);
  if (fields.every((x4) => x4 == null))
    return;
  let candCol;
  let candLabel;
  let type2;
  for (let i = 0; i < fields.length; ++i) {
    const { column: column3, label: label2 } = fields[i] || {};
    if (column3 === void 0 && label2 === void 0) {
      continue;
    } else if (candCol === void 0 && candLabel === void 0) {
      candCol = column3;
      candLabel = label2;
      type2 = getType(marks2[i].data, key) || "number";
    } else if (candLabel !== label2) {
      candLabel = void 0;
    } else if (candCol !== column3) {
      candCol = void 0;
    }
  }
  let candidate = candLabel || candCol;
  if (candidate === void 0)
    return;
  if ((type2 === "number" || type2 === "date") && (key === "x" || key === "y")) {
    if (scale3.percent)
      candidate = `${candidate} (%)`;
    const order = (key === "x" ? 1 : -1) * (scale3.reverse ? -1 : 1);
    if (key === "x" || scale3.labelAnchor === "center") {
      candidate = key === "x" === order < 0 ? `\u2190 ${candidate}` : `${candidate} \u2192`;
    } else {
      candidate = `${order < 0 ? "\u2191 " : "\u2193 "}${candidate}`;
    }
  }
  spec[key] = { ...scale3, label: candidate };
}
function annotatePlot(svg, indices) {
  const facets = svg.querySelectorAll('g[aria-label="facet"]');
  if (facets.length) {
    for (const facet of facets) {
      annotateMarks(facet, indices);
    }
  } else {
    annotateMarks(svg, indices);
  }
}
function annotateMarks(svg, indices) {
  let index2 = -1;
  for (const child of svg.children) {
    const aria = child.getAttribute("aria-label") || "";
    const skip = child.nodeName === "style" || aria.includes("-axis") || aria.includes("-grid");
    if (!skip) {
      child.setAttribute("data-index", indices[++index2]);
    }
  }
}
function getType(data, channel) {
  const { columns } = data;
  const col = columns[channel] ?? columns[channel + "1"] ?? columns[channel + "2"];
  if (col) {
    for (const v3 of col) {
      if (v3 != null) {
        return v3 instanceof Date ? "date" : typeof v3;
      }
    }
  }
}

// ../plot/src/plot.js
var DEFAULT_ATTRIBUTES = {
  width: 640,
  marginLeft: 40,
  marginRight: 20,
  marginTop: 20,
  marginBottom: 30
};
var Plot = class {
  constructor(element) {
    this.attributes = { ...DEFAULT_ATTRIBUTES };
    this.listeners = null;
    this.interactors = [];
    this.legends = [];
    this.marks = [];
    this.markset = null;
    this.element = element || document.createElement("div");
    this.element.setAttribute("class", "plot");
    this.element.style.display = "flex";
    this.element.value = this;
    this.params = /* @__PURE__ */ new Map();
    this.synch = synchronizer();
  }
  margins() {
    return {
      left: this.getAttribute("marginLeft"),
      top: this.getAttribute("marginTop"),
      bottom: this.getAttribute("marginBottom"),
      right: this.getAttribute("marginRight")
    };
  }
  innerWidth() {
    const { left: left2, right: right2 } = this.margins();
    return this.getAttribute("width") - left2 - right2;
  }
  innerHeight(defaultValue = 400) {
    const { top: top2, bottom: bottom2 } = this.margins();
    let h2 = this.getAttribute("height");
    if (h2 == null && defaultValue != null) {
      h2 = defaultValue;
      this.setAttribute("height", h2, { silent: true });
    }
    return h2 - top2 - bottom2;
  }
  pending(mark2) {
    this.synch.pending(mark2);
  }
  update(mark2) {
    if (this.synch.ready(mark2) && !this.pendingRender) {
      this.pendingRender = true;
      requestAnimationFrame(() => this.render());
    }
    return this.synch.promise;
  }
  async render() {
    this.pendingRender = false;
    const svg = await plotRenderer(this);
    const legends = this.legends.flatMap(({ legend: legend3, include }) => {
      const el = legend3.init(svg);
      return include ? el : [];
    });
    this.element.replaceChildren(svg, ...legends);
    this.synch.resolve();
  }
  /**
   * @param {string} name The attribute to return.
   * @returns {*} The value of the attribute.
   */
  getAttribute(name2) {
    return this.attributes[name2];
  }
  /**
   * @param {string} name The name of the attribute to set.
   * @param {*} value The value to set.
   * @param {{silent: boolean}} [options] Options for setting the attribute.
   * @returns {boolean} whether the value changed.
   */
  setAttribute(name2, value, options) {
    if (distinct(this.attributes[name2], value)) {
      if (value === void 0) {
        delete this.attributes[name2];
      } else {
        this.attributes[name2] = value;
      }
      if (!options?.silent) {
        this.listeners?.get(name2)?.forEach((cb) => cb(name2, value));
      }
      return true;
    }
    return false;
  }
  /**
   * @param {string} name The attribute name.
   * @param {*} callback The function to call when the attribute changes.
   * @returns {this}
   */
  addAttributeListener(name2, callback) {
    const map4 = this.listeners || (this.listeners = /* @__PURE__ */ new Map());
    if (!map4.has(name2))
      map4.set(name2, /* @__PURE__ */ new Set());
    map4.get(name2).add(callback);
    return this;
  }
  /**
   * @param {string} name The attribute name.
   * @param {*} callback The function to call when the attribute changes.
   * @returns {void}
   */
  removeAttributeListener(name2, callback) {
    return this.listeners?.get(name2)?.delete(callback);
  }
  addParams(mark2, paramSet) {
    const { params } = this;
    for (const param of paramSet) {
      if (params.has(param)) {
        params.get(param).push(mark2);
      } else {
        params.set(param, [mark2]);
        param.addEventListener("value", () => {
          return Promise.allSettled(
            params.get(param).map((mark3) => mark3.requestQuery())
          );
        });
      }
    }
  }
  addMark(mark2) {
    mark2.setPlot(this, this.marks.length);
    this.marks.push(mark2);
    this.markset = null;
    return this;
  }
  get markSet() {
    return this.markset || (this.markset = new Set(this.marks));
  }
  addInteractor(sel) {
    this.interactors.push(sel);
    return this;
  }
  addLegend(legend3, include = true) {
    legend3.setPlot(this);
    this.legends.push({ legend: legend3, include });
  }
};

// ../plot/src/marks/util/is-color.js
function isColor2(value) {
  if (typeof value !== "string")
    return false;
  value = value.toLowerCase().trim();
  return value === "none" || value === "currentcolor" || value.startsWith("url(") && value.endsWith(")") || // <funciri>, e.g. pattern or gradient
  value.startsWith("var(") && value.endsWith(")") || // CSS variable
  color(value) !== null;
}

// ../plot/src/marks/util/is-constant-option.js
var constantOptions = /* @__PURE__ */ new Set([
  "order",
  "sort",
  "label",
  "anchor",
  "curve",
  "tension",
  "marker",
  "markerStart",
  "markerMid",
  "markerEnd",
  "textAnchor",
  "lineAnchor",
  "lineHeight",
  "textOverflow",
  "monospace",
  "fontFamily",
  "fontSize",
  "fontStyle",
  "fontVariant",
  "fontWeight",
  "frameAnchor",
  "strokeLinejoin",
  "strokeLinecap",
  "strokeMiterlimit",
  "strokeDasharray",
  "strokeDashoffset",
  "mixBlendMode",
  "shapeRendering",
  "imageRendering",
  "preserveAspectRatio",
  "interpolate",
  "crossOrigin",
  "paintOrder",
  "pointerEvents",
  "target"
]);
function isConstantOption(value) {
  return constantOptions.has(value);
}

// ../plot/src/marks/util/is-symbol.js
var symbols2 = /* @__PURE__ */ new Set([
  "asterisk",
  "circle",
  "cross",
  "diamond",
  "diamond2",
  "hexagon",
  "plus",
  "square",
  "square2",
  "star",
  "times",
  "triangle",
  "triangle2",
  "wye"
]);
function isSymbol2(value) {
  return symbols2.has(`${value}`.toLowerCase());
}

// ../plot/src/marks/util/to-data-columns.js
function toDataColumns(data) {
  return isArrowTable(data) ? arrowToColumns(data) : arrayToColumns(data);
}
function arrowToColumns(data) {
  const { numRows, numCols, schema: { fields } } = data;
  const columns = {};
  for (let col = 0; col < numCols; ++col) {
    const name2 = fields[col].name;
    if (columns[name2]) {
      console.warn(`Redundant column name "${name2}". Skipping...`);
    } else {
      columns[name2] = convertArrowColumn(data.getChildAt(col));
    }
  }
  return { numRows, columns };
}
function arrayToColumns(data) {
  const numRows = data.length;
  if (typeof data[0] === "object") {
    const names = numRows ? Object.keys(data[0]) : [];
    const columns = {};
    if (names.length > 0) {
      names.forEach((name2) => {
        columns[name2] = data.map((d) => d[name2]);
      });
    }
    return { numRows, columns };
  } else {
    return { numRows, values: data };
  }
}

// ../plot/src/marks/Mark.js
var isColorChannel = (channel) => channel === "stroke" || channel === "fill";
var isOpacityChannel = (channel) => /opacity$/i.test(channel);
var isSymbolChannel = (channel) => channel === "symbol";
var isFieldObject = (channel, field2) => {
  return channel !== "sort" && channel !== "tip" && field2 != null && !Array.isArray(field2);
};
var fieldEntry = (channel, field2) => ({
  channel,
  field: field2,
  as: field2 instanceof Ref ? field2.column : channel
});
var valueEntry = (channel, value) => ({ channel, value });
var isDataArray = (source) => Array.isArray(source);
var Mark2 = class extends MosaicClient {
  constructor(type2, source, encodings, reqs = {}) {
    super(source?.options?.filterBy);
    this.type = type2;
    this.reqs = reqs;
    this.source = source;
    if (isDataArray(this.source)) {
      this.data = toDataColumns(this.source);
    }
    const channels = this.channels = [];
    const detail = this.detail = /* @__PURE__ */ new Set();
    const params = this.params = /* @__PURE__ */ new Set();
    const process = (channel, entry) => {
      const type3 = typeof entry;
      if (channel === "channels") {
        for (const name2 in entry) {
          detail.add(name2);
          process(name2, entry[name2]);
        }
      } else if (type3 === "function" && entry[Transform]) {
        const enc = entry(this, channel);
        for (const key in enc) {
          process(key, enc[key]);
        }
      } else if (type3 === "string") {
        if (isConstantOption(channel) || isColorChannel(channel) && isColor2(entry) || isSymbolChannel(channel) && isSymbol2(entry)) {
          channels.push(valueEntry(channel, entry));
        } else {
          channels.push(fieldEntry(channel, column(entry)));
        }
      } else if (isParamLike(entry)) {
        if (Array.isArray(entry.columns)) {
          channels.push(fieldEntry(channel, entry));
          params.add(entry);
        } else {
          const c4 = valueEntry(channel, entry.value);
          channels.push(c4);
          entry.addEventListener("value", (value) => {
            c4.value = value;
            return this.update();
          });
        }
      } else if (type3 === "object" && isFieldObject(channel, entry)) {
        channels.push(fieldEntry(channel, entry));
      } else if (entry !== void 0) {
        channels.push(valueEntry(channel, entry));
      }
    };
    for (const channel in encodings) {
      process(channel, encodings[channel]);
    }
  }
  /**
   * @param {import('../plot.js').Plot} plot The plot.
   * @param {number} index 
   */
  setPlot(plot3, index2) {
    this.plot = plot3;
    this.index = index2;
    plot3.addParams(this, this.params);
    if (this.source?.table)
      this.queryPending();
  }
  hasOwnData() {
    return this.source == null || isDataArray(this.source);
  }
  hasFieldInfo() {
    return !!this._fieldInfo;
  }
  channel(channel) {
    return this.channels.find((c4) => c4.channel === channel);
  }
  channelField(channel, { exact = false } = {}) {
    const c4 = exact ? this.channel(channel) : this.channels.find((c5) => c5.channel.startsWith(channel));
    return c4?.field ? c4 : null;
  }
  fields() {
    if (this.hasOwnData())
      return null;
    const { source: { table: table3 }, channels, reqs } = this;
    const fields = /* @__PURE__ */ new Map();
    for (const { channel, field: field2 } of channels) {
      if (!field2)
        continue;
      const stats = field2.stats?.stats || [];
      const key = field2.stats?.column ?? field2;
      const entry = fields.get(key) ?? fields.set(key, /* @__PURE__ */ new Set()).get(key);
      stats.forEach((s2) => entry.add(s2));
      reqs[channel]?.forEach((s2) => entry.add(s2));
    }
    return Array.from(fields, ([c4, s2]) => ({ table: table3, column: c4, stats: s2 }));
  }
  fieldInfo(info) {
    const lookup = Object.fromEntries(info.map((x4) => [x4.column, x4]));
    for (const entry of this.channels) {
      const { field: field2 } = entry;
      if (field2) {
        Object.assign(entry, lookup[field2.stats?.column ?? field2]);
      }
    }
    this._fieldInfo = true;
    return this;
  }
  /**
   * Return a query specifying the data needed by this Mark client.
   * @param {*} [filter] The filtering criteria to apply in the query.
   * @returns {*} The client query
   */
  query(filter3 = []) {
    if (this.hasOwnData())
      return null;
    const { channels, source: { table: table3 } } = this;
    return markQuery(channels, table3).where(filter3);
  }
  queryPending() {
    this.plot.pending(this);
    return this;
  }
  /**
   * Provide query result data to the mark.
   */
  queryResult(data) {
    this.data = toDataColumns(data);
    return this;
  }
  update() {
    return this.plot.update(this);
  }
  /**
   * Generate an array of Plot mark specifications.
   * @returns {object[]}
   */
  plotSpecs() {
    const { type: type2, detail, channels } = this;
    const { numRows: length4, values: values2, columns } = this.data || {};
    const options = {};
    const side = {};
    for (const c4 of channels) {
      const obj = detail.has(c4.channel) ? side : options;
      obj[c4.channel] = channelOption(c4, columns);
    }
    if (detail.size)
      options.channels = side;
    const data = values2 ?? (this.data ? { length: length4 } : null);
    const spec = [{ type: type2, data, options }];
    return spec;
  }
};
function channelOption(c4, columns) {
  const value = columns?.[c4.as] ?? c4.as;
  return Object.hasOwn(c4, "value") ? c4.value : isColorChannel(c4.channel) ? { value, scale: "color" } : isOpacityChannel(c4.channel) ? { value, scale: "opacity" } : value;
}
function markQuery(channels, table3, skip = []) {
  const q2 = Query.from({ source: table3 });
  const dims = /* @__PURE__ */ new Set();
  let aggr = false;
  for (const c4 of channels) {
    const { channel, field: field2, as } = c4;
    if (skip.includes(channel))
      continue;
    if (channel === "orderby") {
      q2.orderby(c4.value);
    } else if (field2) {
      if (field2.aggregate) {
        aggr = true;
      } else {
        if (dims.has(as))
          continue;
        dims.add(as);
      }
      q2.select({ [as]: field2 });
    }
  }
  if (aggr) {
    q2.groupby(Array.from(dims));
  }
  return q2;
}

// ../plot/src/marks/util/channel-scale.js
function channelScale(mark2, channel) {
  const { plot: plot3 } = mark2;
  let scaleType = plot3.getAttribute(`${channel}Scale`);
  if (!scaleType) {
    const { type: type2 } = mark2.channelField(channel);
    scaleType = type2 === "date" ? "time" : "linear";
  }
  const options = { type: scaleType };
  switch (scaleType) {
    case "log":
      options.base = plot3.getAttribute(`${channel}Base`) ?? 10;
      break;
    case "pow":
      options.exponent = plot3.getAttribute(`${channel}Exponent`) ?? 1;
      break;
    case "symlog":
      options.constant = plot3.getAttribute(`${channel}Constant`) ?? 1;
      break;
  }
  return scaleTransform(options);
}

// ../plot/src/marks/util/bin-expr.js
function binExpr(mark2, channel, n, extent4, pad3 = 1, expr) {
  const { field: field2 } = mark2.channelField(channel);
  expr = expr ?? field2;
  const { type: type2, apply: apply2, sqlApply } = channelScale(mark2, channel);
  const reverse3 = !!mark2.plot.getAttribute(`${channel}Reverse`);
  const [lo, hi] = extent4.map((v4) => apply2(v4));
  const v3 = sqlApply(expr);
  const f2 = type2 === "time" || type2 === "utc" ? v3 : expr;
  const d = hi === lo ? 0 : (n - pad3) / (hi - lo);
  const s2 = d !== 1 ? ` * ${d}::DOUBLE` : "";
  const bin3 = reverse3 ? sql`(${hi} - ${v3}::DOUBLE)${s2}` : sql`(${v3}::DOUBLE - ${lo})${s2}`;
  return [bin3, f2];
}

// ../plot/src/marks/util/extent.js
var xext = { x: ["min", "max"] };
var yext = { y: ["min", "max"] };
var xyext = { ...xext, ...yext };
function plotExtent(mark2, filter3, channel, domainAttr, niceAttr) {
  const { plot: plot3 } = mark2;
  const domain = plot3.getAttribute(domainAttr);
  const nice3 = plot3.getAttribute(niceAttr);
  if (Array.isArray(domain) && !domain[Transient]) {
    return domain;
  } else {
    const { column: column3, min: min5, max: max4 } = mark2.channelField(channel);
    const dom = filteredExtent(filter3, column3) || (nice3 ? linear2().domain([min5, max4]).nice().domain() : [min5, max4]);
    if (domain !== Fixed)
      dom[Transient] = true;
    plot3.setAttribute(domainAttr, dom, { silent: true });
    return dom;
  }
}
function extentX(mark2, filter3) {
  return plotExtent(mark2, filter3, "x", "xDomain", "xNice");
}
function extentY(mark2, filter3) {
  return plotExtent(mark2, filter3, "y", "yDomain", "yNice");
}
function filteredExtent(filter3, column3) {
  if (!filter3)
    return;
  let lo;
  let hi;
  const visitor = (type2, clause) => {
    if (type2 === "BETWEEN" && `${clause.field}` === column3) {
      const { range: range3 } = clause;
      if (range3 && (lo == null || range3[0] < lo))
        lo = range3[0];
      if (range3 && (hi == null || range3[1] > hi))
        hi = range3[1];
    }
  };
  if (Array.isArray(filter3)) {
    filter3.forEach((p2) => p2.visit?.(visitor));
  } else if (filter3.visit) {
    filter3.visit(visitor);
  }
  return lo != null && hi != null && lo !== hi ? [lo, hi] : void 0;
}

// ../plot/src/marks/ConnectedMark.js
var ConnectedMark = class extends Mark2 {
  constructor(type2, source, encodings) {
    const dim = type2.endsWith("X") ? "y" : type2.endsWith("Y") ? "x" : null;
    const req = dim ? { [dim]: ["min", "max"] } : void 0;
    super(type2, source, encodings, req);
    this.dim = dim;
  }
  /**
   * Return a query specifying the data needed by this Mark client.
   * @param {*} [filter] The filtering criteria to apply in the query.
   * @returns {*} The client query
   */
  query(filter3 = []) {
    const { plot: plot3, dim, source } = this;
    const { optimize = true } = source.options || {};
    const q2 = super.query(filter3);
    if (!dim)
      return q2;
    const ortho = dim === "x" ? "y" : "x";
    const value = this.channelField(ortho, { exact: true })?.as;
    const { field: field2, as, type: type2, min: min5, max: max4 } = this.channelField(dim);
    const isContinuous = type2 === "date" || type2 === "number";
    if (optimize && isContinuous && value) {
      const size = dim === "x" ? plot3.innerWidth() : plot3.innerHeight();
      const [lo, hi] = filteredExtent(filter3, field2) || [min5, max4];
      const [expr] = binExpr(this, dim, size, [lo, hi], 1, as);
      const cols = q2.select().map((c4) => c4.as).filter((c4) => c4 !== as && c4 !== value);
      return m4(q2, expr, as, value, cols);
    } else {
      return q2.orderby(field2);
    }
  }
};
function m4(input3, bin3, x4, y4, cols = []) {
  const pixel = sql`FLOOR(${bin3})::INTEGER`;
  const q2 = (sel) => Query.from(input3).select(sel).groupby(pixel, cols);
  return Query.union(
    q2([{ [x4]: min(x4), [y4]: argmin(y4, x4) }, ...cols]),
    q2([{ [x4]: max(x4), [y4]: argmax(y4, x4) }, ...cols]),
    q2([{ [x4]: argmin(x4, y4), [y4]: min(y4) }, ...cols]),
    q2([{ [x4]: argmax(x4, y4), [y4]: max(y4) }, ...cols])
  ).orderby(cols, x4);
}

// ../plot/src/marks/util/grid.js
function array3(size, proto = []) {
  return new proto.constructor(size);
}
function grid1d(size, index2, value) {
  const G = array3(size, value);
  const n = value.length;
  for (let i = 0; i < n; ++i) {
    G[index2[i]] = value[i];
  }
  return G;
}
function grid2d(w, h2, index2, columns, aggregates, groupby, interpolate) {
  const numRows = index2.length;
  const size = w * h2;
  const values2 = aggregates.map((name2) => columns[name2]);
  const result = {};
  const cells = [];
  const group3 = new Int32Array(numRows);
  if (groupby?.length) {
    const gvalues = groupby.map((name2) => columns[name2]);
    const cellMap = {};
    for (let row = 0; row < numRows; ++row) {
      const key = gvalues.map((group4) => group4[row]);
      group3[row] = cellMap[key] ??= cells.push(key) - 1;
    }
    for (let i = 0; i < groupby.length; ++i) {
      result[groupby[i]] = cells.map((cell3) => cell3[i]);
    }
  } else {
    cells.push([]);
  }
  if (interpolate) {
    const X3 = index2.map((k3) => k3 % w);
    const Y3 = index2.map((k3) => Math.floor(k3 / w));
    const I2 = cells.map(() => []);
    for (let row = 0; row < numRows; ++row) {
      I2[group3[row]].push(row);
    }
    aggregates.forEach((name2, i) => {
      const V2 = values2[i];
      result[name2] = cells.map((_2, j2) => interpolate(I2[j2], w, h2, X3, Y3, V2));
    });
  } else {
    aggregates.forEach((name2, i) => {
      const V2 = values2[i];
      const G = result[name2] = cells.map(() => array3(size, V2));
      for (let row = 0; row < numRows; ++row) {
        G[group3[row]][index2[row]] = V2[row];
      }
    });
  }
  return { numRows: cells.length, columns: result };
}
function gridDomainContinuous(grids) {
  let lo = Infinity, hi = -Infinity;
  grids.forEach((G) => {
    const n = G.length;
    for (let i = 0; i < n; ++i) {
      const v3 = G[i];
      if (v3 < lo)
        lo = v3;
      if (v3 > hi)
        hi = v3;
    }
  });
  return Number.isFinite(lo) && Number.isFinite(hi) ? [lo, hi] : [0, 1];
}
function gridDomainDiscrete(grids) {
  const values2 = new InternSet();
  grids.forEach((G) => {
    const n = G.length;
    for (let i = 0; i < n; ++i) {
      values2.add(G[i]);
    }
  });
  return Array.from(values2).sort(ascending);
}

// ../plot/src/marks/util/handle-param.js
function handleParam(value, update2) {
  return isParam(value) ? (value.addEventListener("value", update2), value.value) : value;
}

// ../plot/src/marks/util/density.js
function dericheConfig(sigma, negative2 = false) {
  const a3 = new Float64Array(5);
  const bc4 = new Float64Array(4);
  dericheCausalCoeff(a3, bc4, sigma);
  const ba = Float64Array.of(
    0,
    bc4[1] - a3[1] * bc4[0],
    bc4[2] - a3[2] * bc4[0],
    bc4[3] - a3[3] * bc4[0],
    -a3[4] * bc4[0]
  );
  const accum_denom = 1 + a3[1] + a3[2] + a3[3] + a3[4];
  const sum_causal = (bc4[0] + bc4[1] + bc4[2] + bc4[3]) / accum_denom;
  const sum_anticausal = (ba[1] + ba[2] + ba[3] + ba[4]) / accum_denom;
  return {
    sigma,
    negative: negative2,
    a: a3,
    b_causal: bc4,
    b_anticausal: ba,
    sum_causal,
    sum_anticausal
  };
}
function dericheCausalCoeff(a_out, b_out, sigma) {
  const K3 = 4;
  const alpha = Float64Array.of(
    0.84,
    1.8675,
    0.84,
    -1.8675,
    -0.34015,
    -0.1299,
    -0.34015,
    0.1299
  );
  const x12 = Math.exp(-1.783 / sigma);
  const x22 = Math.exp(-1.723 / sigma);
  const y12 = 0.6318 / sigma;
  const y22 = 1.997 / sigma;
  const beta = Float64Array.of(
    -x12 * Math.cos(y12),
    x12 * Math.sin(y12),
    -x12 * Math.cos(-y12),
    x12 * Math.sin(-y12),
    -x22 * Math.cos(y22),
    x22 * Math.sin(y22),
    -x22 * Math.cos(-y22),
    x22 * Math.sin(-y22)
  );
  const denom = sigma * 2.5066282746310007;
  const b2 = Float64Array.of(alpha[0], alpha[1], 0, 0, 0, 0, 0, 0);
  const a3 = Float64Array.of(1, 0, beta[0], beta[1], 0, 0, 0, 0, 0, 0);
  let j2, k3;
  for (k3 = 2; k3 < 8; k3 += 2) {
    b2[k3] = beta[k3] * b2[k3 - 2] - beta[k3 + 1] * b2[k3 - 1];
    b2[k3 + 1] = beta[k3] * b2[k3 - 1] + beta[k3 + 1] * b2[k3 - 2];
    for (j2 = k3 - 2; j2 > 0; j2 -= 2) {
      b2[j2] += beta[k3] * b2[j2 - 2] - beta[k3 + 1] * b2[j2 - 1];
      b2[j2 + 1] += beta[k3] * b2[j2 - 1] + beta[k3 + 1] * b2[j2 - 2];
    }
    for (j2 = 0; j2 <= k3; j2 += 2) {
      b2[j2] += alpha[k3] * a3[j2] - alpha[k3 + 1] * a3[j2 + 1];
      b2[j2 + 1] += alpha[k3] * a3[j2 + 1] + alpha[k3 + 1] * a3[j2];
    }
    a3[k3 + 2] = beta[k3] * a3[k3] - beta[k3 + 1] * a3[k3 + 1];
    a3[k3 + 3] = beta[k3] * a3[k3 + 1] + beta[k3 + 1] * a3[k3];
    for (j2 = k3; j2 > 0; j2 -= 2) {
      a3[j2] += beta[k3] * a3[j2 - 2] - beta[k3 + 1] * a3[j2 - 1];
      a3[j2 + 1] += beta[k3] * a3[j2 - 1] + beta[k3 + 1] * a3[j2 - 2];
    }
  }
  for (k3 = 0; k3 < K3; ++k3) {
    j2 = k3 << 1;
    b_out[k3] = b2[j2] / denom;
    a_out[k3 + 1] = a3[j2 + 2];
  }
}
function dericheConv2d(cx, cy, grid2, [nx, ny]) {
  const yc = new Float64Array(Math.max(nx, ny));
  const ya = new Float64Array(Math.max(nx, ny));
  const h2 = new Float64Array(5);
  const d = new Float64Array(grid2.length);
  for (let row = 0, r0 = 0; row < ny; ++row, r0 += nx) {
    const dx = d.subarray(r0);
    dericheConv1d(cx, grid2.subarray(r0), nx, 1, yc, ya, h2, dx);
  }
  for (let c0 = 0; c0 < nx; ++c0) {
    const dy = d.subarray(c0);
    dericheConv1d(cy, dy, ny, nx, yc, ya, h2, dy);
  }
  return d;
}
function dericheConv1d(c4, src, N2, stride = 1, y_causal = new Float64Array(N2), y_anticausal = new Float64Array(N2), h2 = new Float64Array(5), d = y_causal, init2 = dericheInitZeroPad) {
  const stride_2 = stride * 2;
  const stride_3 = stride * 3;
  const stride_4 = stride * 4;
  const stride_N = stride * N2;
  let i, n;
  init2(
    y_causal,
    src,
    N2,
    stride,
    c4.b_causal,
    3,
    c4.a,
    4,
    c4.sum_causal,
    h2,
    c4.sigma
  );
  for (n = 4, i = stride_4; n < N2; ++n, i += stride) {
    y_causal[n] = c4.b_causal[0] * src[i] + c4.b_causal[1] * src[i - stride] + c4.b_causal[2] * src[i - stride_2] + c4.b_causal[3] * src[i - stride_3] - c4.a[1] * y_causal[n - 1] - c4.a[2] * y_causal[n - 2] - c4.a[3] * y_causal[n - 3] - c4.a[4] * y_causal[n - 4];
  }
  init2(
    y_anticausal,
    src,
    N2,
    -stride,
    c4.b_anticausal,
    4,
    c4.a,
    4,
    c4.sum_anticausal,
    h2,
    c4.sigma
  );
  for (n = 4, i = stride_N - stride * 5; n < N2; ++n, i -= stride) {
    y_anticausal[n] = c4.b_anticausal[1] * src[i + stride] + c4.b_anticausal[2] * src[i + stride_2] + c4.b_anticausal[3] * src[i + stride_3] + c4.b_anticausal[4] * src[i + stride_4] - c4.a[1] * y_anticausal[n - 1] - c4.a[2] * y_anticausal[n - 2] - c4.a[3] * y_anticausal[n - 3] - c4.a[4] * y_anticausal[n - 4];
  }
  if (c4.negative) {
    for (n = 0, i = 0; n < N2; ++n, i += stride) {
      d[i] = y_causal[n] + y_anticausal[N2 - n - 1];
    }
  } else {
    for (n = 0, i = 0; n < N2; ++n, i += stride) {
      d[i] = Math.max(0, y_causal[n] + y_anticausal[N2 - n - 1]);
    }
  }
  return d;
}
function dericheInitZeroPad(dest, src, N2, stride, b2, p2, a3, q2, sum5, h2, sigma, tol = 0.5) {
  const stride_N = Math.abs(stride) * N2;
  const off = stride < 0 ? stride_N + stride : 0;
  let i, n, m2;
  for (n = 0; n <= q2; ++n) {
    h2[n] = n <= p2 ? b2[n] : 0;
    for (m2 = 1; m2 <= q2 && m2 <= n; ++m2) {
      h2[n] -= a3[m2] * h2[n - m2];
    }
  }
  for (m2 = 0; m2 < q2; ++m2) {
    for (dest[m2] = 0, n = 1; n <= m2; ++n) {
      i = off + stride * n;
      if (i >= 0 && i < stride_N) {
        dest[m2] += h2[m2 - n] * src[i];
      }
    }
  }
  const cur = src[off];
  const max_iter = Math.ceil(sigma * 10);
  for (n = 0; n < max_iter; ++n) {
    for (m2 = 0; m2 < q2; ++m2) {
      dest[m2] += h2[m2] * cur;
    }
    sum5 -= Math.abs(h2[0]);
    if (sum5 <= tol)
      break;
    h2[q2] = n + q2 <= p2 ? b2[n + q2] : 0;
    for (m2 = 1; m2 <= q2; ++m2) {
      h2[q2] -= a3[m2] * h2[q2 - m2];
    }
    for (m2 = 0; m2 < q2; ++m2) {
      h2[m2] = h2[m2 + 1];
    }
  }
  return;
}

// ../plot/src/marks/Grid2DMark.js
var DENSITY = "density";
var Grid2DMark = class extends Mark2 {
  constructor(type2, source, options) {
    const {
      bandwidth = 0,
      interpolate = "none",
      pixelSize = 1,
      pad: pad3 = 1,
      width: width2,
      height: height2,
      ...channels
    } = options;
    const densityMap = createDensityMap(channels);
    super(type2, source, channels, xyext);
    this.densityMap = densityMap;
    this.bandwidth = handleParam(bandwidth, (value) => {
      this.bandwidth = value;
      return this.grids ? this.convolve().update() : null;
    });
    this.interpolate = handleParam(interpolate, (value) => {
      return this.interpolate = value, this.requestUpdate();
    });
    this.pixelSize = handleParam(pixelSize, (value) => {
      return this.pixelSize = value, this.requestUpdate();
    });
    this.pad = handleParam(pad3, (value) => {
      return this.pad = value, this.requestUpdate();
    });
    this.width = handleParam(width2, (value) => {
      return this.width = value, this.requestUpdate();
    });
    this.height = handleParam(height2, (value) => {
      return this.height = value, this.requestUpdate();
    });
  }
  /**
   * @param {import('../plot.js').Plot} plot The plot.
   * @param {number} index 
   */
  setPlot(plot3, index2) {
    const update2 = () => {
      if (this.hasFieldInfo())
        this.requestUpdate();
    };
    plot3.addAttributeListener("xDomain", update2);
    plot3.addAttributeListener("yDomain", update2);
    super.setPlot(plot3, index2);
  }
  get filterIndexable() {
    const xdom = this.plot.getAttribute("xDomain");
    const ydom = this.plot.getAttribute("yDomain");
    return xdom && ydom && !xdom[Transient] && !ydom[Transient];
  }
  query(filter3 = []) {
    const { interpolate, pad: pad3, channels, densityMap, source } = this;
    const [x06, x12] = this.extentX = extentX(this, filter3);
    const [y06, y12] = this.extentY = extentY(this, filter3);
    const [nx, ny] = this.bins = this.binDimensions();
    const [x4, bx] = binExpr(this, "x", nx, [x06, x12], pad3);
    const [y4, by] = binExpr(this, "y", ny, [y06, y12], pad3);
    const bounds = pad3 ? [isBetween(bx, [+x06, +x12]), isBetween(by, [+y06, +y12])] : [lte(+x06, bx), lt(bx, +x12), lte(+y06, by), lt(by, +y12)];
    const q2 = Query.from(source.table).where(filter3.concat(bounds));
    const groupby = this.groupby = [];
    const aggrMap = {};
    for (const c4 of channels) {
      if (Object.hasOwn(c4, "field")) {
        const { as, channel, field: field2 } = c4;
        if (field2.aggregate) {
          aggrMap[channel] = field2;
          densityMap[channel] = true;
        } else if (channel === "weight") {
          aggrMap[DENSITY] = sum(field2);
        } else if (channel !== "x" && channel !== "y") {
          q2.select({ [as]: field2 });
          groupby.push(as);
        }
      }
    }
    const aggr = this.aggr = Object.keys(aggrMap);
    if (aggrMap.density && aggr.length > 1) {
      throw new Error("Weight option can not be used with custom aggregates.");
    }
    if (!aggr.length) {
      aggr.push(DENSITY);
      aggrMap.density = count();
    }
    if (interpolate === "linear") {
      if (aggr.length > 1) {
        throw new Error("Linear binning not applicable to multiple aggregates.");
      }
      if (!aggrMap.density) {
        throw new Error("Linear binning not applicable to custom aggregates.");
      }
      return binLinear2d(q2, x4, y4, aggrMap[DENSITY], nx, groupby);
    } else {
      return bin2d(q2, x4, y4, aggrMap, nx, groupby);
    }
  }
  /**
   * @returns {[number, number]} The bin dimensions.
   */
  binDimensions() {
    const { plot: plot3, pixelSize, width: width2, height: height2 } = this;
    return [
      width2 ?? Math.round(plot3.innerWidth() / pixelSize),
      height2 ?? Math.round(plot3.innerHeight() / pixelSize)
    ];
  }
  queryResult(data) {
    const [w, h2] = this.bins;
    const interp = maybeInterpolate2(this.interpolate);
    const { columns } = toDataColumns(data);
    this.grids0 = grid2d(w, h2, columns.index, columns, this.aggr, this.groupby, interp);
    return this.convolve();
  }
  convolve() {
    const { aggr, bandwidth, bins: bins2, grids0, plot: plot3 } = this;
    this.grids = grids0;
    if (bandwidth > 0) {
      const prop = aggr.length === 1 ? aggr[0] : aggr.includes(DENSITY) ? DENSITY : null;
      if (!prop) {
        console.warn("No compatible grid found for smoothing.");
        return this;
      }
      const g2 = grids0.columns[prop];
      const w = plot3.innerWidth();
      const h2 = plot3.innerHeight();
      const [nx, ny] = bins2;
      const neg = g2.some((grid2) => grid2.some((v3) => v3 < 0));
      const configX = dericheConfig(bandwidth * (nx - 1) / w, neg);
      const configY = dericheConfig(bandwidth * (ny - 1) / h2, neg);
      this.grids = {
        numRows: grids0.numRows,
        columns: {
          ...grids0.columns,
          // @ts-ignore
          [prop]: g2.map((grid2) => dericheConv2d(configX, configY, grid2, bins2))
        }
      };
    }
    return this;
  }
};
function createDensityMap(channels) {
  const densityMap = {};
  for (const key in channels) {
    if (channels[key] === "density") {
      delete channels[key];
      densityMap[key] = true;
    }
  }
  return densityMap;
}
function maybeInterpolate2(interpolate = "none") {
  if (typeof interpolate === "function")
    return interpolate;
  switch (interpolate.toLowerCase()) {
    case "none":
    case "linear":
      return void 0;
    case "nearest":
      return interpolateNearest;
    case "barycentric":
      return interpolatorBarycentric();
    case "random-walk":
      return interpolatorRandomWalk();
  }
  throw new Error(`invalid interpolate: ${interpolate}`);
}
function bin2d(q2, xp, yp, aggs, xn, groupby) {
  return q2.select({
    index: sql`FLOOR(${xp})::INTEGER + FLOOR(${yp})::INTEGER * ${xn}`,
    ...aggs
  }).groupby("index", groupby);
}
function binLinear2d(q2, xp, yp, density3, xn, groupby) {
  const w = density3?.column ? `* ${density3.column}` : "";
  const subq = (i, w2) => q2.clone().select({ xp, yp, i, w: w2 });
  const a3 = subq(
    sql`FLOOR(xp)::INTEGER + FLOOR(yp)::INTEGER * ${xn}`,
    sql`(FLOOR(xp)::INTEGER + 1 - xp) * (FLOOR(yp)::INTEGER + 1 - yp)${w}`
  );
  const b2 = subq(
    sql`FLOOR(xp)::INTEGER + (FLOOR(yp)::INTEGER + 1) * ${xn}`,
    sql`(FLOOR(xp)::INTEGER + 1 - xp) * (yp - FLOOR(yp)::INTEGER)${w}`
  );
  const c4 = subq(
    sql`FLOOR(xp)::INTEGER + 1 + FLOOR(yp)::INTEGER * ${xn}`,
    sql`(xp - FLOOR(xp)::INTEGER) * (FLOOR(yp)::INTEGER + 1 - yp)${w}`
  );
  const d = subq(
    sql`FLOOR(xp)::INTEGER + 1 + (FLOOR(yp)::INTEGER + 1) * ${xn}`,
    sql`(xp - FLOOR(xp)::INTEGER) * (yp - FLOOR(yp)::INTEGER)${w}`
  );
  return Query.from(Query.unionAll(a3, b2, c4, d)).select({ index: "i", density: sum("w") }, groupby).groupby("index", groupby).having(neq("density", 0));
}

// ../plot/src/marks/ContourMark.js
var ContourMark = class extends Grid2DMark {
  constructor(source, options) {
    const { thresholds = 10, ...channels } = options;
    super("geo", source, {
      bandwidth: 20,
      interpolate: "linear",
      pixelSize: 2,
      ...channels
    });
    this.thresholds = handleParam(thresholds, (value) => {
      this.thresholds = value;
      return this.grids ? this.contours().update() : null;
    });
  }
  convolve() {
    return super.convolve().contours();
  }
  contours() {
    const { bins: bins2, densityMap, grids, thresholds, plot: plot3 } = this;
    const { numRows, columns } = grids;
    let t = thresholds;
    let tz;
    if (Array.isArray(t)) {
      tz = t;
    } else {
      const [, hi] = gridDomainContinuous(columns.density);
      tz = Array.from({ length: t - 1 }, (_2, i) => hi * (i + 1) / t);
    }
    if (densityMap.fill || densityMap.stroke) {
      if (this.plot.getAttribute("colorScale") !== "log") {
        this.plot.setAttribute("colorZero", true);
      }
    }
    const [nx, ny] = bins2;
    const [x06, x12] = plot3.getAttribute("xDomain");
    const [y06, y12] = plot3.getAttribute("yDomain");
    const sx = (x12 - x06) / nx;
    const sy = (y12 - y06) / ny;
    const xo = +x06;
    const yo = +y06;
    const x4 = (v3) => xo + v3 * sx;
    const y4 = (v3) => yo + v3 * sy;
    const contour3 = contours_default().size(bins2);
    const data = this.contourData = Array(numRows * tz.length);
    const { density: density3, ...groupby } = columns;
    const groups2 = Object.entries(groupby);
    for (let i = 0, k3 = 0; i < numRows; ++i) {
      const grid2 = density3[i];
      const rest = groups2.reduce((o, [name2, col]) => (o[name2] = col[i], o), {});
      for (let j2 = 0; j2 < tz.length; ++j2, ++k3) {
        data[k3] = Object.assign(
          transform2(contour3.contour(grid2, tz[j2]), x4, y4),
          rest
        );
      }
    }
    return this;
  }
  plotSpecs() {
    const { type: type2, channels, densityMap, contourData: data } = this;
    const options = {};
    for (const c4 of channels) {
      const { channel } = c4;
      if (channel !== "x" && channel !== "y") {
        options[channel] = channelOption(c4);
      }
    }
    for (const channel in densityMap) {
      if (!densityMap[channel])
        continue;
      options[channel] = channelOption({ channel, as: "value" });
    }
    return [{ type: type2, data, options }];
  }
};
function transform2(geometry, x4, y4) {
  function transformPolygon(coordinates) {
    coordinates.forEach(transformRing);
  }
  function transformRing(coordinates) {
    coordinates.forEach(transformPoint);
  }
  function transformPoint(coordinates) {
    coordinates[0] = x4(coordinates[0]);
    coordinates[1] = y4(coordinates[1]);
  }
  geometry.coordinates.forEach(transformPolygon);
  return geometry;
}

// ../plot/src/marks/util/raster.js
function createCanvas(w, h2) {
  if (typeof document !== "undefined") {
    const c4 = document.createElement("canvas");
    c4.setAttribute("width", w);
    c4.setAttribute("height", h2);
    return c4;
  }
  throw new Error("Can not create a canvas instance.");
}
function alphaConstant(v3 = 1) {
  const a3 = 255 * v3 | 0;
  return (data, w, h2) => {
    for (let j2 = 0, k3 = 0; j2 < h2; ++j2) {
      for (let i = 0; i < w; ++i, k3 += 4) {
        data[k3 + 3] = a3;
      }
    }
  };
}
function alphaScheme(scale3) {
  const { apply: apply2 } = scale3;
  return (data, w, h2, grid2) => {
    for (let j2 = 0, k3 = 0; j2 < h2; ++j2) {
      for (let i = 0, row = (h2 - j2 - 1) * w; i < w; ++i, k3 += 4) {
        data[k3 + 3] = 255 * apply2(grid2[i + row]) | 0;
      }
    }
  };
}
function colorConstant(v3 = {}) {
  const { r = 0, g: g2 = 0, b: b2 = 0, opacity: opacity2 = 1 } = typeof v3 === "string" ? rgb(v3) : v3;
  const c4 = new Uint8ClampedArray([r, g2, b2, 255 * opacity2 | 0]);
  return (data, w, h2) => {
    for (let j2 = 0, k3 = 0; j2 < h2; ++j2) {
      for (let i = 0; i < w; ++i, k3 += 4) {
        data[k3 + 0] = c4[0];
        data[k3 + 1] = c4[1];
        data[k3 + 2] = c4[2];
        data[k3 + 3] = c4[3];
      }
    }
  };
}
function colorCategory(scale3) {
  const { domain, range: range3 } = scale3;
  const idx = /* @__PURE__ */ Object.create(null);
  const p2 = new Uint8ClampedArray(4 * domain.length);
  const n = domain.length - 1;
  const m2 = range3.length;
  for (let i = 0; i <= n; ++i) {
    const v3 = range3[i % m2];
    const { r, g: g2, b: b2, opacity: opacity2 = 1 } = typeof v3 === "string" ? rgb(v3) : v3;
    const k3 = i << 2;
    p2[k3 + 0] = r;
    p2[k3 + 1] = g2;
    p2[k3 + 2] = b2;
    p2[k3 + 3] = 255 * opacity2 | 0;
    idx[domain[i]] = k3;
  }
  return (data, w, h2, grid2) => {
    if (grid2.map) {
      for (let j2 = 0, k3 = 0; j2 < h2; ++j2) {
        for (let i = 0, row = (h2 - j2 - 1) * w; i < w; ++i, k3 += 4) {
          const c4 = idx[grid2[i + row]];
          data[k3 + 0] = p2[c4 + 0];
          data[k3 + 1] = p2[c4 + 1];
          data[k3 + 2] = p2[c4 + 2];
          data[k3 + 3] = p2[c4 + 3];
        }
      }
    } else {
      const c4 = idx[grid2];
      for (let j2 = 0, k3 = 0; j2 < h2; ++j2) {
        for (let i = 0; i < w; ++i, k3 += 4) {
          data[k3 + 0] = p2[c4 + 0];
          data[k3 + 1] = p2[c4 + 1];
          data[k3 + 2] = p2[c4 + 2];
          data[k3 + 3] = p2[c4 + 3];
        }
      }
    }
  };
}
function colorScheme(size, scale3, frac) {
  const { interpolate } = scale3;
  const p2 = new Uint8ClampedArray(4 * size);
  const n = size - 1;
  for (let i = 0; i <= n; ++i) {
    const v3 = interpolate(i / n);
    const { r, g: g2, b: b2, opacity: opacity2 = 1 } = typeof v3 === "string" ? rgb(v3) : v3;
    const k3 = i << 2;
    p2[k3 + 0] = r;
    p2[k3 + 1] = g2;
    p2[k3 + 2] = b2;
    p2[k3 + 3] = 255 * opacity2 | 0;
  }
  return (data, w, h2, grid2) => {
    for (let j2 = 0, k3 = 0; j2 < h2; ++j2) {
      for (let i = 0, row = (h2 - j2 - 1) * w; i < w; ++i, k3 += 4) {
        const c4 = n * frac(grid2[i + row]) << 2;
        data[k3 + 0] = p2[c4 + 0];
        data[k3 + 1] = p2[c4 + 1];
        data[k3 + 2] = p2[c4 + 2];
        data[k3 + 3] = p2[c4 + 3];
      }
    }
  };
}

// ../plot/src/marks/RasterMark.js
var RasterMark = class extends Grid2DMark {
  constructor(source, options) {
    super("image", source, options);
    this.image = null;
  }
  setPlot(plot3, index2) {
    const update2 = () => {
      if (this.hasFieldInfo())
        this.rasterize();
    };
    plot3.addAttributeListener("schemeColor", update2);
    super.setPlot(plot3, index2);
  }
  convolve() {
    return super.convolve().rasterize();
  }
  rasterize() {
    const { bins: bins2, grids } = this;
    const [w, h2] = bins2;
    const { numRows, columns } = grids;
    const { canvas, ctx, img } = imageData(this, w, h2);
    const { alpha, alphaProp, color: color3, colorProp } = rasterEncoding(this);
    const alphaData = columns[alphaProp] ?? [];
    const colorData = columns[colorProp] ?? [];
    this.data = {
      numRows,
      columns: {
        src: Array.from({ length: numRows }, (_2, i) => {
          color3?.(img.data, w, h2, colorData[i]);
          alpha?.(img.data, w, h2, alphaData[i]);
          ctx.putImageData(img, 0, 0);
          return canvas.toDataURL();
        })
      }
    };
    return this;
  }
  plotSpecs() {
    const { type: type2, plot: plot3, data: { numRows: length4, columns } } = this;
    const options = {
      src: columns.src,
      width: plot3.innerWidth(),
      height: plot3.innerHeight(),
      preserveAspectRatio: "none",
      imageRendering: this.channel("imageRendering")?.value,
      frameAnchor: "middle"
    };
    return [{ type: type2, data: { length: length4 }, options }];
  }
};
var HeatmapMark = class extends RasterMark {
  constructor(source, options) {
    super(source, {
      bandwidth: 20,
      interpolate: "linear",
      pixelSize: 2,
      ...options
    });
  }
};
function rasterEncoding(mark2) {
  const { aggr, densityMap, groupby, plot: plot3 } = mark2;
  const hasDensity = aggr.includes(DENSITY);
  const hasFillOpacity = aggr.includes("fillOpacity");
  const fillEntry = mark2.channel("fill");
  const opacEntry = mark2.channel("fillOpacity");
  if (aggr.length > 2 || hasDensity && hasFillOpacity) {
    throw new Error("Invalid raster encodings. Try dropping an aggregate?");
  }
  if (groupby.includes(opacEntry?.as)) {
    throw new Error("Raster fillOpacity must be an aggregate or constant.");
  }
  const fill = densityMap.fill || aggr.includes("fill") ? "grid" : groupby.includes(fillEntry?.as) ? "group" : isColor2(fillEntry?.value) ? fillEntry.value : hasDensity && plot3.getAttribute("colorScheme") ? "grid" : void 0;
  const opac = densityMap.fillOpacity || aggr.includes("fillOpacity") ? "grid" : typeof opacEntry?.value === "number" ? opacEntry.value : hasDensity && fill !== "grid" ? "grid" : void 0;
  if (fill !== "grid" && opac !== "grid") {
    throw new Error("Raster mark missing density values.");
  }
  const colorProp = fillEntry?.as ?? (fill === "grid" ? DENSITY : null);
  const alphaProp = opacEntry?.as ?? (opac === "grid" ? DENSITY : null);
  const color3 = fill !== "grid" && fill !== "group" ? colorConstant(fill) : colorScale(mark2, colorProp);
  const alpha = opac !== "grid" ? alphaConstant(opac) : alphaScale(mark2, alphaProp);
  return { alphaProp, colorProp, alpha, color: color3 };
}
function alphaScale(mark2, prop) {
  const { plot: plot3, grids } = mark2;
  const domainAttr = plot3.getAttribute("opacityDomain");
  const domainFixed = domainAttr === Fixed;
  const domainTransient = domainAttr?.[Transient];
  const domain = !domainFixed && !domainTransient && domainAttr || gridDomainContinuous(grids.columns[prop]);
  if (domainFixed || domainTransient || !domainAttr) {
    if (!domainFixed)
      domain[Transient] = true;
    plot3.setAttribute("opacityDomain", domain);
  }
  const s2 = scale2({
    opacity: {
      type: plot3.getAttribute("opacityScale"),
      domain,
      clamp: plot3.getAttribute("opacityClamp"),
      nice: plot3.getAttribute("opacityNice"),
      reverse: plot3.getAttribute("opacityReverse"),
      zero: plot3.getAttribute("opacityZero"),
      base: plot3.getAttribute("opacityBase"),
      exponent: plot3.getAttribute("opacityExponent"),
      constant: plot3.getAttribute("opacityConstant")
    }
  });
  return alphaScheme(s2);
}
function colorScale(mark2, prop) {
  const { plot: plot3, grids } = mark2;
  const data = grids.columns[prop];
  const flat = !data[0]?.map;
  const discrete = flat || Array.isArray(data[0]);
  const domainAttr = plot3.getAttribute("colorDomain");
  const domainFixed = domainAttr === Fixed;
  const domainTransient = domainAttr?.[Transient];
  const domain = !domainFixed && !domainTransient && domainAttr || (flat ? data.sort(ascending) : discrete ? gridDomainDiscrete(data) : gridDomainContinuous(data));
  if (domainFixed || domainTransient || !domainAttr) {
    if (!domainFixed)
      domain[Transient] = true;
    plot3.setAttribute("colorDomain", domain);
  }
  const s2 = scale2({
    color: {
      type: plot3.getAttribute("colorScale"),
      domain,
      range: plot3.getAttribute("colorRange"),
      clamp: plot3.getAttribute("colorClamp"),
      n: plot3.getAttribute("colorN"),
      nice: plot3.getAttribute("colorNice"),
      reverse: plot3.getAttribute("colorReverse"),
      scheme: plot3.getAttribute("colorScheme"),
      interpolate: plot3.getAttribute("colorInterpolate"),
      pivot: plot3.getAttribute("colorPivot"),
      symmetric: plot3.getAttribute("colorSymmetric"),
      zero: plot3.getAttribute("colorZero"),
      base: plot3.getAttribute("colorBase"),
      exponent: plot3.getAttribute("colorExponent"),
      constant: plot3.getAttribute("colorConstant")
    }
  });
  if (discrete) {
    return colorCategory(s2);
  } else {
    const frac = scale2({
      x: {
        type: inferScaleType2(s2.type),
        domain: s2.domain,
        reverse: s2.reverse,
        range: [0, 1],
        clamp: s2.clamp,
        base: s2.base,
        exponent: s2.exponent,
        constant: s2.constant
      }
    });
    return colorScheme(1024, s2, frac.apply);
  }
}
function inferScaleType2(type2) {
  if (type2.endsWith("symlog"))
    return "symlog";
  if (type2.endsWith("log"))
    return "log";
  if (type2.endsWith("pow"))
    return "pow";
  if (type2.endsWith("sqrt"))
    return "sqrt";
  if (type2 === "diverging")
    return "linear";
  return type2;
}
function imageData(mark2, w, h2) {
  if (!mark2.image || mark2.image.w !== w || mark2.image.h !== h2) {
    const canvas = createCanvas(w, h2);
    const ctx = canvas.getContext("2d", { willReadFrequently: true });
    const img = ctx.getImageData(0, 0, w, h2);
    mark2.image = { canvas, ctx, img, w, h: h2 };
  }
  return mark2.image;
}

// ../plot/src/marks/DenseLineMark.js
var DenseLineMark = class extends RasterMark {
  constructor(source, options) {
    const { normalize: normalize4 = true, ...rest } = options;
    super(source, rest);
    this.normalize = handleParam(normalize4, (value) => {
      return this.normalize = value, this.requestUpdate();
    });
  }
  query(filter3 = []) {
    const { channels, normalize: normalize4, source, pad: pad3 } = this;
    const [nx, ny] = this.bins = this.binDimensions();
    const [x4] = binExpr(this, "x", nx, extentX(this, filter3), pad3);
    const [y4] = binExpr(this, "y", ny, extentY(this, filter3), pad3);
    const q2 = Query.from(source.table).where(stripXY(this, filter3));
    this.aggr = ["density"];
    const groupby = this.groupby = [];
    const z2 = [];
    for (const c4 of channels) {
      if (Object.hasOwn(c4, "field")) {
        const { channel, field: field2 } = c4;
        if (channel === "z") {
          q2.select({ [channel]: field2 });
          z2.push("z");
        } else if (channel !== "x" && channel !== "y") {
          q2.select({ [channel]: field2 });
          groupby.push(channel);
        }
      }
    }
    return lineDensity(q2, x4, y4, z2, nx, ny, groupby, normalize4);
  }
};
function stripXY(mark2, filter3) {
  if (Array.isArray(filter3) && !filter3.length)
    return filter3;
  const { column: xc } = mark2.channelField("x");
  const { column: yc } = mark2.channelField("y");
  const test = (p2) => {
    const col = `${p2.field}`;
    return p2.op !== "BETWEEN" || col !== xc && col !== yc;
  };
  const filterAnd = (p2) => p2.op === "AND" ? and(p2.children.filter((c4) => test(c4))) : p2;
  return Array.isArray(filter3) ? filter3.filter((p2) => test(p2)).map((p2) => filterAnd(p2)) : filterAnd(filter3);
}
function lineDensity(q2, x4, y4, z2, xn, yn, groupby = [], normalize4 = true) {
  q2.select({
    x: sql`FLOOR(${x4})::INTEGER`,
    y: sql`FLOOR(${y4})::INTEGER`
  });
  const groups2 = groupby.concat(z2);
  const pairPart = groups2.length ? `PARTITION BY ${groups2.join(", ")} ` : "";
  const pairs2 = Query.from(q2).select(groups2, {
    x0: "x",
    y0: "y",
    dx: sql`(lead(x) OVER sw - x)`,
    dy: sql`(lead(y) OVER sw - y)`
  }).window({ sw: sql`${pairPart}ORDER BY x ASC` }).qualify(and(
    sql`(x0 < ${xn} OR x0 + dx < ${xn})`,
    sql`(y0 < ${yn} OR y0 + dy < ${yn})`,
    sql`(x0 > 0 OR x0 + dx > 0)`,
    sql`(y0 > 0 OR y0 + dy > 0)`
  ));
  const num = Query.select({ x: sql`GREATEST(MAX(ABS(dx)), MAX(ABS(dy)))` }).from("pairs");
  const indices = Query.select({ i: sql`UNNEST(range((${num})))::INTEGER` });
  const raster3 = Query.unionAll(
    Query.select(groups2, {
      x: sql`x0 + i`,
      y: sql`y0 + ROUND(i * dy / dx::FLOAT)::INTEGER`
    }).from("pairs", "indices").where(sql`ABS(dy) <= ABS(dx) AND i < ABS(dx)`),
    Query.select(groups2, {
      x: sql`x0 + ROUND(SIGN(dy) * i * dx / dy::FLOAT)::INTEGER`,
      y: sql`y0 + SIGN(dy) * i`
    }).from("pairs", "indices").where(sql`ABS(dy) > ABS(dx) AND i < ABS(dy)`),
    Query.select(groups2, { x: "x0", y: "y0" }).from("pairs").where(isNull("dx"))
  );
  const pointPart = ["x"].concat(groups2).join(", ");
  const points2 = Query.from("raster").select(
    groups2,
    "x",
    "y",
    normalize4 ? { w: sql`1.0 / COUNT(*) OVER (PARTITION BY ${pointPart})` } : null
  ).where(and(isBetween("x", [0, xn], true), isBetween("y", [0, yn], true)));
  return Query.with({ pairs: pairs2, indices, raster: raster3, points: points2 }).from("points").select(groupby, {
    index: sql`x + y * ${xn}::INTEGER`,
    density: normalize4 ? sum("w") : count()
  }).groupby("index", groupby);
}

// ../plot/src/marks/Density1DMark.js
var Density1DMark = class extends Mark2 {
  constructor(type2, source, options) {
    const { bins: bins2 = 1024, bandwidth = 20, ...channels } = options;
    const dim = type2.endsWith("X") ? "y" : "x";
    super(type2, source, channels, dim === "x" ? xext : yext);
    this.dim = dim;
    this.bins = handleParam(bins2, (value) => {
      return this.bins = value, this.requestUpdate();
    });
    this.bandwidth = handleParam(bandwidth, (value) => {
      this.bandwidth = value;
      return this.grid ? this.convolve().update() : null;
    });
  }
  get filterIndexable() {
    const name2 = this.dim === "x" ? "xDomain" : "yDomain";
    const dom = this.plot.getAttribute(name2);
    return dom && !dom[Transient];
  }
  query(filter3 = []) {
    if (this.hasOwnData())
      throw new Error("Density1DMark requires a data source");
    const { bins: bins2, channels, dim, source: { table: table3 } } = this;
    const extent4 = this.extent = (dim === "x" ? extentX : extentY)(this, filter3);
    const [x4, bx] = binExpr(this, dim, bins2, extent4);
    const q2 = markQuery(channels, table3, [dim]).where(filter3.concat(isBetween(bx, extent4)));
    const v3 = this.channelField("weight") ? "weight" : null;
    return binLinear1d(q2, x4, v3);
  }
  queryResult(data) {
    const { columns: { index: index2, density: density3 } } = toDataColumns(data);
    this.grid = grid1d(this.bins, index2, density3);
    return this.convolve();
  }
  convolve() {
    const { bins: bins2, bandwidth, dim, grid: grid2, plot: plot3, extent: [lo, hi] } = this;
    const neg = grid2.some((v4) => v4 < 0);
    const size = dim === "x" ? plot3.innerWidth() : plot3.innerHeight();
    const config = dericheConfig(bandwidth * (bins2 - 1) / size, neg);
    const result = dericheConv1d(config, grid2, bins2);
    const v3 = dim === "x" ? "y" : "x";
    const b2 = this.channelField(dim).as;
    const b0 = +lo;
    const delta = (hi - b0) / (bins2 - 1);
    const scale3 = 1 / delta;
    const _b3 = new Float64Array(bins2);
    const _v3 = new Float64Array(bins2);
    for (let i = 0; i < bins2; ++i) {
      _b3[i] = b0 + i * delta;
      _v3[i] = result[i] * scale3;
    }
    this.data = { numRows: bins2, columns: { [b2]: _b3, [v3]: _v3 } };
    return this;
  }
  plotSpecs() {
    const { type: type2, data: { numRows: length4, columns }, channels, dim } = this;
    const options = dim === "x" ? { y: columns.y } : { x: columns.x };
    for (const c4 of channels) {
      options[c4.channel] = channelOption(c4, columns);
    }
    return [{ type: type2, data: { length: length4 }, options }];
  }
};
function binLinear1d(q2, p2, density3) {
  const w = density3 ? `* ${density3}` : "";
  const u4 = q2.clone().select({
    p: p2,
    i: sql`FLOOR(p)::INTEGER`,
    w: sql`(FLOOR(p) + 1 - p)${w}`
  });
  const v3 = q2.clone().select({
    p: p2,
    i: sql`FLOOR(p)::INTEGER + 1`,
    w: sql`(p - FLOOR(p))${w}`
  });
  return Query.from(Query.unionAll(u4, v3)).select({ index: "i", density: sum("w") }).groupby("index").having(gt("density", 0));
}

// ../plot/src/marks/Density2DMark.js
var Density2DMark = class extends Grid2DMark {
  constructor(source, options) {
    const { type: type2 = "dot", ...channels } = options;
    super(type2, source, {
      bandwidth: 20,
      interpolate: "linear",
      pad: 0,
      pixelSize: 2,
      ...channels
    });
  }
  convolve() {
    super.convolve();
    const { bins: bins2, pad: pad3, extentX: extentX2, extentY: extentY2 } = this;
    const [nx, ny] = bins2;
    const scaleX = channelScale(this, "x");
    const scaleY = channelScale(this, "y");
    const [x06, x12] = extentX2.map((v3) => scaleX.apply(v3));
    const [y06, y12] = extentY2.map((v3) => scaleY.apply(v3));
    const deltaX = (x12 - x06) / (nx - pad3);
    const deltaY = (y12 - y06) / (ny - pad3);
    const offset2 = pad3 ? 0 : 0.5;
    this.data = points(
      this.grids,
      bins2,
      x06,
      y06,
      deltaX,
      deltaY,
      scaleX.invert,
      scaleY.invert,
      offset2
    );
    return this;
  }
  plotSpecs() {
    const { type: type2, channels, densityMap, data: { numRows: length4, columns } } = this;
    const options = {};
    for (const c4 of channels) {
      const { channel } = c4;
      options[channel] = channel === "x" || channel === "y" ? columns[channel] : channelOption(c4, columns);
    }
    for (const channel in densityMap) {
      if (densityMap[channel]) {
        options[channel] = columns.density;
      }
    }
    return [{ type: type2, data: { length: length4 }, options }];
  }
};
function points(data, bins2, x06, y06, deltaX, deltaY, invertX, invertY, offset2) {
  const scale3 = 1 / (deltaX * deltaY);
  const [nx, ny] = bins2;
  const batch = nx * ny;
  const numRows = batch * data.numRows;
  const x4 = new Float64Array(numRows);
  const y4 = new Float64Array(numRows);
  const density3 = new Float64Array(numRows);
  const columns = { x: x4, y: y4, density: density3 };
  const { density: grids, ...rest } = data.columns;
  for (const name2 in rest) {
    columns[name2] = new rest[name2].constructor(numRows);
  }
  let r = 0;
  for (let row = 0; row < data.numRows; ++row) {
    for (const name2 in rest) {
      columns[name2].fill(rest[name2][row], r, r + batch);
    }
    const grid2 = grids[row];
    for (let k3 = 0, j2 = 0; j2 < ny; ++j2) {
      for (let i = 0; i < nx; ++i, ++r, ++k3) {
        x4[r] = invertX(x06 + (i + offset2) * deltaX);
        y4[r] = invertY(y06 + (j2 + offset2) * deltaY);
        density3[r] = grid2[k3] * scale3;
      }
    }
  }
  return { numRows, columns };
}

// ../plot/src/marks/GeoMark.js
var DEFAULT_GEOMETRY_COLUMN = "geom";
var GeoMark = class extends Mark2 {
  constructor(source, encodings = {}, reqs) {
    if (!isDataArray(source) && !encodings?.geometry) {
      encodings.geometry = geojson(DEFAULT_GEOMETRY_COLUMN);
    }
    super("geo", source, encodings, reqs);
  }
  queryResult(data) {
    super.queryResult(data);
    const geom = this.channelField("geometry")?.as;
    if (geom) {
      const { columns } = this.data;
      if (typeof columns[geom][0] === "string") {
        columns[geom] = columns[geom].map((s2) => JSON.parse(s2));
      }
    }
    return this;
  }
};

// ../plot/src/marks/HexbinMark.js
var HexbinMark = class extends Mark2 {
  constructor(source, options) {
    const { type: type2 = "hexagon", binWidth = 20, ...channels } = options;
    super(type2, source, { r: binWidth / 2, clip: true, ...channels }, xyext);
    this.binWidth = handleParam(binWidth, (value) => {
      return this.binWidth = value, this.requestUpdate();
    });
  }
  get filterIndexable() {
    const xdom = this.plot.getAttribute("xDomain");
    const ydom = this.plot.getAttribute("yDomain");
    return xdom && ydom && !xdom[Transient] && !ydom[Transient];
  }
  query(filter3 = []) {
    if (this.hasOwnData())
      return null;
    const { plot: plot3, binWidth, channels, source } = this;
    const [x12, x22] = extentX(this, filter3);
    const [y12, y22] = extentY(this, filter3);
    const ox2 = 0.5 - plot3.getAttribute("marginLeft");
    const oy2 = 0 - plot3.getAttribute("marginTop");
    const dx = `${binWidth}::DOUBLE`;
    const dy = `${binWidth * (1.5 / Math.sqrt(3))}::DOUBLE`;
    const xr = `${plot3.innerWidth() / (x22 - x12)}::DOUBLE`;
    const yr = `${plot3.innerHeight() / (y22 - y12)}::DOUBLE`;
    let x4, y4;
    const aggr = /* @__PURE__ */ new Set();
    const cols = {};
    let orderby;
    for (const c4 of channels) {
      if (c4.channel === "orderby") {
        orderby = c4.value;
      } else if (c4.channel === "x") {
        x4 = c4;
      } else if (c4.channel === "y") {
        y4 = c4;
      } else if (Object.hasOwn(c4, "field")) {
        cols[c4.as] = c4.field;
        if (c4.field.aggregate) {
          c4.field.columns.forEach((col) => aggr.add(col));
        }
      }
    }
    const q2 = Query.select({
      [x4.as]: sql`${x12}::DOUBLE + ((x + 0.5 * (y & 1)) * ${dx} + ${ox2})::DOUBLE / ${xr}`,
      [y4.as]: sql`${y22}::DOUBLE - (y * ${dy} + ${oy2})::DOUBLE / ${yr}`,
      ...cols
    }).groupby("x", "y");
    if (orderby)
      q2.orderby(orderby);
    const xx = `${xr} * (${x4.field} - ${x12}::DOUBLE)`;
    const yy = `${yr} * (${y22}::DOUBLE - ${y4.field})`;
    const hex2 = Query.select({
      py: sql`(${yy} - ${oy2}) / ${dy}`,
      pj: sql`ROUND(py)::INTEGER`,
      px: sql`(${xx} - ${ox2}) / ${dx} - 0.5 * (pj & 1)`,
      pi: sql`ROUND(px)::INTEGER`,
      tt: sql`ABS(py-pj) * 3 > 1 AND (px-pi)**2 + (py-pj)**2 > (px - pi - 0.5 * CASE WHEN px < pi THEN -1 ELSE 1 END)**2 + (py - pj - CASE WHEN py < pj THEN -1 ELSE 1 END)**2`,
      x: sql`CASE WHEN tt THEN (pi + (CASE WHEN px < pi THEN -0.5 ELSE 0.5 END) + (CASE WHEN pj & 1 <> 0 THEN 0.5 ELSE -0.5 END))::INTEGER ELSE pi END`,
      y: sql`CASE WHEN tt THEN (pj + CASE WHEN py < pj THEN -1 ELSE 1 END)::INTEGER ELSE pj END`
    }).select(Array.from(aggr)).from(source.table).where(isNotNull(x4.field), isNotNull(y4.field), filter3);
    return q2.from(hex2);
  }
};

// ../plot/src/marks/RasterTileMark.js
var RasterTileMark = class extends Grid2DMark {
  constructor(source, options) {
    const { origin = [0, 0], dim = "xy", ...markOptions2 } = options;
    super("image", source, markOptions2);
    this.image = null;
    this.origin = origin;
    this.tileX = dim.toLowerCase().includes("x");
    this.tileY = dim.toLowerCase().includes("y");
  }
  setPlot(plot3, index2) {
    const update2 = () => {
      if (this.hasFieldInfo())
        this.rasterize();
    };
    plot3.addAttributeListener("schemeColor", update2);
    super.setPlot(plot3, index2);
  }
  requestQuery() {
    return this.requestTiles();
  }
  query(filter3 = []) {
    this._filter = filter3;
    return null;
  }
  tileQuery(extent4) {
    const { interpolate, pad: pad3, channels, densityMap, source } = this;
    const [[x06, x12], [y06, y12]] = extent4;
    const [nx, ny] = this.bins;
    const [x4, bx] = binExpr(this, "x", nx, [x06, x12], pad3);
    const [y4, by] = binExpr(this, "y", ny, [y06, y12], pad3);
    const bounds = pad3 ? [isBetween(bx, [+x06, +x12]), isBetween(by, [+y06, +y12])] : [lte(+x06, bx), lt(bx, +x12), lte(+y06, by), lt(by, +y12)];
    const q2 = Query.from(source.table).where(bounds);
    const groupby = this.groupby = [];
    const aggrMap = {};
    for (const c4 of channels) {
      if (Object.hasOwn(c4, "field")) {
        const { as, channel, field: field2 } = c4;
        if (field2.aggregate) {
          aggrMap[channel] = field2;
          densityMap[channel] = true;
        } else if (channel === "weight") {
          aggrMap.density = sum(field2);
        } else if (channel !== "x" && channel !== "y") {
          q2.select({ [as]: field2 });
          groupby.push(as);
        }
      }
    }
    const aggr = this.aggr = Object.keys(aggrMap);
    if (aggrMap.density && aggr.length > 1) {
      throw new Error("Weight option can not be used with custom aggregates.");
    }
    if (!aggr.length) {
      aggr.push("density");
      aggrMap.density = count();
    }
    if (interpolate === "linear") {
      if (aggr.length > 1) {
        throw new Error("Linear binning not applicable to multiple aggregates.");
      }
      if (!aggrMap.density) {
        throw new Error("Linear binning not applicable to custom aggregates.");
      }
      return binLinear2d2(q2, x4, y4, aggrMap.density, nx, groupby);
    } else {
      return bin2d2(q2, x4, y4, aggrMap, nx, groupby);
    }
  }
  async requestTiles() {
    const mc = coordinator();
    if (this.prefetch)
      mc.cancel(this.prefetch);
    const { pad: pad3, tileX, tileY, origin: [tx, ty] } = this;
    const [m2, n] = this.bins = this.binDimensions();
    const [x06, x12] = extentX(this, this._filter);
    const [y06, y12] = extentY(this, this._filter);
    const xspan = x12 - x06;
    const yspan = y12 - y06;
    const xx = Math.floor((x06 - tx) * (m2 - pad3) / xspan);
    const yy = Math.floor((y06 - ty) * (n - pad3) / yspan);
    const tileExtent = (i, j2) => [
      [tx + i * xspan, tx + (i + 1) * xspan],
      [ty + j2 * yspan, ty + (j2 + 1) * yspan]
    ];
    const i0 = Math.floor((x06 - tx) / xspan);
    const i1 = tileX ? tileFloor((x12 - tx) / xspan) : i0;
    const j0 = Math.floor((y06 - ty) / yspan);
    const j1 = tileY ? tileFloor((y12 - ty) / yspan) : j0;
    const coords = [];
    for (let i = i0; i <= i1; ++i) {
      for (let j2 = j0; j2 <= j1; ++j2) {
        coords.push([i, j2]);
      }
    }
    const queries = coords.map(
      ([i, j2]) => mc.query(this.tileQuery(tileExtent(i, j2)))
    );
    const prefetchCoords = [];
    if (tileX) {
      for (let j2 = j0; j2 <= j1; ++j2) {
        prefetchCoords.push([i1 + 1, j2]);
        prefetchCoords.push([i0 - 1, j2]);
      }
    }
    if (tileY) {
      const x07 = tileX ? i0 - 1 : i0;
      const x13 = tileX ? i1 + 1 : i1;
      for (let i = x07; i <= x13; ++i) {
        prefetchCoords.push([i, j1 + 1]);
        prefetchCoords.push([i, j0 - 1]);
      }
    }
    this.prefetch = prefetchCoords.map(
      ([i, j2]) => mc.prefetch(this.tileQuery(tileExtent(i, j2)))
    );
    const tiles = await Promise.all(queries);
    const density3 = processTiles(m2, n, xx, yy, coords, tiles);
    this.grids0 = {
      numRows: density3.length,
      columns: { density: [density3] }
    };
    this.convolve().update();
  }
  convolve() {
    return super.convolve().rasterize();
  }
  rasterize() {
    const { bins: bins2, grids } = this;
    const [w, h2] = bins2;
    const { numRows, columns } = grids;
    const { canvas, ctx, img } = imageData2(this, w, h2);
    const { alpha, alphaProp, color: color3, colorProp } = rasterEncoding(this);
    const alphaData = columns[alphaProp] ?? [];
    const colorData = columns[colorProp] ?? [];
    this.data = {
      numRows,
      columns: {
        src: Array.from({ length: numRows }, (_2, i) => {
          color3?.(img.data, w, h2, colorData[i]);
          alpha?.(img.data, w, h2, alphaData[i]);
          ctx.putImageData(img, 0, 0);
          return canvas.toDataURL();
        })
      }
    };
    return this;
  }
  plotSpecs() {
    const { type: type2, plot: plot3, data: { numRows: length4, columns } } = this;
    const options = {
      src: columns.src,
      width: plot3.innerWidth(),
      height: plot3.innerHeight(),
      preserveAspectRatio: "none",
      imageRendering: this.channel("imageRendering")?.value,
      frameAnchor: "middle"
    };
    return [{ type: type2, data: { length: length4 }, options }];
  }
};
function processTiles(m2, n, x4, y4, coords, tiles) {
  const grid2 = new Float64Array(m2 * n);
  tiles.forEach((data, index2) => {
    const [i, j2] = coords[index2];
    const tx = i * m2 - x4;
    const ty = j2 * n - y4;
    copy3(m2, n, grid2, data, tx, ty);
  });
  return grid2;
}
function copy3(m2, n, grid2, values2, tx, ty) {
  const num = values2.numRows;
  if (num === 0)
    return;
  const index2 = values2.getChild("index").toArray();
  const value = values2.getChild("density").toArray();
  for (let row = 0; row < num; ++row) {
    const idx = index2[row];
    const i = tx + idx % m2;
    const j2 = ty + Math.floor(idx / m2);
    if (0 <= i && i < m2 && 0 <= j2 && j2 < n) {
      grid2[i + j2 * m2] = value[row];
    }
  }
}
function imageData2(mark2, w, h2) {
  if (!mark2.image || mark2.image.w !== w || mark2.image.h !== h2) {
    const canvas = createCanvas(w, h2);
    const ctx = canvas.getContext("2d", { willReadFrequently: true });
    const img = ctx.getImageData(0, 0, w, h2);
    mark2.image = { canvas, ctx, img, w, h: h2 };
  }
  return mark2.image;
}
function bin2d2(q2, xp, yp, aggs, xn, groupby) {
  return q2.select({
    index: sql`FLOOR(${xp})::INTEGER + FLOOR(${yp})::INTEGER * ${xn}`,
    ...aggs
  }).groupby("index", groupby);
}
function binLinear2d2(q2, xp, yp, value, xn, groupby) {
  const w = value.column ? `* ${value.column}` : "";
  const subq = (i, w2) => q2.clone().select({ xp, yp, i, w: w2 });
  const a3 = subq(
    sql`FLOOR(xp)::INTEGER + FLOOR(yp)::INTEGER * ${xn}`,
    sql`(FLOOR(xp)::INTEGER + 1 - xp) * (FLOOR(yp)::INTEGER + 1 - yp)${w}`
  );
  const b2 = subq(
    sql`FLOOR(xp)::INTEGER + (FLOOR(yp)::INTEGER + 1) * ${xn}`,
    sql`(FLOOR(xp)::INTEGER + 1 - xp) * (yp - FLOOR(yp)::INTEGER)${w}`
  );
  const c4 = subq(
    sql`FLOOR(xp)::INTEGER + 1 + FLOOR(yp)::INTEGER * ${xn}`,
    sql`(xp - FLOOR(xp)::INTEGER) * (FLOOR(yp)::INTEGER + 1 - yp)${w}`
  );
  const d = subq(
    sql`FLOOR(xp)::INTEGER + 1 + (FLOOR(yp)::INTEGER + 1) * ${xn}`,
    sql`(xp - FLOOR(xp)::INTEGER) * (yp - FLOOR(yp)::INTEGER)${w}`
  );
  return Query.from(Query.unionAll(a3, b2, c4, d)).select({ index: "i", density: sum("w") }, groupby).groupby("index", groupby).having(neq("density", 0));
}
function tileFloor(value) {
  const floored = Math.floor(value);
  return floored === value ? floored - 1 : floored;
}

// ../plot/src/marks/util/stats.js
function ibetainv2(p2, a3, b2) {
  var EPS2 = 1e-8;
  var a1 = a3 - 1;
  var b1 = b2 - 1;
  var j2 = 0;
  var lna, lnb, pp, t, u4, err, x4, al, h2, w, afac;
  if (p2 <= 0)
    return 0;
  if (p2 >= 1)
    return 1;
  if (a3 >= 1 && b2 >= 1) {
    pp = p2 < 0.5 ? p2 : 1 - p2;
    t = Math.sqrt(-2 * Math.log(pp));
    x4 = (2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t;
    if (p2 < 0.5)
      x4 = -x4;
    al = (x4 * x4 - 3) / 6;
    h2 = 2 / (1 / (2 * a3 - 1) + 1 / (2 * b2 - 1));
    w = x4 * Math.sqrt(al + h2) / h2 - (1 / (2 * b2 - 1) - 1 / (2 * a3 - 1)) * (al + 5 / 6 - 2 / (3 * h2));
    x4 = a3 / (a3 + b2 * Math.exp(2 * w));
  } else {
    lna = Math.log(a3 / (a3 + b2));
    lnb = Math.log(b2 / (a3 + b2));
    t = Math.exp(a3 * lna) / a3;
    u4 = Math.exp(b2 * lnb) / b2;
    w = t + u4;
    if (p2 < t / w)
      x4 = Math.pow(a3 * w * p2, 1 / a3);
    else
      x4 = 1 - Math.pow(b2 * w * (1 - p2), 1 / b2);
  }
  afac = -gammaln2(a3) - gammaln2(b2) + gammaln2(a3 + b2);
  for (; j2 < 10; j2++) {
    if (x4 === 0 || x4 === 1)
      return x4;
    err = ibeta2(x4, a3, b2) - p2;
    t = Math.exp(a1 * Math.log(x4) + b1 * Math.log(1 - x4) + afac);
    u4 = err / t;
    x4 -= t = u4 / (1 - 0.5 * Math.min(1, u4 * (a1 / x4 - b1 / (1 - x4))));
    if (x4 <= 0)
      x4 = 0.5 * (x4 + t);
    if (x4 >= 1)
      x4 = 0.5 * (x4 + t + 1);
    if (Math.abs(t) < EPS2 * x4 && j2 > 0)
      break;
  }
  return x4;
}
function ibeta2(x4, a3, b2) {
  var bt = x4 === 0 || x4 === 1 ? 0 : Math.exp(gammaln2(a3 + b2) - gammaln2(a3) - gammaln2(b2) + a3 * Math.log(x4) + b2 * Math.log(1 - x4));
  if (x4 < 0 || x4 > 1)
    return 0;
  if (x4 < (a3 + 1) / (a3 + b2 + 2))
    return bt * betacf2(x4, a3, b2) / a3;
  return 1 - bt * betacf2(1 - x4, b2, a3) / b2;
}
function betacf2(x4, a3, b2) {
  var fpmin = 1e-30;
  var m2 = 1;
  var qab = a3 + b2;
  var qap = a3 + 1;
  var qam = a3 - 1;
  var c4 = 1;
  var d = 1 - qab * x4 / qap;
  var m22, aa2, del, h2;
  if (Math.abs(d) < fpmin)
    d = fpmin;
  d = 1 / d;
  h2 = d;
  for (; m2 <= 100; m2++) {
    m22 = 2 * m2;
    aa2 = m2 * (b2 - m2) * x4 / ((qam + m22) * (a3 + m22));
    d = 1 + aa2 * d;
    if (Math.abs(d) < fpmin)
      d = fpmin;
    c4 = 1 + aa2 / c4;
    if (Math.abs(c4) < fpmin)
      c4 = fpmin;
    d = 1 / d;
    h2 *= d * c4;
    aa2 = -(a3 + m2) * (qab + m2) * x4 / ((a3 + m22) * (qap + m22));
    d = 1 + aa2 * d;
    if (Math.abs(d) < fpmin)
      d = fpmin;
    c4 = 1 + aa2 / c4;
    if (Math.abs(c4) < fpmin)
      c4 = fpmin;
    d = 1 / d;
    del = d * c4;
    h2 *= del;
    if (Math.abs(del - 1) < 3e-7)
      break;
  }
  return h2;
}
function gammaln2(x4) {
  var j2 = 0;
  var cof = [
    76.18009172947146,
    -86.5053203294167,
    24.01409824083091,
    -1.231739572450155,
    0.001208650973866179,
    -5395239384953e-18
  ];
  var ser = 1.000000000190015;
  var xx, y4, tmp3;
  tmp3 = (y4 = xx = x4) + 5.5;
  tmp3 -= (xx + 0.5) * Math.log(tmp3);
  for (; j2 < 6; j2++)
    ser += cof[j2] / ++y4;
  return Math.log(2.506628274631 * ser / xx) - tmp3;
}
function qt2(p2, dof) {
  var x4 = ibetainv2(2 * Math.min(p2, 1 - p2), 0.5 * dof, 0.5);
  x4 = Math.sqrt(dof * (1 - x4) / x4);
  return p2 > 0.5 ? x4 : -x4;
}

// ../plot/src/marks/RegressionMark.js
var RegressionMark = class extends Mark2 {
  constructor(source, options) {
    const { ci = 0.95, precision = 4, ...channels } = options;
    super("line", source, channels);
    const update2 = () => this.modelFit ? this.confidenceBand().update() : null;
    this.ci = handleParam(ci, (value) => {
      return this.ci = value, update2();
    });
    this.precision = handleParam(precision, (value) => {
      return this.precision = value, update2();
    });
  }
  query(filter3 = []) {
    const x4 = this.channelField("x").as;
    const y4 = this.channelField("y").as;
    const groupby = Array.from(new Set(
      ["stroke", "z", "fx", "fy"].flatMap((c4) => this.channelField(c4)?.as || [])
    ));
    return Query.from(super.query(filter3)).select({
      intercept: regrIntercept(y4, x4),
      slope: regrSlope(y4, x4),
      n: regrCount(y4, x4),
      ssy: regrSYY(y4, x4),
      ssx: regrSXX(y4, x4),
      xm: regrAvgX(y4, x4),
      x0: castDouble(min(x4).where(isNotNull(y4))),
      x1: castDouble(max(x4).where(isNotNull(y4)))
    }).select(groupby).groupby(groupby);
  }
  queryResult(data) {
    this.modelFit = toDataColumns(data);
    this.lineData = linePoints(this.modelFit);
    return this.confidenceBand();
  }
  confidenceBand() {
    const { ci, modelFit, precision, plot: plot3 } = this;
    const width2 = plot3.innerWidth();
    this.areaData = ci ? areaPoints(modelFit, ci, precision, width2) : null;
    return this;
  }
  plotSpecs() {
    const { lineData, areaData, channels, ci } = this;
    const lcols = lineData.columns;
    const acols = ci ? areaData.columns : {};
    const lopt = { x: lcols.x, y: lcols.y };
    const aopt = { x: acols.x, y1: acols.y1, y2: acols.y2, fillOpacity: 0.1 };
    for (const c4 of channels) {
      switch (c4.channel) {
        case "x":
        case "y":
        case "fill":
          break;
        case "tip":
          aopt.tip = channelOption(c4, acols);
          break;
        case "stroke":
          lopt.stroke = channelOption(c4, lcols);
          aopt.fill = channelOption(c4, acols);
          break;
        case "strokeOpacity":
          lopt.strokeOpacity = channelOption(c4, lcols);
          break;
        case "fillOpacity":
          aopt.fillOpacity = channelOption(c4, acols);
          break;
        default:
          lopt[c4.channel] = channelOption(c4, lcols);
          aopt[c4.channel] = channelOption(c4, acols);
          break;
      }
    }
    return [
      ...ci ? [{ type: "areaY", data: { length: areaData.numRows }, options: aopt }] : [],
      { type: "line", data: { length: lineData.numRows }, options: lopt }
    ];
  }
};
function concat(a3, b2) {
  if (a3.concat)
    return a3.concat(b2);
  const array4 = new a3.constructor(a3.length + b2.length);
  array4.set(a3, 0);
  array4.set(b2, a3.length);
  return array4;
}
function linePoints(fit2) {
  const { x0: x06, x1: x12, xm, intercept, slope, n, ssx, ssy, ...rest } = fit2.columns;
  const predict = (x5, i) => intercept[i] + x5 * slope[i];
  const x4 = concat(x06, x12);
  const y4 = concat(x06.map(predict), x12.map(predict));
  for (const name2 in rest) {
    rest[name2] = concat(rest[name2], rest[name2]);
  }
  return { numRows: x4.length, columns: { x: x4, y: y4, ...rest } };
}
function areaPoints(fit2, ci, precision, width2) {
  const len = fit2.numRows;
  const { x0: x06, x1: x12, xm, intercept, slope, n, ssx, ssy, ...rest } = fit2.columns;
  const other = Object.keys(rest);
  const columns = { x: [], y1: [], y2: [] };
  other.forEach((name2) => columns[name2] = []);
  for (let i = 0; i < len; ++i) {
    const pp = precision * (x12[i] - x06[i]) / width2;
    const t_sy = qt2((1 - ci) / 2, n[i] - 2) * Math.sqrt(ssy[i] / (n[i] - 2));
    range(x06[i], x12[i] - pp / 2, pp).concat(x12[i]).forEach((x4) => {
      const y4 = intercept[i] + x4 * slope[i];
      const ye = t_sy * Math.sqrt(1 / n[i] + (x4 - xm[i]) ** 2 / ssx[i]);
      columns.x.push(x4);
      columns.y1.push(y4 - ye);
      columns.y2.push(y4 + ye);
      other.forEach((name2) => columns[name2].push(rest[name2][i]));
    });
  }
  return { numRows: columns.x.length, columns };
}

// ../plot/src/interactors/util/to-kebab-case.js
function toKebabCase(cc2) {
  const lc = cc2.toLowerCase();
  const n = cc2.length;
  let kc = "";
  for (let i = 0; i < n; ++i) {
    kc += (cc2[i] !== lc[i] ? "-" : "") + lc[i];
  }
  return kc;
}

// ../plot/src/interactors/util/sanitize-styles.js
function sanitizeStyles(styles2) {
  const s2 = {};
  for (const name2 in styles2) {
    s2[toKebabCase(name2)] = styles2[name2];
  }
  return s2;
}

// ../plot/src/interactors/Highlight.js
function configureMark(mark2) {
  const { channels } = mark2;
  const dims = /* @__PURE__ */ new Set();
  let ordered = false;
  let aggregate = false;
  for (const c4 of channels) {
    const { channel, field: field2, as } = c4;
    if (channel === "orderby") {
      ordered = true;
    } else if (field2) {
      if (field2.aggregate) {
        aggregate = true;
      } else {
        if (dims.has(as))
          continue;
        dims.add(as);
      }
    }
  }
  if (!ordered && aggregate && dims.size) {
    mark2.channels.push({ channel: "orderby", value: Array.from(dims) });
  }
  return mark2;
}
var Highlight = class {
  constructor(mark2, {
    selection: selection2,
    channels = {}
  }) {
    this.mark = configureMark(mark2);
    this.selection = selection2;
    const c4 = Object.entries(sanitizeStyles(channels));
    this.channels = c4.length ? c4 : [["opacity", 0.2]];
    this.selection.addEventListener("value", throttle(() => this.update()));
  }
  init(svg) {
    this.svg = svg;
    const values2 = this.values = [];
    const index2 = this.mark.index;
    const nodes = this.nodes = svg.querySelectorAll(`[data-index="${index2}"] > *`);
    const { channels } = this;
    for (let i = 0; i < nodes.length; ++i) {
      const node = nodes[i];
      values2.push(channels.map((c4) => node.getAttribute(c4[0])));
    }
    return this.update();
  }
  async update() {
    const { svg, nodes, channels, values: values2, mark: mark2, selection: selection2 } = this;
    if (!svg)
      return;
    const test = await predicateFunction(mark2, selection2);
    for (let i = 0; i < nodes.length; ++i) {
      const node = nodes[i];
      const base = values2[i];
      const t = test(node.__data__);
      for (let j2 = 0; j2 < channels.length; ++j2) {
        const [attr, value] = channels[j2];
        node.setAttribute(attr, t ? base[j2] : value);
      }
    }
  }
};
async function predicateFunction(mark2, selection2) {
  const pred = selection2?.predicate(mark2);
  if (!pred || pred.length === 0) {
    return () => true;
  }
  const filter3 = mark2.filterBy?.predicate(mark2, true);
  const s2 = { __: and(pred) };
  const q2 = mark2.query(filter3);
  const p2 = q2.groupby().length ? q2.select(s2) : q2.$select(s2);
  const data = await mark2.coordinator.query(p2);
  const v3 = data.getChild?.("__");
  return !(data.numRows || data.length) ? () => false : v3 ? (i) => v3.get(i) : (i) => data[i].__;
}

// ../plot/src/interactors/util/brush.js
function wrap(brush3) {
  const brushOn = brush3.on;
  let enabled = true;
  function silence(callback) {
    enabled = false;
    callback();
    enabled = true;
  }
  brush3.reset = (...args) => {
    silence(() => brush3.clear(...args));
  };
  brush3.moveSilent = (...args) => {
    silence(() => brush3.move(...args));
  };
  brush3.on = (...args) => {
    if (args.length > 1 && args[1]) {
      const callback = args[1];
      args[1] = (...event) => enabled && callback(...event);
    }
    return brushOn(...args);
  };
  return brush3;
}
function brush2() {
  return wrap(brush_default());
}
function brushX2() {
  return wrap(brushX());
}
function brushY2() {
  return wrap(brushY());
}

// ../plot/src/interactors/util/close-to.js
var EPS = 1e-12;
function closeTo(a3, b2) {
  return a3 === b2 || a3 && b2 && Math.abs(a3[0] - b2[0]) < EPS && Math.abs(a3[1] - b2[1]) < EPS || false;
}

// ../plot/src/interactors/util/get-field.js
function getField(mark2, channel) {
  const field2 = mark2.channelField(channel)?.field;
  return field2?.basis || field2;
}

// ../plot/src/interactors/util/invert.js
function invert(value, scale3, pixelSize = 1) {
  return scale3.invert(pixelSize * Math.floor(value / pixelSize));
}

// ../plot/src/interactors/util/patchScreenCTM.js
function patchScreenCTM() {
  const node = this;
  const getScreenCTM = node.getScreenCTM;
  let memo2;
  node.getScreenCTM = () => {
    return node.isConnected ? memo2 = getScreenCTM.call(node) : memo2;
  };
}

// ../plot/src/interactors/Interval1D.js
var Interval1D = class {
  constructor(mark2, {
    channel,
    selection: selection2,
    field: field2 = void 0,
    pixelSize = 1,
    peers = true,
    brush: style2
  }) {
    this.mark = mark2;
    this.channel = channel;
    this.pixelSize = pixelSize || 1;
    this.selection = selection2;
    this.peers = peers;
    this.field = field2 || getField(mark2, channel);
    this.style = style2 && sanitizeStyles(style2);
    this.brush = channel === "y" ? brushY2() : brushX2();
    this.brush.on("brush end", ({ selection: selection3 }) => this.publish(selection3));
  }
  reset() {
    this.value = void 0;
    if (this.g)
      this.brush.reset(this.g);
  }
  activate() {
    this.selection.activate(this.clause(this.value || [0, 1]));
  }
  publish(extent4) {
    let range3 = void 0;
    if (extent4) {
      range3 = extent4.map((v3) => invert(v3, this.scale, this.pixelSize)).sort((a3, b2) => a3 - b2);
    }
    if (!closeTo(range3, this.value)) {
      this.value = range3;
      this.g.call(this.brush.moveSilent, extent4);
      this.selection.update(this.clause(range3));
    }
  }
  clause(value) {
    const { mark: mark2, pixelSize, field: field2, scale: scale3 } = this;
    return {
      source: this,
      schema: { type: "interval", pixelSize, scales: [scale3] },
      clients: this.peers ? mark2.plot.markSet : (/* @__PURE__ */ new Set()).add(mark2),
      value,
      predicate: value ? isBetween(field2, value) : null
    };
  }
  init(svg, root2) {
    const { brush: brush3, channel, style: style2 } = this;
    this.scale = svg.scale(channel);
    const rx = svg.scale("x").range;
    const ry = svg.scale("y").range;
    brush3.extent([[min2(rx), min2(ry)], [max2(rx), max2(ry)]]);
    const facets = select_default2(svg).selectAll('g[aria-label="facet"]');
    root2 = facets.size() ? facets : select_default2(root2 ?? svg);
    this.g = root2.append("g").attr("class", `interval-${channel}`).each(patchScreenCTM).call(brush3).call(brush3.moveSilent, this.value?.map(this.scale.apply));
    if (style2) {
      const brushes = this.g.selectAll("rect.selection");
      for (const name2 in style2) {
        brushes.attr(name2, style2[name2]);
      }
    }
    svg.addEventListener("pointerenter", (evt) => {
      if (!evt.buttons)
        this.activate();
    });
  }
};

// ../plot/src/interactors/Interval2D.js
var asc = (a3, b2) => a3 - b2;
var Interval2D = class {
  constructor(mark2, {
    selection: selection2,
    xfield,
    yfield,
    pixelSize = 1,
    peers = true,
    brush: style2
  }) {
    this.mark = mark2;
    this.pixelSize = pixelSize || 1;
    this.selection = selection2;
    this.peers = peers;
    this.xfield = xfield || getField(mark2, "x");
    this.yfield = yfield || getField(mark2, "y");
    this.style = style2 && sanitizeStyles(style2);
    this.brush = brush2();
    this.brush.on("brush end", ({ selection: selection3 }) => this.publish(selection3));
  }
  reset() {
    this.value = void 0;
    if (this.g)
      this.brush.reset(this.g);
  }
  activate() {
    this.selection.activate(this.clause(this.value || [[0, 1], [0, 1]]));
  }
  publish(extent4) {
    const { value, pixelSize, xscale, yscale } = this;
    let xr = void 0;
    let yr = void 0;
    if (extent4) {
      const [a3, b2] = extent4;
      xr = [a3[0], b2[0]].map((v3) => invert(v3, xscale, pixelSize)).sort(asc);
      yr = [a3[1], b2[1]].map((v3) => invert(v3, yscale, pixelSize)).sort(asc);
    }
    if (!closeTo(xr, value?.[0]) || !closeTo(yr, value?.[1])) {
      this.value = extent4 ? [xr, yr] : void 0;
      this.g.call(this.brush.moveSilent, extent4);
      this.selection.update(this.clause(this.value));
    }
  }
  clause(value) {
    const { mark: mark2, pixelSize, xfield, yfield, xscale, yscale } = this;
    return {
      source: this,
      schema: { type: "interval", pixelSize, scales: [xscale, yscale] },
      clients: this.peers ? mark2.plot.markSet : (/* @__PURE__ */ new Set()).add(mark2),
      value,
      predicate: value ? and(isBetween(xfield, value[0]), isBetween(yfield, value[1])) : null
    };
  }
  init(svg) {
    const { brush: brush3, style: style2 } = this;
    const xscale = this.xscale = svg.scale("x");
    const yscale = this.yscale = svg.scale("y");
    const rx = xscale.range;
    const ry = yscale.range;
    brush3.extent([[min2(rx), min2(ry)], [max2(rx), max2(ry)]]);
    const facets = select_default2(svg).selectAll('g[aria-label="facet"]');
    const root2 = facets.size() ? facets : select_default2(svg);
    this.g = root2.append("g").attr("class", `interval-xy`).each(patchScreenCTM).call(brush3);
    if (style2) {
      const brushes = this.g.selectAll("rect.selection");
      for (const name2 in style2) {
        brushes.attr(name2, style2[name2]);
      }
    }
    if (this.value) {
      const [x12, x22] = this.value[0].map(xscale.apply).sort(asc);
      const [y12, y22] = this.value[1].map(yscale.apply).sort(asc);
      this.g.call(brush3.moveSilent, [[x12, y12], [x22, y22]]);
    }
    svg.addEventListener("pointerenter", (evt) => {
      if (!evt.buttons)
        this.activate();
    });
  }
};

// ../plot/src/interactors/Nearest.js
var Nearest = class {
  constructor(mark2, {
    selection: selection2,
    channel,
    field: field2
  }) {
    this.mark = mark2;
    this.selection = selection2;
    this.clients = (/* @__PURE__ */ new Set()).add(mark2);
    this.channel = channel;
    this.field = field2 || getField(mark2, [channel]);
  }
  clause(value) {
    const { clients, field: field2 } = this;
    const predicate = value ? eq(field2, literal(value)) : null;
    return {
      source: this,
      schema: { type: "point" },
      clients,
      value,
      predicate
    };
  }
  init(svg) {
    const that = this;
    const { mark: mark2, channel, selection: selection2 } = this;
    const { data } = mark2;
    const key = mark2.channelField(channel).as;
    const facets = select_default2(svg).selectAll('g[aria-label="facet"]');
    const root2 = facets.size() ? facets : select_default2(svg);
    const scale3 = svg.scale(channel);
    const param = !isSelection(selection2);
    root2.on("pointerdown pointermove", function(evt) {
      const [x4, y4] = pointer_default(evt, this);
      const z2 = findNearest(data.columns[key], scale3.invert(channel === "x" ? x4 : y4));
      selection2.update(param ? z2 : that.clause(z2));
    });
    if (param)
      return;
    svg.addEventListener("pointerenter", (evt) => {
      if (!evt.buttons)
        this.selection.activate(this.clause(0));
    });
  }
};
function findNearest(values2, value) {
  let dist2 = Infinity;
  let nearest;
  for (let i = 0; i < values2.length; ++i) {
    const delta = Math.abs(values2[i] - value);
    if (delta < dist2) {
      dist2 = delta;
      nearest = values2[i];
    }
  }
  return nearest;
}

// ../plot/src/interactors/PanZoom.js
var asc2 = (a3, b2) => a3 - b2;
var PanZoom = class {
  constructor(mark2, {
    x: x4 = new Selection(),
    y: y4 = new Selection(),
    xfield,
    yfield,
    zoom: zoom2 = true,
    panx = true,
    pany = true
  }) {
    this.mark = mark2;
    this.xsel = x4;
    this.ysel = y4;
    this.xfield = xfield || getField(mark2, "x");
    this.yfield = yfield || getField(mark2, "y");
    this.zoom = extent3(zoom2, [0, Infinity], [1, 1]);
    this.panx = this.xsel && panx;
    this.pany = this.ysel && pany;
    const { plot: plot3 } = mark2;
    if (panx) {
      this.xsel.addEventListener("value", (value) => {
        if (plot3.setAttribute("xDomain", value))
          plot3.update();
      });
    }
    if (pany) {
      this.ysel.addEventListener("value", (value) => {
        if (plot3.setAttribute("yDomain", value))
          plot3.update();
      });
    }
  }
  publish(transform3) {
    if (this.panx) {
      const xdom = rescaleX(transform3, this.xscale);
      this.xsel.update(this.clause(xdom, this.xfield, this.xscale));
    }
    if (this.pany) {
      const ydom = rescaleY(transform3, this.yscale);
      this.ysel.update(this.clause(ydom, this.yfield, this.yscale));
    }
  }
  clause(value, field2, scale3) {
    return {
      source: this,
      schema: { type: "interval", scales: [scale3] },
      clients: this.mark.plot.markSet,
      value,
      predicate: value ? isBetween(field2, value) : null
    };
  }
  init(svg) {
    this.svg = svg;
    if (this.initialized)
      return;
    else
      this.initialized = true;
    const { panx, pany, mark: { plot: { element } }, xsel, ysel } = this;
    this.xscale = svg.scale("x");
    this.yscale = svg.scale("y");
    const rx = this.xscale.range.slice().sort(asc2);
    const ry = this.yscale.range.slice().sort(asc2);
    const tx = extent3(panx, [-Infinity, Infinity], rx);
    const ty = extent3(pany, [-Infinity, Infinity], ry);
    const z2 = zoom_default2().extent([[rx[0], ry[0]], [rx[1], ry[1]]]).scaleExtent(this.zoom).translateExtent([[tx[0], ty[0]], [tx[1], ty[1]]]).on("start", () => {
      this.xscale = this.svg.scale("x");
      this.yscale = this.svg.scale("y");
    }).on("end", () => element.__zoom = new Transform2(1, 0, 0)).on("zoom", ({ transform: transform3 }) => this.publish(transform3));
    select_default2(element).call(z2);
    if (panx || pany) {
      let enter = false;
      element.addEventListener("pointerenter", (evt) => {
        if (enter)
          return;
        else
          enter = true;
        if (evt.buttons)
          return;
        if (panx) {
          const { xscale, xfield } = this;
          xsel.activate(this.clause(xscale.domain, xfield, xscale));
        }
        if (pany) {
          const { yscale, yfield } = this;
          ysel.activate(this.clause(yscale.domain, yfield, yscale));
        }
      });
      element.addEventListener("pointerleave", () => enter = false);
    }
  }
};
function extent3(ext, defaultTrue, defaultFalse) {
  return ext ? Array.isArray(ext) ? ext : defaultTrue : defaultFalse;
}
function rescaleX(transform3, scale3) {
  return scale3.range.map(transform3.invertX, transform3).map(scale3.invert, scale3);
}
function rescaleY(transform3, scale3) {
  return scale3.range.map(transform3.invertY, transform3).map(scale3.invert, scale3);
}

// ../plot/src/interactors/Toggle.js
var Toggle = class {
  /**
   * @param {*} mark The mark to interact with.
   * @param {*} options The interactor options.
   */
  constructor(mark2, {
    selection: selection2,
    channels,
    peers = true
  }) {
    this.value = null;
    this.mark = mark2;
    this.selection = selection2;
    this.peers = peers;
    this.channels = channels.map((c4) => {
      const q2 = c4 === "color" ? ["color", "fill", "stroke"] : c4 === "x" ? ["x", "x1", "x2"] : c4 === "y" ? ["y", "y1", "y2"] : [c4];
      for (let i = 0; i < q2.length; ++i) {
        const f2 = mark2.channelField(q2[i], { exact: true });
        if (f2)
          return {
            field: f2.field?.basis || f2.field,
            as: f2.as
          };
      }
      throw new Error(`Missing channel: ${c4}`);
    });
  }
  clause(value) {
    const { channels, mark: mark2 } = this;
    let predicate = null;
    if (value) {
      const clauses = value.map((vals) => {
        const list = vals.map((v3, i) => {
          return isNotDistinct(channels[i].field, literal(v3));
        });
        return list.length > 1 ? and(list) : list[0];
      });
      predicate = clauses.length > 1 ? or(clauses) : clauses[0];
    }
    return {
      source: this,
      schema: { type: "point" },
      clients: this.peers ? mark2.plot.markSet : (/* @__PURE__ */ new Set()).add(mark2),
      value,
      predicate
    };
  }
  init(svg, selector, accessor) {
    const { mark: mark2, channels, selection: selection2 } = this;
    const { data: { columns = {} } = {} } = mark2;
    accessor ??= (target) => channels.map((c4) => columns[c4.as][target.__data__]);
    selector ??= `[data-index="${mark2.index}"]`;
    const groups2 = new Set(svg.querySelectorAll(selector));
    svg.addEventListener("pointerdown", (evt) => {
      const state = selection2.single ? selection2.value : this.value;
      const target = evt.target;
      let value = null;
      if (isTargetElement(groups2, target)) {
        const point6 = accessor(target);
        if ((evt.shiftKey || evt.metaKey) && state?.length) {
          value = state.filter((s2) => neq2(s2, point6));
          if (value.length === state.length)
            value.push(point6);
        } else if (state?.length === 1 && !neq2(state[0], point6)) {
          value = null;
        } else {
          value = [point6];
        }
      }
      this.value = value;
      if (neqSome(state, value)) {
        selection2.update(this.clause(value));
      }
    });
    svg.addEventListener("pointerenter", (evt) => {
      if (evt.buttons)
        return;
      this.selection.activate(this.clause([this.channels.map(() => 0)]));
    });
  }
};
function isTargetElement(groups2, node) {
  return groups2.has(node) || groups2.has(node.parentNode) || groups2.has(node.parentNode?.parentNode);
}
function neqSome(a3, b2) {
  return a3 == null || b2 == null ? a3 != null || b2 != null : a3.length !== b2.length || a3.some((x4, i) => neq2(x4, b2[i]));
}
function neq2(a3, b2) {
  const n = a3.length;
  if (b2.length !== n)
    return true;
  for (let i = 0; i < n; ++i) {
    if (a3[i] !== b2[i])
      return true;
  }
  return false;
}

// ../plot/src/legend.js
var TOGGLE_SELECTOR = ":scope > div, :scope > span";
var SWATCH = "swatch";
var RAMP = "ramp";
var Legend = class {
  constructor(channel, options) {
    const { as, field: field2, ...rest } = options;
    this.channel = channel;
    this.options = { label: null, ...rest };
    this.type = null;
    this.handler = null;
    this.selection = as;
    this.field = field2;
    this.legend = null;
    this.element = document.createElement("div");
    this.element.setAttribute("class", "legend");
    Object.assign(this.element, { value: this });
  }
  setPlot(plot3) {
    this.plot = plot3;
  }
  init(svg) {
    const el = createLegend(this, svg);
    this.element.replaceChildren(el);
    return this.element;
  }
  update() {
    if (!this.legend)
      return;
    const { value } = this.selection;
    const curr = value && value.length ? new Set(value.map((v3) => v3[0])) : null;
    const nodes = this.legend.querySelectorAll(TOGGLE_SELECTOR);
    for (const node of nodes) {
      const selected = curr ? curr.has(node.__data__) : true;
      node.style.opacity = selected ? 1 : 0.2;
    }
  }
};
function createLegend(legend3, svg) {
  const { channel, options, selection: selection2 } = legend3;
  const scale3 = svg.scale(channel);
  const type2 = scale3.type === "ordinal" ? SWATCH : RAMP;
  const opt = type2 === SWATCH ? options : options.label ? { tickSize: 2, ...options } : { tickSize: 2, marginTop: 1, height: 29, ...options };
  const el = svg.legend(channel, opt);
  legend3.legend = el;
  let interactive = !!selection2;
  if (interactive && type2 === RAMP) {
    const width2 = opt.width ?? 240;
    const spatial = spatialScale(scale3, width2);
    if (spatial) {
      el.scale = function(type3) {
        return type3 === "x" ? { range: [0, width2] } : type3 === "y" ? { range: [-10, 0] } : type3 === channel ? spatial : void 0;
      };
    } else {
      interactive = false;
    }
  }
  if (interactive) {
    const handler = getInteractor(legend3, type2);
    if (type2 === SWATCH) {
      handler.init(el, TOGGLE_SELECTOR, (el2) => [el2.__data__]);
      legend3.update();
    } else {
      handler.init(el, el.querySelector("g:last-of-type"));
    }
  }
  return el;
}
function getInteractor(legend3, type2) {
  const { channel, handler, selection: selection2 } = legend3;
  if (handler)
    return handler;
  const mark2 = interactorMark(legend3);
  if (type2 === SWATCH) {
    legend3.handler = new Toggle(mark2, { selection: selection2, channels: [channel] });
    selection2.addEventListener("value", () => legend3.update());
  } else {
    const brush3 = { fill: "none", stroke: "currentColor" };
    legend3.handler = new Interval1D(mark2, { selection: selection2, channel, brush: brush3 });
  }
  return legend3.handler;
}
function interactorMark(legend3) {
  const { channel, plot: plot3 } = legend3;
  const field2 = legend3.field ?? findField(plot3.marks, channel) ?? "value";
  if (field2) {
    const f2 = { field: field2 };
    return { plot: plot3, channelField: (c4) => channel === c4 ? f2 : void 0 };
  }
}
function findField(marks2, channel) {
  const channels = channel === "color" ? ["fill", "stroke"] : channel === "opacity" ? ["opacity", "fillOpacity", "strokeOpacity"] : null;
  if (channels == null)
    return null;
  for (let i = marks2.length - 1; i > -1; --i) {
    for (const c4 of channels) {
      const field2 = marks2[i].channelField(c4, { exact: true });
      if (field2)
        return field2.field;
    }
  }
  return null;
}
function spatialScale(sourceScale, width2) {
  const { apply: apply2, invert: invert2, interpolate, ...rest } = sourceScale;
  let src = sourceScale.type;
  if (src.startsWith("diverging-"))
    src = src.slice(11);
  let type2;
  switch (src) {
    case "log":
    case "pow":
    case "sqrt":
    case "symlog":
      type2 = src;
      break;
    case "threshold":
    case "quantize":
    case "quantile":
      console.warn(`Legends do not yet support ${src} scales.`);
      return null;
    default:
      type2 = "linear";
  }
  return scale2({ x: { ...rest, type: type2, range: [0, width2] } });
}

// ../plot/src/transforms/bin.js
var EXTENT = /* @__PURE__ */ new Set(["rectY-x", "rectX-y", "rect-x", "rect-y"]);
function bin2(field2, options = { steps: 25 }) {
  const fn = (mark2, channel) => {
    if (EXTENT.has(`${mark2.type}-${channel}`)) {
      return {
        [`${channel}1`]: binField(mark2, channel, field2, options),
        [`${channel}2`]: binField(mark2, channel, field2, { ...options, offset: 1 })
      };
    } else {
      return {
        [channel]: binField(mark2, channel, field2, options)
      };
    }
  };
  fn[Transform] = true;
  return fn;
}
function binField(mark2, channel, column3, options) {
  return {
    column: column3,
    label: column3,
    get stats() {
      return { column: column3, stats: ["min", "max"] };
    },
    get columns() {
      return [column3];
    },
    get basis() {
      return column3;
    },
    toString() {
      const { apply: apply2, sqlApply, sqlInvert } = channelScale(mark2, channel);
      const { min: min5, max: max4 } = mark2.channelField(channel);
      const b2 = bins(apply2(min5), apply2(max4), options);
      const col = sqlApply(column3);
      const base = b2.min === 0 ? col : `(${col} - ${b2.min})`;
      const alpha = `${(b2.max - b2.min) / b2.steps}::DOUBLE`;
      const off = options.offset ? `${options.offset} + ` : "";
      const expr = `${b2.min} + ${alpha} * (${off}FLOOR(${base} / ${alpha}))`;
      return `${sqlInvert(expr)}`;
    }
  };
}
function bins(min5, max4, options) {
  let { steps = 25, minstep = 0, nice: nice3 = true } = options;
  if (nice3 !== false) {
    const span = max4 - min5;
    const maxb = steps;
    const logb = Math.LN10;
    const level = Math.ceil(Math.log(maxb) / logb);
    let step = Math.max(
      minstep,
      Math.pow(10, Math.round(Math.log(span) / logb) - level)
    );
    while (Math.ceil(span / step) > maxb) {
      step *= 10;
    }
    const div = [5, 2];
    let v3;
    for (let i = 0, n = div.length; i < n; ++i) {
      v3 = step / div[i];
      if (v3 >= minstep && span / v3 <= maxb)
        step = v3;
    }
    v3 = Math.log(step);
    const precision = v3 >= 0 ? 0 : ~~(-v3 / logb) + 1;
    const eps2 = Math.pow(10, -precision - 1);
    v3 = Math.floor(min5 / step + eps2) * step;
    min5 = min5 < v3 ? v3 - step : v3;
    max4 = Math.ceil(max4 / step) * step;
    steps = Math.round((max4 - min5) / step);
  }
  return { min: min5, max: max4, steps };
}

// ../inputs/src/Menu.js
var isObject4 = (v3) => {
  return v3 && typeof v3 === "object" && !Array.isArray(v3);
};
var Menu = class extends MosaicClient {
  /**
   * Create a new Menu instance.
   * @param {object} options Options object
   */
  constructor({
    element,
    filterBy,
    from: from2,
    column: column3,
    label: label2 = column3,
    format: format3 = (x4) => x4,
    // TODO
    options,
    value,
    as
  } = {}) {
    super(filterBy);
    this.from = from2;
    this.column = column3;
    this.selection = as;
    this.format = format3;
    this.element = element ?? document.createElement("div");
    this.element.setAttribute("class", "input");
    this.element.value = this;
    const lab3 = document.createElement("label");
    lab3.innerText = label2 || column3;
    this.element.appendChild(lab3);
    this.select = document.createElement("select");
    if (options) {
      this.data = options.map((value2) => isObject4(value2) ? value2 : { value: value2 });
      this.update();
    }
    value = value ?? this.selection?.value ?? this.data?.[0]?.value;
    if (this.selection?.value === void 0)
      this.publish(value);
    this.element.appendChild(this.select);
    if (this.selection) {
      this.select.addEventListener("input", () => {
        this.publish(this.selectedValue() ?? null);
      });
      if (!isSelection(this.selection)) {
        this.selection.addEventListener("value", (value2) => {
          if (value2 !== this.select.value) {
            this.selectedValue(value2);
          }
        });
      }
    }
  }
  selectedValue(value) {
    if (arguments.length === 0) {
      const index2 = this.select.selectedIndex;
      return this.data[index2].value;
    } else {
      const index2 = this.data?.findIndex((opt) => opt.value === value);
      if (index2 >= 0) {
        this.select.selectedIndex = index2;
      } else {
        this.select.value = String(value);
      }
    }
  }
  reset() {
    this.select.selectedIndex = this.from ? 0 : -1;
  }
  publish(value) {
    const { selection: selection2, column: column3 } = this;
    if (isSelection(selection2)) {
      selection2.update({
        source: this,
        schema: { type: "point" },
        value,
        predicate: value !== "" && value !== void 0 ? eq(column3, literal(value)) : null
      });
    } else if (isParam(selection2)) {
      selection2.update(value);
    }
  }
  query(filter3 = []) {
    const { from: from2, column: column3 } = this;
    if (!from2)
      return null;
    return Query.from(from2).select({ value: column3 }).distinct().where(filter3).orderby(column3);
  }
  queryResult(data) {
    this.data = [{ value: "", label: "All" }, ...data];
    return this;
  }
  update() {
    const { data, format: format3, select: select2 } = this;
    select2.replaceChildren();
    for (const { value, label: label2 } of data) {
      const opt = document.createElement("option");
      opt.setAttribute("value", value);
      opt.innerText = label2 ?? format3(value);
      this.select.appendChild(opt);
    }
    if (this.selection) {
      this.selectedValue(this.selection?.value ?? "");
    }
    return this;
  }
};

// ../inputs/src/Search.js
var FUNCTIONS = { contains, prefix, suffix, regexp: regexp_matches };
var _id = 0;
var Search = class extends MosaicClient {
  /**
   * Create a new Search instance.
   * @param {object} options Options object
   */
  constructor({
    element,
    filterBy,
    from: from2,
    column: column3,
    label: label2,
    type: type2 = "contains",
    as
  } = {}) {
    super(filterBy);
    this.id = "search_" + ++_id;
    this.type = type2;
    this.from = from2;
    this.column = column3;
    this.selection = as;
    this.element = element ?? document.createElement("div");
    this.element.setAttribute("class", "input");
    this.element.value = this;
    if (label2) {
      const lab3 = document.createElement("label");
      lab3.setAttribute("for", this.id);
      lab3.innerText = label2;
      this.element.appendChild(lab3);
    }
    this.searchbox = document.createElement("input");
    this.searchbox.setAttribute("id", this.id);
    this.searchbox.setAttribute("type", "text");
    this.searchbox.setAttribute("placeholder", "Query");
    this.element.appendChild(this.searchbox);
    if (this.selection) {
      this.searchbox.addEventListener("input", () => {
        this.publish(this.searchbox.value || null);
      });
      if (!isSelection(this.selection)) {
        this.selection.addEventListener("value", (value) => {
          if (value !== this.searchbox.value) {
            this.searchbox.value = value;
          }
        });
      }
    }
  }
  reset() {
    this.searchbox.value = "";
  }
  publish(value) {
    const { selection: selection2, column: column3, type: type2 } = this;
    if (isSelection(selection2)) {
      selection2.update({
        source: this,
        schema: { type: type2 },
        value,
        predicate: value ? FUNCTIONS[type2](column3, literal(value)) : null
      });
    } else if (isParam(selection2)) {
      selection2.update(value);
    }
  }
  query(filter3 = []) {
    const { from: from2, column: column3 } = this;
    if (!from2)
      return null;
    return Query.from(from2).select({ list: column3 }).distinct().where(filter3);
  }
  queryResult(data) {
    this.data = data;
    return this;
  }
  update() {
    const list = document.createElement("datalist");
    const id2 = `${this.id}_list`;
    list.setAttribute("id", id2);
    for (const d of this.data) {
      const opt = document.createElement("option");
      opt.setAttribute("value", d.list);
      list.append(opt);
    }
    if (this.datalist)
      this.datalist.remove();
    this.element.appendChild(this.datalist = list);
    this.searchbox.setAttribute("list", id2);
    return this;
  }
};

// ../inputs/src/Slider.js
var _id2 = 0;
var Slider = class extends MosaicClient {
  /**
   * Create a new Slider instance.
   * @param {object} options Options object
   */
  constructor({
    element,
    filterBy,
    as,
    min: min5,
    max: max4,
    step,
    from: from2,
    column: column3,
    label: label2 = column3,
    value = as?.value,
    width: width2
  } = {}) {
    super(filterBy);
    this.id = "slider_" + ++_id2;
    this.from = from2;
    this.column = column3 || "value";
    this.selection = as;
    this.min = min5;
    this.max = max4;
    this.step = step;
    this.element = element || document.createElement("div");
    this.element.setAttribute("class", "input");
    this.element.value = this;
    if (label2) {
      const lab3 = document.createElement("label");
      lab3.setAttribute("for", this.id);
      lab3.innerText = label2;
      this.element.appendChild(lab3);
    }
    this.slider = document.createElement("input");
    this.slider.setAttribute("id", this.id);
    this.slider.setAttribute("type", "range");
    if (width2 != null)
      this.slider.style.width = `${+width2}px`;
    if (min5 != null)
      this.slider.setAttribute("min", min5);
    if (max4 != null)
      this.slider.setAttribute("max", max4);
    if (step != null)
      this.slider.setAttribute("step", step);
    if (value != null) {
      this.slider.setAttribute("value", value);
      if (this.selection?.value === void 0)
        this.publish(value);
    }
    this.element.appendChild(this.slider);
    if (this.selection) {
      this.slider.addEventListener("input", () => {
        this.publish(+this.slider.value);
      });
      if (!isSelection(this.selection)) {
        this.selection.addEventListener("value", (value2) => {
          if (value2 !== +this.slider.value) {
            this.slider.value = value2;
          }
        });
      }
    }
  }
  query(filter3 = []) {
    const { from: from2, column: column3 } = this;
    if (!from2 || this.min != null && this.max != null)
      return null;
    return Query.select({ min: min(column3), max: max(column3) }).from(from2).where(filter3);
  }
  queryResult(data) {
    const { min: min5, max: max4 } = Array.from(data)[0];
    if (this.min == null)
      this.slider.setAttribute("min", min5);
    if (this.max == null)
      this.slider.setAttribute("max", max4);
    if (this.step == null)
      this.slider.setAttribute("step", String((max4 - min5) / 500));
    return this;
  }
  publish(value) {
    const { selection: selection2, column: column3 } = this;
    if (isSelection(selection2)) {
      selection2.update({
        source: this,
        schema: { type: "point" },
        value,
        predicate: eq(column3, literal(value))
      });
    } else if (isParam(this.selection)) {
      selection2.update(value);
    }
  }
};

// ../inputs/src/util/format.js
var formatLocaleAuto = localize((locale3) => {
  const formatNumber3 = formatLocaleNumber(locale3);
  return (value) => value == null ? "" : typeof value === "number" ? formatNumber3(value) : value instanceof Date ? formatDate(value) : `${value}`;
});
var formatLocaleNumber = localize((locale3) => {
  return (value) => value === 0 ? "0" : value.toLocaleString(locale3);
});
var formatAuto2 = formatLocaleAuto();
var formatNumber2 = formatLocaleNumber();
function formatDate(date2) {
  return format2(date2, "Invalid Date");
}
function localize(f2) {
  let key = null;
  let value;
  return (locale3 = "en") => locale3 === key ? value : value = f2(key = locale3);
}

// ../inputs/src/Table.js
var _id3 = -1;
var Table3 = class extends MosaicClient {
  /**
   * Create a new Table instance.
   * @param {object} options Options object
   */
  constructor({
    element,
    filterBy,
    from: from2,
    columns = ["*"],
    align: align2 = {},
    format: format3,
    width: width2,
    maxWidth,
    height: height2 = 500,
    rowBatch = 100
  } = {}) {
    super(filterBy);
    this.id = `table-${++_id3}`;
    this.from = from2;
    this.columns = columns;
    this.format = format3;
    this.align = align2;
    this.widths = typeof width2 === "object" ? width2 : {};
    this.offset = 0;
    this.limit = +rowBatch;
    this.pending = false;
    this.sortHeader = null;
    this.sortColumn = null;
    this.sortDesc = false;
    this.element = element || document.createElement("div");
    this.element.setAttribute("id", this.id);
    this.element.value = this;
    if (typeof width2 === "number")
      this.element.style.width = `${width2}px`;
    if (maxWidth)
      this.element.style.maxWidth = `${maxWidth}px`;
    this.element.style.maxHeight = `${height2}px`;
    this.element.style.overflow = "auto";
    let prevScrollTop = -1;
    this.element.addEventListener("scroll", (evt) => {
      const { pending, loaded } = this;
      const { scrollHeight, scrollTop, clientHeight } = evt.target;
      const back = scrollTop < prevScrollTop;
      prevScrollTop = scrollTop;
      if (back || pending || loaded)
        return;
      if (scrollHeight - scrollTop < 2 * clientHeight) {
        this.pending = true;
        this.requestData(this.offset + this.limit);
      }
    });
    this.tbl = document.createElement("table");
    this.element.appendChild(this.tbl);
    this.head = document.createElement("thead");
    this.tbl.appendChild(this.head);
    this.body = document.createElement("tbody");
    this.tbl.appendChild(this.body);
    this.style = document.createElement("style");
    this.element.appendChild(this.style);
  }
  requestData(offset2 = 0) {
    this.offset = offset2;
    const query = this.query(this.filterBy?.predicate(this));
    this.requestQuery(query);
    coordinator().prefetch(query.clone().offset(offset2 + this.limit));
  }
  fields() {
    return this.columns.map((name2) => column(this.from, name2));
  }
  fieldInfo(info) {
    this.schema = info;
    const thead = this.head;
    thead.innerHTML = "";
    const tr = document.createElement("tr");
    for (const { column: column3 } of info) {
      const th = document.createElement("th");
      th.addEventListener("click", (evt) => this.sort(evt, column3));
      th.appendChild(document.createElement("span"));
      th.appendChild(document.createTextNode(column3));
      tr.appendChild(th);
    }
    thead.appendChild(tr);
    this.formats = formatof(this.format, info);
    this.style.innerText = tableCSS(
      this.id,
      alignof(this.align, info),
      widthof(this.widths, info)
    );
    return this;
  }
  query(filter3 = []) {
    const { from: from2, limit, offset: offset2, schema, sortColumn, sortDesc } = this;
    return Query.from(from2).select(schema.map((s2) => s2.column)).where(filter3).orderby(sortColumn ? sortDesc ? desc(sortColumn) : sortColumn : []).limit(limit).offset(offset2);
  }
  queryResult(data) {
    if (!this.pending) {
      this.loaded = false;
      this.body.replaceChildren();
    }
    this.data = data;
    return this;
  }
  update() {
    const { body, formats, data, schema, limit } = this;
    const nf = schema.length;
    let count4 = 0;
    for (const row of data) {
      ++count4;
      const tr = document.createElement("tr");
      for (let i = 0; i < nf; ++i) {
        const value = row[schema[i].column];
        const td = document.createElement("td");
        td.innerText = value == null ? "" : formats[i](value);
        tr.appendChild(td);
      }
      body.appendChild(tr);
    }
    if (count4 < limit) {
      this.loaded = true;
    }
    this.pending = false;
    return this;
  }
  sort(event, column3) {
    if (column3 === this.sortColumn) {
      this.sortDesc = !this.sortDesc;
    } else {
      this.sortColumn = column3;
      this.sortDesc = false;
    }
    const th = event.currentTarget;
    const currentHeader = this.sortHeader;
    if (currentHeader === th && event.metaKey) {
      currentHeader.firstChild.textContent = "";
      this.sortHeader = null;
      this.sortColumn = null;
    } else {
      if (currentHeader)
        currentHeader.firstChild.textContent = "";
      this.sortHeader = th;
      th.firstChild.textContent = this.sortDesc ? "\u25BE" : "\u25B4";
    }
    this.requestData();
  }
};
function formatof(base = {}, schema, locale3) {
  return schema.map(({ column: column3, type: type2 }) => {
    if (column3 in base) {
      return base[column3];
    } else {
      switch (type2) {
        case "number":
          return formatLocaleNumber(locale3);
        case "date":
          return formatDate;
        default:
          return formatLocaleAuto(locale3);
      }
    }
  });
}
function alignof(base = {}, schema) {
  return schema.map(({ column: column3, type: type2 }) => {
    if (column3 in base) {
      return base[column3];
    } else if (type2 === "number") {
      return "right";
    } else {
      return "left";
    }
  });
}
function widthof(base = {}, schema) {
  return schema.map(({ column: column3 }) => base[column3]);
}
function tableCSS(id2, aligns, widths) {
  const styles2 = [];
  aligns.forEach((a3, i) => {
    const w = +widths[i];
    if (a3 !== "left" || w) {
      const align2 = a3 !== "left" ? `text-align:${a3};` : "";
      const width2 = w ? `width:${w}px;max-width:${w}px;` : "";
      styles2.push(`#${id2} tr>:nth-child(${i + 1}) {${align2}${width2}}`);
    }
  });
  return styles2.join(" ");
}

// src/connect.js
function connect(ctx, ...clients) {
  const coord = ctx?.context?.coordinator ?? coordinator();
  for (const client of clients) {
    coord.connect(client);
  }
}

// src/inputs.js
function input2(ctx, InputClass, options) {
  const input3 = new InputClass(options);
  connect(ctx, input3);
  return input3.element;
}
function menu2(options) {
  return input2(this, Menu, options);
}
function search2(options) {
  return input2(this, Search, options);
}
function slider2(options) {
  return input2(this, Slider, options);
}
function table2(options) {
  return input2(this, Table3, options);
}

// src/layout/concat.js
function concat2({ direction = "vertical", wrap: wrap2 = false }, children2) {
  const div = document.createElement("div");
  div.style.display = "flex";
  div.style.flexDirection = direction === "vertical" ? "column" : "row";
  div.style.flexWrap = !wrap2 ? "nowrap" : wrap2 === true ? "wrap" : wrap2;
  div.style.justifyContent = "flex-start";
  div.style.alignItems = "flex-start";
  children2.forEach((child) => div.appendChild(child));
  Object.assign(div, { value: { element: div } });
  return div;
}
function vconcat(...plots) {
  return concat2({ direction: "vertical" }, plots.flat());
}
function hconcat(...plots) {
  return concat2({ direction: "horizontal" }, plots.flat());
}

// src/layout/space.js
function space({ dim = "width", size = 10 }) {
  const span = document.createElement("span");
  span.style.display = "inline-block";
  span.style[dim] = Number.isNaN(+size) ? size : `${size}px`;
  return Object.assign(span, { value: { element: span } });
}
function vspace(size) {
  return space({ dim: "height", size });
}
function hspace(size) {
  return space({ dim: "width", size });
}

// src/plot/attributes.js
var attributes_exports = {};
__export(attributes_exports, {
  align: () => align,
  aspectRatio: () => aspectRatio,
  axis: () => axis2,
  colorBase: () => colorBase,
  colorClamp: () => colorClamp,
  colorConstant: () => colorConstant2,
  colorDomain: () => colorDomain,
  colorExponent: () => colorExponent,
  colorInterpolate: () => colorInterpolate,
  colorLabel: () => colorLabel,
  colorN: () => colorN,
  colorNice: () => colorNice,
  colorPivot: () => colorPivot,
  colorRange: () => colorRange,
  colorReverse: () => colorReverse,
  colorScale: () => colorScale2,
  colorScheme: () => colorScheme2,
  colorSymmetric: () => colorSymmetric,
  colorTickFormat: () => colorTickFormat,
  colorZero: () => colorZero,
  facetGrid: () => facetGrid,
  facetLabel: () => facetLabel,
  facetMargin: () => facetMargin,
  facetMarginBottom: () => facetMarginBottom,
  facetMarginLeft: () => facetMarginLeft,
  facetMarginRight: () => facetMarginRight,
  facetMarginTop: () => facetMarginTop,
  fxAlign: () => fxAlign,
  fxAriaDescription: () => fxAriaDescription,
  fxAriaLabel: () => fxAriaLabel,
  fxAxis: () => fxAxis,
  fxDomain: () => fxDomain,
  fxFontVariant: () => fxFontVariant,
  fxGrid: () => fxGrid,
  fxInset: () => fxInset,
  fxInsetLeft: () => fxInsetLeft,
  fxInsetRight: () => fxInsetRight,
  fxLabel: () => fxLabel,
  fxLabelAnchor: () => fxLabelAnchor,
  fxLabelOffset: () => fxLabelOffset,
  fxLine: () => fxLine,
  fxNice: () => fxNice,
  fxPadding: () => fxPadding,
  fxPaddingInner: () => fxPaddingInner,
  fxPaddingOuter: () => fxPaddingOuter,
  fxRange: () => fxRange,
  fxReverse: () => fxReverse,
  fxRound: () => fxRound,
  fxTickFormat: () => fxTickFormat,
  fxTickPadding: () => fxTickPadding,
  fxTickRotate: () => fxTickRotate,
  fxTickSize: () => fxTickSize,
  fxTickSpacing: () => fxTickSpacing,
  fxTicks: () => fxTicks,
  fyAlign: () => fyAlign,
  fyAriaDescription: () => fyAriaDescription,
  fyAriaLabel: () => fyAriaLabel,
  fyAxis: () => fyAxis,
  fyDomain: () => fyDomain,
  fyFontVariant: () => fyFontVariant,
  fyGrid: () => fyGrid,
  fyInset: () => fyInset,
  fyInsetBottom: () => fyInsetBottom,
  fyInsetTop: () => fyInsetTop,
  fyLabel: () => fyLabel,
  fyLabelAnchor: () => fyLabelAnchor,
  fyLabelOffset: () => fyLabelOffset,
  fyLine: () => fyLine,
  fyNice: () => fyNice,
  fyPadding: () => fyPadding,
  fyPaddingInner: () => fyPaddingInner,
  fyPaddingOuter: () => fyPaddingOuter,
  fyRange: () => fyRange,
  fyReverse: () => fyReverse,
  fyRound: () => fyRound,
  fyTickFormat: () => fyTickFormat,
  fyTickPadding: () => fyTickPadding,
  fyTickRotate: () => fyTickRotate,
  fyTickSize: () => fyTickSize,
  fyTickSpacing: () => fyTickSpacing,
  fyTicks: () => fyTicks,
  grid: () => grid,
  height: () => height,
  inset: () => inset,
  label: () => label,
  lengthBase: () => lengthBase,
  lengthClamp: () => lengthClamp,
  lengthConstant: () => lengthConstant,
  lengthDomain: () => lengthDomain,
  lengthExponent: () => lengthExponent,
  lengthNice: () => lengthNice,
  lengthRange: () => lengthRange,
  lengthScale: () => lengthScale,
  lengthZero: () => lengthZero,
  margin: () => margin,
  marginBottom: () => marginBottom,
  marginLeft: () => marginLeft,
  marginRight: () => marginRight,
  marginTop: () => marginTop,
  margins: () => margins,
  name: () => name,
  opacityBase: () => opacityBase,
  opacityClamp: () => opacityClamp,
  opacityConstant: () => opacityConstant,
  opacityDomain: () => opacityDomain,
  opacityExponent: () => opacityExponent,
  opacityLabel: () => opacityLabel,
  opacityNice: () => opacityNice,
  opacityRange: () => opacityRange,
  opacityReverse: () => opacityReverse,
  opacityScale: () => opacityScale,
  opacityTickFormat: () => opacityTickFormat,
  opacityZero: () => opacityZero,
  padding: () => padding,
  projectionClip: () => projectionClip,
  projectionDomain: () => projectionDomain,
  projectionInset: () => projectionInset,
  projectionInsetBottom: () => projectionInsetBottom,
  projectionInsetLeft: () => projectionInsetLeft,
  projectionInsetRight: () => projectionInsetRight,
  projectionInsetTop: () => projectionInsetTop,
  projectionParallels: () => projectionParallels,
  projectionPrecision: () => projectionPrecision,
  projectionRotate: () => projectionRotate,
  projectionType: () => projectionType,
  rBase: () => rBase,
  rClamp: () => rClamp,
  rConstant: () => rConstant,
  rDomain: () => rDomain,
  rExponent: () => rExponent,
  rNice: () => rNice,
  rRange: () => rRange,
  rScale: () => rScale,
  rZero: () => rZero,
  style: () => style,
  symbolDomain: () => symbolDomain,
  symbolRange: () => symbolRange,
  symbolScale: () => symbolScale,
  width: () => width,
  xAlign: () => xAlign,
  xAriaDescription: () => xAriaDescription,
  xAriaLabel: () => xAriaLabel,
  xAxis: () => xAxis,
  xBase: () => xBase,
  xClamp: () => xClamp,
  xConstant: () => xConstant,
  xDomain: () => xDomain,
  xExponent: () => xExponent,
  xFontVariant: () => xFontVariant,
  xGrid: () => xGrid,
  xInset: () => xInset,
  xInsetLeft: () => xInsetLeft,
  xInsetRight: () => xInsetRight,
  xLabel: () => xLabel,
  xLabelAnchor: () => xLabelAnchor,
  xLabelOffset: () => xLabelOffset,
  xLine: () => xLine,
  xNice: () => xNice,
  xPadding: () => xPadding,
  xPaddingInner: () => xPaddingInner,
  xPaddingOuter: () => xPaddingOuter,
  xRange: () => xRange,
  xReverse: () => xReverse,
  xRound: () => xRound,
  xScale: () => xScale,
  xTickFormat: () => xTickFormat,
  xTickPadding: () => xTickPadding,
  xTickRotate: () => xTickRotate,
  xTickSize: () => xTickSize,
  xTickSpacing: () => xTickSpacing,
  xTicks: () => xTicks,
  xZero: () => xZero,
  xyDomain: () => xyDomain,
  yAlign: () => yAlign,
  yAriaDescription: () => yAriaDescription,
  yAriaLabel: () => yAriaLabel,
  yAxis: () => yAxis,
  yBase: () => yBase,
  yClamp: () => yClamp,
  yConstant: () => yConstant,
  yDomain: () => yDomain,
  yExponent: () => yExponent,
  yFontVariant: () => yFontVariant,
  yGrid: () => yGrid,
  yInset: () => yInset,
  yInsetBottom: () => yInsetBottom,
  yInsetTop: () => yInsetTop,
  yLabel: () => yLabel,
  yLabelAnchor: () => yLabelAnchor,
  yLabelOffset: () => yLabelOffset,
  yLine: () => yLine,
  yNice: () => yNice,
  yPadding: () => yPadding,
  yPaddingInner: () => yPaddingInner,
  yPaddingOuter: () => yPaddingOuter,
  yRange: () => yRange,
  yReverse: () => yReverse,
  yRound: () => yRound,
  yScale: () => yScale,
  yTickFormat: () => yTickFormat,
  yTickPadding: () => yTickPadding,
  yTickRotate: () => yTickRotate,
  yTickSize: () => yTickSize,
  yTickSpacing: () => yTickSpacing,
  yTicks: () => yTicks,
  yZero: () => yZero
});

// src/plot/named-plots.js
var NamedPlots = class extends Map {
  request(name2, callback) {
    if (this.has(name2)) {
      callback(this.get(name2));
    } else {
      const waiting = this.waiting || (this.waiting = /* @__PURE__ */ new Map());
      const list = waiting.get(name2) || [];
      waiting.set(name2, list.concat(callback));
    }
  }
  set(name2, plot3) {
    if (this.has(name2)) {
      console.warn(`Overwriting named plot "${name2}".`);
    }
    const { waiting } = this;
    if (waiting?.has(name2)) {
      waiting.get(name2).forEach((fn) => fn(plot3));
      waiting.delete(name2);
    }
    return super.set(name2, plot3);
  }
  clear() {
    this.waiting?.clear();
    return super.clear();
  }
};
var namedPlots = new NamedPlots();
function requestNamedPlot(ctx, name2, callback) {
  const map4 = ctx?.context?.namedPlots ?? namedPlots;
  map4.request(name2, callback);
}
function setNamedPlot(ctx, name2, plot3) {
  const map4 = ctx?.context?.namedPlots ?? namedPlots;
  map4.set(name2, plot3);
}

// src/plot/attributes.js
function name(name2) {
  return (plot3) => setNamedPlot(this, name2, plot3);
}
function setAttribute(plot3, name2, value) {
  if (isParam(value)) {
    value.addEventListener("value", (value2) => {
      plot3.setAttribute(name2, value2);
      plot3.update();
    });
    if (value.value !== void 0) {
      plot3.setAttribute(name2, value.value);
    }
  } else {
    plot3.setAttribute(name2, value);
  }
}
function attribute(name2, value) {
  return (plot3) => {
    setAttribute(plot3, name2, value);
  };
}
function attributes(values2) {
  return (plot3) => {
    for (const [name2, value] of Object.entries(values2)) {
      setAttribute(plot3, name2, value);
    }
  };
}
function margins(object) {
  const { top: top2, bottom: bottom2, left: left2, right: right2 } = object;
  const attr = {};
  if (top2 !== void 0)
    attr.marginTop = top2;
  if (bottom2 !== void 0)
    attr.marginBottom = bottom2;
  if (left2 !== void 0)
    attr.marginLeft = left2;
  if (right2 !== void 0)
    attr.marginRight = right2;
  return attributes(attr);
}
function margin(value) {
  return attributes({
    marginTop: value,
    marginBottom: value,
    marginLeft: value,
    marginRight: value
  });
}
function xyDomain(value) {
  return attributes({ xDomain: value, yDomain: value });
}
var attrf = (name2) => (value) => attribute(name2, value);
var style = attrf("style");
var width = attrf("width");
var height = attrf("height");
var marginLeft = attrf("marginLeft");
var marginRight = attrf("marginRight");
var marginTop = attrf("marginTop");
var marginBottom = attrf("marginBottom");
var align = attrf("align");
var aspectRatio = attrf("aspectRatio");
var axis2 = attrf("axis");
var inset = attrf("inset");
var grid = attrf("grid");
var label = attrf("label");
var padding = attrf("padding");
var xScale = attrf("xScale");
var xDomain = attrf("xDomain");
var xRange = attrf("xRange");
var xNice = attrf("xNice");
var xInset = attrf("xInset");
var xInsetLeft = attrf("xInsetLeft");
var xInsetRight = attrf("xInsetRight");
var xClamp = attrf("xClamp");
var xRound = attrf("xRound");
var xAlign = attrf("xAlign");
var xPadding = attrf("xPadding");
var xPaddingInner = attrf("xPaddingInner");
var xPaddingOuter = attrf("xPaddingOuter");
var xAxis = attrf("xAxis");
var xTicks = attrf("xTicks");
var xTickSize = attrf("xTickSize");
var xTickSpacing = attrf("xTickSpacing");
var xTickPadding = attrf("xTickPadding");
var xTickFormat = attrf("xTickFormat");
var xTickRotate = attrf("xTickRotate");
var xGrid = attrf("xGrid");
var xLine = attrf("xLine");
var xLabel = attrf("xLabel");
var xLabelAnchor = attrf("xLabelAnchor");
var xLabelOffset = attrf("xLabelOffset");
var xFontVariant = attrf("xFontVariant");
var xAriaLabel = attrf("xAriaLabel");
var xAriaDescription = attrf("xAriaDescription");
var xReverse = attrf("xReverse");
var xZero = attrf("xZero");
var xBase = attrf("xBase");
var xExponent = attrf("xExponent");
var xConstant = attrf("xConstant");
var yScale = attrf("yScale");
var yDomain = attrf("yDomain");
var yRange = attrf("yRange");
var yNice = attrf("yNice");
var yInset = attrf("yInset");
var yInsetTop = attrf("yInsetTop");
var yInsetBottom = attrf("yInsetBottom");
var yClamp = attrf("yClamp");
var yRound = attrf("yRound");
var yAlign = attrf("yAlign");
var yPadding = attrf("yPadding");
var yPaddingInner = attrf("yPaddingInner");
var yPaddingOuter = attrf("yPaddingOuter");
var yAxis = attrf("yAxis");
var yTicks = attrf("yTicks");
var yTickSize = attrf("yTickSize");
var yTickSpacing = attrf("yTickSpacing");
var yTickPadding = attrf("yTickPadding");
var yTickFormat = attrf("yTickFormat");
var yTickRotate = attrf("yTickRotate");
var yGrid = attrf("yGrid");
var yLine = attrf("yLine");
var yLabel = attrf("yLabel");
var yLabelAnchor = attrf("yLabelAnchor");
var yLabelOffset = attrf("yLabelOffset");
var yFontVariant = attrf("yFontVariant");
var yAriaLabel = attrf("yAriaLabel");
var yAriaDescription = attrf("yAriaDescription");
var yReverse = attrf("yReverse");
var yZero = attrf("yZero");
var yBase = attrf("yBase");
var yExponent = attrf("yExponent");
var yConstant = attrf("yConstant");
var facetMargin = attrf("facetMargin");
var facetMarginTop = attrf("facetMarginTop");
var facetMarginBottom = attrf("facetMarginBottom");
var facetMarginLeft = attrf("facetMarginLeft");
var facetMarginRight = attrf("facetMarginRight");
var facetGrid = attrf("facetGrid");
var facetLabel = attrf("facetLabel");
var fxDomain = attrf("fxDomain");
var fxRange = attrf("fxRange");
var fxNice = attrf("fxNice");
var fxInset = attrf("fxInset");
var fxInsetLeft = attrf("fxInsetLeft");
var fxInsetRight = attrf("fxInsetRight");
var fxRound = attrf("fxRound");
var fxAlign = attrf("fxAlign");
var fxPadding = attrf("fxPadding");
var fxPaddingInner = attrf("fxPaddingInner");
var fxPaddingOuter = attrf("fxPaddingOuter");
var fxAxis = attrf("fxAxis");
var fxTicks = attrf("fxTicks");
var fxTickSize = attrf("fxTickSize");
var fxTickSpacing = attrf("fxTickSpacing");
var fxTickPadding = attrf("fxTickPadding");
var fxTickFormat = attrf("fxTickFormat");
var fxTickRotate = attrf("fxTickRotate");
var fxGrid = attrf("fxGrid");
var fxLine = attrf("fxLine");
var fxLabel = attrf("fxLabel");
var fxLabelAnchor = attrf("fxLabelAnchor");
var fxLabelOffset = attrf("fxLabelOffset");
var fxFontVariant = attrf("fxFontVariant");
var fxAriaLabel = attrf("fxAriaLabel");
var fxAriaDescription = attrf("fxAriaDescription");
var fxReverse = attrf("fxReverse");
var fyDomain = attrf("fyDomain");
var fyRange = attrf("fyRange");
var fyNice = attrf("fyNice");
var fyInset = attrf("fyInset");
var fyInsetTop = attrf("fyInsetTop");
var fyInsetBottom = attrf("fyInsetBottom");
var fyRound = attrf("fyRound");
var fyAlign = attrf("fyAlign");
var fyPadding = attrf("fyPadding");
var fyPaddingInner = attrf("fyPaddingInner");
var fyPaddingOuter = attrf("fyPaddingOuter");
var fyAxis = attrf("fyAxis");
var fyTicks = attrf("fyTicks");
var fyTickSize = attrf("fyTickSize");
var fyTickSpacing = attrf("fyTickSpacing");
var fyTickPadding = attrf("fyTickPadding");
var fyTickFormat = attrf("fyTickFormat");
var fyTickRotate = attrf("fyTickRotate");
var fyGrid = attrf("fyGrid");
var fyLine = attrf("fyLine");
var fyLabel = attrf("fyLabel");
var fyLabelAnchor = attrf("fyLabelAnchor");
var fyLabelOffset = attrf("fyLabelOffset");
var fyFontVariant = attrf("fyFontVariant");
var fyAriaLabel = attrf("fyAriaLabel");
var fyAriaDescription = attrf("fyAriaDescription");
var fyReverse = attrf("fyReverse");
var colorScale2 = attrf("colorScale");
var colorDomain = attrf("colorDomain");
var colorRange = attrf("colorRange");
var colorClamp = attrf("colorClamp");
var colorN = attrf("colorN");
var colorNice = attrf("colorNice");
var colorScheme2 = attrf("colorScheme");
var colorInterpolate = attrf("colorInterpolate");
var colorPivot = attrf("colorPivot");
var colorSymmetric = attrf("colorSymmetric");
var colorLabel = attrf("colorLabel");
var colorReverse = attrf("colorReverse");
var colorZero = attrf("colorZero");
var colorTickFormat = attrf("colorTickFormat");
var colorBase = attrf("colorBase");
var colorExponent = attrf("colorExponent");
var colorConstant2 = attrf("colorConstant");
var opacityScale = attrf("opacityScale");
var opacityDomain = attrf("opacityDomain");
var opacityRange = attrf("opacityRange");
var opacityClamp = attrf("opacityClamp");
var opacityNice = attrf("opacityNice");
var opacityLabel = attrf("opacityLabel");
var opacityReverse = attrf("opacityReverse");
var opacityZero = attrf("opacityZero");
var opacityTickFormat = attrf("opacityTickFormat");
var opacityBase = attrf("opacityBase");
var opacityExponent = attrf("opacityExponent");
var opacityConstant = attrf("opacityConstant");
var symbolScale = attrf("symbolScale");
var symbolDomain = attrf("symbolDomain");
var symbolRange = attrf("symbolRange");
var rScale = attrf("rScale");
var rDomain = attrf("rDomain");
var rRange = attrf("rRange");
var rClamp = attrf("rClamp");
var rNice = attrf("rNice");
var rZero = attrf("rZero");
var rBase = attrf("rBase");
var rExponent = attrf("rExponent");
var rConstant = attrf("rConstant");
var lengthScale = attrf("lengthScale");
var lengthDomain = attrf("lengthDomain");
var lengthRange = attrf("lengthRange");
var lengthClamp = attrf("lengthClamp");
var lengthNice = attrf("lengthNice");
var lengthZero = attrf("lengthZero");
var lengthBase = attrf("lengthBase");
var lengthExponent = attrf("lengthExponent");
var lengthConstant = attrf("lengthConstant");
var projectionType = attrf("projectionType");
var projectionParallels = attrf("projectionParallels");
var projectionPrecision = attrf("projectionPrecision");
var projectionRotate = attrf("projectionRotate");
var projectionDomain = attrf("projectionDomain");
var projectionInset = attrf("projectionInset");
var projectionInsetLeft = attrf("projectionInsetLeft");
var projectionInsetRight = attrf("projectionInsetRight");
var projectionInsetTop = attrf("projectionInsetTop");
var projectionInsetBottom = attrf("projectionInsetBottom");
var projectionClip = attrf("projectionClip");

// src/plot/data.js
function from(table3, options) {
  return { table: table3, options };
}

// src/plot/marks.js
var marks_exports = {};
__export(marks_exports, {
  area: () => area2,
  areaX: () => areaX2,
  areaY: () => areaY2,
  arrow: () => arrow2,
  axisFx: () => axisFx2,
  axisFy: () => axisFy2,
  axisX: () => axisX2,
  axisY: () => axisY2,
  barX: () => barX2,
  barY: () => barY2,
  cell: () => cell2,
  cellX: () => cellX2,
  cellY: () => cellY2,
  circle: () => circle2,
  contour: () => contour2,
  delaunayLink: () => delaunayLink2,
  delaunayMesh: () => delaunayMesh2,
  denseLine: () => denseLine,
  density: () => density2,
  densityX: () => densityX,
  densityY: () => densityY,
  dot: () => dot2,
  dotX: () => dotX2,
  dotY: () => dotY2,
  frame: () => frame3,
  geo: () => geo2,
  graticule: () => graticule3,
  gridFx: () => gridFx2,
  gridFy: () => gridFy2,
  gridX: () => gridX2,
  gridY: () => gridY2,
  heatmap: () => heatmap,
  hexagon: () => hexagon2,
  hexbin: () => hexbin2,
  hexgrid: () => hexgrid2,
  hull: () => hull2,
  image: () => image2,
  line: () => line2,
  lineX: () => lineX2,
  lineY: () => lineY2,
  link: () => link3,
  raster: () => raster2,
  rasterTile: () => rasterTile,
  rect: () => rect2,
  rectX: () => rectX2,
  rectY: () => rectY2,
  regressionY: () => regressionY,
  ruleX: () => ruleX2,
  ruleY: () => ruleY2,
  sphere: () => sphere2,
  spike: () => spike2,
  text: () => text2,
  textX: () => textX2,
  textY: () => textY2,
  tickX: () => tickX2,
  tickY: () => tickY2,
  vector: () => vector2,
  vectorX: () => vectorX2,
  vectorY: () => vectorY2,
  voronoi: () => voronoi2,
  voronoiMesh: () => voronoiMesh2
});
var decorators = /* @__PURE__ */ new Set([
  "frame",
  "axisX",
  "axisY",
  "axisFx",
  "axisFy",
  "gridX",
  "gridY",
  "gridFx",
  "gridFy",
  "hexgrid",
  "graticule",
  "sphere"
]);
function mark(type2, data, channels = {}) {
  if (arguments.length === 2 && !Array.isArray(data)) {
    channels = data;
    data = decorators.has(type2) ? null : [{}];
  }
  const MarkClass = type2.startsWith("area") || type2.startsWith("line") ? ConnectedMark : Mark2;
  return explicitType(MarkClass, type2, data, channels);
}
function explicitType(MarkClass, type2, data, channels) {
  return (plot3) => {
    plot3.addMark(new MarkClass(type2, data, channels));
  };
}
function implicitType(MarkClass, data, channels) {
  return (plot3) => {
    plot3.addMark(new MarkClass(data, channels));
  };
}
var area2 = (...args) => mark("area", ...args);
var areaX2 = (...args) => mark("areaX", ...args);
var areaY2 = (...args) => mark("areaY", ...args);
var line2 = (...args) => mark("line", ...args);
var lineX2 = (...args) => mark("lineX", ...args);
var lineY2 = (...args) => mark("lineY", ...args);
var barX2 = (...args) => mark("barX", ...args);
var barY2 = (...args) => mark("barY", ...args);
var cell2 = (...args) => mark("cell", ...args);
var cellX2 = (...args) => mark("cellX", ...args);
var cellY2 = (...args) => mark("cellY", ...args);
var rect2 = (...args) => mark("rect", ...args);
var rectX2 = (...args) => mark("rectX", ...args);
var rectY2 = (...args) => mark("rectY", ...args);
var dot2 = (...args) => mark("dot", ...args);
var dotX2 = (...args) => mark("dotX", ...args);
var dotY2 = (...args) => mark("dotY", ...args);
var circle2 = (...args) => mark("circle", ...args);
var hexagon2 = (...args) => mark("hexagon", ...args);
var text2 = (...args) => mark("text", ...args);
var textX2 = (...args) => mark("textX", ...args);
var textY2 = (...args) => mark("textY", ...args);
var ruleX2 = (...args) => mark("ruleX", ...args);
var ruleY2 = (...args) => mark("ruleY", ...args);
var tickX2 = (...args) => mark("tickX", ...args);
var tickY2 = (...args) => mark("tickY", ...args);
var vector2 = (...args) => mark("vector", ...args);
var vectorX2 = (...args) => mark("vectoX", ...args);
var vectorY2 = (...args) => mark("vectorY", ...args);
var spike2 = (...args) => mark("spike", ...args);
var image2 = (...args) => mark("image", ...args);
var densityX = (...args) => explicitType(Density1DMark, "areaX", ...args);
var densityY = (...args) => explicitType(Density1DMark, "areaY", ...args);
var density2 = (...args) => implicitType(Density2DMark, ...args);
var denseLine = (...args) => implicitType(DenseLineMark, ...args);
var contour2 = (...args) => implicitType(ContourMark, ...args);
var heatmap = (...args) => implicitType(HeatmapMark, ...args);
var raster2 = (...args) => implicitType(RasterMark, ...args);
var rasterTile = (...args) => implicitType(RasterTileMark, ...args);
var hexbin2 = (...args) => implicitType(HexbinMark, ...args);
var hexgrid2 = (...args) => mark("hexgrid", ...args);
var regressionY = (...args) => implicitType(RegressionMark, ...args);
var voronoi2 = (...args) => mark("voronoi", ...args);
var voronoiMesh2 = (...args) => mark("voronoiMesh", ...args);
var delaunayLink2 = (...args) => mark("delaunayLink", ...args);
var delaunayMesh2 = (...args) => mark("delaunayMesh", ...args);
var hull2 = (...args) => mark("hull", ...args);
var arrow2 = (...args) => mark("arrow", ...args);
var link3 = (...args) => mark("link", ...args);
var frame3 = (...args) => mark("frame", ...args);
var axisX2 = (...args) => mark("axisX", ...args);
var axisY2 = (...args) => mark("axisY", ...args);
var axisFx2 = (...args) => mark("axisFx", ...args);
var axisFy2 = (...args) => mark("axisFy", ...args);
var gridX2 = (...args) => mark("gridX", ...args);
var gridY2 = (...args) => mark("gridY", ...args);
var gridFx2 = (...args) => mark("gridFx", ...args);
var gridFy2 = (...args) => mark("gridFy", ...args);
var geo2 = (...args) => implicitType(GeoMark, ...args);
var sphere2 = (...args) => mark("sphere", ...args);
var graticule3 = (...args) => mark("graticule", ...args);

// src/plot/interactors.js
var interactors_exports = {};
__export(interactors_exports, {
  highlight: () => highlight,
  intervalX: () => intervalX,
  intervalXY: () => intervalXY,
  intervalY: () => intervalY,
  nearestX: () => nearestX,
  nearestY: () => nearestY,
  pan: () => pan,
  panX: () => panX,
  panY: () => panY,
  panZoom: () => panZoom,
  panZoomX: () => panZoomX,
  panZoomY: () => panZoomY,
  toggle: () => toggle,
  toggleColor: () => toggleColor,
  toggleX: () => toggleX,
  toggleY: () => toggleY
});
function interactor(InteractorClass, options) {
  return (plot3) => {
    const mark2 = plot3.marks[plot3.marks.length - 1];
    plot3.addInteractor(new InteractorClass(mark2, options));
  };
}
function highlight({ by, ...channels }) {
  return interactor(Highlight, { selection: by, channels });
}
function toggle({ as, ...rest }) {
  return interactor(Toggle, { ...rest, selection: as });
}
function toggleX(options) {
  return toggle({ ...options, channels: ["x"] });
}
function toggleY(options) {
  return toggle({ ...options, channels: ["y"] });
}
function toggleColor(options) {
  return toggle({ ...options, channels: ["color"] });
}
function nearestX({ as, ...rest }) {
  return interactor(Nearest, { ...rest, selection: as, channel: "x" });
}
function nearestY({ as, ...rest }) {
  return interactor(Nearest, { ...rest, selection: as, channel: "y" });
}
function intervalX({ as, ...rest }) {
  return interactor(Interval1D, { ...rest, selection: as, channel: "x" });
}
function intervalY({ as, ...rest }) {
  return interactor(Interval1D, { ...rest, selection: as, channel: "y" });
}
function intervalXY({ as, ...rest }) {
  return interactor(Interval2D, { ...rest, selection: as });
}
function zoom(options) {
  return interactor(PanZoom, options);
}
function pan(options = {}) {
  return zoom({ ...options, zoom: false });
}
function panX(options = {}) {
  return zoom({ ...options, zoom: false, pany: false });
}
function panY(options = {}) {
  return zoom({ ...options, zoom: false, panx: false });
}
function panZoom(options = {}) {
  return zoom(options);
}
function panZoomX(options = {}) {
  return zoom({ ...options, pany: false });
}
function panZoomY(options = {}) {
  return zoom({ ...options, panx: false });
}

// src/plot/legends.js
var legends_exports = {};
__export(legends_exports, {
  colorLegend: () => colorLegend,
  opacityLegend: () => opacityLegend,
  symbolLegend: () => symbolLegend
});
function legend2(channel, options = {}) {
  if (options.for) {
    const { for: maybePlot, ...rest } = options;
    const legend3 = new Legend(channel, rest);
    const type2 = typeof maybePlot;
    const add = (plot3) => plot3.addLegend(legend3, false);
    if (type2 === "string") {
      requestNamedPlot(this, maybePlot, add);
    } else if (maybePlot.value) {
      add(maybePlot.value);
    }
    return legend3.element;
  } else {
    return (plot3) => plot3.addLegend(new Legend(channel, options));
  }
}
function colorLegend(options) {
  return legend2.call(this, "color", options);
}
function opacityLegend(options) {
  return legend2.call(this, "opacity", options);
}
function symbolLegend(options) {
  return legend2.call(this, "symbol", options);
}

// src/plot/plot.js
function plot2(...directives) {
  const p2 = new Plot();
  directives.flat().forEach((dir) => dir(p2));
  connect(this, ...p2.marks);
  p2.update();
  return p2.element;
}

// src/context.js
function createAPIContext({
  coordinator: coordinator2 = coordinator(),
  namedPlots: namedPlots2 = new NamedPlots(),
  extensions = null,
  ...options
} = {}) {
  return {
    ...api_exports,
    ...extensions,
    context: {
      coordinator: coordinator2,
      namedPlots: namedPlots2,
      ...options
    }
  };
}
export {
  Coordinator,
  Fixed,
  MosaicClient,
  Param,
  Query,
  Selection,
  agg,
  align,
  and,
  area2 as area,
  areaX2 as areaX,
  areaY2 as areaY,
  argmax,
  argmin,
  arrayAgg,
  arrow2 as arrow,
  aspectRatio,
  attributes_exports as attributeDirectives,
  avg,
  axis2 as axis,
  axisFx2 as axisFx,
  axisFy2 as axisFy,
  axisX2 as axisX,
  axisY2 as axisY,
  barX2 as barX,
  barY2 as barY,
  bin2 as bin,
  cast,
  castDouble,
  castInteger,
  cell2 as cell,
  cellX2 as cellX,
  cellY2 as cellY,
  centroid,
  centroidX,
  centroidY,
  circle2 as circle,
  colorBase,
  colorClamp,
  colorConstant2 as colorConstant,
  colorDomain,
  colorExponent,
  colorInterpolate,
  colorLabel,
  colorLegend,
  colorN,
  colorNice,
  colorPivot,
  colorRange,
  colorReverse,
  colorScale2 as colorScale,
  colorScheme2 as colorScheme,
  colorSymmetric,
  colorTickFormat,
  colorZero,
  column,
  connect,
  contour2 as contour,
  coordinator,
  corr,
  count,
  covarPop,
  create,
  createAPIContext,
  cume_dist,
  dateDay,
  dateMonth,
  dateMonthDay,
  delaunayLink2 as delaunayLink,
  delaunayMesh2 as delaunayMesh,
  denseLine,
  dense_rank,
  density2 as density,
  densityX,
  densityY,
  dot2 as dot,
  dotX2 as dotX,
  dotY2 as dotY,
  entropy,
  eq,
  facetGrid,
  facetLabel,
  facetMargin,
  facetMarginBottom,
  facetMarginLeft,
  facetMarginRight,
  facetMarginTop,
  first,
  first_value,
  frame3 as frame,
  from,
  fxAlign,
  fxAriaDescription,
  fxAriaLabel,
  fxAxis,
  fxDomain,
  fxFontVariant,
  fxGrid,
  fxInset,
  fxInsetLeft,
  fxInsetRight,
  fxLabel,
  fxLabelAnchor,
  fxLabelOffset,
  fxLine,
  fxNice,
  fxPadding,
  fxPaddingInner,
  fxPaddingOuter,
  fxRange,
  fxReverse,
  fxRound,
  fxTickFormat,
  fxTickPadding,
  fxTickRotate,
  fxTickSize,
  fxTickSpacing,
  fxTicks,
  fyAlign,
  fyAriaDescription,
  fyAriaLabel,
  fyAxis,
  fyDomain,
  fyFontVariant,
  fyGrid,
  fyInset,
  fyInsetBottom,
  fyInsetTop,
  fyLabel,
  fyLabelAnchor,
  fyLabelOffset,
  fyLine,
  fyNice,
  fyPadding,
  fyPaddingInner,
  fyPaddingOuter,
  fyRange,
  fyReverse,
  fyRound,
  fyTickFormat,
  fyTickPadding,
  fyTickRotate,
  fyTickSize,
  fyTickSpacing,
  fyTicks,
  geo2 as geo,
  geojson,
  graticule3 as graticule,
  grid,
  gridFx2 as gridFx,
  gridFy2 as gridFy,
  gridX2 as gridX,
  gridY2 as gridY,
  gt,
  gte,
  hconcat,
  heatmap,
  height,
  hexagon2 as hexagon,
  hexbin2 as hexbin,
  hexgrid2 as hexgrid,
  highlight,
  hspace,
  hull2 as hull,
  image2 as image,
  inset,
  interactors_exports as interactorDirectives,
  intervalX,
  intervalXY,
  intervalY,
  isBetween,
  isDistinct,
  isNotBetween,
  isNotDistinct,
  isNotNull,
  isNull,
  kurtosis,
  label,
  lag,
  last,
  last_value,
  lead,
  legends_exports as legendDirectives,
  lengthBase,
  lengthClamp,
  lengthConstant,
  lengthDomain,
  lengthExponent,
  lengthNice,
  lengthRange,
  lengthScale,
  lengthZero,
  line2 as line,
  lineX2 as lineX,
  lineY2 as lineY,
  link3 as link,
  literal,
  loadCSV,
  loadExtension,
  loadJSON,
  loadObjects,
  loadParquet,
  loadSpatial,
  lt,
  lte,
  mad,
  margin,
  marginBottom,
  marginLeft,
  marginRight,
  marginTop,
  margins,
  marks_exports as markDirectives,
  max,
  median,
  menu2 as menu,
  min,
  mode,
  name,
  namedPlots,
  nearestX,
  nearestY,
  neq,
  not,
  nth_value,
  ntile,
  opacityBase,
  opacityClamp,
  opacityConstant,
  opacityDomain,
  opacityExponent,
  opacityLabel,
  opacityLegend,
  opacityNice,
  opacityRange,
  opacityReverse,
  opacityScale,
  opacityTickFormat,
  opacityZero,
  or,
  padding,
  pan,
  panX,
  panY,
  panZoom,
  panZoomX,
  panZoomY,
  percent_rank,
  plot2 as plot,
  product,
  projectionClip,
  projectionDomain,
  projectionInset,
  projectionInsetBottom,
  projectionInsetLeft,
  projectionInsetRight,
  projectionInsetTop,
  projectionParallels,
  projectionPrecision,
  projectionRotate,
  projectionType,
  quantile,
  rBase,
  rClamp,
  rConstant,
  rDomain,
  rExponent,
  rNice,
  rRange,
  rScale,
  rZero,
  rank,
  raster2 as raster,
  rasterTile,
  rect2 as rect,
  rectX2 as rectX,
  rectY2 as rectY,
  regressionY,
  requestNamedPlot,
  restConnector,
  row_number,
  ruleX2 as ruleX,
  ruleY2 as ruleY,
  search2 as search,
  skewness,
  slider2 as slider,
  socketConnector,
  sphere2 as sphere,
  spike2 as spike,
  sql,
  stddev,
  stddevPop,
  stringAgg,
  style,
  sum,
  symbolDomain,
  symbolLegend,
  symbolRange,
  symbolScale,
  table2 as table,
  text2 as text,
  textX2 as textX,
  textY2 as textY,
  tickX2 as tickX,
  tickY2 as tickY,
  toggle,
  toggleColor,
  toggleX,
  toggleY,
  varPop,
  variance,
  vconcat,
  vector2 as vector,
  vectorX2 as vectorX,
  vectorY2 as vectorY,
  voronoi2 as voronoi,
  voronoiMesh2 as voronoiMesh,
  vspace,
  wasmConnector,
  width,
  xAlign,
  xAriaDescription,
  xAriaLabel,
  xAxis,
  xBase,
  xClamp,
  xConstant,
  xDomain,
  xExponent,
  xFontVariant,
  xGrid,
  xInset,
  xInsetLeft,
  xInsetRight,
  xLabel,
  xLabelAnchor,
  xLabelOffset,
  xLine,
  xNice,
  xPadding,
  xPaddingInner,
  xPaddingOuter,
  xRange,
  xReverse,
  xRound,
  xScale,
  xTickFormat,
  xTickPadding,
  xTickRotate,
  xTickSize,
  xTickSpacing,
  xTicks,
  xZero,
  xyDomain,
  yAlign,
  yAriaDescription,
  yAriaLabel,
  yAxis,
  yBase,
  yClamp,
  yConstant,
  yDomain,
  yExponent,
  yFontVariant,
  yGrid,
  yInset,
  yInsetBottom,
  yInsetTop,
  yLabel,
  yLabelAnchor,
  yLabelOffset,
  yLine,
  yNice,
  yPadding,
  yPaddingInner,
  yPaddingOuter,
  yRange,
  yReverse,
  yRound,
  yScale,
  yTickFormat,
  yTickPadding,
  yTickRotate,
  yTickSize,
  yTickSpacing,
  yTicks,
  yZero
};
