const M_ = {};
function FI(e, t = !1) {
  let n, i, r = M_;
  function s(l) {
    n = e(l).then(() => {
      if (i) {
        const { value: u } = i;
        i = null, s(u);
      } else
        n = null;
    });
  }
  function o(l) {
    i = { event: l };
  }
  function a(l) {
    n ? o(l) : s(l);
  }
  function c(l) {
    r !== l && requestAnimationFrame(() => {
      const u = r;
      r = M_, a(u);
    }), r = l;
  }
  return t ? c : a;
}
class af {
  /**
   * Constructor.
   * @param {*} filterSelection An optional selection to interactively filter
   *  this client's data. If provided, a coordinator will re-query and update
   *  the client when the selection updates.
   */
  constructor(t) {
    this._filterBy = t, this._requestUpdate = FI(() => this.requestQuery(), !0), this._coordinator = null;
  }
  /**
   * Return this client's connected coordinator.
   */
  get coordinator() {
    return this._coordinator;
  }
  /**
   * Set this client's connected coordinator.
   */
  set coordinator(t) {
    this._coordinator = t;
  }
  /**
   * Return this client's filter selection.
   */
  get filterBy() {
    return this._filterBy;
  }
  /**
   * Return a boolean indicating if the client query can be indexed. Should
   * return true if changes to the filterBy selection does not change the
   * groupby domain of the client query.
   */
  get filterIndexable() {
    return !0;
  }
  /**
   * Return an array of fields queried by this client.
   * @returns {object[]|null} The fields to retrieve info for.
   */
  fields() {
    return null;
  }
  /**
   * Called by the coordinator to set the field info for this client.
   * @param {*} info The field info result.
   * @returns {this}
   */
  fieldInfo(t) {
    return this;
  }
  /**
   * Return a query specifying the data needed by this client.
   * @param {*} [filter] The filtering criteria to apply in the query.
   * @returns {*} The client query
   */
  query(t) {
    return null;
  }
  /**
   * Called by the coordinator to inform the client that a query is pending.
   * @returns {this}
   */
  queryPending() {
    return this;
  }
  /**
   * Called by the coordinator to return a query result.
   * @param {*} data The query result.
   * @returns {this}
   */
  queryResult(t) {
    return this;
  }
  /**
   * Called by the coordinator to report a query execution error.
   * @param {*} error
   * @returns {this}
   */
  queryError(t) {
    return console.error(t), this;
  }
  /**
   * Request the coordinator to execute a query for this client.
   * If an explicit query is not provided, the client query method will
   * be called, filtered by the current filterBy selection.
   */
  requestQuery(t) {
    var i;
    const n = t || this.query((i = this.filterBy) == null ? void 0 : i.predicate(this));
    return this._coordinator.requestQuery(this, n);
  }
  /**
   * Request that the coordinator perform a throttled update of this client
   * using the default query. Unlike requestQuery, for which every call will
   * result in an executed query, multiple calls to requestUpdate may be
   * consolidated into a single update.
   */
  requestUpdate() {
    this._requestUpdate();
  }
  /**
   * Requests a client update.
   * For example to (re-)render an interface component.
   * 
   * @returns {this | Promise<any>}
   */
  update() {
    return this;
  }
}
function W(e, t, n, i) {
  function r(s) {
    return s instanceof n ? s : new n(function(o) {
      o(s);
    });
  }
  return new (n || (n = Promise))(function(s, o) {
    function a(u) {
      try {
        l(i.next(u));
      } catch (f) {
        o(f);
      }
    }
    function c(u) {
      try {
        l(i.throw(u));
      } catch (f) {
        o(f);
      }
    }
    function l(u) {
      u.done ? s(u.value) : r(u.value).then(a, c);
    }
    l((i = i.apply(e, t || [])).next());
  });
}
function $_(e) {
  var t = typeof Symbol == "function" && Symbol.iterator, n = t && e[t], i = 0;
  if (n)
    return n.call(e);
  if (e && typeof e.length == "number")
    return {
      next: function() {
        return e && i >= e.length && (e = void 0), { value: e && e[i++], done: !e };
      }
    };
  throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function H(e) {
  return this instanceof H ? (this.v = e, this) : new H(e);
}
function Re(e, t, n) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var i = n.apply(e, t || []), r, s = [];
  return r = {}, o("next"), o("throw"), o("return"), r[Symbol.asyncIterator] = function() {
    return this;
  }, r;
  function o(h) {
    i[h] && (r[h] = function(d) {
      return new Promise(function(p, y) {
        s.push([h, d, p, y]) > 1 || a(h, d);
      });
    });
  }
  function a(h, d) {
    try {
      c(i[h](d));
    } catch (p) {
      f(s[0][3], p);
    }
  }
  function c(h) {
    h.value instanceof H ? Promise.resolve(h.value.v).then(l, u) : f(s[0][2], h);
  }
  function l(h) {
    a("next", h);
  }
  function u(h) {
    a("throw", h);
  }
  function f(h, d) {
    h(d), s.shift(), s.length && a(s[0][0], s[0][1]);
  }
}
function ks(e) {
  var t, n;
  return t = {}, i("next"), i("throw", function(r) {
    throw r;
  }), i("return"), t[Symbol.iterator] = function() {
    return this;
  }, t;
  function i(r, s) {
    t[r] = e[r] ? function(o) {
      return (n = !n) ? { value: H(e[r](o)), done: !1 } : s ? s(o) : o;
    } : s;
  }
}
function ci(e) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var t = e[Symbol.asyncIterator], n;
  return t ? t.call(e) : (e = typeof $_ == "function" ? $_(e) : e[Symbol.iterator](), n = {}, i("next"), i("throw"), i("return"), n[Symbol.asyncIterator] = function() {
    return this;
  }, n);
  function i(s) {
    n[s] = e[s] && function(o) {
      return new Promise(function(a, c) {
        o = e[s](o), r(a, c, o.done, o.value);
      });
    };
  }
  function r(s, o, a, c) {
    Promise.resolve(c).then(function(l) {
      s({ value: l, done: a });
    }, o);
  }
}
const BC = new TextDecoder("utf-8"), pg = (e) => BC.decode(e), OC = new TextEncoder(), hb = (e) => OC.encode(e), FC = (e) => typeof e == "number", EC = (e) => typeof e == "boolean", on = (e) => typeof e == "function", Ii = (e) => e != null && Object(e) === e, bu = (e) => Ii(e) && on(e.then), Ly = (e) => Ii(e) && on(e[Symbol.iterator]), db = (e) => Ii(e) && on(e[Symbol.asyncIterator]), yg = (e) => Ii(e) && Ii(e.schema), EI = (e) => Ii(e) && "done" in e && "value" in e, LI = (e) => Ii(e) && on(e.stat) && FC(e.fd), RI = (e) => Ii(e) && pb(e.body), CI = (e) => "_getDOMStream" in e && "_getNodeStream" in e, pb = (e) => Ii(e) && on(e.cancel) && on(e.getReader) && !CI(e), kI = (e) => Ii(e) && on(e.read) && on(e.pipe) && EC(e.readable) && !CI(e), LC = (e) => Ii(e) && on(e.clear) && on(e.bytes) && on(e.position) && on(e.setPosition) && on(e.capacity) && on(e.getBufferIdentifier) && on(e.createLong), yb = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : ArrayBuffer;
function RC(e) {
  const t = e[0] ? [e[0]] : [];
  let n, i, r, s;
  for (let o, a, c = 0, l = 0, u = e.length; ++c < u; ) {
    if (o = t[l], a = e[c], !o || !a || o.buffer !== a.buffer || a.byteOffset < o.byteOffset) {
      a && (t[++l] = a);
      continue;
    }
    if ({ byteOffset: n, byteLength: r } = o, { byteOffset: i, byteLength: s } = a, n + r < i || i + s < n) {
      a && (t[++l] = a);
      continue;
    }
    t[l] = new Uint8Array(o.buffer, n, i - n + s);
  }
  return t;
}
function T_(e, t, n = 0, i = t.byteLength) {
  const r = e.byteLength, s = new Uint8Array(e.buffer, e.byteOffset, r), o = new Uint8Array(t.buffer, t.byteOffset, Math.min(i, r));
  return s.set(o, n), e;
}
function cr(e, t) {
  const n = RC(e), i = n.reduce((u, f) => u + f.byteLength, 0);
  let r, s, o, a = 0, c = -1;
  const l = Math.min(t || Number.POSITIVE_INFINITY, i);
  for (const u = n.length; ++c < u; ) {
    if (r = n[c], s = r.subarray(0, Math.min(r.length, l - a)), l <= a + s.length) {
      s.length < r.length ? n[c] = r.subarray(s.length) : s.length === r.length && c++, o ? T_(o, s, a) : o = s;
      break;
    }
    T_(o || (o = new Uint8Array(l)), s, a), a += s.length;
  }
  return [o || new Uint8Array(0), n.slice(c), i - (o ? o.byteLength : 0)];
}
function re(e, t) {
  let n = EI(t) ? t.value : t;
  return n instanceof e ? e === Uint8Array ? new e(n.buffer, n.byteOffset, n.byteLength) : n : n ? (typeof n == "string" && (n = hb(n)), n instanceof ArrayBuffer ? new e(n) : n instanceof yb ? new e(n) : LC(n) ? re(e, n.bytes()) : ArrayBuffer.isView(n) ? n.byteLength <= 0 ? new e(0) : new e(n.buffer, n.byteOffset, n.byteLength / e.BYTES_PER_ELEMENT) : e.from(n)) : new e(0);
}
const bl = (e) => re(Int32Array, e), D_ = (e) => re(BigInt64Array, e), Yt = (e) => re(Uint8Array, e), mg = (e) => (e.next(), e);
function* CC(e, t) {
  const n = function* (r) {
    yield r;
  }, i = typeof t == "string" || ArrayBuffer.isView(t) || t instanceof ArrayBuffer || t instanceof yb ? n(t) : Ly(t) ? t : n(t);
  return yield* mg(function* (r) {
    let s = null;
    do
      s = r.next(yield re(e, s));
    while (!s.done);
  }(i[Symbol.iterator]())), new e();
}
const kC = (e) => CC(Uint8Array, e);
function UI(e, t) {
  return Re(this, arguments, function* () {
    if (bu(t))
      return yield H(yield H(yield* ks(ci(UI(e, yield H(t))))));
    const i = function(o) {
      return Re(this, arguments, function* () {
        yield yield H(yield H(o));
      });
    }, r = function(o) {
      return Re(this, arguments, function* () {
        yield H(yield* ks(ci(mg(function* (a) {
          let c = null;
          do
            c = a.next(yield c == null ? void 0 : c.value);
          while (!c.done);
        }(o[Symbol.iterator]())))));
      });
    }, s = typeof t == "string" || ArrayBuffer.isView(t) || t instanceof ArrayBuffer || t instanceof yb ? i(t) : Ly(t) ? r(t) : db(t) ? t : i(t);
    return yield H(
      // otherwise if AsyncIterable, use it
      yield* ks(ci(mg(function(o) {
        return Re(this, arguments, function* () {
          let a = null;
          do
            a = yield H(o.next(yield yield H(re(e, a))));
          while (!a.done);
        });
      }(s[Symbol.asyncIterator]()))))
    ), yield H(new e());
  });
}
const UC = (e) => UI(Uint8Array, e);
function zC(e, t) {
  let n = 0;
  const i = e.length;
  if (i !== t.length)
    return !1;
  if (i > 0)
    do
      if (e[n] !== t[n])
        return !1;
    while (++n < i);
  return !0;
}
const Jn = {
  fromIterable(e) {
    return th(PC(e));
  },
  fromAsyncIterable(e) {
    return th(VC(e));
  },
  fromDOMStream(e) {
    return th(jC(e));
  },
  fromNodeStream(e) {
    return th(YC(e));
  },
  // @ts-ignore
  toDOMStream(e, t) {
    throw new Error('"toDOMStream" not available in this environment');
  },
  // @ts-ignore
  toNodeStream(e, t) {
    throw new Error('"toNodeStream" not available in this environment');
  }
}, th = (e) => (e.next(), e);
function* PC(e) {
  let t, n = !1, i = [], r, s, o, a = 0;
  function c() {
    return s === "peek" ? cr(i, o)[0] : ([r, i, a] = cr(i, o), r);
  }
  ({ cmd: s, size: o } = (yield null) || { cmd: "read", size: 0 });
  const l = kC(e)[Symbol.iterator]();
  try {
    do
      if ({ done: t, value: r } = Number.isNaN(o - a) ? l.next() : l.next(o - a), !t && r.byteLength > 0 && (i.push(r), a += r.byteLength), t || o <= a)
        do
          ({ cmd: s, size: o } = yield c());
        while (o < a);
    while (!t);
  } catch (u) {
    (n = !0) && typeof l.throw == "function" && l.throw(u);
  } finally {
    n === !1 && typeof l.return == "function" && l.return(null);
  }
  return null;
}
function VC(e) {
  return Re(this, arguments, function* () {
    let n, i = !1, r = [], s, o, a, c = 0;
    function l() {
      return o === "peek" ? cr(r, a)[0] : ([s, r, c] = cr(r, a), s);
    }
    ({ cmd: o, size: a } = (yield yield H(null)) || { cmd: "read", size: 0 });
    const u = UC(e)[Symbol.asyncIterator]();
    try {
      do
        if ({ done: n, value: s } = Number.isNaN(a - c) ? yield H(u.next()) : yield H(u.next(a - c)), !n && s.byteLength > 0 && (r.push(s), c += s.byteLength), n || a <= c)
          do
            ({ cmd: o, size: a } = yield yield H(l()));
          while (a < c);
      while (!n);
    } catch (f) {
      (i = !0) && typeof u.throw == "function" && (yield H(u.throw(f)));
    } finally {
      i === !1 && typeof u.return == "function" && (yield H(u.return(new Uint8Array(0))));
    }
    return yield H(null);
  });
}
function jC(e) {
  return Re(this, arguments, function* () {
    let n = !1, i = !1, r = [], s, o, a, c = 0;
    function l() {
      return o === "peek" ? cr(r, a)[0] : ([s, r, c] = cr(r, a), s);
    }
    ({ cmd: o, size: a } = (yield yield H(null)) || { cmd: "read", size: 0 });
    const u = new qC(e);
    try {
      do
        if ({ done: n, value: s } = Number.isNaN(a - c) ? yield H(u.read()) : yield H(u.read(a - c)), !n && s.byteLength > 0 && (r.push(Yt(s)), c += s.byteLength), n || a <= c)
          do
            ({ cmd: o, size: a } = yield yield H(l()));
          while (a < c);
      while (!n);
    } catch (f) {
      (i = !0) && (yield H(u.cancel(f)));
    } finally {
      i === !1 ? yield H(u.cancel()) : e.locked && u.releaseLock();
    }
    return yield H(null);
  });
}
let qC = class {
  constructor(t) {
    this.source = t, this.reader = null, this.reader = this.source.getReader(), this.reader.closed.catch(() => {
    });
  }
  get closed() {
    return this.reader ? this.reader.closed.catch(() => {
    }) : Promise.resolve();
  }
  releaseLock() {
    this.reader && this.reader.releaseLock(), this.reader = null;
  }
  cancel(t) {
    return W(this, void 0, void 0, function* () {
      const { reader: n, source: i } = this;
      n && (yield n.cancel(t).catch(() => {
      })), i && i.locked && this.releaseLock();
    });
  }
  read(t) {
    return W(this, void 0, void 0, function* () {
      if (t === 0)
        return { done: this.reader == null, value: new Uint8Array(0) };
      const n = yield this.reader.read();
      return !n.done && (n.value = Yt(n)), n;
    });
  }
};
const Q0 = (e, t) => {
  const n = (r) => i([t, r]);
  let i;
  return [t, n, new Promise((r) => (i = r) && e.once(t, n))];
};
function YC(e) {
  return Re(this, arguments, function* () {
    const n = [];
    let i = "error", r = !1, s = null, o, a, c = 0, l = [], u;
    function f() {
      return o === "peek" ? cr(l, a)[0] : ([u, l, c] = cr(l, a), u);
    }
    if ({ cmd: o, size: a } = (yield yield H(null)) || { cmd: "read", size: 0 }, e.isTTY)
      return yield yield H(new Uint8Array(0)), yield H(null);
    try {
      n[0] = Q0(e, "end"), n[1] = Q0(e, "error");
      do {
        if (n[2] = Q0(e, "readable"), [i, s] = yield H(Promise.race(n.map((d) => d[2]))), i === "error")
          break;
        if ((r = i === "end") || (Number.isFinite(a - c) ? (u = Yt(e.read(a - c)), u.byteLength < a - c && (u = Yt(e.read()))) : u = Yt(e.read()), u.byteLength > 0 && (l.push(u), c += u.byteLength)), r || a <= c)
          do
            ({ cmd: o, size: a } = yield yield H(f()));
          while (a < c);
      } while (!r);
    } finally {
      yield H(h(n, i === "error" ? s : null));
    }
    return yield H(null);
    function h(d, p) {
      return u = l = null, new Promise((y, m) => {
        for (const [g, b] of d)
          e.off(g, b);
        try {
          const g = e.destroy;
          g && g.call(e, p), p = void 0;
        } catch (g) {
          p = g || p;
        } finally {
          p != null ? m(p) : y();
        }
      });
    }
  });
}
var Ee;
(function(e) {
  e[e.V1 = 0] = "V1", e[e.V2 = 1] = "V2", e[e.V3 = 2] = "V3", e[e.V4 = 3] = "V4", e[e.V5 = 4] = "V5";
})(Ee || (Ee = {}));
var Mn;
(function(e) {
  e[e.Sparse = 0] = "Sparse", e[e.Dense = 1] = "Dense";
})(Mn || (Mn = {}));
var nn;
(function(e) {
  e[e.HALF = 0] = "HALF", e[e.SINGLE = 1] = "SINGLE", e[e.DOUBLE = 2] = "DOUBLE";
})(nn || (nn = {}));
var Ai;
(function(e) {
  e[e.DAY = 0] = "DAY", e[e.MILLISECOND = 1] = "MILLISECOND";
})(Ai || (Ai = {}));
var gt;
(function(e) {
  e[e.SECOND = 0] = "SECOND", e[e.MILLISECOND = 1] = "MILLISECOND", e[e.MICROSECOND = 2] = "MICROSECOND", e[e.NANOSECOND = 3] = "NANOSECOND";
})(gt || (gt = {}));
var lr;
(function(e) {
  e[e.YEAR_MONTH = 0] = "YEAR_MONTH", e[e.DAY_TIME = 1] = "DAY_TIME", e[e.MONTH_DAY_NANO = 2] = "MONTH_DAY_NANO";
})(lr || (lr = {}));
const tm = 2, Ji = 4, Vr = 4, nt = 4, Ms = new Int32Array(2), N_ = new Float32Array(Ms.buffer), B_ = new Float64Array(Ms.buffer), eh = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;
var gg;
(function(e) {
  e[e.UTF8_BYTES = 1] = "UTF8_BYTES", e[e.UTF16_STRING = 2] = "UTF16_STRING";
})(gg || (gg = {}));
let ur = class zI {
  /**
   * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)
   */
  constructor(t) {
    this.bytes_ = t, this.position_ = 0, this.text_decoder_ = new TextDecoder();
  }
  /**
   * Create and allocate a new ByteBuffer with a given size.
   */
  static allocate(t) {
    return new zI(new Uint8Array(t));
  }
  clear() {
    this.position_ = 0;
  }
  /**
   * Get the underlying `Uint8Array`.
   */
  bytes() {
    return this.bytes_;
  }
  /**
   * Get the buffer's position.
   */
  position() {
    return this.position_;
  }
  /**
   * Set the buffer's position.
   */
  setPosition(t) {
    this.position_ = t;
  }
  /**
   * Get the buffer's capacity.
   */
  capacity() {
    return this.bytes_.length;
  }
  readInt8(t) {
    return this.readUint8(t) << 24 >> 24;
  }
  readUint8(t) {
    return this.bytes_[t];
  }
  readInt16(t) {
    return this.readUint16(t) << 16 >> 16;
  }
  readUint16(t) {
    return this.bytes_[t] | this.bytes_[t + 1] << 8;
  }
  readInt32(t) {
    return this.bytes_[t] | this.bytes_[t + 1] << 8 | this.bytes_[t + 2] << 16 | this.bytes_[t + 3] << 24;
  }
  readUint32(t) {
    return this.readInt32(t) >>> 0;
  }
  readInt64(t) {
    return BigInt.asIntN(64, BigInt(this.readUint32(t)) + (BigInt(this.readUint32(t + 4)) << BigInt(32)));
  }
  readUint64(t) {
    return BigInt.asUintN(64, BigInt(this.readUint32(t)) + (BigInt(this.readUint32(t + 4)) << BigInt(32)));
  }
  readFloat32(t) {
    return Ms[0] = this.readInt32(t), N_[0];
  }
  readFloat64(t) {
    return Ms[eh ? 0 : 1] = this.readInt32(t), Ms[eh ? 1 : 0] = this.readInt32(t + 4), B_[0];
  }
  writeInt8(t, n) {
    this.bytes_[t] = n;
  }
  writeUint8(t, n) {
    this.bytes_[t] = n;
  }
  writeInt16(t, n) {
    this.bytes_[t] = n, this.bytes_[t + 1] = n >> 8;
  }
  writeUint16(t, n) {
    this.bytes_[t] = n, this.bytes_[t + 1] = n >> 8;
  }
  writeInt32(t, n) {
    this.bytes_[t] = n, this.bytes_[t + 1] = n >> 8, this.bytes_[t + 2] = n >> 16, this.bytes_[t + 3] = n >> 24;
  }
  writeUint32(t, n) {
    this.bytes_[t] = n, this.bytes_[t + 1] = n >> 8, this.bytes_[t + 2] = n >> 16, this.bytes_[t + 3] = n >> 24;
  }
  writeInt64(t, n) {
    this.writeInt32(t, Number(BigInt.asIntN(32, n))), this.writeInt32(t + 4, Number(BigInt.asIntN(32, n >> BigInt(32))));
  }
  writeUint64(t, n) {
    this.writeUint32(t, Number(BigInt.asUintN(32, n))), this.writeUint32(t + 4, Number(BigInt.asUintN(32, n >> BigInt(32))));
  }
  writeFloat32(t, n) {
    N_[0] = n, this.writeInt32(t, Ms[0]);
  }
  writeFloat64(t, n) {
    B_[0] = n, this.writeInt32(t, Ms[eh ? 0 : 1]), this.writeInt32(t + 4, Ms[eh ? 1 : 0]);
  }
  /**
   * Return the file identifier.   Behavior is undefined for FlatBuffers whose
   * schema does not include a file_identifier (likely points at padding or the
   * start of a the root vtable).
   */
  getBufferIdentifier() {
    if (this.bytes_.length < this.position_ + Ji + Vr)
      throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
    let t = "";
    for (let n = 0; n < Vr; n++)
      t += String.fromCharCode(this.readInt8(this.position_ + Ji + n));
    return t;
  }
  /**
   * Look up a field in the vtable, return an offset into the object, or 0 if the
   * field is not present.
   */
  __offset(t, n) {
    const i = t - this.readInt32(t);
    return n < this.readInt16(i) ? this.readInt16(i + n) : 0;
  }
  /**
   * Initialize any Table-derived type to point to the union at the given offset.
   */
  __union(t, n) {
    return t.bb_pos = n + this.readInt32(n), t.bb = this, t;
  }
  /**
   * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.
   * This allocates a new string and converts to wide chars upon each access.
   *
   * To avoid the conversion to string, pass Encoding.UTF8_BYTES as the
   * "optionalEncoding" argument. This is useful for avoiding conversion when
   * the data will just be packaged back up in another FlatBuffer later on.
   *
   * @param offset
   * @param opt_encoding Defaults to UTF16_STRING
   */
  __string(t, n) {
    t += this.readInt32(t);
    const i = this.readInt32(t);
    t += Ji;
    const r = this.bytes_.subarray(t, t + i);
    return n === gg.UTF8_BYTES ? r : this.text_decoder_.decode(r);
  }
  /**
   * Handle unions that can contain string as its member, if a Table-derived type then initialize it,
   * if a string then return a new one
   *
   * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this
   * makes the behaviour of __union_with_string different compared to __union
   */
  __union_with_string(t, n) {
    return typeof t == "string" ? this.__string(n) : this.__union(t, n);
  }
  /**
   * Retrieve the relative offset stored at "offset"
   */
  __indirect(t) {
    return t + this.readInt32(t);
  }
  /**
   * Get the start of data of a vector whose offset is stored at "offset" in this object.
   */
  __vector(t) {
    return t + this.readInt32(t) + Ji;
  }
  /**
   * Get the length of a vector whose offset is stored at "offset" in this object.
   */
  __vector_len(t) {
    return this.readInt32(t + this.readInt32(t));
  }
  __has_identifier(t) {
    if (t.length != Vr)
      throw new Error("FlatBuffers: file identifier must be length " + Vr);
    for (let n = 0; n < Vr; n++)
      if (t.charCodeAt(n) != this.readInt8(this.position() + Ji + n))
        return !1;
    return !0;
  }
  /**
   * A helper function for generating list for obj api
   */
  createScalarList(t, n) {
    const i = [];
    for (let r = 0; r < n; ++r) {
      const s = t(r);
      s !== null && i.push(s);
    }
    return i;
  }
  /**
   * A helper function for generating list for obj api
   * @param listAccessor function that accepts an index and return data at that index
   * @param listLength listLength
   * @param res result list
   */
  createObjList(t, n) {
    const i = [];
    for (let r = 0; r < n; ++r) {
      const s = t(r);
      s !== null && i.push(s.unpack());
    }
    return i;
  }
}, Ry = class PI {
  /**
   * Create a FlatBufferBuilder.
   */
  constructor(t) {
    this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = !1, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = !1, this.string_maps = null, this.text_encoder = new TextEncoder();
    let n;
    t ? n = t : n = 1024, this.bb = ur.allocate(n), this.space = n;
  }
  clear() {
    this.bb.clear(), this.space = this.bb.capacity(), this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = !1, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = !1, this.string_maps = null;
  }
  /**
   * In order to save space, fields that are set to their default value
   * don't get serialized into the buffer. Forcing defaults provides a
   * way to manually disable this optimization.
   *
   * @param forceDefaults true always serializes default values
   */
  forceDefaults(t) {
    this.force_defaults = t;
  }
  /**
   * Get the ByteBuffer representing the FlatBuffer. Only call this after you've
   * called finish(). The actual data starts at the ByteBuffer's current position,
   * not necessarily at 0.
   */
  dataBuffer() {
    return this.bb;
  }
  /**
   * Get the bytes representing the FlatBuffer. Only call this after you've
   * called finish().
   */
  asUint8Array() {
    return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
  }
  /**
   * Prepare to write an element of `size` after `additional_bytes` have been
   * written, e.g. if you write a string, you need to align such the int length
   * field is aligned to 4 bytes, and the string data follows it directly. If all
   * you need to do is alignment, `additional_bytes` will be 0.
   *
   * @param size This is the of the new element to write
   * @param additional_bytes The padding size
   */
  prep(t, n) {
    t > this.minalign && (this.minalign = t);
    const i = ~(this.bb.capacity() - this.space + n) + 1 & t - 1;
    for (; this.space < i + t + n; ) {
      const r = this.bb.capacity();
      this.bb = PI.growByteBuffer(this.bb), this.space += this.bb.capacity() - r;
    }
    this.pad(i);
  }
  pad(t) {
    for (let n = 0; n < t; n++)
      this.bb.writeInt8(--this.space, 0);
  }
  writeInt8(t) {
    this.bb.writeInt8(this.space -= 1, t);
  }
  writeInt16(t) {
    this.bb.writeInt16(this.space -= 2, t);
  }
  writeInt32(t) {
    this.bb.writeInt32(this.space -= 4, t);
  }
  writeInt64(t) {
    this.bb.writeInt64(this.space -= 8, t);
  }
  writeFloat32(t) {
    this.bb.writeFloat32(this.space -= 4, t);
  }
  writeFloat64(t) {
    this.bb.writeFloat64(this.space -= 8, t);
  }
  /**
   * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int8` to add the buffer.
   */
  addInt8(t) {
    this.prep(1, 0), this.writeInt8(t);
  }
  /**
   * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int16` to add the buffer.
   */
  addInt16(t) {
    this.prep(2, 0), this.writeInt16(t);
  }
  /**
   * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int32` to add the buffer.
   */
  addInt32(t) {
    this.prep(4, 0), this.writeInt32(t);
  }
  /**
   * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int64` to add the buffer.
   */
  addInt64(t) {
    this.prep(8, 0), this.writeInt64(t);
  }
  /**
   * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `float32` to add the buffer.
   */
  addFloat32(t) {
    this.prep(4, 0), this.writeFloat32(t);
  }
  /**
   * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `float64` to add the buffer.
   */
  addFloat64(t) {
    this.prep(8, 0), this.writeFloat64(t);
  }
  addFieldInt8(t, n, i) {
    (this.force_defaults || n != i) && (this.addInt8(n), this.slot(t));
  }
  addFieldInt16(t, n, i) {
    (this.force_defaults || n != i) && (this.addInt16(n), this.slot(t));
  }
  addFieldInt32(t, n, i) {
    (this.force_defaults || n != i) && (this.addInt32(n), this.slot(t));
  }
  addFieldInt64(t, n, i) {
    (this.force_defaults || n !== i) && (this.addInt64(n), this.slot(t));
  }
  addFieldFloat32(t, n, i) {
    (this.force_defaults || n != i) && (this.addFloat32(n), this.slot(t));
  }
  addFieldFloat64(t, n, i) {
    (this.force_defaults || n != i) && (this.addFloat64(n), this.slot(t));
  }
  addFieldOffset(t, n, i) {
    (this.force_defaults || n != i) && (this.addOffset(n), this.slot(t));
  }
  /**
   * Structs are stored inline, so nothing additional is being added. `d` is always 0.
   */
  addFieldStruct(t, n, i) {
    n != i && (this.nested(n), this.slot(t));
  }
  /**
   * Structures are always stored inline, they need to be created right
   * where they're used.  You'll get this assertion failure if you
   * created it elsewhere.
   */
  nested(t) {
    if (t != this.offset())
      throw new TypeError("FlatBuffers: struct must be serialized inline.");
  }
  /**
   * Should not be creating any other object, string or vector
   * while an object is being constructed
   */
  notNested() {
    if (this.isNested)
      throw new TypeError("FlatBuffers: object serialization must not be nested.");
  }
  /**
   * Set the current vtable at `voffset` to the current location in the buffer.
   */
  slot(t) {
    this.vtable !== null && (this.vtable[t] = this.offset());
  }
  /**
   * @returns Offset relative to the end of the buffer.
   */
  offset() {
    return this.bb.capacity() - this.space;
  }
  /**
   * Doubles the size of the backing ByteBuffer and copies the old data towards
   * the end of the new buffer (since we build the buffer backwards).
   *
   * @param bb The current buffer with the existing data
   * @returns A new byte buffer with the old data copied
   * to it. The data is located at the end of the buffer.
   *
   * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass
   * it a uint8Array we need to suppress the type check:
   * @suppress {checkTypes}
   */
  static growByteBuffer(t) {
    const n = t.capacity();
    if (n & 3221225472)
      throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");
    const i = n << 1, r = ur.allocate(i);
    return r.setPosition(i - n), r.bytes().set(t.bytes(), i - n), r;
  }
  /**
   * Adds on offset, relative to where it will be written.
   *
   * @param offset The offset to add.
   */
  addOffset(t) {
    this.prep(Ji, 0), this.writeInt32(this.offset() - t + Ji);
  }
  /**
   * Start encoding a new object in the buffer.  Users will not usually need to
   * call this directly. The FlatBuffers compiler will generate helper methods
   * that call this method internally.
   */
  startObject(t) {
    this.notNested(), this.vtable == null && (this.vtable = []), this.vtable_in_use = t;
    for (let n = 0; n < t; n++)
      this.vtable[n] = 0;
    this.isNested = !0, this.object_start = this.offset();
  }
  /**
   * Finish off writing the object that is under construction.
   *
   * @returns The offset to the object inside `dataBuffer`
   */
  endObject() {
    if (this.vtable == null || !this.isNested)
      throw new Error("FlatBuffers: endObject called without startObject");
    this.addInt32(0);
    const t = this.offset();
    let n = this.vtable_in_use - 1;
    for (; n >= 0 && this.vtable[n] == 0; n--)
      ;
    const i = n + 1;
    for (; n >= 0; n--)
      this.addInt16(this.vtable[n] != 0 ? t - this.vtable[n] : 0);
    const r = 2;
    this.addInt16(t - this.object_start);
    const s = (i + r) * tm;
    this.addInt16(s);
    let o = 0;
    const a = this.space;
    t:
      for (n = 0; n < this.vtables.length; n++) {
        const c = this.bb.capacity() - this.vtables[n];
        if (s == this.bb.readInt16(c)) {
          for (let l = tm; l < s; l += tm)
            if (this.bb.readInt16(a + l) != this.bb.readInt16(c + l))
              continue t;
          o = this.vtables[n];
          break;
        }
      }
    return o ? (this.space = this.bb.capacity() - t, this.bb.writeInt32(this.space, o - t)) : (this.vtables.push(this.offset()), this.bb.writeInt32(this.bb.capacity() - t, this.offset() - t)), this.isNested = !1, t;
  }
  /**
   * Finalize a buffer, poiting to the given `root_table`.
   */
  finish(t, n, i) {
    const r = i ? nt : 0;
    if (n) {
      const s = n;
      if (this.prep(this.minalign, Ji + Vr + r), s.length != Vr)
        throw new TypeError("FlatBuffers: file identifier must be length " + Vr);
      for (let o = Vr - 1; o >= 0; o--)
        this.writeInt8(s.charCodeAt(o));
    }
    this.prep(this.minalign, Ji + r), this.addOffset(t), r && this.addInt32(this.bb.capacity() - this.space), this.bb.setPosition(this.space);
  }
  /**
   * Finalize a size prefixed buffer, pointing to the given `root_table`.
   */
  finishSizePrefixed(t, n) {
    this.finish(t, n, !0);
  }
  /**
   * This checks a required field has been set in a given table that has
   * just been constructed.
   */
  requiredField(t, n) {
    const i = this.bb.capacity() - t, r = i - this.bb.readInt32(i);
    if (!(n < this.bb.readInt16(r) && this.bb.readInt16(r + n) != 0))
      throw new TypeError("FlatBuffers: field " + n + " must be set");
  }
  /**
   * Start a new array/vector of objects.  Users usually will not call
   * this directly. The FlatBuffers compiler will create a start/end
   * method for vector types in generated code.
   *
   * @param elem_size The size of each element in the array
   * @param num_elems The number of elements in the array
   * @param alignment The alignment of the array
   */
  startVector(t, n, i) {
    this.notNested(), this.vector_num_elems = n, this.prep(Ji, t * n), this.prep(i, t * n);
  }
  /**
   * Finish off the creation of an array and all its elements. The array must be
   * created with `startVector`.
   *
   * @returns The offset at which the newly created array
   * starts.
   */
  endVector() {
    return this.writeInt32(this.vector_num_elems), this.offset();
  }
  /**
   * Encode the string `s` in the buffer using UTF-8. If the string passed has
   * already been seen, we return the offset of the already written string
   *
   * @param s The string to encode
   * @return The offset in the buffer where the encoded string starts
   */
  createSharedString(t) {
    if (!t)
      return 0;
    if (this.string_maps || (this.string_maps = /* @__PURE__ */ new Map()), this.string_maps.has(t))
      return this.string_maps.get(t);
    const n = this.createString(t);
    return this.string_maps.set(t, n), n;
  }
  /**
   * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed
   * instead of a string, it is assumed to contain valid UTF-8 encoded data.
   *
   * @param s The string to encode
   * @return The offset in the buffer where the encoded string starts
   */
  createString(t) {
    if (t == null)
      return 0;
    let n;
    t instanceof Uint8Array ? n = t : n = this.text_encoder.encode(t), this.addInt8(0), this.startVector(1, n.length, 1), this.bb.setPosition(this.space -= n.length);
    for (let i = 0, r = this.space, s = this.bb.bytes(); i < n.length; i++)
      s[r++] = n[i];
    return this.endVector();
  }
  /**
   * A helper function to pack an object
   *
   * @returns offset of obj
   */
  createObjectOffset(t) {
    return t === null ? 0 : typeof t == "string" ? this.createString(t) : t.pack(this);
  }
  /**
   * A helper function to pack a list of object
   *
   * @returns list of offsets of each non null object
   */
  createObjectOffsetList(t) {
    const n = [];
    for (let i = 0; i < t.length; ++i) {
      const r = t[i];
      if (r !== null)
        n.push(this.createObjectOffset(r));
      else
        throw new TypeError("FlatBuffers: Argument for createObjectOffsetList cannot contain null.");
    }
    return n;
  }
  createStructOffsetList(t, n) {
    return n(this, t.length), this.createObjectOffsetList(t.slice().reverse()), this.endVector();
  }
};
var bd;
(function(e) {
  e[e.BUFFER = 0] = "BUFFER";
})(bd || (bd = {}));
var wd;
(function(e) {
  e[e.LZ4_FRAME = 0] = "LZ4_FRAME", e[e.ZSTD = 1] = "ZSTD";
})(wd || (wd = {}));
let WC = class wo {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsBodyCompression(t, n) {
    return (n || new wo()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsBodyCompression(t, n) {
    return t.setPosition(t.position() + nt), (n || new wo()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  /**
   * Compressor library.
   * For LZ4_FRAME, each compressed buffer must consist of a single frame.
   */
  codec() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt8(this.bb_pos + t) : wd.LZ4_FRAME;
  }
  /**
   * Indicates the way the record batch body was compressed
   */
  method() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.readInt8(this.bb_pos + t) : bd.BUFFER;
  }
  static startBodyCompression(t) {
    t.startObject(2);
  }
  static addCodec(t, n) {
    t.addFieldInt8(0, n, wd.LZ4_FRAME);
  }
  static addMethod(t, n) {
    t.addFieldInt8(1, n, bd.BUFFER);
  }
  static endBodyCompression(t) {
    return t.endObject();
  }
  static createBodyCompression(t, n, i) {
    return wo.startBodyCompression(t), wo.addCodec(t, n), wo.addMethod(t, i), wo.endBodyCompression(t);
  }
}, VI = class {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  /**
   * The relative offset into the shared memory page where the bytes for this
   * buffer starts
   */
  offset() {
    return this.bb.readInt64(this.bb_pos);
  }
  /**
   * The absolute length (in bytes) of the memory buffer. The memory is found
   * from offset (inclusive) to offset + length (non-inclusive). When building
   * messages using the encapsulated IPC message, padding bytes may be written
   * after a buffer, but such padding bytes do not need to be accounted for in
   * the size here.
   */
  length() {
    return this.bb.readInt64(this.bb_pos + 8);
  }
  static sizeOf() {
    return 16;
  }
  static createBuffer(t, n, i) {
    return t.prep(8, 16), t.writeInt64(BigInt(i ?? 0)), t.writeInt64(BigInt(n ?? 0)), t.offset();
  }
}, jI = class {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  /**
   * The number of value slots in the Arrow array at this level of a nested
   * tree
   */
  length() {
    return this.bb.readInt64(this.bb_pos);
  }
  /**
   * The number of observed nulls. Fields with null_count == 0 may choose not
   * to write their physical validity bitmap out as a materialized buffer,
   * instead setting the length of the bitmap buffer to 0.
   */
  nullCount() {
    return this.bb.readInt64(this.bb_pos + 8);
  }
  static sizeOf() {
    return 16;
  }
  static createFieldNode(t, n, i) {
    return t.prep(8, 16), t.writeInt64(BigInt(i ?? 0)), t.writeInt64(BigInt(n ?? 0)), t.offset();
  }
}, Lr = class bg {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsRecordBatch(t, n) {
    return (n || new bg()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsRecordBatch(t, n) {
    return t.setPosition(t.position() + nt), (n || new bg()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  /**
   * number of records / rows. The arrays in the batch should all have this
   * length
   */
  length() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt64(this.bb_pos + t) : BigInt("0");
  }
  /**
   * Nodes correspond to the pre-ordered flattened logical schema
   */
  nodes(t, n) {
    const i = this.bb.__offset(this.bb_pos, 6);
    return i ? (n || new jI()).__init(this.bb.__vector(this.bb_pos + i) + t * 16, this.bb) : null;
  }
  nodesLength() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  /**
   * Buffers correspond to the pre-ordered flattened buffer tree
   *
   * The number of buffers appended to this list depends on the schema. For
   * example, most primitive arrays will have 2 buffers, 1 for the validity
   * bitmap and 1 for the values. For struct arrays, there will only be a
   * single buffer for the validity (nulls) bitmap
   */
  buffers(t, n) {
    const i = this.bb.__offset(this.bb_pos, 8);
    return i ? (n || new VI()).__init(this.bb.__vector(this.bb_pos + i) + t * 16, this.bb) : null;
  }
  buffersLength() {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  /**
   * Optional compression of the message body
   */
  compression(t) {
    const n = this.bb.__offset(this.bb_pos, 10);
    return n ? (t || new WC()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;
  }
  static startRecordBatch(t) {
    t.startObject(4);
  }
  static addLength(t, n) {
    t.addFieldInt64(0, n, BigInt("0"));
  }
  static addNodes(t, n) {
    t.addFieldOffset(1, n, 0);
  }
  static startNodesVector(t, n) {
    t.startVector(16, n, 8);
  }
  static addBuffers(t, n) {
    t.addFieldOffset(2, n, 0);
  }
  static startBuffersVector(t, n) {
    t.startVector(16, n, 8);
  }
  static addCompression(t, n) {
    t.addFieldOffset(3, n, 0);
  }
  static endRecordBatch(t) {
    return t.endObject();
  }
}, Da = class wg {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsDictionaryBatch(t, n) {
    return (n || new wg()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsDictionaryBatch(t, n) {
    return t.setPosition(t.position() + nt), (n || new wg()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  id() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt64(this.bb_pos + t) : BigInt("0");
  }
  data(t) {
    const n = this.bb.__offset(this.bb_pos, 6);
    return n ? (t || new Lr()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;
  }
  /**
   * If isDelta is true the values in the dictionary are to be appended to a
   * dictionary with the indicated id. If isDelta is false this dictionary
   * should replace the existing dictionary.
   */
  isDelta() {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? !!this.bb.readInt8(this.bb_pos + t) : !1;
  }
  static startDictionaryBatch(t) {
    t.startObject(3);
  }
  static addId(t, n) {
    t.addFieldInt64(0, n, BigInt("0"));
  }
  static addData(t, n) {
    t.addFieldOffset(1, n, 0);
  }
  static addIsDelta(t, n) {
    t.addFieldInt8(2, +n, 0);
  }
  static endDictionaryBatch(t) {
    return t.endObject();
  }
};
var xc;
(function(e) {
  e[e.Little = 0] = "Little", e[e.Big = 1] = "Big";
})(xc || (xc = {}));
var vd;
(function(e) {
  e[e.DenseArray = 0] = "DenseArray";
})(vd || (vd = {}));
let Ja = class vo {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsInt(t, n) {
    return (n || new vo()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsInt(t, n) {
    return t.setPosition(t.position() + nt), (n || new vo()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  bitWidth() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt32(this.bb_pos + t) : 0;
  }
  isSigned() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? !!this.bb.readInt8(this.bb_pos + t) : !1;
  }
  static startInt(t) {
    t.startObject(2);
  }
  static addBitWidth(t, n) {
    t.addFieldInt32(0, n, 0);
  }
  static addIsSigned(t, n) {
    t.addFieldInt8(1, +n, 0);
  }
  static endInt(t) {
    return t.endObject();
  }
  static createInt(t, n, i) {
    return vo.startInt(t), vo.addBitWidth(t, n), vo.addIsSigned(t, i), vo.endInt(t);
  }
}, Na = class vg {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsDictionaryEncoding(t, n) {
    return (n || new vg()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsDictionaryEncoding(t, n) {
    return t.setPosition(t.position() + nt), (n || new vg()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  /**
   * The known dictionary id in the application where this data is used. In
   * the file or streaming formats, the dictionary ids are found in the
   * DictionaryBatch messages
   */
  id() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt64(this.bb_pos + t) : BigInt("0");
  }
  /**
   * The dictionary indices are constrained to be non-negative integers. If
   * this field is null, the indices must be signed int32. To maximize
   * cross-language compatibility and performance, implementations are
   * recommended to prefer signed integer types over unsigned integer types
   * and to avoid uint64 indices unless they are required by an application.
   */
  indexType(t) {
    const n = this.bb.__offset(this.bb_pos, 6);
    return n ? (t || new Ja()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;
  }
  /**
   * By default, dictionaries are not ordered, or the order does not have
   * semantic meaning. In some statistical, applications, dictionary-encoding
   * is used to represent ordered categorical data, and we provide a way to
   * preserve that metadata here
   */
  isOrdered() {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? !!this.bb.readInt8(this.bb_pos + t) : !1;
  }
  dictionaryKind() {
    const t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.readInt16(this.bb_pos + t) : vd.DenseArray;
  }
  static startDictionaryEncoding(t) {
    t.startObject(4);
  }
  static addId(t, n) {
    t.addFieldInt64(0, n, BigInt("0"));
  }
  static addIndexType(t, n) {
    t.addFieldOffset(1, n, 0);
  }
  static addIsOrdered(t, n) {
    t.addFieldInt8(2, +n, 0);
  }
  static addDictionaryKind(t, n) {
    t.addFieldInt16(3, n, vd.DenseArray);
  }
  static endDictionaryEncoding(t) {
    return t.endObject();
  }
}, ii = class _o {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsKeyValue(t, n) {
    return (n || new _o()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsKeyValue(t, n) {
    return t.setPosition(t.position() + nt), (n || new _o()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  key(t) {
    const n = this.bb.__offset(this.bb_pos, 4);
    return n ? this.bb.__string(this.bb_pos + n, t) : null;
  }
  value(t) {
    const n = this.bb.__offset(this.bb_pos, 6);
    return n ? this.bb.__string(this.bb_pos + n, t) : null;
  }
  static startKeyValue(t) {
    t.startObject(2);
  }
  static addKey(t, n) {
    t.addFieldOffset(0, n, 0);
  }
  static addValue(t, n) {
    t.addFieldOffset(1, n, 0);
  }
  static endKeyValue(t) {
    return t.endObject();
  }
  static createKeyValue(t, n, i) {
    return _o.startKeyValue(t), _o.addKey(t, n), _o.addValue(t, i), _o.endKeyValue(t);
  }
}, O_ = class Fl {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsBinary(t, n) {
    return (n || new Fl()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsBinary(t, n) {
    return t.setPosition(t.position() + nt), (n || new Fl()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static startBinary(t) {
    t.startObject(0);
  }
  static endBinary(t) {
    return t.endObject();
  }
  static createBinary(t) {
    return Fl.startBinary(t), Fl.endBinary(t);
  }
}, F_ = class El {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsBool(t, n) {
    return (n || new El()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsBool(t, n) {
    return t.setPosition(t.position() + nt), (n || new El()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static startBool(t) {
    t.startObject(0);
  }
  static endBool(t) {
    return t.endObject();
  }
  static createBool(t) {
    return El.startBool(t), El.endBool(t);
  }
}, Ch = class Ba {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsDate(t, n) {
    return (n || new Ba()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsDate(t, n) {
    return t.setPosition(t.position() + nt), (n || new Ba()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  unit() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt16(this.bb_pos + t) : Ai.MILLISECOND;
  }
  static startDate(t) {
    t.startObject(1);
  }
  static addUnit(t, n) {
    t.addFieldInt16(0, n, Ai.MILLISECOND);
  }
  static endDate(t) {
    return t.endObject();
  }
  static createDate(t, n) {
    return Ba.startDate(t), Ba.addUnit(t, n), Ba.endDate(t);
  }
}, Oa = class Ss {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsDecimal(t, n) {
    return (n || new Ss()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsDecimal(t, n) {
    return t.setPosition(t.position() + nt), (n || new Ss()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  /**
   * Total number of decimal digits
   */
  precision() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt32(this.bb_pos + t) : 0;
  }
  /**
   * Number of digits after the decimal point "."
   */
  scale() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.readInt32(this.bb_pos + t) : 0;
  }
  /**
   * Number of bits per value. The only accepted widths are 128 and 256.
   * We use bitWidth for consistency with Int::bitWidth.
   */
  bitWidth() {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.readInt32(this.bb_pos + t) : 128;
  }
  static startDecimal(t) {
    t.startObject(3);
  }
  static addPrecision(t, n) {
    t.addFieldInt32(0, n, 0);
  }
  static addScale(t, n) {
    t.addFieldInt32(1, n, 0);
  }
  static addBitWidth(t, n) {
    t.addFieldInt32(2, n, 128);
  }
  static endDecimal(t) {
    return t.endObject();
  }
  static createDecimal(t, n, i, r) {
    return Ss.startDecimal(t), Ss.addPrecision(t, n), Ss.addScale(t, i), Ss.addBitWidth(t, r), Ss.endDecimal(t);
  }
}, kh = class Fa {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsDuration(t, n) {
    return (n || new Fa()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsDuration(t, n) {
    return t.setPosition(t.position() + nt), (n || new Fa()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  unit() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt16(this.bb_pos + t) : gt.MILLISECOND;
  }
  static startDuration(t) {
    t.startObject(1);
  }
  static addUnit(t, n) {
    t.addFieldInt16(0, n, gt.MILLISECOND);
  }
  static endDuration(t) {
    return t.endObject();
  }
  static createDuration(t, n) {
    return Fa.startDuration(t), Fa.addUnit(t, n), Fa.endDuration(t);
  }
}, Uh = class Ea {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsFixedSizeBinary(t, n) {
    return (n || new Ea()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsFixedSizeBinary(t, n) {
    return t.setPosition(t.position() + nt), (n || new Ea()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  /**
   * Number of bytes per value
   */
  byteWidth() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt32(this.bb_pos + t) : 0;
  }
  static startFixedSizeBinary(t) {
    t.startObject(1);
  }
  static addByteWidth(t, n) {
    t.addFieldInt32(0, n, 0);
  }
  static endFixedSizeBinary(t) {
    return t.endObject();
  }
  static createFixedSizeBinary(t, n) {
    return Ea.startFixedSizeBinary(t), Ea.addByteWidth(t, n), Ea.endFixedSizeBinary(t);
  }
}, zh = class La {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsFixedSizeList(t, n) {
    return (n || new La()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsFixedSizeList(t, n) {
    return t.setPosition(t.position() + nt), (n || new La()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  /**
   * Number of list items per value
   */
  listSize() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt32(this.bb_pos + t) : 0;
  }
  static startFixedSizeList(t) {
    t.startObject(1);
  }
  static addListSize(t, n) {
    t.addFieldInt32(0, n, 0);
  }
  static endFixedSizeList(t) {
    return t.endObject();
  }
  static createFixedSizeList(t, n) {
    return La.startFixedSizeList(t), La.addListSize(t, n), La.endFixedSizeList(t);
  }
}, Ph = class Ra {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsFloatingPoint(t, n) {
    return (n || new Ra()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsFloatingPoint(t, n) {
    return t.setPosition(t.position() + nt), (n || new Ra()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  precision() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt16(this.bb_pos + t) : nn.HALF;
  }
  static startFloatingPoint(t) {
    t.startObject(1);
  }
  static addPrecision(t, n) {
    t.addFieldInt16(0, n, nn.HALF);
  }
  static endFloatingPoint(t) {
    return t.endObject();
  }
  static createFloatingPoint(t, n) {
    return Ra.startFloatingPoint(t), Ra.addPrecision(t, n), Ra.endFloatingPoint(t);
  }
}, Vh = class Ca {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsInterval(t, n) {
    return (n || new Ca()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsInterval(t, n) {
    return t.setPosition(t.position() + nt), (n || new Ca()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  unit() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt16(this.bb_pos + t) : lr.YEAR_MONTH;
  }
  static startInterval(t) {
    t.startObject(1);
  }
  static addUnit(t, n) {
    t.addFieldInt16(0, n, lr.YEAR_MONTH);
  }
  static endInterval(t) {
    return t.endObject();
  }
  static createInterval(t, n) {
    return Ca.startInterval(t), Ca.addUnit(t, n), Ca.endInterval(t);
  }
}, E_ = class Ll {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsLargeBinary(t, n) {
    return (n || new Ll()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsLargeBinary(t, n) {
    return t.setPosition(t.position() + nt), (n || new Ll()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static startLargeBinary(t) {
    t.startObject(0);
  }
  static endLargeBinary(t) {
    return t.endObject();
  }
  static createLargeBinary(t) {
    return Ll.startLargeBinary(t), Ll.endLargeBinary(t);
  }
}, L_ = class Rl {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsLargeUtf8(t, n) {
    return (n || new Rl()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsLargeUtf8(t, n) {
    return t.setPosition(t.position() + nt), (n || new Rl()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static startLargeUtf8(t) {
    t.startObject(0);
  }
  static endLargeUtf8(t) {
    return t.endObject();
  }
  static createLargeUtf8(t) {
    return Rl.startLargeUtf8(t), Rl.endLargeUtf8(t);
  }
}, R_ = class Cl {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsList(t, n) {
    return (n || new Cl()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsList(t, n) {
    return t.setPosition(t.position() + nt), (n || new Cl()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static startList(t) {
    t.startObject(0);
  }
  static endList(t) {
    return t.endObject();
  }
  static createList(t) {
    return Cl.startList(t), Cl.endList(t);
  }
}, jh = class ka {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsMap(t, n) {
    return (n || new ka()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsMap(t, n) {
    return t.setPosition(t.position() + nt), (n || new ka()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  /**
   * Set to true if the keys within each value are sorted
   */
  keysSorted() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? !!this.bb.readInt8(this.bb_pos + t) : !1;
  }
  static startMap(t) {
    t.startObject(1);
  }
  static addKeysSorted(t, n) {
    t.addFieldInt8(0, +n, 0);
  }
  static endMap(t) {
    return t.endObject();
  }
  static createMap(t, n) {
    return ka.startMap(t), ka.addKeysSorted(t, n), ka.endMap(t);
  }
}, C_ = class kl {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsNull(t, n) {
    return (n || new kl()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsNull(t, n) {
    return t.setPosition(t.position() + nt), (n || new kl()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static startNull(t) {
    t.startObject(0);
  }
  static endNull(t) {
    return t.endObject();
  }
  static createNull(t) {
    return kl.startNull(t), kl.endNull(t);
  }
}, k_ = class Ul {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsStruct_(t, n) {
    return (n || new Ul()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsStruct_(t, n) {
    return t.setPosition(t.position() + nt), (n || new Ul()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static startStruct_(t) {
    t.startObject(0);
  }
  static endStruct_(t) {
    return t.endObject();
  }
  static createStruct_(t) {
    return Ul.startStruct_(t), Ul.endStruct_(t);
  }
}, zl = class So {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsTime(t, n) {
    return (n || new So()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsTime(t, n) {
    return t.setPosition(t.position() + nt), (n || new So()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  unit() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt16(this.bb_pos + t) : gt.MILLISECOND;
  }
  bitWidth() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.readInt32(this.bb_pos + t) : 32;
  }
  static startTime(t) {
    t.startObject(2);
  }
  static addUnit(t, n) {
    t.addFieldInt16(0, n, gt.MILLISECOND);
  }
  static addBitWidth(t, n) {
    t.addFieldInt32(1, n, 32);
  }
  static endTime(t) {
    return t.endObject();
  }
  static createTime(t, n, i) {
    return So.startTime(t), So.addUnit(t, n), So.addBitWidth(t, i), So.endTime(t);
  }
}, Pl = class xo {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsTimestamp(t, n) {
    return (n || new xo()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsTimestamp(t, n) {
    return t.setPosition(t.position() + nt), (n || new xo()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  unit() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt16(this.bb_pos + t) : gt.SECOND;
  }
  timezone(t) {
    const n = this.bb.__offset(this.bb_pos, 6);
    return n ? this.bb.__string(this.bb_pos + n, t) : null;
  }
  static startTimestamp(t) {
    t.startObject(2);
  }
  static addUnit(t, n) {
    t.addFieldInt16(0, n, gt.SECOND);
  }
  static addTimezone(t, n) {
    t.addFieldOffset(1, n, 0);
  }
  static endTimestamp(t) {
    return t.endObject();
  }
  static createTimestamp(t, n, i) {
    return xo.startTimestamp(t), xo.addUnit(t, n), xo.addTimezone(t, i), xo.endTimestamp(t);
  }
}, Io = class Ao {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsUnion(t, n) {
    return (n || new Ao()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsUnion(t, n) {
    return t.setPosition(t.position() + nt), (n || new Ao()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  mode() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt16(this.bb_pos + t) : Mn.Sparse;
  }
  typeIds(t) {
    const n = this.bb.__offset(this.bb_pos, 6);
    return n ? this.bb.readInt32(this.bb.__vector(this.bb_pos + n) + t * 4) : 0;
  }
  typeIdsLength() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  typeIdsArray() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null;
  }
  static startUnion(t) {
    t.startObject(2);
  }
  static addMode(t, n) {
    t.addFieldInt16(0, n, Mn.Sparse);
  }
  static addTypeIds(t, n) {
    t.addFieldOffset(1, n, 0);
  }
  static createTypeIdsVector(t, n) {
    t.startVector(4, n.length, 4);
    for (let i = n.length - 1; i >= 0; i--)
      t.addInt32(n[i]);
    return t.endVector();
  }
  static startTypeIdsVector(t, n) {
    t.startVector(4, n, 4);
  }
  static endUnion(t) {
    return t.endObject();
  }
  static createUnion(t, n, i) {
    return Ao.startUnion(t), Ao.addMode(t, n), Ao.addTypeIds(t, i), Ao.endUnion(t);
  }
}, U_ = class Vl {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsUtf8(t, n) {
    return (n || new Vl()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsUtf8(t, n) {
    return t.setPosition(t.position() + nt), (n || new Vl()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static startUtf8(t) {
    t.startObject(0);
  }
  static endUtf8(t) {
    return t.endObject();
  }
  static createUtf8(t) {
    return Vl.startUtf8(t), Vl.endUtf8(t);
  }
};
var he;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.Null = 1] = "Null", e[e.Int = 2] = "Int", e[e.FloatingPoint = 3] = "FloatingPoint", e[e.Binary = 4] = "Binary", e[e.Utf8 = 5] = "Utf8", e[e.Bool = 6] = "Bool", e[e.Decimal = 7] = "Decimal", e[e.Date = 8] = "Date", e[e.Time = 9] = "Time", e[e.Timestamp = 10] = "Timestamp", e[e.Interval = 11] = "Interval", e[e.List = 12] = "List", e[e.Struct_ = 13] = "Struct_", e[e.Union = 14] = "Union", e[e.FixedSizeBinary = 15] = "FixedSizeBinary", e[e.FixedSizeList = 16] = "FixedSizeList", e[e.Map = 17] = "Map", e[e.Duration = 18] = "Duration", e[e.LargeBinary = 19] = "LargeBinary", e[e.LargeUtf8 = 20] = "LargeUtf8", e[e.LargeList = 21] = "LargeList", e[e.RunEndEncoded = 22] = "RunEndEncoded";
})(he || (he = {}));
let Xn = class qh {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsField(t, n) {
    return (n || new qh()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsField(t, n) {
    return t.setPosition(t.position() + nt), (n || new qh()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  name(t) {
    const n = this.bb.__offset(this.bb_pos, 4);
    return n ? this.bb.__string(this.bb_pos + n, t) : null;
  }
  /**
   * Whether or not this field can contain nulls. Should be true in general.
   */
  nullable() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? !!this.bb.readInt8(this.bb_pos + t) : !1;
  }
  typeType() {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.readUint8(this.bb_pos + t) : he.NONE;
  }
  /**
   * This is the type of the decoded value if the field is dictionary encoded.
   */
  type(t) {
    const n = this.bb.__offset(this.bb_pos, 10);
    return n ? this.bb.__union(t, this.bb_pos + n) : null;
  }
  /**
   * Present only if the field is dictionary encoded.
   */
  dictionary(t) {
    const n = this.bb.__offset(this.bb_pos, 12);
    return n ? (t || new Na()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;
  }
  /**
   * children apply only to nested data types like Struct, List and Union. For
   * primitive types children will have length 0.
   */
  children(t, n) {
    const i = this.bb.__offset(this.bb_pos, 14);
    return i ? (n || new qh()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + t * 4), this.bb) : null;
  }
  childrenLength() {
    const t = this.bb.__offset(this.bb_pos, 14);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  /**
   * User-defined metadata
   */
  customMetadata(t, n) {
    const i = this.bb.__offset(this.bb_pos, 16);
    return i ? (n || new ii()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + t * 4), this.bb) : null;
  }
  customMetadataLength() {
    const t = this.bb.__offset(this.bb_pos, 16);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  static startField(t) {
    t.startObject(7);
  }
  static addName(t, n) {
    t.addFieldOffset(0, n, 0);
  }
  static addNullable(t, n) {
    t.addFieldInt8(1, +n, 0);
  }
  static addTypeType(t, n) {
    t.addFieldInt8(2, n, he.NONE);
  }
  static addType(t, n) {
    t.addFieldOffset(3, n, 0);
  }
  static addDictionary(t, n) {
    t.addFieldOffset(4, n, 0);
  }
  static addChildren(t, n) {
    t.addFieldOffset(5, n, 0);
  }
  static createChildrenVector(t, n) {
    t.startVector(4, n.length, 4);
    for (let i = n.length - 1; i >= 0; i--)
      t.addOffset(n[i]);
    return t.endVector();
  }
  static startChildrenVector(t, n) {
    t.startVector(4, n, 4);
  }
  static addCustomMetadata(t, n) {
    t.addFieldOffset(6, n, 0);
  }
  static createCustomMetadataVector(t, n) {
    t.startVector(4, n.length, 4);
    for (let i = n.length - 1; i >= 0; i--)
      t.addOffset(n[i]);
    return t.endVector();
  }
  static startCustomMetadataVector(t, n) {
    t.startVector(4, n, 4);
  }
  static endField(t) {
    return t.endObject();
  }
}, Yi = class Dr {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsSchema(t, n) {
    return (n || new Dr()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsSchema(t, n) {
    return t.setPosition(t.position() + nt), (n || new Dr()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  /**
   * endianness of the buffer
   * it is Little Endian by default
   * if endianness doesn't match the underlying system then the vectors need to be converted
   */
  endianness() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt16(this.bb_pos + t) : xc.Little;
  }
  fields(t, n) {
    const i = this.bb.__offset(this.bb_pos, 6);
    return i ? (n || new Xn()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + t * 4), this.bb) : null;
  }
  fieldsLength() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  customMetadata(t, n) {
    const i = this.bb.__offset(this.bb_pos, 8);
    return i ? (n || new ii()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + t * 4), this.bb) : null;
  }
  customMetadataLength() {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  /**
   * Features used in the stream/file.
   */
  features(t) {
    const n = this.bb.__offset(this.bb_pos, 10);
    return n ? this.bb.readInt64(this.bb.__vector(this.bb_pos + n) + t * 8) : BigInt(0);
  }
  featuresLength() {
    const t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  static startSchema(t) {
    t.startObject(4);
  }
  static addEndianness(t, n) {
    t.addFieldInt16(0, n, xc.Little);
  }
  static addFields(t, n) {
    t.addFieldOffset(1, n, 0);
  }
  static createFieldsVector(t, n) {
    t.startVector(4, n.length, 4);
    for (let i = n.length - 1; i >= 0; i--)
      t.addOffset(n[i]);
    return t.endVector();
  }
  static startFieldsVector(t, n) {
    t.startVector(4, n, 4);
  }
  static addCustomMetadata(t, n) {
    t.addFieldOffset(2, n, 0);
  }
  static createCustomMetadataVector(t, n) {
    t.startVector(4, n.length, 4);
    for (let i = n.length - 1; i >= 0; i--)
      t.addOffset(n[i]);
    return t.endVector();
  }
  static startCustomMetadataVector(t, n) {
    t.startVector(4, n, 4);
  }
  static addFeatures(t, n) {
    t.addFieldOffset(3, n, 0);
  }
  static createFeaturesVector(t, n) {
    t.startVector(8, n.length, 8);
    for (let i = n.length - 1; i >= 0; i--)
      t.addInt64(n[i]);
    return t.endVector();
  }
  static startFeaturesVector(t, n) {
    t.startVector(8, n, 8);
  }
  static endSchema(t) {
    return t.endObject();
  }
  static finishSchemaBuffer(t, n) {
    t.finish(n);
  }
  static finishSizePrefixedSchemaBuffer(t, n) {
    t.finish(n, void 0, !0);
  }
  static createSchema(t, n, i, r, s) {
    return Dr.startSchema(t), Dr.addEndianness(t, n), Dr.addFields(t, i), Dr.addCustomMetadata(t, r), Dr.addFeatures(t, s), Dr.endSchema(t);
  }
};
var Qt;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.Schema = 1] = "Schema", e[e.DictionaryBatch = 2] = "DictionaryBatch", e[e.RecordBatch = 3] = "RecordBatch", e[e.Tensor = 4] = "Tensor", e[e.SparseTensor = 5] = "SparseTensor";
})(Qt || (Qt = {}));
var F;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.Null = 1] = "Null", e[e.Int = 2] = "Int", e[e.Float = 3] = "Float", e[e.Binary = 4] = "Binary", e[e.Utf8 = 5] = "Utf8", e[e.Bool = 6] = "Bool", e[e.Decimal = 7] = "Decimal", e[e.Date = 8] = "Date", e[e.Time = 9] = "Time", e[e.Timestamp = 10] = "Timestamp", e[e.Interval = 11] = "Interval", e[e.List = 12] = "List", e[e.Struct = 13] = "Struct", e[e.Union = 14] = "Union", e[e.FixedSizeBinary = 15] = "FixedSizeBinary", e[e.FixedSizeList = 16] = "FixedSizeList", e[e.Map = 17] = "Map", e[e.Duration = 18] = "Duration", e[e.LargeBinary = 19] = "LargeBinary", e[e.LargeUtf8 = 20] = "LargeUtf8", e[e.Dictionary = -1] = "Dictionary", e[e.Int8 = -2] = "Int8", e[e.Int16 = -3] = "Int16", e[e.Int32 = -4] = "Int32", e[e.Int64 = -5] = "Int64", e[e.Uint8 = -6] = "Uint8", e[e.Uint16 = -7] = "Uint16", e[e.Uint32 = -8] = "Uint32", e[e.Uint64 = -9] = "Uint64", e[e.Float16 = -10] = "Float16", e[e.Float32 = -11] = "Float32", e[e.Float64 = -12] = "Float64", e[e.DateDay = -13] = "DateDay", e[e.DateMillisecond = -14] = "DateMillisecond", e[e.TimestampSecond = -15] = "TimestampSecond", e[e.TimestampMillisecond = -16] = "TimestampMillisecond", e[e.TimestampMicrosecond = -17] = "TimestampMicrosecond", e[e.TimestampNanosecond = -18] = "TimestampNanosecond", e[e.TimeSecond = -19] = "TimeSecond", e[e.TimeMillisecond = -20] = "TimeMillisecond", e[e.TimeMicrosecond = -21] = "TimeMicrosecond", e[e.TimeNanosecond = -22] = "TimeNanosecond", e[e.DenseUnion = -23] = "DenseUnion", e[e.SparseUnion = -24] = "SparseUnion", e[e.IntervalDayTime = -25] = "IntervalDayTime", e[e.IntervalYearMonth = -26] = "IntervalYearMonth", e[e.DurationSecond = -27] = "DurationSecond", e[e.DurationMillisecond = -28] = "DurationMillisecond", e[e.DurationMicrosecond = -29] = "DurationMicrosecond", e[e.DurationNanosecond = -30] = "DurationNanosecond";
})(F || (F = {}));
var Rr;
(function(e) {
  e[e.OFFSET = 0] = "OFFSET", e[e.DATA = 1] = "DATA", e[e.VALIDITY = 2] = "VALIDITY", e[e.TYPE = 3] = "TYPE";
})(Rr || (Rr = {}));
const GC = void 0;
function wu(e) {
  if (e === null)
    return "null";
  if (e === GC)
    return "undefined";
  switch (typeof e) {
    case "number":
      return `${e}`;
    case "bigint":
      return `${e}`;
    case "string":
      return `"${e}"`;
  }
  return typeof e[Symbol.toPrimitive] == "function" ? e[Symbol.toPrimitive]("string") : ArrayBuffer.isView(e) ? e instanceof BigInt64Array || e instanceof BigUint64Array ? `[${[...e].map((t) => wu(t))}]` : `[${e}]` : ArrayBuffer.isView(e) ? `[${e}]` : JSON.stringify(e, (t, n) => typeof n == "bigint" ? `${n}` : n);
}
const XC = Symbol.for("isArrowBigNum");
function Li(e, ...t) {
  return t.length === 0 ? Object.setPrototypeOf(re(this.TypedArray, e), this.constructor.prototype) : Object.setPrototypeOf(new this.TypedArray(e, ...t), this.constructor.prototype);
}
Li.prototype[XC] = !0;
Li.prototype.toJSON = function() {
  return `"${_u(this)}"`;
};
Li.prototype.valueOf = function() {
  return qI(this);
};
Li.prototype.toString = function() {
  return _u(this);
};
Li.prototype[Symbol.toPrimitive] = function(e = "default") {
  switch (e) {
    case "number":
      return qI(this);
    case "string":
      return _u(this);
    case "default":
      return HC(this);
  }
  return _u(this);
};
function oc(...e) {
  return Li.apply(this, e);
}
function ac(...e) {
  return Li.apply(this, e);
}
function vu(...e) {
  return Li.apply(this, e);
}
Object.setPrototypeOf(oc.prototype, Object.create(Int32Array.prototype));
Object.setPrototypeOf(ac.prototype, Object.create(Uint32Array.prototype));
Object.setPrototypeOf(vu.prototype, Object.create(Uint32Array.prototype));
Object.assign(oc.prototype, Li.prototype, { constructor: oc, signed: !0, TypedArray: Int32Array, BigIntArray: BigInt64Array });
Object.assign(ac.prototype, Li.prototype, { constructor: ac, signed: !1, TypedArray: Uint32Array, BigIntArray: BigUint64Array });
Object.assign(vu.prototype, Li.prototype, { constructor: vu, signed: !0, TypedArray: Uint32Array, BigIntArray: BigUint64Array });
function qI(e) {
  const { buffer: t, byteOffset: n, length: i, signed: r } = e, s = new BigUint64Array(t, n, i), o = r && s.at(-1) & BigInt(1) << BigInt(63);
  let a = BigInt(o ? 1 : 0), c = BigInt(0);
  if (o) {
    for (const l of s)
      a += ~l * (BigInt(1) << BigInt(32) * c++);
    a *= BigInt(-1);
  } else
    for (const l of s)
      a += l * (BigInt(1) << BigInt(32) * c++);
  return a;
}
const _u = (e) => {
  if (e.byteLength === 8)
    return `${new e.BigIntArray(e.buffer, e.byteOffset, 1)[0]}`;
  if (!e.signed)
    return em(e);
  let t = new Uint16Array(e.buffer, e.byteOffset, e.byteLength / 2);
  if (new Int16Array([t.at(-1)])[0] >= 0)
    return em(e);
  t = t.slice();
  let i = 1;
  for (let s = 0; s < t.length; s++) {
    const o = t[s], a = ~o + i;
    t[s] = a, i &= o === 0 ? 1 : 0;
  }
  return `-${em(t)}`;
}, HC = (e) => e.byteLength === 8 ? new e.BigIntArray(e.buffer, e.byteOffset, 1)[0] : _u(e);
function em(e) {
  let t = "";
  const n = new Uint32Array(2);
  let i = new Uint16Array(e.buffer, e.byteOffset, e.byteLength / 2);
  const r = new Uint32Array((i = new Uint16Array(i).reverse()).buffer);
  let s = -1;
  const o = i.length - 1;
  do {
    for (n[0] = i[s = 0]; s < o; )
      i[s++] = n[1] = n[0] / 10, n[0] = (n[0] - n[1] * 10 << 16) + i[s];
    i[s] = n[1] = n[0] / 10, n[0] = n[0] - n[1] * 10, t = `${n[0]}${t}`;
  } while (r[0] || r[1] || r[2] || r[3]);
  return t ?? "0";
}
let JC = class YI {
  /** @nocollapse */
  static new(t, n) {
    switch (n) {
      case !0:
        return new oc(t);
      case !1:
        return new ac(t);
    }
    switch (t.constructor) {
      case Int8Array:
      case Int16Array:
      case Int32Array:
      case BigInt64Array:
        return new oc(t);
    }
    return t.byteLength === 16 ? new vu(t) : new ac(t);
  }
  /** @nocollapse */
  static signed(t) {
    return new oc(t);
  }
  /** @nocollapse */
  static unsigned(t) {
    return new ac(t);
  }
  /** @nocollapse */
  static decimal(t) {
    return new vu(t);
  }
  constructor(t, n) {
    return YI.new(t, n);
  }
};
function pn(e) {
  if (typeof e == "bigint" && (e < Number.MIN_SAFE_INTEGER || e > Number.MAX_SAFE_INTEGER))
    throw new TypeError(`${e} is not safe to convert to a number.`);
  return Number(e);
}
var WI, GI, XI, HI, JI, KI, ZI, QI, tA, eA, nA, iA, rA, sA, oA, aA, cA, lA, uA, fA, hA, dA;
let rt = class _g {
  /** @nocollapse */
  static isNull(t) {
    return (t == null ? void 0 : t.typeId) === F.Null;
  }
  /** @nocollapse */
  static isInt(t) {
    return (t == null ? void 0 : t.typeId) === F.Int;
  }
  /** @nocollapse */
  static isFloat(t) {
    return (t == null ? void 0 : t.typeId) === F.Float;
  }
  /** @nocollapse */
  static isBinary(t) {
    return (t == null ? void 0 : t.typeId) === F.Binary;
  }
  /** @nocollapse */
  static isLargeBinary(t) {
    return (t == null ? void 0 : t.typeId) === F.LargeBinary;
  }
  /** @nocollapse */
  static isUtf8(t) {
    return (t == null ? void 0 : t.typeId) === F.Utf8;
  }
  /** @nocollapse */
  static isLargeUtf8(t) {
    return (t == null ? void 0 : t.typeId) === F.LargeUtf8;
  }
  /** @nocollapse */
  static isBool(t) {
    return (t == null ? void 0 : t.typeId) === F.Bool;
  }
  /** @nocollapse */
  static isDecimal(t) {
    return (t == null ? void 0 : t.typeId) === F.Decimal;
  }
  /** @nocollapse */
  static isDate(t) {
    return (t == null ? void 0 : t.typeId) === F.Date;
  }
  /** @nocollapse */
  static isTime(t) {
    return (t == null ? void 0 : t.typeId) === F.Time;
  }
  /** @nocollapse */
  static isTimestamp(t) {
    return (t == null ? void 0 : t.typeId) === F.Timestamp;
  }
  /** @nocollapse */
  static isInterval(t) {
    return (t == null ? void 0 : t.typeId) === F.Interval;
  }
  /** @nocollapse */
  static isDuration(t) {
    return (t == null ? void 0 : t.typeId) === F.Duration;
  }
  /** @nocollapse */
  static isList(t) {
    return (t == null ? void 0 : t.typeId) === F.List;
  }
  /** @nocollapse */
  static isStruct(t) {
    return (t == null ? void 0 : t.typeId) === F.Struct;
  }
  /** @nocollapse */
  static isUnion(t) {
    return (t == null ? void 0 : t.typeId) === F.Union;
  }
  /** @nocollapse */
  static isFixedSizeBinary(t) {
    return (t == null ? void 0 : t.typeId) === F.FixedSizeBinary;
  }
  /** @nocollapse */
  static isFixedSizeList(t) {
    return (t == null ? void 0 : t.typeId) === F.FixedSizeList;
  }
  /** @nocollapse */
  static isMap(t) {
    return (t == null ? void 0 : t.typeId) === F.Map;
  }
  /** @nocollapse */
  static isDictionary(t) {
    return (t == null ? void 0 : t.typeId) === F.Dictionary;
  }
  /** @nocollapse */
  static isDenseUnion(t) {
    return _g.isUnion(t) && t.mode === Mn.Dense;
  }
  /** @nocollapse */
  static isSparseUnion(t) {
    return _g.isUnion(t) && t.mode === Mn.Sparse;
  }
  constructor(t) {
    this.typeId = t;
  }
};
WI = Symbol.toStringTag;
rt[WI] = ((e) => (e.children = null, e.ArrayType = Array, e.OffsetArrayType = Int32Array, e[Symbol.toStringTag] = "DataType"))(rt.prototype);
let zs = class extends rt {
  constructor() {
    super(F.Null);
  }
  toString() {
    return "Null";
  }
};
GI = Symbol.toStringTag;
zs[GI] = ((e) => e[Symbol.toStringTag] = "Null")(zs.prototype);
let Ps = class extends rt {
  constructor(t, n) {
    super(F.Int), this.isSigned = t, this.bitWidth = n;
  }
  get ArrayType() {
    switch (this.bitWidth) {
      case 8:
        return this.isSigned ? Int8Array : Uint8Array;
      case 16:
        return this.isSigned ? Int16Array : Uint16Array;
      case 32:
        return this.isSigned ? Int32Array : Uint32Array;
      case 64:
        return this.isSigned ? BigInt64Array : BigUint64Array;
    }
    throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
  }
  toString() {
    return `${this.isSigned ? "I" : "Ui"}nt${this.bitWidth}`;
  }
};
XI = Symbol.toStringTag;
Ps[XI] = ((e) => (e.isSigned = null, e.bitWidth = null, e[Symbol.toStringTag] = "Int"))(Ps.prototype);
let Su = class extends Ps {
  constructor() {
    super(!0, 32);
  }
  get ArrayType() {
    return Int32Array;
  }
};
Object.defineProperty(Su.prototype, "ArrayType", { value: Int32Array });
let xu = class extends rt {
  constructor(t) {
    super(F.Float), this.precision = t;
  }
  get ArrayType() {
    switch (this.precision) {
      case nn.HALF:
        return Uint16Array;
      case nn.SINGLE:
        return Float32Array;
      case nn.DOUBLE:
        return Float64Array;
    }
    throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
  }
  toString() {
    return `Float${this.precision << 5 || 16}`;
  }
};
HI = Symbol.toStringTag;
xu[HI] = ((e) => (e.precision = null, e[Symbol.toStringTag] = "Float"))(xu.prototype);
let _d = class extends rt {
  constructor() {
    super(F.Binary);
  }
  toString() {
    return "Binary";
  }
};
JI = Symbol.toStringTag;
_d[JI] = ((e) => (e.ArrayType = Uint8Array, e[Symbol.toStringTag] = "Binary"))(_d.prototype);
let Sd = class extends rt {
  constructor() {
    super(F.LargeBinary);
  }
  toString() {
    return "LargeBinary";
  }
};
KI = Symbol.toStringTag;
Sd[KI] = ((e) => (e.ArrayType = Uint8Array, e.OffsetArrayType = BigInt64Array, e[Symbol.toStringTag] = "LargeBinary"))(Sd.prototype);
let xd = class extends rt {
  constructor() {
    super(F.Utf8);
  }
  toString() {
    return "Utf8";
  }
};
ZI = Symbol.toStringTag;
xd[ZI] = ((e) => (e.ArrayType = Uint8Array, e[Symbol.toStringTag] = "Utf8"))(xd.prototype);
let Id = class extends rt {
  constructor() {
    super(F.LargeUtf8);
  }
  toString() {
    return "LargeUtf8";
  }
};
QI = Symbol.toStringTag;
Id[QI] = ((e) => (e.ArrayType = Uint8Array, e.OffsetArrayType = BigInt64Array, e[Symbol.toStringTag] = "LargeUtf8"))(Id.prototype);
let Ad = class extends rt {
  constructor() {
    super(F.Bool);
  }
  toString() {
    return "Bool";
  }
};
tA = Symbol.toStringTag;
Ad[tA] = ((e) => (e.ArrayType = Uint8Array, e[Symbol.toStringTag] = "Bool"))(Ad.prototype);
let Md = class extends rt {
  constructor(t, n, i = 128) {
    super(F.Decimal), this.scale = t, this.precision = n, this.bitWidth = i;
  }
  toString() {
    return `Decimal[${this.precision}e${this.scale > 0 ? "+" : ""}${this.scale}]`;
  }
};
eA = Symbol.toStringTag;
Md[eA] = ((e) => (e.scale = null, e.precision = null, e.ArrayType = Uint32Array, e[Symbol.toStringTag] = "Decimal"))(Md.prototype);
let $d = class extends rt {
  constructor(t) {
    super(F.Date), this.unit = t;
  }
  toString() {
    return `Date${(this.unit + 1) * 32}<${Ai[this.unit]}>`;
  }
};
nA = Symbol.toStringTag;
$d[nA] = ((e) => (e.unit = null, e.ArrayType = Int32Array, e[Symbol.toStringTag] = "Date"))($d.prototype);
let Iu = class extends rt {
  constructor(t, n) {
    super(F.Time), this.unit = t, this.bitWidth = n;
  }
  toString() {
    return `Time${this.bitWidth}<${gt[this.unit]}>`;
  }
  get ArrayType() {
    switch (this.bitWidth) {
      case 32:
        return Int32Array;
      case 64:
        return BigInt64Array;
    }
    throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
  }
};
iA = Symbol.toStringTag;
Iu[iA] = ((e) => (e.unit = null, e.bitWidth = null, e[Symbol.toStringTag] = "Time"))(Iu.prototype);
let Td = class extends rt {
  constructor(t, n) {
    super(F.Timestamp), this.unit = t, this.timezone = n;
  }
  toString() {
    return `Timestamp<${gt[this.unit]}${this.timezone ? `, ${this.timezone}` : ""}>`;
  }
};
rA = Symbol.toStringTag;
Td[rA] = ((e) => (e.unit = null, e.timezone = null, e.ArrayType = Int32Array, e[Symbol.toStringTag] = "Timestamp"))(Td.prototype);
let Dd = class extends rt {
  constructor(t) {
    super(F.Interval), this.unit = t;
  }
  toString() {
    return `Interval<${lr[this.unit]}>`;
  }
};
sA = Symbol.toStringTag;
Dd[sA] = ((e) => (e.unit = null, e.ArrayType = Int32Array, e[Symbol.toStringTag] = "Interval"))(Dd.prototype);
let Nd = class extends rt {
  constructor(t) {
    super(F.Duration), this.unit = t;
  }
  toString() {
    return `Duration<${gt[this.unit]}>`;
  }
};
oA = Symbol.toStringTag;
Nd[oA] = ((e) => (e.unit = null, e.ArrayType = BigInt64Array, e[Symbol.toStringTag] = "Duration"))(Nd.prototype);
let Bd = class extends rt {
  constructor(t) {
    super(F.List), this.children = [t];
  }
  toString() {
    return `List<${this.valueType}>`;
  }
  get valueType() {
    return this.children[0].type;
  }
  get valueField() {
    return this.children[0];
  }
  get ArrayType() {
    return this.valueType.ArrayType;
  }
};
aA = Symbol.toStringTag;
Bd[aA] = ((e) => (e.children = null, e[Symbol.toStringTag] = "List"))(Bd.prototype);
let fn = class extends rt {
  constructor(t) {
    super(F.Struct), this.children = t;
  }
  toString() {
    return `Struct<{${this.children.map((t) => `${t.name}:${t.type}`).join(", ")}}>`;
  }
};
cA = Symbol.toStringTag;
fn[cA] = ((e) => (e.children = null, e[Symbol.toStringTag] = "Struct"))(fn.prototype);
let Od = class extends rt {
  constructor(t, n, i) {
    super(F.Union), this.mode = t, this.children = i, this.typeIds = n = Int32Array.from(n), this.typeIdToChildIndex = n.reduce((r, s, o) => (r[s] = o) && r || r, /* @__PURE__ */ Object.create(null));
  }
  toString() {
    return `${this[Symbol.toStringTag]}<${this.children.map((t) => `${t.type}`).join(" | ")}>`;
  }
};
lA = Symbol.toStringTag;
Od[lA] = ((e) => (e.mode = null, e.typeIds = null, e.children = null, e.typeIdToChildIndex = null, e.ArrayType = Int8Array, e[Symbol.toStringTag] = "Union"))(Od.prototype);
let Fd = class extends rt {
  constructor(t) {
    super(F.FixedSizeBinary), this.byteWidth = t;
  }
  toString() {
    return `FixedSizeBinary[${this.byteWidth}]`;
  }
};
uA = Symbol.toStringTag;
Fd[uA] = ((e) => (e.byteWidth = null, e.ArrayType = Uint8Array, e[Symbol.toStringTag] = "FixedSizeBinary"))(Fd.prototype);
let Ed = class extends rt {
  constructor(t, n) {
    super(F.FixedSizeList), this.listSize = t, this.children = [n];
  }
  get valueType() {
    return this.children[0].type;
  }
  get valueField() {
    return this.children[0];
  }
  get ArrayType() {
    return this.valueType.ArrayType;
  }
  toString() {
    return `FixedSizeList[${this.listSize}]<${this.valueType}>`;
  }
};
fA = Symbol.toStringTag;
Ed[fA] = ((e) => (e.children = null, e.listSize = null, e[Symbol.toStringTag] = "FixedSizeList"))(Ed.prototype);
let Ld = class extends rt {
  constructor(t, n = !1) {
    var i, r, s;
    if (super(F.Map), this.children = [t], this.keysSorted = n, t && (t.name = "entries", !((i = t == null ? void 0 : t.type) === null || i === void 0) && i.children)) {
      const o = (r = t == null ? void 0 : t.type) === null || r === void 0 ? void 0 : r.children[0];
      o && (o.name = "key");
      const a = (s = t == null ? void 0 : t.type) === null || s === void 0 ? void 0 : s.children[1];
      a && (a.name = "value");
    }
  }
  get keyType() {
    return this.children[0].type.children[0].type;
  }
  get valueType() {
    return this.children[0].type.children[1].type;
  }
  get childType() {
    return this.children[0].type;
  }
  toString() {
    return `Map<{${this.children[0].type.children.map((t) => `${t.name}:${t.type}`).join(", ")}}>`;
  }
};
hA = Symbol.toStringTag;
Ld[hA] = ((e) => (e.children = null, e.keysSorted = null, e[Symbol.toStringTag] = "Map_"))(Ld.prototype);
const KC = /* @__PURE__ */ ((e) => () => ++e)(-1);
let Ic = class extends rt {
  constructor(t, n, i, r) {
    super(F.Dictionary), this.indices = n, this.dictionary = t, this.isOrdered = r || !1, this.id = i == null ? KC() : pn(i);
  }
  get children() {
    return this.dictionary.children;
  }
  get valueType() {
    return this.dictionary;
  }
  get ArrayType() {
    return this.dictionary.ArrayType;
  }
  toString() {
    return `Dictionary<${this.indices}, ${this.dictionary}>`;
  }
};
dA = Symbol.toStringTag;
Ic[dA] = ((e) => (e.id = null, e.indices = null, e.isOrdered = null, e.dictionary = null, e[Symbol.toStringTag] = "Dictionary"))(Ic.prototype);
function Cr(e) {
  const t = e;
  switch (e.typeId) {
    case F.Decimal:
      return e.bitWidth / 32;
    case F.Timestamp:
      return 2;
    case F.Date:
      return 1 + t.unit;
    case F.Interval:
      return 1 + t.unit;
    case F.FixedSizeList:
      return t.listSize;
    case F.FixedSizeBinary:
      return t.byteWidth;
    default:
      return 1;
  }
}
let Ut = class {
  visitMany(t, ...n) {
    return t.map((i, r) => this.visit(i, ...n.map((s) => s[r])));
  }
  visit(...t) {
    return this.getVisitFn(t[0], !1).apply(this, t);
  }
  getVisitFn(t, n = !0) {
    return ZC(this, t, n);
  }
  getVisitFnByTypeId(t, n = !0) {
    return Ua(this, t, n);
  }
  visitNull(t, ...n) {
    return null;
  }
  visitBool(t, ...n) {
    return null;
  }
  visitInt(t, ...n) {
    return null;
  }
  visitFloat(t, ...n) {
    return null;
  }
  visitUtf8(t, ...n) {
    return null;
  }
  visitLargeUtf8(t, ...n) {
    return null;
  }
  visitBinary(t, ...n) {
    return null;
  }
  visitLargeBinary(t, ...n) {
    return null;
  }
  visitFixedSizeBinary(t, ...n) {
    return null;
  }
  visitDate(t, ...n) {
    return null;
  }
  visitTimestamp(t, ...n) {
    return null;
  }
  visitTime(t, ...n) {
    return null;
  }
  visitDecimal(t, ...n) {
    return null;
  }
  visitList(t, ...n) {
    return null;
  }
  visitStruct(t, ...n) {
    return null;
  }
  visitUnion(t, ...n) {
    return null;
  }
  visitDictionary(t, ...n) {
    return null;
  }
  visitInterval(t, ...n) {
    return null;
  }
  visitDuration(t, ...n) {
    return null;
  }
  visitFixedSizeList(t, ...n) {
    return null;
  }
  visitMap(t, ...n) {
    return null;
  }
};
function ZC(e, t, n = !0) {
  return typeof t == "number" ? Ua(e, t, n) : typeof t == "string" && t in F ? Ua(e, F[t], n) : t && t instanceof rt ? Ua(e, z_(t), n) : t != null && t.type && t.type instanceof rt ? Ua(e, z_(t.type), n) : Ua(e, F.NONE, n);
}
function Ua(e, t, n = !0) {
  let i = null;
  switch (t) {
    case F.Null:
      i = e.visitNull;
      break;
    case F.Bool:
      i = e.visitBool;
      break;
    case F.Int:
      i = e.visitInt;
      break;
    case F.Int8:
      i = e.visitInt8 || e.visitInt;
      break;
    case F.Int16:
      i = e.visitInt16 || e.visitInt;
      break;
    case F.Int32:
      i = e.visitInt32 || e.visitInt;
      break;
    case F.Int64:
      i = e.visitInt64 || e.visitInt;
      break;
    case F.Uint8:
      i = e.visitUint8 || e.visitInt;
      break;
    case F.Uint16:
      i = e.visitUint16 || e.visitInt;
      break;
    case F.Uint32:
      i = e.visitUint32 || e.visitInt;
      break;
    case F.Uint64:
      i = e.visitUint64 || e.visitInt;
      break;
    case F.Float:
      i = e.visitFloat;
      break;
    case F.Float16:
      i = e.visitFloat16 || e.visitFloat;
      break;
    case F.Float32:
      i = e.visitFloat32 || e.visitFloat;
      break;
    case F.Float64:
      i = e.visitFloat64 || e.visitFloat;
      break;
    case F.Utf8:
      i = e.visitUtf8;
      break;
    case F.LargeUtf8:
      i = e.visitLargeUtf8;
      break;
    case F.Binary:
      i = e.visitBinary;
      break;
    case F.LargeBinary:
      i = e.visitLargeBinary;
      break;
    case F.FixedSizeBinary:
      i = e.visitFixedSizeBinary;
      break;
    case F.Date:
      i = e.visitDate;
      break;
    case F.DateDay:
      i = e.visitDateDay || e.visitDate;
      break;
    case F.DateMillisecond:
      i = e.visitDateMillisecond || e.visitDate;
      break;
    case F.Timestamp:
      i = e.visitTimestamp;
      break;
    case F.TimestampSecond:
      i = e.visitTimestampSecond || e.visitTimestamp;
      break;
    case F.TimestampMillisecond:
      i = e.visitTimestampMillisecond || e.visitTimestamp;
      break;
    case F.TimestampMicrosecond:
      i = e.visitTimestampMicrosecond || e.visitTimestamp;
      break;
    case F.TimestampNanosecond:
      i = e.visitTimestampNanosecond || e.visitTimestamp;
      break;
    case F.Time:
      i = e.visitTime;
      break;
    case F.TimeSecond:
      i = e.visitTimeSecond || e.visitTime;
      break;
    case F.TimeMillisecond:
      i = e.visitTimeMillisecond || e.visitTime;
      break;
    case F.TimeMicrosecond:
      i = e.visitTimeMicrosecond || e.visitTime;
      break;
    case F.TimeNanosecond:
      i = e.visitTimeNanosecond || e.visitTime;
      break;
    case F.Decimal:
      i = e.visitDecimal;
      break;
    case F.List:
      i = e.visitList;
      break;
    case F.Struct:
      i = e.visitStruct;
      break;
    case F.Union:
      i = e.visitUnion;
      break;
    case F.DenseUnion:
      i = e.visitDenseUnion || e.visitUnion;
      break;
    case F.SparseUnion:
      i = e.visitSparseUnion || e.visitUnion;
      break;
    case F.Dictionary:
      i = e.visitDictionary;
      break;
    case F.Interval:
      i = e.visitInterval;
      break;
    case F.IntervalDayTime:
      i = e.visitIntervalDayTime || e.visitInterval;
      break;
    case F.IntervalYearMonth:
      i = e.visitIntervalYearMonth || e.visitInterval;
      break;
    case F.Duration:
      i = e.visitDuration;
      break;
    case F.DurationSecond:
      i = e.visitDurationSecond || e.visitDuration;
      break;
    case F.DurationMillisecond:
      i = e.visitDurationMillisecond || e.visitDuration;
      break;
    case F.DurationMicrosecond:
      i = e.visitDurationMicrosecond || e.visitDuration;
      break;
    case F.DurationNanosecond:
      i = e.visitDurationNanosecond || e.visitDuration;
      break;
    case F.FixedSizeList:
      i = e.visitFixedSizeList;
      break;
    case F.Map:
      i = e.visitMap;
      break;
  }
  if (typeof i == "function")
    return i;
  if (!n)
    return () => null;
  throw new Error(`Unrecognized type '${F[t]}'`);
}
function z_(e) {
  switch (e.typeId) {
    case F.Null:
      return F.Null;
    case F.Int: {
      const { bitWidth: t, isSigned: n } = e;
      switch (t) {
        case 8:
          return n ? F.Int8 : F.Uint8;
        case 16:
          return n ? F.Int16 : F.Uint16;
        case 32:
          return n ? F.Int32 : F.Uint32;
        case 64:
          return n ? F.Int64 : F.Uint64;
      }
      return F.Int;
    }
    case F.Float:
      switch (e.precision) {
        case nn.HALF:
          return F.Float16;
        case nn.SINGLE:
          return F.Float32;
        case nn.DOUBLE:
          return F.Float64;
      }
      return F.Float;
    case F.Binary:
      return F.Binary;
    case F.LargeBinary:
      return F.LargeBinary;
    case F.Utf8:
      return F.Utf8;
    case F.LargeUtf8:
      return F.LargeUtf8;
    case F.Bool:
      return F.Bool;
    case F.Decimal:
      return F.Decimal;
    case F.Time:
      switch (e.unit) {
        case gt.SECOND:
          return F.TimeSecond;
        case gt.MILLISECOND:
          return F.TimeMillisecond;
        case gt.MICROSECOND:
          return F.TimeMicrosecond;
        case gt.NANOSECOND:
          return F.TimeNanosecond;
      }
      return F.Time;
    case F.Timestamp:
      switch (e.unit) {
        case gt.SECOND:
          return F.TimestampSecond;
        case gt.MILLISECOND:
          return F.TimestampMillisecond;
        case gt.MICROSECOND:
          return F.TimestampMicrosecond;
        case gt.NANOSECOND:
          return F.TimestampNanosecond;
      }
      return F.Timestamp;
    case F.Date:
      switch (e.unit) {
        case Ai.DAY:
          return F.DateDay;
        case Ai.MILLISECOND:
          return F.DateMillisecond;
      }
      return F.Date;
    case F.Interval:
      switch (e.unit) {
        case lr.DAY_TIME:
          return F.IntervalDayTime;
        case lr.YEAR_MONTH:
          return F.IntervalYearMonth;
      }
      return F.Interval;
    case F.Duration:
      switch (e.unit) {
        case gt.SECOND:
          return F.DurationSecond;
        case gt.MILLISECOND:
          return F.DurationMillisecond;
        case gt.MICROSECOND:
          return F.DurationMicrosecond;
        case gt.NANOSECOND:
          return F.DurationNanosecond;
      }
      return F.Duration;
    case F.Map:
      return F.Map;
    case F.List:
      return F.List;
    case F.Struct:
      return F.Struct;
    case F.Union:
      switch (e.mode) {
        case Mn.Dense:
          return F.DenseUnion;
        case Mn.Sparse:
          return F.SparseUnion;
      }
      return F.Union;
    case F.FixedSizeBinary:
      return F.FixedSizeBinary;
    case F.FixedSizeList:
      return F.FixedSizeList;
    case F.Dictionary:
      return F.Dictionary;
  }
  throw new Error(`Unrecognized type '${F[e.typeId]}'`);
}
Ut.prototype.visitInt8 = null;
Ut.prototype.visitInt16 = null;
Ut.prototype.visitInt32 = null;
Ut.prototype.visitInt64 = null;
Ut.prototype.visitUint8 = null;
Ut.prototype.visitUint16 = null;
Ut.prototype.visitUint32 = null;
Ut.prototype.visitUint64 = null;
Ut.prototype.visitFloat16 = null;
Ut.prototype.visitFloat32 = null;
Ut.prototype.visitFloat64 = null;
Ut.prototype.visitDateDay = null;
Ut.prototype.visitDateMillisecond = null;
Ut.prototype.visitTimestampSecond = null;
Ut.prototype.visitTimestampMillisecond = null;
Ut.prototype.visitTimestampMicrosecond = null;
Ut.prototype.visitTimestampNanosecond = null;
Ut.prototype.visitTimeSecond = null;
Ut.prototype.visitTimeMillisecond = null;
Ut.prototype.visitTimeMicrosecond = null;
Ut.prototype.visitTimeNanosecond = null;
Ut.prototype.visitDenseUnion = null;
Ut.prototype.visitSparseUnion = null;
Ut.prototype.visitIntervalDayTime = null;
Ut.prototype.visitIntervalYearMonth = null;
Ut.prototype.visitDuration = null;
Ut.prototype.visitDurationSecond = null;
Ut.prototype.visitDurationMillisecond = null;
Ut.prototype.visitDurationMicrosecond = null;
Ut.prototype.visitDurationNanosecond = null;
const pA = new Float64Array(1), ma = new Uint32Array(pA.buffer);
function yA(e) {
  const t = (e & 31744) >> 10, n = (e & 1023) / 1024, i = Math.pow(-1, (e & 32768) >> 15);
  switch (t) {
    case 31:
      return i * (n ? Number.NaN : 1 / 0);
    case 0:
      return i * (n ? 6103515625e-14 * n : 0);
  }
  return i * Math.pow(2, t - 15) * (1 + n);
}
function QC(e) {
  if (e !== e)
    return 32256;
  pA[0] = e;
  const t = (ma[1] & 2147483648) >> 16 & 65535;
  let n = ma[1] & 2146435072, i = 0;
  return n >= 1089470464 ? ma[0] > 0 ? n = 31744 : (n = (n & 2080374784) >> 16, i = (ma[1] & 1048575) >> 10) : n <= 1056964608 ? (i = 1048576 + (ma[1] & 1048575), i = 1048576 + (i << (n >> 20) - 998) >> 21, n = 0) : (n = n - 1056964608 >> 10, i = (ma[1] & 1048575) + 512 >> 10), t | n | i & 65535;
}
let vt = class extends Ut {
};
function Dt(e) {
  return (t, n, i) => {
    if (t.setValid(n, i != null))
      return e(t, n, i);
  };
}
const tk = (e, t, n) => {
  e[t] = Math.trunc(n / 864e5);
}, mb = (e, t, n) => {
  e[t] = Math.trunc(n % 4294967296), e[t + 1] = Math.trunc(n / 4294967296);
}, ek = (e, t, n) => {
  e[t] = Math.trunc(n * 1e3 % 4294967296), e[t + 1] = Math.trunc(n * 1e3 / 4294967296);
}, nk = (e, t, n) => {
  e[t] = Math.trunc(n * 1e6 % 4294967296), e[t + 1] = Math.trunc(n * 1e6 / 4294967296);
}, mA = (e, t, n, i) => {
  if (n + 1 < t.length) {
    const r = pn(t[n]), s = pn(t[n + 1]);
    e.set(i.subarray(0, s - r), r);
  }
}, ik = ({ offset: e, values: t }, n, i) => {
  const r = e + n;
  i ? t[r >> 3] |= 1 << r % 8 : t[r >> 3] &= ~(1 << r % 8);
}, cs = ({ values: e }, t, n) => {
  e[t] = n;
}, gb = ({ values: e }, t, n) => {
  e[t] = n;
}, gA = ({ values: e }, t, n) => {
  e[t] = QC(n);
}, rk = (e, t, n) => {
  switch (e.type.precision) {
    case nn.HALF:
      return gA(e, t, n);
    case nn.SINGLE:
    case nn.DOUBLE:
      return gb(e, t, n);
  }
}, bA = ({ values: e }, t, n) => {
  tk(e, t, n.valueOf());
}, wA = ({ values: e }, t, n) => {
  mb(e, t * 2, n.valueOf());
}, sk = ({ stride: e, values: t }, n, i) => {
  t.set(i.subarray(0, e), e * n);
}, vA = ({ values: e, valueOffsets: t }, n, i) => mA(e, t, n, i), _A = ({ values: e, valueOffsets: t }, n, i) => mA(e, t, n, hb(i)), ok = (e, t, n) => {
  e.type.unit === Ai.DAY ? bA(e, t, n) : wA(e, t, n);
}, SA = ({ values: e }, t, n) => mb(e, t * 2, n / 1e3), xA = ({ values: e }, t, n) => mb(e, t * 2, n), IA = ({ values: e }, t, n) => ek(e, t * 2, n), AA = ({ values: e }, t, n) => nk(e, t * 2, n), ak = (e, t, n) => {
  switch (e.type.unit) {
    case gt.SECOND:
      return SA(e, t, n);
    case gt.MILLISECOND:
      return xA(e, t, n);
    case gt.MICROSECOND:
      return IA(e, t, n);
    case gt.NANOSECOND:
      return AA(e, t, n);
  }
}, MA = ({ values: e }, t, n) => {
  e[t] = n;
}, $A = ({ values: e }, t, n) => {
  e[t] = n;
}, TA = ({ values: e }, t, n) => {
  e[t] = n;
}, DA = ({ values: e }, t, n) => {
  e[t] = n;
}, ck = (e, t, n) => {
  switch (e.type.unit) {
    case gt.SECOND:
      return MA(e, t, n);
    case gt.MILLISECOND:
      return $A(e, t, n);
    case gt.MICROSECOND:
      return TA(e, t, n);
    case gt.NANOSECOND:
      return DA(e, t, n);
  }
}, lk = ({ values: e, stride: t }, n, i) => {
  e.set(i.subarray(0, t), t * n);
}, uk = (e, t, n) => {
  const i = e.children[0], r = e.valueOffsets, s = li.getVisitFn(i);
  if (Array.isArray(n))
    for (let o = -1, a = r[t], c = r[t + 1]; a < c; )
      s(i, a++, n[++o]);
  else
    for (let o = -1, a = r[t], c = r[t + 1]; a < c; )
      s(i, a++, n.get(++o));
}, fk = (e, t, n) => {
  const i = e.children[0], { valueOffsets: r } = e, s = li.getVisitFn(i);
  let { [t]: o, [t + 1]: a } = r;
  const c = n instanceof Map ? n.entries() : Object.entries(n);
  for (const l of c)
    if (s(i, o, l), ++o >= a)
      break;
}, hk = (e, t) => (n, i, r, s) => i && n(i, e, t[s]), dk = (e, t) => (n, i, r, s) => i && n(i, e, t.get(s)), pk = (e, t) => (n, i, r, s) => i && n(i, e, t.get(r.name)), yk = (e, t) => (n, i, r, s) => i && n(i, e, t[r.name]), mk = (e, t, n) => {
  const i = e.type.children.map((s) => li.getVisitFn(s.type)), r = n instanceof Map ? pk(t, n) : n instanceof Ne ? dk(t, n) : Array.isArray(n) ? hk(t, n) : yk(t, n);
  e.type.children.forEach((s, o) => r(i[o], e.children[o], s, o));
}, gk = (e, t, n) => {
  e.type.mode === Mn.Dense ? NA(e, t, n) : BA(e, t, n);
}, NA = (e, t, n) => {
  const i = e.type.typeIdToChildIndex[e.typeIds[t]], r = e.children[i];
  li.visit(r, e.valueOffsets[t], n);
}, BA = (e, t, n) => {
  const i = e.type.typeIdToChildIndex[e.typeIds[t]], r = e.children[i];
  li.visit(r, t, n);
}, bk = (e, t, n) => {
  var i;
  (i = e.dictionary) === null || i === void 0 || i.set(e.values[t], n);
}, wk = (e, t, n) => {
  e.type.unit === lr.DAY_TIME ? OA(e, t, n) : FA(e, t, n);
}, OA = ({ values: e }, t, n) => {
  e.set(n.subarray(0, 2), 2 * t);
}, FA = ({ values: e }, t, n) => {
  e[t] = n[0] * 12 + n[1] % 12;
}, EA = ({ values: e }, t, n) => {
  e[t] = n;
}, LA = ({ values: e }, t, n) => {
  e[t] = n;
}, RA = ({ values: e }, t, n) => {
  e[t] = n;
}, CA = ({ values: e }, t, n) => {
  e[t] = n;
}, vk = (e, t, n) => {
  switch (e.type.unit) {
    case gt.SECOND:
      return EA(e, t, n);
    case gt.MILLISECOND:
      return LA(e, t, n);
    case gt.MICROSECOND:
      return RA(e, t, n);
    case gt.NANOSECOND:
      return CA(e, t, n);
  }
}, _k = (e, t, n) => {
  const { stride: i } = e, r = e.children[0], s = li.getVisitFn(r);
  if (Array.isArray(n))
    for (let o = -1, a = t * i; ++o < i; )
      s(r, a + o, n[o]);
  else
    for (let o = -1, a = t * i; ++o < i; )
      s(r, a + o, n.get(o));
};
vt.prototype.visitBool = Dt(ik);
vt.prototype.visitInt = Dt(cs);
vt.prototype.visitInt8 = Dt(cs);
vt.prototype.visitInt16 = Dt(cs);
vt.prototype.visitInt32 = Dt(cs);
vt.prototype.visitInt64 = Dt(cs);
vt.prototype.visitUint8 = Dt(cs);
vt.prototype.visitUint16 = Dt(cs);
vt.prototype.visitUint32 = Dt(cs);
vt.prototype.visitUint64 = Dt(cs);
vt.prototype.visitFloat = Dt(rk);
vt.prototype.visitFloat16 = Dt(gA);
vt.prototype.visitFloat32 = Dt(gb);
vt.prototype.visitFloat64 = Dt(gb);
vt.prototype.visitUtf8 = Dt(_A);
vt.prototype.visitLargeUtf8 = Dt(_A);
vt.prototype.visitBinary = Dt(vA);
vt.prototype.visitLargeBinary = Dt(vA);
vt.prototype.visitFixedSizeBinary = Dt(sk);
vt.prototype.visitDate = Dt(ok);
vt.prototype.visitDateDay = Dt(bA);
vt.prototype.visitDateMillisecond = Dt(wA);
vt.prototype.visitTimestamp = Dt(ak);
vt.prototype.visitTimestampSecond = Dt(SA);
vt.prototype.visitTimestampMillisecond = Dt(xA);
vt.prototype.visitTimestampMicrosecond = Dt(IA);
vt.prototype.visitTimestampNanosecond = Dt(AA);
vt.prototype.visitTime = Dt(ck);
vt.prototype.visitTimeSecond = Dt(MA);
vt.prototype.visitTimeMillisecond = Dt($A);
vt.prototype.visitTimeMicrosecond = Dt(TA);
vt.prototype.visitTimeNanosecond = Dt(DA);
vt.prototype.visitDecimal = Dt(lk);
vt.prototype.visitList = Dt(uk);
vt.prototype.visitStruct = Dt(mk);
vt.prototype.visitUnion = Dt(gk);
vt.prototype.visitDenseUnion = Dt(NA);
vt.prototype.visitSparseUnion = Dt(BA);
vt.prototype.visitDictionary = Dt(bk);
vt.prototype.visitInterval = Dt(wk);
vt.prototype.visitIntervalDayTime = Dt(OA);
vt.prototype.visitIntervalYearMonth = Dt(FA);
vt.prototype.visitDuration = Dt(vk);
vt.prototype.visitDurationSecond = Dt(EA);
vt.prototype.visitDurationMillisecond = Dt(LA);
vt.prototype.visitDurationMicrosecond = Dt(RA);
vt.prototype.visitDurationNanosecond = Dt(CA);
vt.prototype.visitFixedSizeList = Dt(_k);
vt.prototype.visitMap = Dt(fk);
const li = new vt(), yi = Symbol.for("parent"), cc = Symbol.for("rowIndex");
let bb = class {
  constructor(t, n) {
    return this[yi] = t, this[cc] = n, new Proxy(this, new xk());
  }
  toArray() {
    return Object.values(this.toJSON());
  }
  toJSON() {
    const t = this[cc], n = this[yi], i = n.type.children, r = {};
    for (let s = -1, o = i.length; ++s < o; )
      r[i[s].name] = $n.visit(n.children[s], t);
    return r;
  }
  toString() {
    return `{${[...this].map(([t, n]) => `${wu(t)}: ${wu(n)}`).join(", ")}}`;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.toString();
  }
  [Symbol.iterator]() {
    return new Sk(this[yi], this[cc]);
  }
}, Sk = class {
  constructor(t, n) {
    this.childIndex = 0, this.children = t.children, this.rowIndex = n, this.childFields = t.type.children, this.numChildren = this.childFields.length;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const t = this.childIndex;
    return t < this.numChildren ? (this.childIndex = t + 1, {
      done: !1,
      value: [
        this.childFields[t].name,
        $n.visit(this.children[t], this.rowIndex)
      ]
    }) : { done: !0, value: null };
  }
};
Object.defineProperties(bb.prototype, {
  [Symbol.toStringTag]: { enumerable: !1, configurable: !1, value: "Row" },
  [yi]: { writable: !0, enumerable: !1, configurable: !1, value: null },
  [cc]: { writable: !0, enumerable: !1, configurable: !1, value: -1 }
});
let xk = class {
  isExtensible() {
    return !1;
  }
  deleteProperty() {
    return !1;
  }
  preventExtensions() {
    return !0;
  }
  ownKeys(t) {
    return t[yi].type.children.map((n) => n.name);
  }
  has(t, n) {
    return t[yi].type.children.findIndex((i) => i.name === n) !== -1;
  }
  getOwnPropertyDescriptor(t, n) {
    if (t[yi].type.children.findIndex((i) => i.name === n) !== -1)
      return { writable: !0, enumerable: !0, configurable: !0 };
  }
  get(t, n) {
    if (Reflect.has(t, n))
      return t[n];
    const i = t[yi].type.children.findIndex((r) => r.name === n);
    if (i !== -1) {
      const r = $n.visit(t[yi].children[i], t[cc]);
      return Reflect.set(t, n, r), r;
    }
  }
  set(t, n, i) {
    const r = t[yi].type.children.findIndex((s) => s.name === n);
    return r !== -1 ? (li.visit(t[yi].children[r], t[cc], i), Reflect.set(t, n, i)) : Reflect.has(t, n) || typeof n == "symbol" ? Reflect.set(t, n, i) : !1;
  }
}, ct = class extends Ut {
};
function _t(e) {
  return (t, n) => t.getValid(n) ? e(t, n) : null;
}
const Ik = (e, t) => 864e5 * e[t], wb = (e, t) => 4294967296 * e[t + 1] + (e[t] >>> 0), Ak = (e, t) => 4294967296 * (e[t + 1] / 1e3) + (e[t] >>> 0) / 1e3, Mk = (e, t) => 4294967296 * (e[t + 1] / 1e6) + (e[t] >>> 0) / 1e6, kA = (e) => new Date(e), $k = (e, t) => kA(Ik(e, t)), Tk = (e, t) => kA(wb(e, t)), Dk = (e, t) => null, UA = (e, t, n) => {
  if (n + 1 >= t.length)
    return null;
  const i = pn(t[n]), r = pn(t[n + 1]);
  return e.subarray(i, r);
}, Nk = ({ offset: e, values: t }, n) => {
  const i = e + n;
  return (t[i >> 3] & 1 << i % 8) !== 0;
}, zA = ({ values: e }, t) => $k(e, t), PA = ({ values: e }, t) => Tk(e, t * 2), io = ({ stride: e, values: t }, n) => t[e * n], Bk = ({ stride: e, values: t }, n) => yA(t[e * n]), VA = ({ values: e }, t) => e[t], Ok = ({ stride: e, values: t }, n) => t.subarray(e * n, e * (n + 1)), jA = ({ values: e, valueOffsets: t }, n) => UA(e, t, n), qA = ({ values: e, valueOffsets: t }, n) => {
  const i = UA(e, t, n);
  return i !== null ? pg(i) : null;
}, Fk = ({ values: e }, t) => e[t], Ek = ({ type: e, values: t }, n) => e.precision !== nn.HALF ? t[n] : yA(t[n]), Lk = (e, t) => e.type.unit === Ai.DAY ? zA(e, t) : PA(e, t), YA = ({ values: e }, t) => 1e3 * wb(e, t * 2), WA = ({ values: e }, t) => wb(e, t * 2), GA = ({ values: e }, t) => Ak(e, t * 2), XA = ({ values: e }, t) => Mk(e, t * 2), Rk = (e, t) => {
  switch (e.type.unit) {
    case gt.SECOND:
      return YA(e, t);
    case gt.MILLISECOND:
      return WA(e, t);
    case gt.MICROSECOND:
      return GA(e, t);
    case gt.NANOSECOND:
      return XA(e, t);
  }
}, HA = ({ values: e }, t) => e[t], JA = ({ values: e }, t) => e[t], KA = ({ values: e }, t) => e[t], ZA = ({ values: e }, t) => e[t], Ck = (e, t) => {
  switch (e.type.unit) {
    case gt.SECOND:
      return HA(e, t);
    case gt.MILLISECOND:
      return JA(e, t);
    case gt.MICROSECOND:
      return KA(e, t);
    case gt.NANOSECOND:
      return ZA(e, t);
  }
}, kk = ({ values: e, stride: t }, n) => JC.decimal(e.subarray(t * n, t * (n + 1))), Uk = (e, t) => {
  const { valueOffsets: n, stride: i, children: r } = e, { [t * i]: s, [t * i + 1]: o } = n, c = r[0].slice(s, o - s);
  return new Ne([c]);
}, zk = (e, t) => {
  const { valueOffsets: n, children: i } = e, { [t]: r, [t + 1]: s } = n, o = i[0];
  return new vb(o.slice(r, s - r));
}, Pk = (e, t) => new bb(e, t), Vk = (e, t) => e.type.mode === Mn.Dense ? QA(e, t) : t3(e, t), QA = (e, t) => {
  const n = e.type.typeIdToChildIndex[e.typeIds[t]], i = e.children[n];
  return $n.visit(i, e.valueOffsets[t]);
}, t3 = (e, t) => {
  const n = e.type.typeIdToChildIndex[e.typeIds[t]], i = e.children[n];
  return $n.visit(i, t);
}, jk = (e, t) => {
  var n;
  return (n = e.dictionary) === null || n === void 0 ? void 0 : n.get(e.values[t]);
}, qk = (e, t) => e.type.unit === lr.DAY_TIME ? e3(e, t) : n3(e, t), e3 = ({ values: e }, t) => e.subarray(2 * t, 2 * (t + 1)), n3 = ({ values: e }, t) => {
  const n = e[t], i = new Int32Array(2);
  return i[0] = Math.trunc(n / 12), i[1] = Math.trunc(n % 12), i;
}, i3 = ({ values: e }, t) => e[t], r3 = ({ values: e }, t) => e[t], s3 = ({ values: e }, t) => e[t], o3 = ({ values: e }, t) => e[t], Yk = (e, t) => {
  switch (e.type.unit) {
    case gt.SECOND:
      return i3(e, t);
    case gt.MILLISECOND:
      return r3(e, t);
    case gt.MICROSECOND:
      return s3(e, t);
    case gt.NANOSECOND:
      return o3(e, t);
  }
}, Wk = (e, t) => {
  const { stride: n, children: i } = e, s = i[0].slice(t * n, n);
  return new Ne([s]);
};
ct.prototype.visitNull = _t(Dk);
ct.prototype.visitBool = _t(Nk);
ct.prototype.visitInt = _t(Fk);
ct.prototype.visitInt8 = _t(io);
ct.prototype.visitInt16 = _t(io);
ct.prototype.visitInt32 = _t(io);
ct.prototype.visitInt64 = _t(VA);
ct.prototype.visitUint8 = _t(io);
ct.prototype.visitUint16 = _t(io);
ct.prototype.visitUint32 = _t(io);
ct.prototype.visitUint64 = _t(VA);
ct.prototype.visitFloat = _t(Ek);
ct.prototype.visitFloat16 = _t(Bk);
ct.prototype.visitFloat32 = _t(io);
ct.prototype.visitFloat64 = _t(io);
ct.prototype.visitUtf8 = _t(qA);
ct.prototype.visitLargeUtf8 = _t(qA);
ct.prototype.visitBinary = _t(jA);
ct.prototype.visitLargeBinary = _t(jA);
ct.prototype.visitFixedSizeBinary = _t(Ok);
ct.prototype.visitDate = _t(Lk);
ct.prototype.visitDateDay = _t(zA);
ct.prototype.visitDateMillisecond = _t(PA);
ct.prototype.visitTimestamp = _t(Rk);
ct.prototype.visitTimestampSecond = _t(YA);
ct.prototype.visitTimestampMillisecond = _t(WA);
ct.prototype.visitTimestampMicrosecond = _t(GA);
ct.prototype.visitTimestampNanosecond = _t(XA);
ct.prototype.visitTime = _t(Ck);
ct.prototype.visitTimeSecond = _t(HA);
ct.prototype.visitTimeMillisecond = _t(JA);
ct.prototype.visitTimeMicrosecond = _t(KA);
ct.prototype.visitTimeNanosecond = _t(ZA);
ct.prototype.visitDecimal = _t(kk);
ct.prototype.visitList = _t(Uk);
ct.prototype.visitStruct = _t(Pk);
ct.prototype.visitUnion = _t(Vk);
ct.prototype.visitDenseUnion = _t(QA);
ct.prototype.visitSparseUnion = _t(t3);
ct.prototype.visitDictionary = _t(jk);
ct.prototype.visitInterval = _t(qk);
ct.prototype.visitIntervalDayTime = _t(e3);
ct.prototype.visitIntervalYearMonth = _t(n3);
ct.prototype.visitDuration = _t(Yk);
ct.prototype.visitDurationSecond = _t(i3);
ct.prototype.visitDurationMillisecond = _t(r3);
ct.prototype.visitDurationMicrosecond = _t(s3);
ct.prototype.visitDurationNanosecond = _t(o3);
ct.prototype.visitFixedSizeList = _t(Wk);
ct.prototype.visitMap = _t(zk);
const $n = new ct(), Ki = Symbol.for("keys"), lc = Symbol.for("vals");
let vb = class {
  constructor(t) {
    return this[Ki] = new Ne([t.children[0]]).memoize(), this[lc] = t.children[1], new Proxy(this, new Xk());
  }
  [Symbol.iterator]() {
    return new Gk(this[Ki], this[lc]);
  }
  get size() {
    return this[Ki].length;
  }
  toArray() {
    return Object.values(this.toJSON());
  }
  toJSON() {
    const t = this[Ki], n = this[lc], i = {};
    for (let r = -1, s = t.length; ++r < s; )
      i[t.get(r)] = $n.visit(n, r);
    return i;
  }
  toString() {
    return `{${[...this].map(([t, n]) => `${wu(t)}: ${wu(n)}`).join(", ")}}`;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.toString();
  }
}, Gk = class {
  constructor(t, n) {
    this.keys = t, this.vals = n, this.keyIndex = 0, this.numKeys = t.length;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const t = this.keyIndex;
    return t === this.numKeys ? { done: !0, value: null } : (this.keyIndex++, {
      done: !1,
      value: [
        this.keys.get(t),
        $n.visit(this.vals, t)
      ]
    });
  }
}, Xk = class {
  isExtensible() {
    return !1;
  }
  deleteProperty() {
    return !1;
  }
  preventExtensions() {
    return !0;
  }
  ownKeys(t) {
    return t[Ki].toArray().map(String);
  }
  has(t, n) {
    return t[Ki].includes(n);
  }
  getOwnPropertyDescriptor(t, n) {
    if (t[Ki].indexOf(n) !== -1)
      return { writable: !0, enumerable: !0, configurable: !0 };
  }
  get(t, n) {
    if (Reflect.has(t, n))
      return t[n];
    const i = t[Ki].indexOf(n);
    if (i !== -1) {
      const r = $n.visit(Reflect.get(t, lc), i);
      return Reflect.set(t, n, r), r;
    }
  }
  set(t, n, i) {
    const r = t[Ki].indexOf(n);
    return r !== -1 ? (li.visit(Reflect.get(t, lc), r, i), Reflect.set(t, n, i)) : Reflect.has(t, n) ? Reflect.set(t, n, i) : !1;
  }
};
Object.defineProperties(vb.prototype, {
  [Symbol.toStringTag]: { enumerable: !1, configurable: !1, value: "Row" },
  [Ki]: { writable: !0, enumerable: !1, configurable: !1, value: null },
  [lc]: { writable: !0, enumerable: !1, configurable: !1, value: null }
});
let P_;
function a3(e, t, n, i) {
  const { length: r = 0 } = e;
  let s = typeof t != "number" ? 0 : t, o = typeof n != "number" ? r : n;
  return s < 0 && (s = (s % r + r) % r), o < 0 && (o = (o % r + r) % r), o < s && (P_ = s, s = o, o = P_), o > r && (o = r), i ? i(e, s, o) : [s, o];
}
const V_ = (e) => e !== e;
function Zc(e) {
  if (typeof e !== "object" || e === null)
    return V_(e) ? V_ : (n) => n === e;
  if (e instanceof Date) {
    const n = e.valueOf();
    return (i) => i instanceof Date ? i.valueOf() === n : !1;
  }
  return ArrayBuffer.isView(e) ? (n) => n ? zC(e, n) : !1 : e instanceof Map ? Jk(e) : Array.isArray(e) ? Hk(e) : e instanceof Ne ? Kk(e) : Zk(e, !0);
}
function Hk(e) {
  const t = [];
  for (let n = -1, i = e.length; ++n < i; )
    t[n] = Zc(e[n]);
  return Cy(t);
}
function Jk(e) {
  let t = -1;
  const n = [];
  for (const i of e.values())
    n[++t] = Zc(i);
  return Cy(n);
}
function Kk(e) {
  const t = [];
  for (let n = -1, i = e.length; ++n < i; )
    t[n] = Zc(e.get(n));
  return Cy(t);
}
function Zk(e, t = !1) {
  const n = Object.keys(e);
  if (!t && n.length === 0)
    return () => !1;
  const i = [];
  for (let r = -1, s = n.length; ++r < s; )
    i[r] = Zc(e[n[r]]);
  return Cy(i, n);
}
function Cy(e, t) {
  return (n) => {
    if (!n || typeof n != "object")
      return !1;
    switch (n.constructor) {
      case Array:
        return Qk(e, n);
      case Map:
        return j_(e, n, n.keys());
      case vb:
      case bb:
      case Object:
      case void 0:
        return j_(e, n, t || Object.keys(n));
    }
    return n instanceof Ne ? t7(e, n) : !1;
  };
}
function Qk(e, t) {
  const n = e.length;
  if (t.length !== n)
    return !1;
  for (let i = -1; ++i < n; )
    if (!e[i](t[i]))
      return !1;
  return !0;
}
function t7(e, t) {
  const n = e.length;
  if (t.length !== n)
    return !1;
  for (let i = -1; ++i < n; )
    if (!e[i](t.get(i)))
      return !1;
  return !0;
}
function j_(e, t, n) {
  const i = n[Symbol.iterator](), r = t instanceof Map ? t.keys() : Object.keys(t)[Symbol.iterator](), s = t instanceof Map ? t.values() : Object.values(t)[Symbol.iterator]();
  let o = 0;
  const a = e.length;
  let c = s.next(), l = i.next(), u = r.next();
  for (; o < a && !l.done && !u.done && !c.done && !(l.value !== u.value || !e[o](c.value)); ++o, l = i.next(), u = r.next(), c = s.next())
    ;
  return o === a && l.done && u.done && c.done ? !0 : (i.return && i.return(), r.return && r.return(), s.return && s.return(), !1);
}
function c3(e, t, n, i) {
  return (n & 1 << i) !== 0;
}
function e7(e, t, n, i) {
  return (n & 1 << i) >> i;
}
function q_(e, t, n) {
  const i = n.byteLength + 7 & -8;
  if (e > 0 || n.byteLength < i) {
    const r = new Uint8Array(i);
    return r.set(e % 8 === 0 ? n.subarray(e >> 3) : (
      // Otherwise iterate each bit from the offset and return a new one
      Sg(new _b(n, e, t, null, c3)).subarray(0, i)
    )), r;
  }
  return n;
}
function Sg(e) {
  const t = [];
  let n = 0, i = 0, r = 0;
  for (const o of e)
    o && (r |= 1 << i), ++i === 8 && (t[n++] = r, r = i = 0);
  (n === 0 || i > 0) && (t[n++] = r);
  const s = new Uint8Array(t.length + 7 & -8);
  return s.set(t), s;
}
let _b = class {
  constructor(t, n, i, r, s) {
    this.bytes = t, this.length = i, this.context = r, this.get = s, this.bit = n % 8, this.byteIndex = n >> 3, this.byte = t[this.byteIndex++], this.index = 0;
  }
  next() {
    return this.index < this.length ? (this.bit === 8 && (this.bit = 0, this.byte = this.bytes[this.byteIndex++]), {
      value: this.get(this.context, this.index++, this.byte, this.bit++)
    }) : { done: !0, value: null };
  }
  [Symbol.iterator]() {
    return this;
  }
};
function xg(e, t, n) {
  if (n - t <= 0)
    return 0;
  if (n - t < 8) {
    let s = 0;
    for (const o of new _b(e, t, n - t, e, e7))
      s += o;
    return s;
  }
  const i = n >> 3 << 3, r = t + (t % 8 === 0 ? 0 : 8 - t % 8);
  return (
    // Get the popcnt of bits between the left hand side, and the next highest multiple of 8
    xg(e, t, r) + // Get the popcnt of bits between the right hand side, and the next lowest multiple of 8
    xg(e, i, n) + // Get the popcnt of all bits between the left and right hand sides' multiples of 8
    n7(e, r >> 3, i - r >> 3)
  );
}
function n7(e, t, n) {
  let i = 0, r = Math.trunc(t);
  const s = new DataView(e.buffer, e.byteOffset, e.byteLength), o = n === void 0 ? e.byteLength : r + n;
  for (; o - r >= 4; )
    i += nm(s.getUint32(r)), r += 4;
  for (; o - r >= 2; )
    i += nm(s.getUint16(r)), r += 2;
  for (; o - r >= 1; )
    i += nm(s.getUint8(r)), r += 1;
  return i;
}
function nm(e) {
  let t = Math.trunc(e);
  return t = t - (t >>> 1 & 1431655765), t = (t & 858993459) + (t >>> 2 & 858993459), (t + (t >>> 4) & 252645135) * 16843009 >>> 24;
}
const i7 = -1;
let de = class Ig {
  get typeId() {
    return this.type.typeId;
  }
  get ArrayType() {
    return this.type.ArrayType;
  }
  get buffers() {
    return [this.valueOffsets, this.values, this.nullBitmap, this.typeIds];
  }
  get nullable() {
    if (this._nullCount !== 0) {
      const { type: t } = this;
      return rt.isSparseUnion(t) ? this.children.some((n) => n.nullable) : rt.isDenseUnion(t) ? this.children.some((n) => n.nullable) : this.nullBitmap && this.nullBitmap.byteLength > 0;
    }
    return !0;
  }
  get byteLength() {
    let t = 0;
    const { valueOffsets: n, values: i, nullBitmap: r, typeIds: s } = this;
    return n && (t += n.byteLength), i && (t += i.byteLength), r && (t += r.byteLength), s && (t += s.byteLength), this.children.reduce((o, a) => o + a.byteLength, t);
  }
  get nullCount() {
    if (rt.isUnion(this.type))
      return this.children.reduce((i, r) => i + r.nullCount, 0);
    let t = this._nullCount, n;
    return t <= i7 && (n = this.nullBitmap) && (this._nullCount = t = this.length - xg(n, this.offset, this.offset + this.length)), t;
  }
  constructor(t, n, i, r, s, o = [], a) {
    this.type = t, this.children = o, this.dictionary = a, this.offset = Math.floor(Math.max(n || 0, 0)), this.length = Math.floor(Math.max(i || 0, 0)), this._nullCount = Math.floor(Math.max(r || 0, -1));
    let c;
    s instanceof Ig ? (this.stride = s.stride, this.values = s.values, this.typeIds = s.typeIds, this.nullBitmap = s.nullBitmap, this.valueOffsets = s.valueOffsets) : (this.stride = Cr(t), s && ((c = s[0]) && (this.valueOffsets = c), (c = s[1]) && (this.values = c), (c = s[2]) && (this.nullBitmap = c), (c = s[3]) && (this.typeIds = c)));
  }
  getValid(t) {
    const { type: n } = this;
    if (rt.isUnion(n)) {
      const i = n, r = this.children[i.typeIdToChildIndex[this.typeIds[t]]], s = i.mode === Mn.Dense ? this.valueOffsets[t] : t;
      return r.getValid(s);
    }
    if (this.nullable && this.nullCount > 0) {
      const i = this.offset + t;
      return (this.nullBitmap[i >> 3] & 1 << i % 8) !== 0;
    }
    return !0;
  }
  setValid(t, n) {
    let i;
    const { type: r } = this;
    if (rt.isUnion(r)) {
      const s = r, o = this.children[s.typeIdToChildIndex[this.typeIds[t]]], a = s.mode === Mn.Dense ? this.valueOffsets[t] : t;
      i = o.getValid(a), o.setValid(a, n);
    } else {
      let { nullBitmap: s } = this;
      const { offset: o, length: a } = this, c = o + t, l = 1 << c % 8, u = c >> 3;
      (!s || s.byteLength <= u) && (s = new Uint8Array((o + a + 63 & -64) >> 3).fill(255), this.nullCount > 0 && s.set(q_(o, a, this.nullBitmap), 0), Object.assign(this, { nullBitmap: s, _nullCount: -1 }));
      const f = s[u];
      i = (f & l) !== 0, n ? s[u] = f | l : s[u] = f & ~l;
    }
    return i !== !!n && (this._nullCount = this.nullCount + (n ? -1 : 1)), n;
  }
  clone(t = this.type, n = this.offset, i = this.length, r = this._nullCount, s = this, o = this.children) {
    return new Ig(t, n, i, r, s, o, this.dictionary);
  }
  slice(t, n) {
    const { stride: i, typeId: r, children: s } = this, o = +(this._nullCount === 0) - 1, a = r === 16 ? i : 1, c = this._sliceBuffers(t, n, i, r);
    return this.clone(
      this.type,
      this.offset + t,
      n,
      o,
      c,
      // Don't slice children if we have value offsets (the variable-width types)
      s.length === 0 || this.valueOffsets ? s : this._sliceChildren(s, a * t, a * n)
    );
  }
  _changeLengthAndBackfillNullBitmap(t) {
    if (this.typeId === F.Null)
      return this.clone(this.type, 0, t, 0);
    const { length: n, nullCount: i } = this, r = new Uint8Array((t + 63 & -64) >> 3).fill(255, 0, n >> 3);
    r[n >> 3] = (1 << n - (n & -8)) - 1, i > 0 && r.set(q_(this.offset, n, this.nullBitmap), 0);
    const s = this.buffers;
    return s[Rr.VALIDITY] = r, this.clone(this.type, 0, t, i + (t - n), s);
  }
  _sliceBuffers(t, n, i, r) {
    let s;
    const { buffers: o } = this;
    return (s = o[Rr.TYPE]) && (o[Rr.TYPE] = s.subarray(t, t + n)), (s = o[Rr.OFFSET]) && (o[Rr.OFFSET] = s.subarray(t, t + n + 1)) || // Otherwise if no offsets, slice the data buffer. Don't slice the data vector for Booleans, since the offset goes by bits not bytes
    (s = o[Rr.DATA]) && (o[Rr.DATA] = r === 6 ? s : s.subarray(i * t, i * (t + n))), o;
  }
  _sliceChildren(t, n, i) {
    return t.map((r) => r.slice(n, i));
  }
};
de.prototype.children = Object.freeze([]);
let r7 = class Yh extends Ut {
  visit(t) {
    return this.getVisitFn(t.type).call(this, t);
  }
  visitNull(t) {
    const { ["type"]: n, ["offset"]: i = 0, ["length"]: r = 0 } = t;
    return new de(n, i, r, r);
  }
  visitBool(t) {
    const { ["type"]: n, ["offset"]: i = 0 } = t, r = Yt(t.nullBitmap), s = re(n.ArrayType, t.data), { ["length"]: o = s.length >> 3, ["nullCount"]: a = t.nullBitmap ? -1 : 0 } = t;
    return new de(n, i, o, a, [void 0, s, r]);
  }
  visitInt(t) {
    const { ["type"]: n, ["offset"]: i = 0 } = t, r = Yt(t.nullBitmap), s = re(n.ArrayType, t.data), { ["length"]: o = s.length, ["nullCount"]: a = t.nullBitmap ? -1 : 0 } = t;
    return new de(n, i, o, a, [void 0, s, r]);
  }
  visitFloat(t) {
    const { ["type"]: n, ["offset"]: i = 0 } = t, r = Yt(t.nullBitmap), s = re(n.ArrayType, t.data), { ["length"]: o = s.length, ["nullCount"]: a = t.nullBitmap ? -1 : 0 } = t;
    return new de(n, i, o, a, [void 0, s, r]);
  }
  visitUtf8(t) {
    const { ["type"]: n, ["offset"]: i = 0 } = t, r = Yt(t.data), s = Yt(t.nullBitmap), o = bl(t.valueOffsets), { ["length"]: a = o.length - 1, ["nullCount"]: c = t.nullBitmap ? -1 : 0 } = t;
    return new de(n, i, a, c, [o, r, s]);
  }
  visitLargeUtf8(t) {
    const { ["type"]: n, ["offset"]: i = 0 } = t, r = Yt(t.data), s = Yt(t.nullBitmap), o = D_(t.valueOffsets), { ["length"]: a = o.length - 1, ["nullCount"]: c = t.nullBitmap ? -1 : 0 } = t;
    return new de(n, i, a, c, [o, r, s]);
  }
  visitBinary(t) {
    const { ["type"]: n, ["offset"]: i = 0 } = t, r = Yt(t.data), s = Yt(t.nullBitmap), o = bl(t.valueOffsets), { ["length"]: a = o.length - 1, ["nullCount"]: c = t.nullBitmap ? -1 : 0 } = t;
    return new de(n, i, a, c, [o, r, s]);
  }
  visitLargeBinary(t) {
    const { ["type"]: n, ["offset"]: i = 0 } = t, r = Yt(t.data), s = Yt(t.nullBitmap), o = D_(t.valueOffsets), { ["length"]: a = o.length - 1, ["nullCount"]: c = t.nullBitmap ? -1 : 0 } = t;
    return new de(n, i, a, c, [o, r, s]);
  }
  visitFixedSizeBinary(t) {
    const { ["type"]: n, ["offset"]: i = 0 } = t, r = Yt(t.nullBitmap), s = re(n.ArrayType, t.data), { ["length"]: o = s.length / Cr(n), ["nullCount"]: a = t.nullBitmap ? -1 : 0 } = t;
    return new de(n, i, o, a, [void 0, s, r]);
  }
  visitDate(t) {
    const { ["type"]: n, ["offset"]: i = 0 } = t, r = Yt(t.nullBitmap), s = re(n.ArrayType, t.data), { ["length"]: o = s.length / Cr(n), ["nullCount"]: a = t.nullBitmap ? -1 : 0 } = t;
    return new de(n, i, o, a, [void 0, s, r]);
  }
  visitTimestamp(t) {
    const { ["type"]: n, ["offset"]: i = 0 } = t, r = Yt(t.nullBitmap), s = re(n.ArrayType, t.data), { ["length"]: o = s.length / Cr(n), ["nullCount"]: a = t.nullBitmap ? -1 : 0 } = t;
    return new de(n, i, o, a, [void 0, s, r]);
  }
  visitTime(t) {
    const { ["type"]: n, ["offset"]: i = 0 } = t, r = Yt(t.nullBitmap), s = re(n.ArrayType, t.data), { ["length"]: o = s.length / Cr(n), ["nullCount"]: a = t.nullBitmap ? -1 : 0 } = t;
    return new de(n, i, o, a, [void 0, s, r]);
  }
  visitDecimal(t) {
    const { ["type"]: n, ["offset"]: i = 0 } = t, r = Yt(t.nullBitmap), s = re(n.ArrayType, t.data), { ["length"]: o = s.length / Cr(n), ["nullCount"]: a = t.nullBitmap ? -1 : 0 } = t;
    return new de(n, i, o, a, [void 0, s, r]);
  }
  visitList(t) {
    const { ["type"]: n, ["offset"]: i = 0, ["child"]: r } = t, s = Yt(t.nullBitmap), o = bl(t.valueOffsets), { ["length"]: a = o.length - 1, ["nullCount"]: c = t.nullBitmap ? -1 : 0 } = t;
    return new de(n, i, a, c, [o, void 0, s], [r]);
  }
  visitStruct(t) {
    const { ["type"]: n, ["offset"]: i = 0, ["children"]: r = [] } = t, s = Yt(t.nullBitmap), { length: o = r.reduce((c, { length: l }) => Math.max(c, l), 0), nullCount: a = t.nullBitmap ? -1 : 0 } = t;
    return new de(n, i, o, a, [void 0, void 0, s], r);
  }
  visitUnion(t) {
    const { ["type"]: n, ["offset"]: i = 0, ["children"]: r = [] } = t, s = re(n.ArrayType, t.typeIds), { ["length"]: o = s.length, ["nullCount"]: a = -1 } = t;
    if (rt.isSparseUnion(n))
      return new de(n, i, o, a, [void 0, void 0, void 0, s], r);
    const c = bl(t.valueOffsets);
    return new de(n, i, o, a, [c, void 0, void 0, s], r);
  }
  visitDictionary(t) {
    const { ["type"]: n, ["offset"]: i = 0 } = t, r = Yt(t.nullBitmap), s = re(n.indices.ArrayType, t.data), { ["dictionary"]: o = new Ne([new Yh().visit({ type: n.dictionary })]) } = t, { ["length"]: a = s.length, ["nullCount"]: c = t.nullBitmap ? -1 : 0 } = t;
    return new de(n, i, a, c, [void 0, s, r], [], o);
  }
  visitInterval(t) {
    const { ["type"]: n, ["offset"]: i = 0 } = t, r = Yt(t.nullBitmap), s = re(n.ArrayType, t.data), { ["length"]: o = s.length / Cr(n), ["nullCount"]: a = t.nullBitmap ? -1 : 0 } = t;
    return new de(n, i, o, a, [void 0, s, r]);
  }
  visitDuration(t) {
    const { ["type"]: n, ["offset"]: i = 0 } = t, r = Yt(t.nullBitmap), s = re(n.ArrayType, t.data), { ["length"]: o = s.length, ["nullCount"]: a = t.nullBitmap ? -1 : 0 } = t;
    return new de(n, i, o, a, [void 0, s, r]);
  }
  visitFixedSizeList(t) {
    const { ["type"]: n, ["offset"]: i = 0, ["child"]: r = new Yh().visit({ type: n.valueType }) } = t, s = Yt(t.nullBitmap), { ["length"]: o = r.length / Cr(n), ["nullCount"]: a = t.nullBitmap ? -1 : 0 } = t;
    return new de(n, i, o, a, [void 0, void 0, s], [r]);
  }
  visitMap(t) {
    const { ["type"]: n, ["offset"]: i = 0, ["child"]: r = new Yh().visit({ type: n.childType }) } = t, s = Yt(t.nullBitmap), o = bl(t.valueOffsets), { ["length"]: a = o.length - 1, ["nullCount"]: c = t.nullBitmap ? -1 : 0 } = t;
    return new de(n, i, a, c, [o, void 0, s], [r]);
  }
};
const s7 = new r7();
function Rt(e) {
  return s7.visit(e);
}
let Y_ = class {
  constructor(t = 0, n) {
    this.numChunks = t, this.getChunkIterator = n, this.chunkIndex = 0, this.chunkIterator = this.getChunkIterator(0);
  }
  next() {
    for (; this.chunkIndex < this.numChunks; ) {
      const t = this.chunkIterator.next();
      if (!t.done)
        return t;
      ++this.chunkIndex < this.numChunks && (this.chunkIterator = this.getChunkIterator(this.chunkIndex));
    }
    return { done: !0, value: null };
  }
  [Symbol.iterator]() {
    return this;
  }
};
function o7(e) {
  return e.some((t) => t.nullable);
}
function l3(e) {
  return e.reduce((t, n) => t + n.nullCount, 0);
}
function u3(e) {
  return e.reduce((t, n, i) => (t[i + 1] = t[i] + n.length, t), new Uint32Array(e.length + 1));
}
function f3(e, t, n, i) {
  const r = [];
  for (let s = -1, o = e.length; ++s < o; ) {
    const a = e[s], c = t[s], { length: l } = a;
    if (c >= i)
      break;
    if (n >= c + l)
      continue;
    if (c >= n && c + l <= i) {
      r.push(a);
      continue;
    }
    const u = Math.max(0, n - c), f = Math.min(i - c, l);
    r.push(a.slice(u, f - u));
  }
  return r.length === 0 && r.push(e[0].slice(0, 0)), r;
}
function Sb(e, t, n, i) {
  let r = 0, s = 0, o = t.length - 1;
  do {
    if (r >= o - 1)
      return n < t[o] ? i(e, r, n - t[r]) : null;
    s = r + Math.trunc((o - r) * 0.5), n < t[s] ? o = s : r = s;
  } while (r < o);
}
function xb(e, t) {
  return e.getValid(t);
}
function Rd(e) {
  function t(n, i, r) {
    return e(n[i], r);
  }
  return function(n) {
    const i = this.data;
    return Sb(i, this._offsets, n, t);
  };
}
function h3(e) {
  let t;
  function n(i, r, s) {
    return e(i[r], s, t);
  }
  return function(i, r) {
    const s = this.data;
    t = r;
    const o = Sb(s, this._offsets, i, n);
    return t = void 0, o;
  };
}
function d3(e) {
  let t;
  function n(i, r, s) {
    let o = s, a = 0, c = 0;
    for (let l = r - 1, u = i.length; ++l < u; ) {
      const f = i[l];
      if (~(a = e(f, t, o)))
        return c + a;
      o = 0, c += f.length;
    }
    return -1;
  }
  return function(i, r) {
    t = i;
    const s = this.data, o = typeof r != "number" ? n(s, 0, 0) : Sb(s, this._offsets, r, n);
    return t = void 0, o;
  };
}
let lt = class extends Ut {
};
function a7(e, t) {
  return t === null && e.length > 0 ? 0 : -1;
}
function c7(e, t) {
  const { nullBitmap: n } = e;
  if (!n || e.nullCount <= 0)
    return -1;
  let i = 0;
  for (const r of new _b(n, e.offset + (t || 0), e.length, n, c3)) {
    if (!r)
      return i;
    ++i;
  }
  return -1;
}
function Bt(e, t, n) {
  if (t === void 0)
    return -1;
  if (t === null)
    switch (e.typeId) {
      case F.Union:
        break;
      case F.Dictionary:
        break;
      default:
        return c7(e, n);
    }
  const i = $n.getVisitFn(e), r = Zc(t);
  for (let s = (n || 0) - 1, o = e.length; ++s < o; )
    if (r(i(e, s)))
      return s;
  return -1;
}
function p3(e, t, n) {
  const i = $n.getVisitFn(e), r = Zc(t);
  for (let s = (n || 0) - 1, o = e.length; ++s < o; )
    if (r(i(e, s)))
      return s;
  return -1;
}
lt.prototype.visitNull = a7;
lt.prototype.visitBool = Bt;
lt.prototype.visitInt = Bt;
lt.prototype.visitInt8 = Bt;
lt.prototype.visitInt16 = Bt;
lt.prototype.visitInt32 = Bt;
lt.prototype.visitInt64 = Bt;
lt.prototype.visitUint8 = Bt;
lt.prototype.visitUint16 = Bt;
lt.prototype.visitUint32 = Bt;
lt.prototype.visitUint64 = Bt;
lt.prototype.visitFloat = Bt;
lt.prototype.visitFloat16 = Bt;
lt.prototype.visitFloat32 = Bt;
lt.prototype.visitFloat64 = Bt;
lt.prototype.visitUtf8 = Bt;
lt.prototype.visitLargeUtf8 = Bt;
lt.prototype.visitBinary = Bt;
lt.prototype.visitLargeBinary = Bt;
lt.prototype.visitFixedSizeBinary = Bt;
lt.prototype.visitDate = Bt;
lt.prototype.visitDateDay = Bt;
lt.prototype.visitDateMillisecond = Bt;
lt.prototype.visitTimestamp = Bt;
lt.prototype.visitTimestampSecond = Bt;
lt.prototype.visitTimestampMillisecond = Bt;
lt.prototype.visitTimestampMicrosecond = Bt;
lt.prototype.visitTimestampNanosecond = Bt;
lt.prototype.visitTime = Bt;
lt.prototype.visitTimeSecond = Bt;
lt.prototype.visitTimeMillisecond = Bt;
lt.prototype.visitTimeMicrosecond = Bt;
lt.prototype.visitTimeNanosecond = Bt;
lt.prototype.visitDecimal = Bt;
lt.prototype.visitList = Bt;
lt.prototype.visitStruct = Bt;
lt.prototype.visitUnion = Bt;
lt.prototype.visitDenseUnion = p3;
lt.prototype.visitSparseUnion = p3;
lt.prototype.visitDictionary = Bt;
lt.prototype.visitInterval = Bt;
lt.prototype.visitIntervalDayTime = Bt;
lt.prototype.visitIntervalYearMonth = Bt;
lt.prototype.visitDuration = Bt;
lt.prototype.visitDurationSecond = Bt;
lt.prototype.visitDurationMillisecond = Bt;
lt.prototype.visitDurationMicrosecond = Bt;
lt.prototype.visitDurationNanosecond = Bt;
lt.prototype.visitFixedSizeList = Bt;
lt.prototype.visitMap = Bt;
const Cd = new lt();
let ut = class extends Ut {
};
function St(e) {
  const { type: t } = e;
  if (e.nullCount === 0 && e.stride === 1 && (t.typeId === F.Timestamp || t instanceof Ps && t.bitWidth !== 64 || t instanceof Iu && t.bitWidth !== 64 || t instanceof xu && t.precision !== nn.HALF))
    return new Y_(e.data.length, (i) => {
      const r = e.data[i];
      return r.values.subarray(0, r.length)[Symbol.iterator]();
    });
  let n = 0;
  return new Y_(e.data.length, (i) => {
    const s = e.data[i].length, o = e.slice(n, n + s);
    return n += s, new l7(o);
  });
}
let l7 = class {
  constructor(t) {
    this.vector = t, this.index = 0;
  }
  next() {
    return this.index < this.vector.length ? {
      value: this.vector.get(this.index++)
    } : { done: !0, value: null };
  }
  [Symbol.iterator]() {
    return this;
  }
};
ut.prototype.visitNull = St;
ut.prototype.visitBool = St;
ut.prototype.visitInt = St;
ut.prototype.visitInt8 = St;
ut.prototype.visitInt16 = St;
ut.prototype.visitInt32 = St;
ut.prototype.visitInt64 = St;
ut.prototype.visitUint8 = St;
ut.prototype.visitUint16 = St;
ut.prototype.visitUint32 = St;
ut.prototype.visitUint64 = St;
ut.prototype.visitFloat = St;
ut.prototype.visitFloat16 = St;
ut.prototype.visitFloat32 = St;
ut.prototype.visitFloat64 = St;
ut.prototype.visitUtf8 = St;
ut.prototype.visitLargeUtf8 = St;
ut.prototype.visitBinary = St;
ut.prototype.visitLargeBinary = St;
ut.prototype.visitFixedSizeBinary = St;
ut.prototype.visitDate = St;
ut.prototype.visitDateDay = St;
ut.prototype.visitDateMillisecond = St;
ut.prototype.visitTimestamp = St;
ut.prototype.visitTimestampSecond = St;
ut.prototype.visitTimestampMillisecond = St;
ut.prototype.visitTimestampMicrosecond = St;
ut.prototype.visitTimestampNanosecond = St;
ut.prototype.visitTime = St;
ut.prototype.visitTimeSecond = St;
ut.prototype.visitTimeMillisecond = St;
ut.prototype.visitTimeMicrosecond = St;
ut.prototype.visitTimeNanosecond = St;
ut.prototype.visitDecimal = St;
ut.prototype.visitList = St;
ut.prototype.visitStruct = St;
ut.prototype.visitUnion = St;
ut.prototype.visitDenseUnion = St;
ut.prototype.visitSparseUnion = St;
ut.prototype.visitDictionary = St;
ut.prototype.visitInterval = St;
ut.prototype.visitIntervalDayTime = St;
ut.prototype.visitIntervalYearMonth = St;
ut.prototype.visitDuration = St;
ut.prototype.visitDurationSecond = St;
ut.prototype.visitDurationMillisecond = St;
ut.prototype.visitDurationMicrosecond = St;
ut.prototype.visitDurationNanosecond = St;
ut.prototype.visitFixedSizeList = St;
ut.prototype.visitMap = St;
const Ib = new ut();
var y3;
const m3 = {}, g3 = {};
let Ne = class Mo {
  constructor(t) {
    var n, i, r;
    const s = t[0] instanceof Mo ? t.flatMap((a) => a.data) : t;
    if (s.length === 0 || s.some((a) => !(a instanceof de)))
      throw new TypeError("Vector constructor expects an Array of Data instances.");
    const o = (n = s[0]) === null || n === void 0 ? void 0 : n.type;
    switch (s.length) {
      case 0:
        this._offsets = [0];
        break;
      case 1: {
        const { get: a, set: c, indexOf: l } = m3[o.typeId], u = s[0];
        this.isValid = (f) => xb(u, f), this.get = (f) => a(u, f), this.set = (f, h) => c(u, f, h), this.indexOf = (f) => l(u, f), this._offsets = [0, u.length];
        break;
      }
      default:
        Object.setPrototypeOf(this, g3[o.typeId]), this._offsets = u3(s);
        break;
    }
    this.data = s, this.type = o, this.stride = Cr(o), this.numChildren = (r = (i = o.children) === null || i === void 0 ? void 0 : i.length) !== null && r !== void 0 ? r : 0, this.length = this._offsets.at(-1);
  }
  /**
   * The aggregate size (in bytes) of this Vector's buffers and/or child Vectors.
   */
  get byteLength() {
    return this.data.reduce((t, n) => t + n.byteLength, 0);
  }
  /**
   * Whether this Vector's elements can contain null values.
   */
  get nullable() {
    return o7(this.data);
  }
  /**
   * The number of null elements in this Vector.
   */
  get nullCount() {
    return l3(this.data);
  }
  /**
   * The Array or TypedArray constructor used for the JS representation
   *  of the element's values in {@link Vector.prototype.toArray `toArray()`}.
   */
  get ArrayType() {
    return this.type.ArrayType;
  }
  /**
   * The name that should be printed when the Vector is logged in a message.
   */
  get [Symbol.toStringTag]() {
    return `${this.VectorName}<${this.type[Symbol.toStringTag]}>`;
  }
  /**
   * The name of this Vector.
   */
  get VectorName() {
    return `${F[this.type.typeId]}Vector`;
  }
  /**
   * Check whether an element is null.
   * @param index The index at which to read the validity bitmap.
   */
  // @ts-ignore
  isValid(t) {
    return !1;
  }
  /**
   * Get an element value by position.
   * @param index The index of the element to read.
   */
  // @ts-ignore
  get(t) {
    return null;
  }
  /**
   * Set an element value by position.
   * @param index The index of the element to write.
   * @param value The value to set.
   */
  // @ts-ignore
  set(t, n) {
  }
  /**
   * Retrieve the index of the first occurrence of a value in an Vector.
   * @param element The value to locate in the Vector.
   * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
   */
  // @ts-ignore
  indexOf(t, n) {
    return -1;
  }
  includes(t, n) {
    return this.indexOf(t, n) > -1;
  }
  /**
   * Iterator for the Vector's elements.
   */
  [Symbol.iterator]() {
    return Ib.visit(this);
  }
  /**
   * Combines two or more Vectors of the same type.
   * @param others Additional Vectors to add to the end of this Vector.
   */
  concat(...t) {
    return new Mo(this.data.concat(t.flatMap((n) => n.data).flat(Number.POSITIVE_INFINITY)));
  }
  /**
   * Return a zero-copy sub-section of this Vector.
   * @param start The beginning of the specified portion of the Vector.
   * @param end The end of the specified portion of the Vector. This is exclusive of the element at the index 'end'.
   */
  slice(t, n) {
    return new Mo(a3(this, t, n, ({ data: i, _offsets: r }, s, o) => f3(i, r, s, o)));
  }
  toJSON() {
    return [...this];
  }
  /**
   * Return a JavaScript Array or TypedArray of the Vector's elements.
   *
   * @note If this Vector contains a single Data chunk and the Vector's type is a
   *  primitive numeric type corresponding to one of the JavaScript TypedArrays, this
   *  method returns a zero-copy slice of the underlying TypedArray values. If there's
   *  more than one chunk, the resulting TypedArray will be a copy of the data from each
   *  chunk's underlying TypedArray values.
   *
   * @returns An Array or TypedArray of the Vector's elements, based on the Vector's DataType.
   */
  toArray() {
    const { type: t, data: n, length: i, stride: r, ArrayType: s } = this;
    switch (t.typeId) {
      case F.Int:
      case F.Float:
      case F.Decimal:
      case F.Time:
      case F.Timestamp:
        switch (n.length) {
          case 0:
            return new s();
          case 1:
            return n[0].values.subarray(0, i * r);
          default:
            return n.reduce((o, { values: a, length: c }) => (o.array.set(a.subarray(0, c * r), o.offset), o.offset += c * r, o), { array: new s(i * r), offset: 0 }).array;
        }
    }
    return [...this];
  }
  /**
   * Returns a string representation of the Vector.
   *
   * @returns A string representation of the Vector.
   */
  toString() {
    return `[${[...this].join(",")}]`;
  }
  /**
   * Returns a child Vector by name, or null if this Vector has no child with the given name.
   * @param name The name of the child to retrieve.
   */
  getChild(t) {
    var n;
    return this.getChildAt((n = this.type.children) === null || n === void 0 ? void 0 : n.findIndex((i) => i.name === t));
  }
  /**
   * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
   * @param index The index of the child to retrieve.
   */
  getChildAt(t) {
    return t > -1 && t < this.numChildren ? new Mo(this.data.map(({ children: n }) => n[t])) : null;
  }
  get isMemoized() {
    return rt.isDictionary(this.type) ? this.data[0].dictionary.isMemoized : !1;
  }
  /**
   * Adds memoization to the Vector's {@link get} method. For dictionary
   * vectors, this method return a vector that memoizes only the dictionary
   * values.
   *
   * Memoization is very useful when decoding a value is expensive such as
   * Utf8. The memoization creates a cache of the size of the Vector and
   * therefore increases memory usage.
   *
   * @returns A new vector that memoizes calls to {@link get}.
   */
  memoize() {
    if (rt.isDictionary(this.type)) {
      const t = new W_(this.data[0].dictionary), n = this.data.map((i) => {
        const r = i.clone();
        return r.dictionary = t, r;
      });
      return new Mo(n);
    }
    return new W_(this);
  }
  /**
   * Returns a vector without memoization of the {@link get} method. If this
   * vector is not memoized, this method returns this vector.
   *
   * @returns A new vector without memoization.
   */
  unmemoize() {
    if (rt.isDictionary(this.type) && this.isMemoized) {
      const t = this.data[0].dictionary.unmemoize(), n = this.data.map((i) => {
        const r = i.clone();
        return r.dictionary = t, r;
      });
      return new Mo(n);
    }
    return this;
  }
};
y3 = Symbol.toStringTag;
Ne[y3] = ((e) => {
  e.type = rt.prototype, e.data = [], e.length = 0, e.stride = 1, e.numChildren = 0, e._offsets = new Uint32Array([0]), e[Symbol.isConcatSpreadable] = !0;
  const t = Object.keys(F).map((n) => F[n]).filter((n) => typeof n == "number" && n !== F.NONE);
  for (const n of t) {
    const i = $n.getVisitFnByTypeId(n), r = li.getVisitFnByTypeId(n), s = Cd.getVisitFnByTypeId(n);
    m3[n] = { get: i, set: r, indexOf: s }, g3[n] = Object.create(e, {
      isValid: { value: Rd(xb) },
      get: { value: Rd($n.getVisitFnByTypeId(n)) },
      set: { value: h3(li.getVisitFnByTypeId(n)) },
      indexOf: { value: d3(Cd.getVisitFnByTypeId(n)) }
    });
  }
  return "Vector";
})(Ne.prototype);
let W_ = class b3 extends Ne {
  constructor(t) {
    super(t.data);
    const n = this.get, i = this.set, r = this.slice, s = new Array(this.length);
    Object.defineProperty(this, "get", {
      value(o) {
        const a = s[o];
        if (a !== void 0)
          return a;
        const c = n.call(this, o);
        return s[o] = c, c;
      }
    }), Object.defineProperty(this, "set", {
      value(o, a) {
        i.call(this, o, a), s[o] = a;
      }
    }), Object.defineProperty(this, "slice", {
      value: (o, a) => new b3(r.call(this, o, a))
    }), Object.defineProperty(this, "isMemoized", { value: !0 }), Object.defineProperty(this, "unmemoize", {
      value: () => new Ne(this.data)
    }), Object.defineProperty(this, "memoize", {
      value: () => this
    });
  }
}, Ag = class {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  /**
   * Index to the start of the RecordBlock (note this is past the Message header)
   */
  offset() {
    return this.bb.readInt64(this.bb_pos);
  }
  /**
   * Length of the metadata
   */
  metaDataLength() {
    return this.bb.readInt32(this.bb_pos + 8);
  }
  /**
   * Length of the data (this is aligned so there can be a gap between this and
   * the metadata).
   */
  bodyLength() {
    return this.bb.readInt64(this.bb_pos + 16);
  }
  static sizeOf() {
    return 24;
  }
  static createBlock(t, n, i, r) {
    return t.prep(8, 24), t.writeInt64(BigInt(r ?? 0)), t.pad(4), t.writeInt32(i), t.writeInt64(BigInt(n ?? 0)), t.offset();
  }
}, Vi = class Mg {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsFooter(t, n) {
    return (n || new Mg()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsFooter(t, n) {
    return t.setPosition(t.position() + nt), (n || new Mg()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  version() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt16(this.bb_pos + t) : Ee.V1;
  }
  schema(t) {
    const n = this.bb.__offset(this.bb_pos, 6);
    return n ? (t || new Yi()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;
  }
  dictionaries(t, n) {
    const i = this.bb.__offset(this.bb_pos, 8);
    return i ? (n || new Ag()).__init(this.bb.__vector(this.bb_pos + i) + t * 24, this.bb) : null;
  }
  dictionariesLength() {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  recordBatches(t, n) {
    const i = this.bb.__offset(this.bb_pos, 10);
    return i ? (n || new Ag()).__init(this.bb.__vector(this.bb_pos + i) + t * 24, this.bb) : null;
  }
  recordBatchesLength() {
    const t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  /**
   * User-defined metadata
   */
  customMetadata(t, n) {
    const i = this.bb.__offset(this.bb_pos, 12);
    return i ? (n || new ii()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + t * 4), this.bb) : null;
  }
  customMetadataLength() {
    const t = this.bb.__offset(this.bb_pos, 12);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  static startFooter(t) {
    t.startObject(5);
  }
  static addVersion(t, n) {
    t.addFieldInt16(0, n, Ee.V1);
  }
  static addSchema(t, n) {
    t.addFieldOffset(1, n, 0);
  }
  static addDictionaries(t, n) {
    t.addFieldOffset(2, n, 0);
  }
  static startDictionariesVector(t, n) {
    t.startVector(24, n, 8);
  }
  static addRecordBatches(t, n) {
    t.addFieldOffset(3, n, 0);
  }
  static startRecordBatchesVector(t, n) {
    t.startVector(24, n, 8);
  }
  static addCustomMetadata(t, n) {
    t.addFieldOffset(4, n, 0);
  }
  static createCustomMetadataVector(t, n) {
    t.startVector(4, n.length, 4);
    for (let i = n.length - 1; i >= 0; i--)
      t.addOffset(n[i]);
    return t.endVector();
  }
  static startCustomMetadataVector(t, n) {
    t.startVector(4, n, 4);
  }
  static endFooter(t) {
    return t.endObject();
  }
  static finishFooterBuffer(t, n) {
    t.finish(n);
  }
  static finishSizePrefixedFooterBuffer(t, n) {
    t.finish(n, void 0, !0);
  }
}, _e = class $o {
  constructor(t = [], n, i, r = Ee.V5) {
    this.fields = t || [], this.metadata = n || /* @__PURE__ */ new Map(), i || (i = Tg(t)), this.dictionaries = i, this.metadataVersion = r;
  }
  get [Symbol.toStringTag]() {
    return "Schema";
  }
  get names() {
    return this.fields.map((t) => t.name);
  }
  toString() {
    return `Schema<{ ${this.fields.map((t, n) => `${n}: ${t}`).join(", ")} }>`;
  }
  /**
   * Construct a new Schema containing only specified fields.
   *
   * @param fieldNames Names of fields to keep.
   * @returns A new Schema of fields matching the specified names.
   */
  select(t) {
    const n = new Set(t), i = this.fields.filter((r) => n.has(r.name));
    return new $o(i, this.metadata);
  }
  /**
   * Construct a new Schema containing only fields at the specified indices.
   *
   * @param fieldIndices Indices of fields to keep.
   * @returns A new Schema of fields at the specified indices.
   */
  selectAt(t) {
    const n = t.map((i) => this.fields[i]).filter(Boolean);
    return new $o(n, this.metadata);
  }
  assign(...t) {
    const n = t[0] instanceof $o ? t[0] : Array.isArray(t[0]) ? new $o(t[0]) : new $o(t), i = [...this.fields], r = nh(nh(/* @__PURE__ */ new Map(), this.metadata), n.metadata), s = n.fields.filter((a) => {
      const c = i.findIndex((l) => l.name === a.name);
      return ~c ? (i[c] = a.clone({
        metadata: nh(nh(/* @__PURE__ */ new Map(), i[c].metadata), a.metadata)
      })) && !1 : !0;
    }), o = Tg(s, /* @__PURE__ */ new Map());
    return new $o([...i, ...s], r, new Map([...this.dictionaries, ...o]));
  }
};
_e.prototype.fields = null;
_e.prototype.metadata = null;
_e.prototype.dictionaries = null;
let Te = class $g {
  /** @nocollapse */
  static new(...t) {
    let [n, i, r, s] = t;
    return t[0] && typeof t[0] == "object" && ({ name: n } = t[0], i === void 0 && (i = t[0].type), r === void 0 && (r = t[0].nullable), s === void 0 && (s = t[0].metadata)), new $g(`${n}`, i, r, s);
  }
  constructor(t, n, i = !1, r) {
    this.name = t, this.type = n, this.nullable = i, this.metadata = r || /* @__PURE__ */ new Map();
  }
  get typeId() {
    return this.type.typeId;
  }
  get [Symbol.toStringTag]() {
    return "Field";
  }
  toString() {
    return `${this.name}: ${this.type}`;
  }
  clone(...t) {
    let [n, i, r, s] = t;
    return !t[0] || typeof t[0] != "object" ? [n = this.name, i = this.type, r = this.nullable, s = this.metadata] = t : { name: n = this.name, type: i = this.type, nullable: r = this.nullable, metadata: s = this.metadata } = t[0], $g.new(n, i, r, s);
  }
};
Te.prototype.type = null;
Te.prototype.name = null;
Te.prototype.nullable = null;
Te.prototype.metadata = null;
function nh(e, t) {
  return new Map([...e || /* @__PURE__ */ new Map(), ...t || /* @__PURE__ */ new Map()]);
}
function Tg(e, t = /* @__PURE__ */ new Map()) {
  for (let n = -1, i = e.length; ++n < i; ) {
    const s = e[n].type;
    if (rt.isDictionary(s)) {
      if (!t.has(s.id))
        t.set(s.id, s.dictionary);
      else if (t.get(s.id) !== s.dictionary)
        throw new Error("Cannot create Schema containing two different dictionaries with the same Id");
    }
    s.children && s.children.length > 0 && Tg(s.children, t);
  }
  return t;
}
var u7 = Ry, f7 = ur;
let Ab = class {
  /** @nocollapse */
  static decode(t) {
    t = new f7(Yt(t));
    const n = Vi.getRootAsFooter(t), i = _e.decode(n.schema(), /* @__PURE__ */ new Map(), n.version());
    return new h7(i, n);
  }
  /** @nocollapse */
  static encode(t) {
    const n = new u7(), i = _e.encode(n, t.schema);
    Vi.startRecordBatchesVector(n, t.numRecordBatches);
    for (const o of [...t.recordBatches()].slice().reverse())
      kd.encode(n, o);
    const r = n.endVector();
    Vi.startDictionariesVector(n, t.numDictionaries);
    for (const o of [...t.dictionaryBatches()].slice().reverse())
      kd.encode(n, o);
    const s = n.endVector();
    return Vi.startFooter(n), Vi.addSchema(n, i), Vi.addVersion(n, Ee.V5), Vi.addRecordBatches(n, r), Vi.addDictionaries(n, s), Vi.finishFooterBuffer(n, Vi.endFooter(n)), n.asUint8Array();
  }
  get numRecordBatches() {
    return this._recordBatches.length;
  }
  get numDictionaries() {
    return this._dictionaryBatches.length;
  }
  constructor(t, n = Ee.V5, i, r) {
    this.schema = t, this.version = n, i && (this._recordBatches = i), r && (this._dictionaryBatches = r);
  }
  *recordBatches() {
    for (let t, n = -1, i = this.numRecordBatches; ++n < i; )
      (t = this.getRecordBatch(n)) && (yield t);
  }
  *dictionaryBatches() {
    for (let t, n = -1, i = this.numDictionaries; ++n < i; )
      (t = this.getDictionaryBatch(n)) && (yield t);
  }
  getRecordBatch(t) {
    return t >= 0 && t < this.numRecordBatches && this._recordBatches[t] || null;
  }
  getDictionaryBatch(t) {
    return t >= 0 && t < this.numDictionaries && this._dictionaryBatches[t] || null;
  }
}, h7 = class extends Ab {
  get numRecordBatches() {
    return this._footer.recordBatchesLength();
  }
  get numDictionaries() {
    return this._footer.dictionariesLength();
  }
  constructor(t, n) {
    super(t, n.version()), this._footer = n;
  }
  getRecordBatch(t) {
    if (t >= 0 && t < this.numRecordBatches) {
      const n = this._footer.recordBatches(t);
      if (n)
        return kd.decode(n);
    }
    return null;
  }
  getDictionaryBatch(t) {
    if (t >= 0 && t < this.numDictionaries) {
      const n = this._footer.dictionaries(t);
      if (n)
        return kd.decode(n);
    }
    return null;
  }
}, kd = class w3 {
  /** @nocollapse */
  static decode(t) {
    return new w3(t.metaDataLength(), t.bodyLength(), t.offset());
  }
  /** @nocollapse */
  static encode(t, n) {
    const { metaDataLength: i } = n, r = BigInt(n.offset), s = BigInt(n.bodyLength);
    return Ag.createBlock(t, r, i, s);
  }
  constructor(t, n, i) {
    this.metaDataLength = t, this.offset = pn(i), this.bodyLength = pn(n);
  }
};
const Se = Object.freeze({ done: !0, value: void 0 });
let G_ = class {
  constructor(t) {
    this._json = t;
  }
  get schema() {
    return this._json.schema;
  }
  get batches() {
    return this._json.batches || [];
  }
  get dictionaries() {
    return this._json.dictionaries || [];
  }
}, v3 = class {
  tee() {
    return this._getDOMStream().tee();
  }
  pipe(t, n) {
    return this._getNodeStream().pipe(t, n);
  }
  pipeTo(t, n) {
    return this._getDOMStream().pipeTo(t, n);
  }
  pipeThrough(t, n) {
    return this._getDOMStream().pipeThrough(t, n);
  }
  _getDOMStream() {
    return this._DOMStream || (this._DOMStream = this.toDOMStream());
  }
  _getNodeStream() {
    return this._nodeStream || (this._nodeStream = this.toNodeStream());
  }
}, d7 = class extends v3 {
  constructor() {
    super(), this._values = [], this.resolvers = [], this._closedPromise = new Promise((t) => this._closedPromiseResolve = t);
  }
  get closed() {
    return this._closedPromise;
  }
  cancel(t) {
    return W(this, void 0, void 0, function* () {
      yield this.return(t);
    });
  }
  write(t) {
    this._ensureOpen() && (this.resolvers.length <= 0 ? this._values.push(t) : this.resolvers.shift().resolve({ done: !1, value: t }));
  }
  abort(t) {
    this._closedPromiseResolve && (this.resolvers.length <= 0 ? this._error = { error: t } : this.resolvers.shift().reject({ done: !0, value: t }));
  }
  close() {
    if (this._closedPromiseResolve) {
      const { resolvers: t } = this;
      for (; t.length > 0; )
        t.shift().resolve(Se);
      this._closedPromiseResolve(), this._closedPromiseResolve = void 0;
    }
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  toDOMStream(t) {
    return Jn.toDOMStream(this._closedPromiseResolve || this._error ? this : this._values, t);
  }
  toNodeStream(t) {
    return Jn.toNodeStream(this._closedPromiseResolve || this._error ? this : this._values, t);
  }
  throw(t) {
    return W(this, void 0, void 0, function* () {
      return yield this.abort(t), Se;
    });
  }
  return(t) {
    return W(this, void 0, void 0, function* () {
      return yield this.close(), Se;
    });
  }
  read(t) {
    return W(this, void 0, void 0, function* () {
      return (yield this.next(t, "read")).value;
    });
  }
  peek(t) {
    return W(this, void 0, void 0, function* () {
      return (yield this.next(t, "peek")).value;
    });
  }
  next(...t) {
    return this._values.length > 0 ? Promise.resolve({ done: !1, value: this._values.shift() }) : this._error ? Promise.reject({ done: !0, value: this._error.error }) : this._closedPromiseResolve ? new Promise((n, i) => {
      this.resolvers.push({ resolve: n, reject: i });
    }) : Promise.resolve(Se);
  }
  _ensureOpen() {
    if (this._closedPromiseResolve)
      return !0;
    throw new Error("AsyncQueue is closed");
  }
}, p7 = class extends d7 {
  write(t) {
    if ((t = Yt(t)).byteLength > 0)
      return super.write(t);
  }
  toString(t = !1) {
    return t ? pg(this.toUint8Array(!0)) : this.toUint8Array(!1).then(pg);
  }
  toUint8Array(t = !1) {
    return t ? cr(this._values)[0] : W(this, void 0, void 0, function* () {
      var n, i, r, s;
      const o = [];
      let a = 0;
      try {
        for (var c = !0, l = ci(this), u; u = yield l.next(), n = u.done, !n; c = !0) {
          s = u.value, c = !1;
          const f = s;
          o.push(f), a += f.byteLength;
        }
      } catch (f) {
        i = { error: f };
      } finally {
        try {
          !c && !n && (r = l.return) && (yield r.call(l));
        } finally {
          if (i)
            throw i.error;
        }
      }
      return cr(o, a)[0];
    });
  }
}, Ud = class {
  constructor(t) {
    t && (this.source = new y7(Jn.fromIterable(t)));
  }
  [Symbol.iterator]() {
    return this;
  }
  next(t) {
    return this.source.next(t);
  }
  throw(t) {
    return this.source.throw(t);
  }
  return(t) {
    return this.source.return(t);
  }
  peek(t) {
    return this.source.peek(t);
  }
  read(t) {
    return this.source.read(t);
  }
}, zd = class _3 {
  constructor(t) {
    t instanceof _3 ? this.source = t.source : t instanceof p7 ? this.source = new mo(Jn.fromAsyncIterable(t)) : kI(t) ? this.source = new mo(Jn.fromNodeStream(t)) : pb(t) ? this.source = new mo(Jn.fromDOMStream(t)) : RI(t) ? this.source = new mo(Jn.fromDOMStream(t.body)) : Ly(t) ? this.source = new mo(Jn.fromIterable(t)) : bu(t) ? this.source = new mo(Jn.fromAsyncIterable(t)) : db(t) && (this.source = new mo(Jn.fromAsyncIterable(t)));
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  next(t) {
    return this.source.next(t);
  }
  throw(t) {
    return this.source.throw(t);
  }
  return(t) {
    return this.source.return(t);
  }
  get closed() {
    return this.source.closed;
  }
  cancel(t) {
    return this.source.cancel(t);
  }
  peek(t) {
    return this.source.peek(t);
  }
  read(t) {
    return this.source.read(t);
  }
}, y7 = class {
  constructor(t) {
    this.source = t;
  }
  cancel(t) {
    this.return(t);
  }
  peek(t) {
    return this.next(t, "peek").value;
  }
  read(t) {
    return this.next(t, "read").value;
  }
  next(t, n = "read") {
    return this.source.next({ cmd: n, size: t });
  }
  throw(t) {
    return Object.create(this.source.throw && this.source.throw(t) || Se);
  }
  return(t) {
    return Object.create(this.source.return && this.source.return(t) || Se);
  }
}, mo = class {
  constructor(t) {
    this.source = t, this._closedPromise = new Promise((n) => this._closedPromiseResolve = n);
  }
  cancel(t) {
    return W(this, void 0, void 0, function* () {
      yield this.return(t);
    });
  }
  get closed() {
    return this._closedPromise;
  }
  read(t) {
    return W(this, void 0, void 0, function* () {
      return (yield this.next(t, "read")).value;
    });
  }
  peek(t) {
    return W(this, void 0, void 0, function* () {
      return (yield this.next(t, "peek")).value;
    });
  }
  next(t, n = "read") {
    return W(this, void 0, void 0, function* () {
      return yield this.source.next({ cmd: n, size: t });
    });
  }
  throw(t) {
    return W(this, void 0, void 0, function* () {
      const n = this.source.throw && (yield this.source.throw(t)) || Se;
      return this._closedPromiseResolve && this._closedPromiseResolve(), this._closedPromiseResolve = void 0, Object.create(n);
    });
  }
  return(t) {
    return W(this, void 0, void 0, function* () {
      const n = this.source.return && (yield this.source.return(t)) || Se;
      return this._closedPromiseResolve && this._closedPromiseResolve(), this._closedPromiseResolve = void 0, Object.create(n);
    });
  }
}, X_ = class extends Ud {
  constructor(t, n) {
    super(), this.position = 0, this.buffer = Yt(t), this.size = n === void 0 ? this.buffer.byteLength : n;
  }
  readInt32(t) {
    const { buffer: n, byteOffset: i } = this.readAt(t, 4);
    return new DataView(n, i).getInt32(0, !0);
  }
  seek(t) {
    return this.position = Math.min(t, this.size), t < this.size;
  }
  read(t) {
    const { buffer: n, size: i, position: r } = this;
    return n && r < i ? (typeof t != "number" && (t = Number.POSITIVE_INFINITY), this.position = Math.min(i, r + Math.min(i - r, t)), n.subarray(r, this.position)) : null;
  }
  readAt(t, n) {
    const i = this.buffer, r = Math.min(this.size, t + n);
    return i ? i.subarray(t, r) : new Uint8Array(n);
  }
  close() {
    this.buffer && (this.buffer = null);
  }
  throw(t) {
    return this.close(), { done: !0, value: t };
  }
  return(t) {
    return this.close(), { done: !0, value: t };
  }
}, Pd = class extends zd {
  constructor(t, n) {
    super(), this.position = 0, this._handle = t, typeof n == "number" ? this.size = n : this._pending = W(this, void 0, void 0, function* () {
      this.size = (yield t.stat()).size, delete this._pending;
    });
  }
  readInt32(t) {
    return W(this, void 0, void 0, function* () {
      const { buffer: n, byteOffset: i } = yield this.readAt(t, 4);
      return new DataView(n, i).getInt32(0, !0);
    });
  }
  seek(t) {
    return W(this, void 0, void 0, function* () {
      return this._pending && (yield this._pending), this.position = Math.min(t, this.size), t < this.size;
    });
  }
  read(t) {
    return W(this, void 0, void 0, function* () {
      this._pending && (yield this._pending);
      const { _handle: n, size: i, position: r } = this;
      if (n && r < i) {
        typeof t != "number" && (t = Number.POSITIVE_INFINITY);
        let s = r, o = 0, a = 0;
        const c = Math.min(i, s + Math.min(i - s, t)), l = new Uint8Array(Math.max(0, (this.position = c) - s));
        for (; (s += a) < c && (o += a) < l.byteLength; )
          ({ bytesRead: a } = yield n.read(l, o, l.byteLength - o, s));
        return l;
      }
      return null;
    });
  }
  readAt(t, n) {
    return W(this, void 0, void 0, function* () {
      this._pending && (yield this._pending);
      const { _handle: i, size: r } = this;
      if (i && t + n < r) {
        const s = Math.min(r, t + n), o = new Uint8Array(s - t);
        return (yield i.read(o, 0, n, t)).buffer;
      }
      return new Uint8Array(n);
    });
  }
  close() {
    return W(this, void 0, void 0, function* () {
      const t = this._handle;
      this._handle = null, t && (yield t.close());
    });
  }
  throw(t) {
    return W(this, void 0, void 0, function* () {
      return yield this.close(), { done: !0, value: t };
    });
  }
  return(t) {
    return W(this, void 0, void 0, function* () {
      return yield this.close(), { done: !0, value: t };
    });
  }
};
const m7 = 65536;
function Ka(e) {
  return e < 0 && (e = 4294967295 + e + 1), `0x${e.toString(16)}`;
}
const Ac = 8, Mb = [
  1,
  10,
  100,
  1e3,
  1e4,
  1e5,
  1e6,
  1e7,
  1e8
];
let S3 = class {
  constructor(t) {
    this.buffer = t;
  }
  high() {
    return this.buffer[1];
  }
  low() {
    return this.buffer[0];
  }
  _times(t) {
    const n = new Uint32Array([
      this.buffer[1] >>> 16,
      this.buffer[1] & 65535,
      this.buffer[0] >>> 16,
      this.buffer[0] & 65535
    ]), i = new Uint32Array([
      t.buffer[1] >>> 16,
      t.buffer[1] & 65535,
      t.buffer[0] >>> 16,
      t.buffer[0] & 65535
    ]);
    let r = n[3] * i[3];
    this.buffer[0] = r & 65535;
    let s = r >>> 16;
    return r = n[2] * i[3], s += r, r = n[3] * i[2] >>> 0, s += r, this.buffer[0] += s << 16, this.buffer[1] = s >>> 0 < r ? m7 : 0, this.buffer[1] += s >>> 16, this.buffer[1] += n[1] * i[3] + n[2] * i[2] + n[3] * i[1], this.buffer[1] += n[0] * i[3] + n[1] * i[2] + n[2] * i[1] + n[3] * i[0] << 16, this;
  }
  _plus(t) {
    const n = this.buffer[0] + t.buffer[0] >>> 0;
    this.buffer[1] += t.buffer[1], n < this.buffer[0] >>> 0 && ++this.buffer[1], this.buffer[0] = n;
  }
  lessThan(t) {
    return this.buffer[1] < t.buffer[1] || this.buffer[1] === t.buffer[1] && this.buffer[0] < t.buffer[0];
  }
  equals(t) {
    return this.buffer[1] === t.buffer[1] && this.buffer[0] == t.buffer[0];
  }
  greaterThan(t) {
    return t.lessThan(this);
  }
  hex() {
    return `${Ka(this.buffer[1])} ${Ka(this.buffer[0])}`;
  }
}, Fe = class Nr extends S3 {
  times(t) {
    return this._times(t), this;
  }
  plus(t) {
    return this._plus(t), this;
  }
  /** @nocollapse */
  static from(t, n = new Uint32Array(2)) {
    return Nr.fromString(typeof t == "string" ? t : t.toString(), n);
  }
  /** @nocollapse */
  static fromNumber(t, n = new Uint32Array(2)) {
    return Nr.fromString(t.toString(), n);
  }
  /** @nocollapse */
  static fromString(t, n = new Uint32Array(2)) {
    const i = t.length, r = new Nr(n);
    for (let s = 0; s < i; ) {
      const o = Ac < i - s ? Ac : i - s, a = new Nr(new Uint32Array([Number.parseInt(t.slice(s, s + o), 10), 0])), c = new Nr(new Uint32Array([Mb[o], 0]));
      r.times(c), r.plus(a), s += o;
    }
    return r;
  }
  /** @nocollapse */
  static convertArray(t) {
    const n = new Uint32Array(t.length * 2);
    for (let i = -1, r = t.length; ++i < r; )
      Nr.from(t[i], new Uint32Array(n.buffer, n.byteOffset + 2 * i * 4, 2));
    return n;
  }
  /** @nocollapse */
  static multiply(t, n) {
    return new Nr(new Uint32Array(t.buffer)).times(n);
  }
  /** @nocollapse */
  static add(t, n) {
    return new Nr(new Uint32Array(t.buffer)).plus(n);
  }
}, au = class Br extends S3 {
  negate() {
    return this.buffer[0] = ~this.buffer[0] + 1, this.buffer[1] = ~this.buffer[1], this.buffer[0] == 0 && ++this.buffer[1], this;
  }
  times(t) {
    return this._times(t), this;
  }
  plus(t) {
    return this._plus(t), this;
  }
  lessThan(t) {
    const n = this.buffer[1] << 0, i = t.buffer[1] << 0;
    return n < i || n === i && this.buffer[0] < t.buffer[0];
  }
  /** @nocollapse */
  static from(t, n = new Uint32Array(2)) {
    return Br.fromString(typeof t == "string" ? t : t.toString(), n);
  }
  /** @nocollapse */
  static fromNumber(t, n = new Uint32Array(2)) {
    return Br.fromString(t.toString(), n);
  }
  /** @nocollapse */
  static fromString(t, n = new Uint32Array(2)) {
    const i = t.startsWith("-"), r = t.length, s = new Br(n);
    for (let o = i ? 1 : 0; o < r; ) {
      const a = Ac < r - o ? Ac : r - o, c = new Br(new Uint32Array([Number.parseInt(t.slice(o, o + a), 10), 0])), l = new Br(new Uint32Array([Mb[a], 0]));
      s.times(l), s.plus(c), o += a;
    }
    return i ? s.negate() : s;
  }
  /** @nocollapse */
  static convertArray(t) {
    const n = new Uint32Array(t.length * 2);
    for (let i = -1, r = t.length; ++i < r; )
      Br.from(t[i], new Uint32Array(n.buffer, n.byteOffset + 2 * i * 4, 2));
    return n;
  }
  /** @nocollapse */
  static multiply(t, n) {
    return new Br(new Uint32Array(t.buffer)).times(n);
  }
  /** @nocollapse */
  static add(t, n) {
    return new Br(new Uint32Array(t.buffer)).plus(n);
  }
}, g7 = class Or {
  constructor(t) {
    this.buffer = t;
  }
  high() {
    return new au(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));
  }
  low() {
    return new au(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset, 2));
  }
  negate() {
    return this.buffer[0] = ~this.buffer[0] + 1, this.buffer[1] = ~this.buffer[1], this.buffer[2] = ~this.buffer[2], this.buffer[3] = ~this.buffer[3], this.buffer[0] == 0 && ++this.buffer[1], this.buffer[1] == 0 && ++this.buffer[2], this.buffer[2] == 0 && ++this.buffer[3], this;
  }
  times(t) {
    const n = new Fe(new Uint32Array([this.buffer[3], 0])), i = new Fe(new Uint32Array([this.buffer[2], 0])), r = new Fe(new Uint32Array([this.buffer[1], 0])), s = new Fe(new Uint32Array([this.buffer[0], 0])), o = new Fe(new Uint32Array([t.buffer[3], 0])), a = new Fe(new Uint32Array([t.buffer[2], 0])), c = new Fe(new Uint32Array([t.buffer[1], 0])), l = new Fe(new Uint32Array([t.buffer[0], 0]));
    let u = Fe.multiply(s, l);
    this.buffer[0] = u.low();
    const f = new Fe(new Uint32Array([u.high(), 0]));
    return u = Fe.multiply(r, l), f.plus(u), u = Fe.multiply(s, c), f.plus(u), this.buffer[1] = f.low(), this.buffer[3] = f.lessThan(u) ? 1 : 0, this.buffer[2] = f.high(), new Fe(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2)).plus(Fe.multiply(i, l)).plus(Fe.multiply(r, c)).plus(Fe.multiply(s, a)), this.buffer[3] += Fe.multiply(n, l).plus(Fe.multiply(i, c)).plus(Fe.multiply(r, a)).plus(Fe.multiply(s, o)).low(), this;
  }
  plus(t) {
    const n = new Uint32Array(4);
    return n[3] = this.buffer[3] + t.buffer[3] >>> 0, n[2] = this.buffer[2] + t.buffer[2] >>> 0, n[1] = this.buffer[1] + t.buffer[1] >>> 0, n[0] = this.buffer[0] + t.buffer[0] >>> 0, n[0] < this.buffer[0] >>> 0 && ++n[1], n[1] < this.buffer[1] >>> 0 && ++n[2], n[2] < this.buffer[2] >>> 0 && ++n[3], this.buffer[3] = n[3], this.buffer[2] = n[2], this.buffer[1] = n[1], this.buffer[0] = n[0], this;
  }
  hex() {
    return `${Ka(this.buffer[3])} ${Ka(this.buffer[2])} ${Ka(this.buffer[1])} ${Ka(this.buffer[0])}`;
  }
  /** @nocollapse */
  static multiply(t, n) {
    return new Or(new Uint32Array(t.buffer)).times(n);
  }
  /** @nocollapse */
  static add(t, n) {
    return new Or(new Uint32Array(t.buffer)).plus(n);
  }
  /** @nocollapse */
  static from(t, n = new Uint32Array(4)) {
    return Or.fromString(typeof t == "string" ? t : t.toString(), n);
  }
  /** @nocollapse */
  static fromNumber(t, n = new Uint32Array(4)) {
    return Or.fromString(t.toString(), n);
  }
  /** @nocollapse */
  static fromString(t, n = new Uint32Array(4)) {
    const i = t.startsWith("-"), r = t.length, s = new Or(n);
    for (let o = i ? 1 : 0; o < r; ) {
      const a = Ac < r - o ? Ac : r - o, c = new Or(new Uint32Array([Number.parseInt(t.slice(o, o + a), 10), 0, 0, 0])), l = new Or(new Uint32Array([Mb[a], 0, 0, 0]));
      s.times(l), s.plus(c), o += a;
    }
    return i ? s.negate() : s;
  }
  /** @nocollapse */
  static convertArray(t) {
    const n = new Uint32Array(t.length * 4);
    for (let i = -1, r = t.length; ++i < r; )
      Or.from(t[i], new Uint32Array(n.buffer, n.byteOffset + 4 * 4 * i, 4));
    return n;
  }
}, x3 = class extends Ut {
  constructor(t, n, i, r, s = Ee.V5) {
    super(), this.nodesIndex = -1, this.buffersIndex = -1, this.bytes = t, this.nodes = n, this.buffers = i, this.dictionaries = r, this.metadataVersion = s;
  }
  visit(t) {
    return super.visit(t instanceof Te ? t.type : t);
  }
  visitNull(t, { length: n } = this.nextFieldNode()) {
    return Rt({ type: t, length: n });
  }
  visitBool(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return Rt({ type: t, length: n, nullCount: i, nullBitmap: this.readNullBitmap(t, i), data: this.readData(t) });
  }
  visitInt(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return Rt({ type: t, length: n, nullCount: i, nullBitmap: this.readNullBitmap(t, i), data: this.readData(t) });
  }
  visitFloat(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return Rt({ type: t, length: n, nullCount: i, nullBitmap: this.readNullBitmap(t, i), data: this.readData(t) });
  }
  visitUtf8(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return Rt({ type: t, length: n, nullCount: i, nullBitmap: this.readNullBitmap(t, i), valueOffsets: this.readOffsets(t), data: this.readData(t) });
  }
  visitLargeUtf8(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return Rt({ type: t, length: n, nullCount: i, nullBitmap: this.readNullBitmap(t, i), valueOffsets: this.readOffsets(t), data: this.readData(t) });
  }
  visitBinary(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return Rt({ type: t, length: n, nullCount: i, nullBitmap: this.readNullBitmap(t, i), valueOffsets: this.readOffsets(t), data: this.readData(t) });
  }
  visitLargeBinary(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return Rt({ type: t, length: n, nullCount: i, nullBitmap: this.readNullBitmap(t, i), valueOffsets: this.readOffsets(t), data: this.readData(t) });
  }
  visitFixedSizeBinary(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return Rt({ type: t, length: n, nullCount: i, nullBitmap: this.readNullBitmap(t, i), data: this.readData(t) });
  }
  visitDate(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return Rt({ type: t, length: n, nullCount: i, nullBitmap: this.readNullBitmap(t, i), data: this.readData(t) });
  }
  visitTimestamp(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return Rt({ type: t, length: n, nullCount: i, nullBitmap: this.readNullBitmap(t, i), data: this.readData(t) });
  }
  visitTime(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return Rt({ type: t, length: n, nullCount: i, nullBitmap: this.readNullBitmap(t, i), data: this.readData(t) });
  }
  visitDecimal(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return Rt({ type: t, length: n, nullCount: i, nullBitmap: this.readNullBitmap(t, i), data: this.readData(t) });
  }
  visitList(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return Rt({ type: t, length: n, nullCount: i, nullBitmap: this.readNullBitmap(t, i), valueOffsets: this.readOffsets(t), child: this.visit(t.children[0]) });
  }
  visitStruct(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return Rt({ type: t, length: n, nullCount: i, nullBitmap: this.readNullBitmap(t, i), children: this.visitMany(t.children) });
  }
  visitUnion(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return this.metadataVersion < Ee.V5 && this.readNullBitmap(t, i), t.mode === Mn.Sparse ? this.visitSparseUnion(t, { length: n, nullCount: i }) : this.visitDenseUnion(t, { length: n, nullCount: i });
  }
  visitDenseUnion(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return Rt({ type: t, length: n, nullCount: i, typeIds: this.readTypeIds(t), valueOffsets: this.readOffsets(t), children: this.visitMany(t.children) });
  }
  visitSparseUnion(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return Rt({ type: t, length: n, nullCount: i, typeIds: this.readTypeIds(t), children: this.visitMany(t.children) });
  }
  visitDictionary(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return Rt({ type: t, length: n, nullCount: i, nullBitmap: this.readNullBitmap(t, i), data: this.readData(t.indices), dictionary: this.readDictionary(t) });
  }
  visitInterval(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return Rt({ type: t, length: n, nullCount: i, nullBitmap: this.readNullBitmap(t, i), data: this.readData(t) });
  }
  visitDuration(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return Rt({ type: t, length: n, nullCount: i, nullBitmap: this.readNullBitmap(t, i), data: this.readData(t) });
  }
  visitFixedSizeList(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return Rt({ type: t, length: n, nullCount: i, nullBitmap: this.readNullBitmap(t, i), child: this.visit(t.children[0]) });
  }
  visitMap(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return Rt({ type: t, length: n, nullCount: i, nullBitmap: this.readNullBitmap(t, i), valueOffsets: this.readOffsets(t), child: this.visit(t.children[0]) });
  }
  nextFieldNode() {
    return this.nodes[++this.nodesIndex];
  }
  nextBufferRange() {
    return this.buffers[++this.buffersIndex];
  }
  readNullBitmap(t, n, i = this.nextBufferRange()) {
    return n > 0 && this.readData(t, i) || new Uint8Array(0);
  }
  readOffsets(t, n) {
    return this.readData(t, n);
  }
  readTypeIds(t, n) {
    return this.readData(t, n);
  }
  readData(t, { length: n, offset: i } = this.nextBufferRange()) {
    return this.bytes.subarray(i, i + n);
  }
  readDictionary(t) {
    return this.dictionaries.get(t.id);
  }
}, b7 = class extends x3 {
  constructor(t, n, i, r, s) {
    super(new Uint8Array(0), n, i, r, s), this.sources = t;
  }
  readNullBitmap(t, n, { offset: i } = this.nextBufferRange()) {
    return n <= 0 ? new Uint8Array(0) : Sg(this.sources[i]);
  }
  readOffsets(t, { offset: n } = this.nextBufferRange()) {
    return re(Uint8Array, re(t.OffsetArrayType, this.sources[n]));
  }
  readTypeIds(t, { offset: n } = this.nextBufferRange()) {
    return re(Uint8Array, re(t.ArrayType, this.sources[n]));
  }
  readData(t, { offset: n } = this.nextBufferRange()) {
    const { sources: i } = this;
    return rt.isTimestamp(t) || (rt.isInt(t) || rt.isTime(t)) && t.bitWidth === 64 || rt.isDuration(t) || rt.isDate(t) && t.unit === Ai.MILLISECOND ? re(Uint8Array, au.convertArray(i[n])) : rt.isDecimal(t) ? re(Uint8Array, g7.convertArray(i[n])) : rt.isBinary(t) || rt.isLargeBinary(t) || rt.isFixedSizeBinary(t) ? w7(i[n]) : rt.isBool(t) ? Sg(i[n]) : rt.isUtf8(t) || rt.isLargeUtf8(t) ? hb(i[n].join("")) : re(Uint8Array, re(t.ArrayType, i[n].map((r) => +r)));
  }
};
function w7(e) {
  const t = e.join(""), n = new Uint8Array(t.length / 2);
  for (let i = 0; i < t.length; i += 2)
    n[i >> 1] = Number.parseInt(t.slice(i, i + 2), 16);
  return n;
}
let ft = class extends Ut {
  compareSchemas(t, n) {
    return t === n || n instanceof t.constructor && this.compareManyFields(t.fields, n.fields);
  }
  compareManyFields(t, n) {
    return t === n || Array.isArray(t) && Array.isArray(n) && t.length === n.length && t.every((i, r) => this.compareFields(i, n[r]));
  }
  compareFields(t, n) {
    return t === n || n instanceof t.constructor && t.name === n.name && t.nullable === n.nullable && this.visit(t.type, n.type);
  }
};
function wn(e, t) {
  return t instanceof e.constructor;
}
function sa(e, t) {
  return e === t || wn(e, t);
}
function ls(e, t) {
  return e === t || wn(e, t) && e.bitWidth === t.bitWidth && e.isSigned === t.isSigned;
}
function ky(e, t) {
  return e === t || wn(e, t) && e.precision === t.precision;
}
function v7(e, t) {
  return e === t || wn(e, t) && e.byteWidth === t.byteWidth;
}
function $b(e, t) {
  return e === t || wn(e, t) && e.unit === t.unit;
}
function cf(e, t) {
  return e === t || wn(e, t) && e.unit === t.unit && e.timezone === t.timezone;
}
function lf(e, t) {
  return e === t || wn(e, t) && e.unit === t.unit && e.bitWidth === t.bitWidth;
}
function _7(e, t) {
  return e === t || wn(e, t) && e.children.length === t.children.length && Vs.compareManyFields(e.children, t.children);
}
function S7(e, t) {
  return e === t || wn(e, t) && e.children.length === t.children.length && Vs.compareManyFields(e.children, t.children);
}
function Tb(e, t) {
  return e === t || wn(e, t) && e.mode === t.mode && e.typeIds.every((n, i) => n === t.typeIds[i]) && Vs.compareManyFields(e.children, t.children);
}
function x7(e, t) {
  return e === t || wn(e, t) && e.id === t.id && e.isOrdered === t.isOrdered && Vs.visit(e.indices, t.indices) && Vs.visit(e.dictionary, t.dictionary);
}
function Db(e, t) {
  return e === t || wn(e, t) && e.unit === t.unit;
}
function uf(e, t) {
  return e === t || wn(e, t) && e.unit === t.unit;
}
function I7(e, t) {
  return e === t || wn(e, t) && e.listSize === t.listSize && e.children.length === t.children.length && Vs.compareManyFields(e.children, t.children);
}
function A7(e, t) {
  return e === t || wn(e, t) && e.keysSorted === t.keysSorted && e.children.length === t.children.length && Vs.compareManyFields(e.children, t.children);
}
ft.prototype.visitNull = sa;
ft.prototype.visitBool = sa;
ft.prototype.visitInt = ls;
ft.prototype.visitInt8 = ls;
ft.prototype.visitInt16 = ls;
ft.prototype.visitInt32 = ls;
ft.prototype.visitInt64 = ls;
ft.prototype.visitUint8 = ls;
ft.prototype.visitUint16 = ls;
ft.prototype.visitUint32 = ls;
ft.prototype.visitUint64 = ls;
ft.prototype.visitFloat = ky;
ft.prototype.visitFloat16 = ky;
ft.prototype.visitFloat32 = ky;
ft.prototype.visitFloat64 = ky;
ft.prototype.visitUtf8 = sa;
ft.prototype.visitLargeUtf8 = sa;
ft.prototype.visitBinary = sa;
ft.prototype.visitLargeBinary = sa;
ft.prototype.visitFixedSizeBinary = v7;
ft.prototype.visitDate = $b;
ft.prototype.visitDateDay = $b;
ft.prototype.visitDateMillisecond = $b;
ft.prototype.visitTimestamp = cf;
ft.prototype.visitTimestampSecond = cf;
ft.prototype.visitTimestampMillisecond = cf;
ft.prototype.visitTimestampMicrosecond = cf;
ft.prototype.visitTimestampNanosecond = cf;
ft.prototype.visitTime = lf;
ft.prototype.visitTimeSecond = lf;
ft.prototype.visitTimeMillisecond = lf;
ft.prototype.visitTimeMicrosecond = lf;
ft.prototype.visitTimeNanosecond = lf;
ft.prototype.visitDecimal = sa;
ft.prototype.visitList = _7;
ft.prototype.visitStruct = S7;
ft.prototype.visitUnion = Tb;
ft.prototype.visitDenseUnion = Tb;
ft.prototype.visitSparseUnion = Tb;
ft.prototype.visitDictionary = x7;
ft.prototype.visitInterval = Db;
ft.prototype.visitIntervalDayTime = Db;
ft.prototype.visitIntervalYearMonth = Db;
ft.prototype.visitDuration = uf;
ft.prototype.visitDurationSecond = uf;
ft.prototype.visitDurationMillisecond = uf;
ft.prototype.visitDurationMicrosecond = uf;
ft.prototype.visitDurationNanosecond = uf;
ft.prototype.visitFixedSizeList = I7;
ft.prototype.visitMap = A7;
const Vs = new ft();
function M7(e, t) {
  return Vs.compareSchemas(e, t);
}
function im(e, t) {
  return $7(e, t.map((n) => n.data.concat()));
}
function $7(e, t) {
  const n = [...e.fields], i = [], r = { numBatches: t.reduce((f, h) => Math.max(f, h.length), 0) };
  let s = 0, o = 0, a = -1;
  const c = t.length;
  let l, u = [];
  for (; r.numBatches-- > 0; ) {
    for (o = Number.POSITIVE_INFINITY, a = -1; ++a < c; )
      u[a] = l = t[a].shift(), o = Math.min(o, l ? l.length : o);
    Number.isFinite(o) && (u = T7(n, o, u, t, r), o > 0 && (i[s++] = Rt({
      type: new fn(n),
      length: o,
      nullCount: 0,
      children: u.slice()
    })));
  }
  return [
    e = e.assign(n),
    i.map((f) => new bi(e, f))
  ];
}
function T7(e, t, n, i, r) {
  var s;
  const o = (t + 63 & -64) >> 3;
  for (let a = -1, c = i.length; ++a < c; ) {
    const l = n[a], u = l == null ? void 0 : l.length;
    if (u >= t)
      u === t ? n[a] = l : (n[a] = l.slice(0, t), r.numBatches = Math.max(r.numBatches, i[a].unshift(l.slice(t, u - t))));
    else {
      const f = e[a];
      e[a] = f.clone({ nullable: !0 }), n[a] = (s = l == null ? void 0 : l._changeLengthAndBackfillNullBitmap(t)) !== null && s !== void 0 ? s : Rt({
        type: f.type,
        length: t,
        nullCount: t,
        nullBitmap: new Uint8Array(o)
      });
    }
  }
  return n;
}
var I3;
let Au = class To {
  constructor(...t) {
    var n, i;
    if (t.length === 0)
      return this.batches = [], this.schema = new _e([]), this._offsets = [0], this;
    let r, s;
    t[0] instanceof _e && (r = t.shift()), t.at(-1) instanceof Uint32Array && (s = t.pop());
    const o = (c) => {
      if (c) {
        if (c instanceof bi)
          return [c];
        if (c instanceof To)
          return c.batches;
        if (c instanceof de) {
          if (c.type instanceof fn)
            return [new bi(new _e(c.type.children), c)];
        } else {
          if (Array.isArray(c))
            return c.flatMap((l) => o(l));
          if (typeof c[Symbol.iterator] == "function")
            return [...c].flatMap((l) => o(l));
          if (typeof c == "object") {
            const l = Object.keys(c), u = l.map((d) => new Ne([c[d]])), f = r ?? new _e(l.map((d, p) => new Te(String(d), u[p].type, u[p].nullable))), [, h] = im(f, u);
            return h.length === 0 ? [new bi(c)] : h;
          }
        }
      }
      return [];
    }, a = t.flatMap((c) => o(c));
    if (r = (i = r ?? ((n = a[0]) === null || n === void 0 ? void 0 : n.schema)) !== null && i !== void 0 ? i : new _e([]), !(r instanceof _e))
      throw new TypeError("Table constructor expects a [Schema, RecordBatch[]] pair.");
    for (const c of a) {
      if (!(c instanceof bi))
        throw new TypeError("Table constructor expects a [Schema, RecordBatch[]] pair.");
      if (!M7(r, c.schema))
        throw new TypeError("Table and inner RecordBatch schemas must be equivalent.");
    }
    this.schema = r, this.batches = a, this._offsets = s ?? u3(this.data);
  }
  /**
   * The contiguous {@link RecordBatch `RecordBatch`} chunks of the Table rows.
   */
  get data() {
    return this.batches.map(({ data: t }) => t);
  }
  /**
   * The number of columns in this Table.
   */
  get numCols() {
    return this.schema.fields.length;
  }
  /**
   * The number of rows in this Table.
   */
  get numRows() {
    return this.data.reduce((t, n) => t + n.length, 0);
  }
  /**
   * The number of null rows in this Table.
   */
  get nullCount() {
    return this._nullCount === -1 && (this._nullCount = l3(this.data)), this._nullCount;
  }
  /**
   * Check whether an element is null.
   *
   * @param index The index at which to read the validity bitmap.
   */
  // @ts-ignore
  isValid(t) {
    return !1;
  }
  /**
   * Get an element value by position.
   *
   * @param index The index of the element to read.
   */
  // @ts-ignore
  get(t) {
    return null;
  }
  /**
   * Set an element value by position.
   *
   * @param index The index of the element to write.
   * @param value The value to set.
   */
  // @ts-ignore
  set(t, n) {
  }
  /**
   * Retrieve the index of the first occurrence of a value in an Vector.
   *
   * @param element The value to locate in the Vector.
   * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
   */
  // @ts-ignore
  indexOf(t, n) {
    return -1;
  }
  /**
   * Iterator for rows in this Table.
   */
  [Symbol.iterator]() {
    return this.batches.length > 0 ? Ib.visit(new Ne(this.data)) : new Array(0)[Symbol.iterator]();
  }
  /**
   * Return a JavaScript Array of the Table rows.
   *
   * @returns An Array of Table rows.
   */
  toArray() {
    return [...this];
  }
  /**
   * Returns a string representation of the Table rows.
   *
   * @returns A string representation of the Table rows.
   */
  toString() {
    return `[
  ${this.toArray().join(`,
  `)}
]`;
  }
  /**
   * Combines two or more Tables of the same schema.
   *
   * @param others Additional Tables to add to the end of this Tables.
   */
  concat(...t) {
    const n = this.schema, i = this.data.concat(t.flatMap(({ data: r }) => r));
    return new To(n, i.map((r) => new bi(n, r)));
  }
  /**
   * Return a zero-copy sub-section of this Table.
   *
   * @param begin The beginning of the specified portion of the Table.
   * @param end The end of the specified portion of the Table. This is exclusive of the element at the index 'end'.
   */
  slice(t, n) {
    const i = this.schema;
    [t, n] = a3({ length: this.numRows }, t, n);
    const r = f3(this.data, this._offsets, t, n);
    return new To(i, r.map((s) => new bi(i, s)));
  }
  /**
   * Returns a child Vector by name, or null if this Vector has no child with the given name.
   *
   * @param name The name of the child to retrieve.
   */
  getChild(t) {
    return this.getChildAt(this.schema.fields.findIndex((n) => n.name === t));
  }
  /**
   * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
   *
   * @param index The index of the child to retrieve.
   */
  getChildAt(t) {
    if (t > -1 && t < this.schema.fields.length) {
      const n = this.data.map((i) => i.children[t]);
      if (n.length === 0) {
        const { type: i } = this.schema.fields[t], r = Rt({ type: i, length: 0, nullCount: 0 });
        n.push(r._changeLengthAndBackfillNullBitmap(this.numRows));
      }
      return new Ne(n);
    }
    return null;
  }
  /**
   * Sets a child Vector by name.
   *
   * @param name The name of the child to overwrite.
   * @returns A new Table with the supplied child for the specified name.
   */
  setChild(t, n) {
    var i;
    return this.setChildAt((i = this.schema.fields) === null || i === void 0 ? void 0 : i.findIndex((r) => r.name === t), n);
  }
  setChildAt(t, n) {
    let i = this.schema, r = [...this.batches];
    if (t > -1 && t < this.numCols) {
      n || (n = new Ne([Rt({ type: new zs(), length: this.numRows })]));
      const s = i.fields.slice(), o = s[t].clone({ type: n.type }), a = this.schema.fields.map((c, l) => this.getChildAt(l));
      [s[t], a[t]] = [o, n], [i, r] = im(i, a);
    }
    return new To(i, r);
  }
  /**
   * Construct a new Table containing only specified columns.
   *
   * @param columnNames Names of columns to keep.
   * @returns A new Table of columns matching the specified names.
   */
  select(t) {
    const n = this.schema.fields.reduce((i, r, s) => i.set(r.name, s), /* @__PURE__ */ new Map());
    return this.selectAt(t.map((i) => n.get(i)).filter((i) => i > -1));
  }
  /**
   * Construct a new Table containing only columns at the specified indices.
   *
   * @param columnIndices Indices of columns to keep.
   * @returns A new Table of columns at the specified indices.
   */
  selectAt(t) {
    const n = this.schema.selectAt(t), i = this.batches.map((r) => r.selectAt(t));
    return new To(n, i);
  }
  assign(t) {
    const n = this.schema.fields, [i, r] = t.schema.fields.reduce((a, c, l) => {
      const [u, f] = a, h = n.findIndex((d) => d.name === c.name);
      return ~h ? f[h] = l : u.push(l), a;
    }, [[], []]), s = this.schema.assign(t.schema), o = [
      ...n.map((a, c) => [c, r[c]]).map(([a, c]) => c === void 0 ? this.getChildAt(a) : t.getChildAt(c)),
      ...i.map((a) => t.getChildAt(a))
    ].filter(Boolean);
    return new To(...im(s, o));
  }
};
I3 = Symbol.toStringTag;
Au[I3] = ((e) => (e.schema = null, e.batches = [], e._offsets = new Uint32Array([0]), e._nullCount = -1, e[Symbol.isConcatSpreadable] = !0, e.isValid = Rd(xb), e.get = Rd($n.getVisitFn(F.Struct)), e.set = h3(li.getVisitFn(F.Struct)), e.indexOf = d3(Cd.getVisitFn(F.Struct)), "Table"))(Au.prototype);
var A3;
let bi = class jl {
  constructor(...t) {
    switch (t.length) {
      case 2: {
        if ([this.schema] = t, !(this.schema instanceof _e))
          throw new TypeError("RecordBatch constructor expects a [Schema, Data] pair.");
        if ([
          ,
          this.data = Rt({
            nullCount: 0,
            type: new fn(this.schema.fields),
            children: this.schema.fields.map((n) => Rt({ type: n.type, nullCount: 0 }))
          })
        ] = t, !(this.data instanceof de))
          throw new TypeError("RecordBatch constructor expects a [Schema, Data] pair.");
        [this.schema, this.data] = H_(this.schema, this.data.children);
        break;
      }
      case 1: {
        const [n] = t, { fields: i, children: r, length: s } = Object.keys(n).reduce((c, l, u) => (c.children[u] = n[l], c.length = Math.max(c.length, n[l].length), c.fields[u] = Te.new({ name: l, type: n[l].type, nullable: !0 }), c), {
          length: 0,
          fields: new Array(),
          children: new Array()
        }), o = new _e(i), a = Rt({ type: new fn(i), length: s, children: r, nullCount: 0 });
        [this.schema, this.data] = H_(o, a.children, s);
        break;
      }
      default:
        throw new TypeError("RecordBatch constructor expects an Object mapping names to child Data, or a [Schema, Data] pair.");
    }
  }
  get dictionaries() {
    return this._dictionaries || (this._dictionaries = M3(this.schema.fields, this.data.children));
  }
  /**
   * The number of columns in this RecordBatch.
   */
  get numCols() {
    return this.schema.fields.length;
  }
  /**
   * The number of rows in this RecordBatch.
   */
  get numRows() {
    return this.data.length;
  }
  /**
   * The number of null rows in this RecordBatch.
   */
  get nullCount() {
    return this.data.nullCount;
  }
  /**
   * Check whether an element is null.
   * @param index The index at which to read the validity bitmap.
   */
  isValid(t) {
    return this.data.getValid(t);
  }
  /**
   * Get a row by position.
   * @param index The index of the element to read.
   */
  get(t) {
    return $n.visit(this.data, t);
  }
  /**
   * Set a row by position.
   * @param index The index of the element to write.
   * @param value The value to set.
   */
  set(t, n) {
    return li.visit(this.data, t, n);
  }
  /**
   * Retrieve the index of the first occurrence of a row in an RecordBatch.
   * @param element The row to locate in the RecordBatch.
   * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
   */
  indexOf(t, n) {
    return Cd.visit(this.data, t, n);
  }
  /**
   * Iterator for rows in this RecordBatch.
   */
  [Symbol.iterator]() {
    return Ib.visit(new Ne([this.data]));
  }
  /**
   * Return a JavaScript Array of the RecordBatch rows.
   * @returns An Array of RecordBatch rows.
   */
  toArray() {
    return [...this];
  }
  /**
   * Combines two or more RecordBatch of the same schema.
   * @param others Additional RecordBatch to add to the end of this RecordBatch.
   */
  concat(...t) {
    return new Au(this.schema, [this, ...t]);
  }
  /**
   * Return a zero-copy sub-section of this RecordBatch.
   * @param start The beginning of the specified portion of the RecordBatch.
   * @param end The end of the specified portion of the RecordBatch. This is exclusive of the element at the index 'end'.
   */
  slice(t, n) {
    const [i] = new Ne([this.data]).slice(t, n).data;
    return new jl(this.schema, i);
  }
  /**
   * Returns a child Vector by name, or null if this Vector has no child with the given name.
   * @param name The name of the child to retrieve.
   */
  getChild(t) {
    var n;
    return this.getChildAt((n = this.schema.fields) === null || n === void 0 ? void 0 : n.findIndex((i) => i.name === t));
  }
  /**
   * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
   * @param index The index of the child to retrieve.
   */
  getChildAt(t) {
    return t > -1 && t < this.schema.fields.length ? new Ne([this.data.children[t]]) : null;
  }
  /**
   * Sets a child Vector by name.
   * @param name The name of the child to overwrite.
   * @returns A new RecordBatch with the new child for the specified name.
   */
  setChild(t, n) {
    var i;
    return this.setChildAt((i = this.schema.fields) === null || i === void 0 ? void 0 : i.findIndex((r) => r.name === t), n);
  }
  setChildAt(t, n) {
    let i = this.schema, r = this.data;
    if (t > -1 && t < this.numCols) {
      n || (n = new Ne([Rt({ type: new zs(), length: this.numRows })]));
      const s = i.fields.slice(), o = r.children.slice(), a = s[t].clone({ type: n.type });
      [s[t], o[t]] = [a, n.data[0]], i = new _e(s, new Map(this.schema.metadata)), r = Rt({ type: new fn(s), children: o });
    }
    return new jl(i, r);
  }
  /**
   * Construct a new RecordBatch containing only specified columns.
   *
   * @param columnNames Names of columns to keep.
   * @returns A new RecordBatch of columns matching the specified names.
   */
  select(t) {
    const n = this.schema.select(t), i = new fn(n.fields), r = [];
    for (const s of t) {
      const o = this.schema.fields.findIndex((a) => a.name === s);
      ~o && (r[o] = this.data.children[o]);
    }
    return new jl(n, Rt({ type: i, length: this.numRows, children: r }));
  }
  /**
   * Construct a new RecordBatch containing only columns at the specified indices.
   *
   * @param columnIndices Indices of columns to keep.
   * @returns A new RecordBatch of columns matching at the specified indices.
   */
  selectAt(t) {
    const n = this.schema.selectAt(t), i = t.map((s) => this.data.children[s]).filter(Boolean), r = Rt({ type: new fn(n.fields), length: this.numRows, children: i });
    return new jl(n, r);
  }
};
A3 = Symbol.toStringTag;
bi[A3] = ((e) => (e._nullCount = -1, e[Symbol.isConcatSpreadable] = !0, "RecordBatch"))(bi.prototype);
function H_(e, t, n = t.reduce((i, r) => Math.max(i, r.length), 0)) {
  var i;
  const r = [...e.fields], s = [...t], o = (n + 63 & -64) >> 3;
  for (const [a, c] of e.fields.entries()) {
    const l = t[a];
    (!l || l.length !== n) && (r[a] = c.clone({ nullable: !0 }), s[a] = (i = l == null ? void 0 : l._changeLengthAndBackfillNullBitmap(n)) !== null && i !== void 0 ? i : Rt({
      type: c.type,
      length: n,
      nullCount: n,
      nullBitmap: new Uint8Array(o)
    }));
  }
  return [
    e.assign(r),
    Rt({ type: new fn(r), length: n, children: s })
  ];
}
function M3(e, t, n = /* @__PURE__ */ new Map()) {
  var i, r;
  if (((i = e == null ? void 0 : e.length) !== null && i !== void 0 ? i : 0) > 0 && (e == null ? void 0 : e.length) === (t == null ? void 0 : t.length))
    for (let s = -1, o = e.length; ++s < o; ) {
      const { type: a } = e[s], c = t[s];
      for (const l of [c, ...((r = c == null ? void 0 : c.dictionary) === null || r === void 0 ? void 0 : r.data) || []])
        M3(a.children, l == null ? void 0 : l.children, n);
      if (rt.isDictionary(a)) {
        const { id: l } = a;
        if (!n.has(l))
          c != null && c.dictionary && n.set(l, c.dictionary);
        else if (n.get(l) !== c.dictionary)
          throw new Error("Cannot create Schema containing two different dictionaries with the same Id");
      }
    }
  return n;
}
let $3 = class extends bi {
  constructor(t) {
    const n = t.fields.map((r) => Rt({ type: r.type })), i = Rt({ type: new fn(t.fields), nullCount: 0, children: n });
    super(t, i);
  }
}, ws = class ji {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsMessage(t, n) {
    return (n || new ji()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsMessage(t, n) {
    return t.setPosition(t.position() + nt), (n || new ji()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  version() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt16(this.bb_pos + t) : Ee.V1;
  }
  headerType() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.readUint8(this.bb_pos + t) : Qt.NONE;
  }
  header(t) {
    const n = this.bb.__offset(this.bb_pos, 8);
    return n ? this.bb.__union(t, this.bb_pos + n) : null;
  }
  bodyLength() {
    const t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.readInt64(this.bb_pos + t) : BigInt("0");
  }
  customMetadata(t, n) {
    const i = this.bb.__offset(this.bb_pos, 12);
    return i ? (n || new ii()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + t * 4), this.bb) : null;
  }
  customMetadataLength() {
    const t = this.bb.__offset(this.bb_pos, 12);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  static startMessage(t) {
    t.startObject(5);
  }
  static addVersion(t, n) {
    t.addFieldInt16(0, n, Ee.V1);
  }
  static addHeaderType(t, n) {
    t.addFieldInt8(1, n, Qt.NONE);
  }
  static addHeader(t, n) {
    t.addFieldOffset(2, n, 0);
  }
  static addBodyLength(t, n) {
    t.addFieldInt64(3, n, BigInt("0"));
  }
  static addCustomMetadata(t, n) {
    t.addFieldOffset(4, n, 0);
  }
  static createCustomMetadataVector(t, n) {
    t.startVector(4, n.length, 4);
    for (let i = n.length - 1; i >= 0; i--)
      t.addOffset(n[i]);
    return t.endVector();
  }
  static startCustomMetadataVector(t, n) {
    t.startVector(4, n, 4);
  }
  static endMessage(t) {
    return t.endObject();
  }
  static finishMessageBuffer(t, n) {
    t.finish(n);
  }
  static finishSizePrefixedMessageBuffer(t, n) {
    t.finish(n, void 0, !0);
  }
  static createMessage(t, n, i, r, s, o) {
    return ji.startMessage(t), ji.addVersion(t, n), ji.addHeaderType(t, i), ji.addHeader(t, r), ji.addBodyLength(t, s), ji.addCustomMetadata(t, o), ji.endMessage(t);
  }
}, D7 = class extends Ut {
  visit(t, n) {
    return t == null || n == null ? void 0 : super.visit(t, n);
  }
  visitNull(t, n) {
    return C_.startNull(n), C_.endNull(n);
  }
  visitInt(t, n) {
    return Ja.startInt(n), Ja.addBitWidth(n, t.bitWidth), Ja.addIsSigned(n, t.isSigned), Ja.endInt(n);
  }
  visitFloat(t, n) {
    return Ph.startFloatingPoint(n), Ph.addPrecision(n, t.precision), Ph.endFloatingPoint(n);
  }
  visitBinary(t, n) {
    return O_.startBinary(n), O_.endBinary(n);
  }
  visitLargeBinary(t, n) {
    return E_.startLargeBinary(n), E_.endLargeBinary(n);
  }
  visitBool(t, n) {
    return F_.startBool(n), F_.endBool(n);
  }
  visitUtf8(t, n) {
    return U_.startUtf8(n), U_.endUtf8(n);
  }
  visitLargeUtf8(t, n) {
    return L_.startLargeUtf8(n), L_.endLargeUtf8(n);
  }
  visitDecimal(t, n) {
    return Oa.startDecimal(n), Oa.addScale(n, t.scale), Oa.addPrecision(n, t.precision), Oa.addBitWidth(n, t.bitWidth), Oa.endDecimal(n);
  }
  visitDate(t, n) {
    return Ch.startDate(n), Ch.addUnit(n, t.unit), Ch.endDate(n);
  }
  visitTime(t, n) {
    return zl.startTime(n), zl.addUnit(n, t.unit), zl.addBitWidth(n, t.bitWidth), zl.endTime(n);
  }
  visitTimestamp(t, n) {
    const i = t.timezone && n.createString(t.timezone) || void 0;
    return Pl.startTimestamp(n), Pl.addUnit(n, t.unit), i !== void 0 && Pl.addTimezone(n, i), Pl.endTimestamp(n);
  }
  visitInterval(t, n) {
    return Vh.startInterval(n), Vh.addUnit(n, t.unit), Vh.endInterval(n);
  }
  visitDuration(t, n) {
    return kh.startDuration(n), kh.addUnit(n, t.unit), kh.endDuration(n);
  }
  visitList(t, n) {
    return R_.startList(n), R_.endList(n);
  }
  visitStruct(t, n) {
    return k_.startStruct_(n), k_.endStruct_(n);
  }
  visitUnion(t, n) {
    Io.startTypeIdsVector(n, t.typeIds.length);
    const i = Io.createTypeIdsVector(n, t.typeIds);
    return Io.startUnion(n), Io.addMode(n, t.mode), Io.addTypeIds(n, i), Io.endUnion(n);
  }
  visitDictionary(t, n) {
    const i = this.visit(t.indices, n);
    return Na.startDictionaryEncoding(n), Na.addId(n, BigInt(t.id)), Na.addIsOrdered(n, t.isOrdered), i !== void 0 && Na.addIndexType(n, i), Na.endDictionaryEncoding(n);
  }
  visitFixedSizeBinary(t, n) {
    return Uh.startFixedSizeBinary(n), Uh.addByteWidth(n, t.byteWidth), Uh.endFixedSizeBinary(n);
  }
  visitFixedSizeList(t, n) {
    return zh.startFixedSizeList(n), zh.addListSize(n, t.listSize), zh.endFixedSizeList(n);
  }
  visitMap(t, n) {
    return jh.startMap(n), jh.addKeysSorted(n, t.keysSorted), jh.endMap(n);
  }
};
const rm = new D7();
function N7(e, t = /* @__PURE__ */ new Map()) {
  return new _e(O7(e, t), Wh(e.metadata), t);
}
function T3(e) {
  return new Mi(e.count, D3(e.columns), N3(e.columns));
}
function B7(e) {
  return new is(T3(e.data), e.id, e.isDelta);
}
function O7(e, t) {
  return (e.fields || []).filter(Boolean).map((n) => Te.fromJSON(n, t));
}
function J_(e, t) {
  return (e.children || []).filter(Boolean).map((n) => Te.fromJSON(n, t));
}
function D3(e) {
  return (e || []).reduce((t, n) => [
    ...t,
    new Qc(n.count, F7(n.VALIDITY)),
    ...D3(n.children)
  ], []);
}
function N3(e, t = []) {
  for (let n = -1, i = (e || []).length; ++n < i; ) {
    const r = e[n];
    r.VALIDITY && t.push(new Yr(t.length, r.VALIDITY.length)), r.TYPE_ID && t.push(new Yr(t.length, r.TYPE_ID.length)), r.OFFSET && t.push(new Yr(t.length, r.OFFSET.length)), r.DATA && t.push(new Yr(t.length, r.DATA.length)), t = N3(r.children, t);
  }
  return t;
}
function F7(e) {
  return (e || []).reduce((t, n) => t + +(n === 0), 0);
}
function E7(e, t) {
  let n, i, r, s, o, a;
  return !t || !(s = e.dictionary) ? (o = Z_(e, J_(e, t)), r = new Te(e.name, o, e.nullable, Wh(e.metadata))) : t.has(n = s.id) ? (i = (i = s.indexType) ? K_(i) : new Su(), a = new Ic(t.get(n), i, n, s.isOrdered), r = new Te(e.name, a, e.nullable, Wh(e.metadata))) : (i = (i = s.indexType) ? K_(i) : new Su(), t.set(n, o = Z_(e, J_(e, t))), a = new Ic(o, i, n, s.isOrdered), r = new Te(e.name, a, e.nullable, Wh(e.metadata))), r || null;
}
function Wh(e = []) {
  return new Map(e.map(({ key: t, value: n }) => [t, n]));
}
function K_(e) {
  return new Ps(e.isSigned, e.bitWidth);
}
function Z_(e, t) {
  const n = e.type.name;
  switch (n) {
    case "NONE":
      return new zs();
    case "null":
      return new zs();
    case "binary":
      return new _d();
    case "largebinary":
      return new Sd();
    case "utf8":
      return new xd();
    case "largeutf8":
      return new Id();
    case "bool":
      return new Ad();
    case "list":
      return new Bd((t || [])[0]);
    case "struct":
      return new fn(t || []);
    case "struct_":
      return new fn(t || []);
  }
  switch (n) {
    case "int": {
      const i = e.type;
      return new Ps(i.isSigned, i.bitWidth);
    }
    case "floatingpoint": {
      const i = e.type;
      return new xu(nn[i.precision]);
    }
    case "decimal": {
      const i = e.type;
      return new Md(i.scale, i.precision, i.bitWidth);
    }
    case "date": {
      const i = e.type;
      return new $d(Ai[i.unit]);
    }
    case "time": {
      const i = e.type;
      return new Iu(gt[i.unit], i.bitWidth);
    }
    case "timestamp": {
      const i = e.type;
      return new Td(gt[i.unit], i.timezone);
    }
    case "interval": {
      const i = e.type;
      return new Dd(lr[i.unit]);
    }
    case "duration": {
      const i = e.type;
      return new Nd(gt[i.unit]);
    }
    case "union": {
      const i = e.type, [r, ...s] = (i.mode + "").toLowerCase(), o = r.toUpperCase() + s.join("");
      return new Od(Mn[o], i.typeIds || [], t || []);
    }
    case "fixedsizebinary": {
      const i = e.type;
      return new Fd(i.byteWidth);
    }
    case "fixedsizelist": {
      const i = e.type;
      return new Ed(i.listSize, (t || [])[0]);
    }
    case "map": {
      const i = e.type;
      return new Ld((t || [])[0], i.keysSorted);
    }
  }
  throw new Error(`Unrecognized type: "${n}"`);
}
var L7 = Ry, R7 = ur;
let cu = class za {
  /** @nocollapse */
  static fromJSON(t, n) {
    const i = new za(0, Ee.V5, n);
    return i._createHeader = C7(t, n), i;
  }
  /** @nocollapse */
  static decode(t) {
    t = new R7(Yt(t));
    const n = ws.getRootAsMessage(t), i = n.bodyLength(), r = n.version(), s = n.headerType(), o = new za(i, r, s);
    return o._createHeader = k7(n, s), o;
  }
  /** @nocollapse */
  static encode(t) {
    const n = new L7();
    let i = -1;
    return t.isSchema() ? i = _e.encode(n, t.header()) : t.isRecordBatch() ? i = Mi.encode(n, t.header()) : t.isDictionaryBatch() && (i = is.encode(n, t.header())), ws.startMessage(n), ws.addVersion(n, Ee.V5), ws.addHeader(n, i), ws.addHeaderType(n, t.headerType), ws.addBodyLength(n, BigInt(t.bodyLength)), ws.finishMessageBuffer(n, ws.endMessage(n)), n.asUint8Array();
  }
  /** @nocollapse */
  static from(t, n = 0) {
    if (t instanceof _e)
      return new za(0, Ee.V5, Qt.Schema, t);
    if (t instanceof Mi)
      return new za(n, Ee.V5, Qt.RecordBatch, t);
    if (t instanceof is)
      return new za(n, Ee.V5, Qt.DictionaryBatch, t);
    throw new Error(`Unrecognized Message header: ${t}`);
  }
  get type() {
    return this.headerType;
  }
  get version() {
    return this._version;
  }
  get headerType() {
    return this._headerType;
  }
  get bodyLength() {
    return this._bodyLength;
  }
  header() {
    return this._createHeader();
  }
  isSchema() {
    return this.headerType === Qt.Schema;
  }
  isRecordBatch() {
    return this.headerType === Qt.RecordBatch;
  }
  isDictionaryBatch() {
    return this.headerType === Qt.DictionaryBatch;
  }
  constructor(t, n, i, r) {
    this._version = n, this._headerType = i, this.body = new Uint8Array(0), r && (this._createHeader = () => r), this._bodyLength = pn(t);
  }
}, Mi = class {
  get nodes() {
    return this._nodes;
  }
  get length() {
    return this._length;
  }
  get buffers() {
    return this._buffers;
  }
  constructor(t, n, i) {
    this._nodes = n, this._buffers = i, this._length = pn(t);
  }
}, is = class {
  get id() {
    return this._id;
  }
  get data() {
    return this._data;
  }
  get isDelta() {
    return this._isDelta;
  }
  get length() {
    return this.data.length;
  }
  get nodes() {
    return this.data.nodes;
  }
  get buffers() {
    return this.data.buffers;
  }
  constructor(t, n, i = !1) {
    this._data = t, this._isDelta = i, this._id = pn(n);
  }
}, Yr = class {
  constructor(t, n) {
    this.offset = pn(t), this.length = pn(n);
  }
}, Qc = class {
  constructor(t, n) {
    this.length = pn(t), this.nullCount = pn(n);
  }
};
function C7(e, t) {
  return () => {
    switch (t) {
      case Qt.Schema:
        return _e.fromJSON(e);
      case Qt.RecordBatch:
        return Mi.fromJSON(e);
      case Qt.DictionaryBatch:
        return is.fromJSON(e);
    }
    throw new Error(`Unrecognized Message type: { name: ${Qt[t]}, type: ${t} }`);
  };
}
function k7(e, t) {
  return () => {
    switch (t) {
      case Qt.Schema:
        return _e.decode(e.header(new Yi()), /* @__PURE__ */ new Map(), e.version());
      case Qt.RecordBatch:
        return Mi.decode(e.header(new Lr()), e.version());
      case Qt.DictionaryBatch:
        return is.decode(e.header(new Da()), e.version());
    }
    throw new Error(`Unrecognized Message type: { name: ${Qt[t]}, type: ${t} }`);
  };
}
Te.encode = H7;
Te.decode = G7;
Te.fromJSON = E7;
_e.encode = X7;
_e.decode = U7;
_e.fromJSON = N7;
Mi.encode = J7;
Mi.decode = z7;
Mi.fromJSON = T3;
is.encode = K7;
is.decode = P7;
is.fromJSON = B7;
Qc.encode = Z7;
Qc.decode = j7;
Yr.encode = Q7;
Yr.decode = V7;
function U7(e, t = /* @__PURE__ */ new Map(), n = Ee.V5) {
  const i = W7(e, t);
  return new _e(i, Gh(e), t, n);
}
function z7(e, t = Ee.V5) {
  if (e.compression() !== null)
    throw new Error("Record batch compression not implemented");
  return new Mi(e.length(), q7(e), Y7(e, t));
}
function P7(e, t = Ee.V5) {
  return new is(Mi.decode(e.data(), t), e.id(), e.isDelta());
}
function V7(e) {
  return new Yr(e.offset(), e.length());
}
function j7(e) {
  return new Qc(e.length(), e.nullCount());
}
function q7(e) {
  const t = [];
  for (let n, i = -1, r = -1, s = e.nodesLength(); ++i < s; )
    (n = e.nodes(i)) && (t[++r] = Qc.decode(n));
  return t;
}
function Y7(e, t) {
  const n = [];
  for (let i, r = -1, s = -1, o = e.buffersLength(); ++r < o; )
    (i = e.buffers(r)) && (t < Ee.V4 && (i.bb_pos += 8 * (r + 1)), n[++s] = Yr.decode(i));
  return n;
}
function W7(e, t) {
  const n = [];
  for (let i, r = -1, s = -1, o = e.fieldsLength(); ++r < o; )
    (i = e.fields(r)) && (n[++s] = Te.decode(i, t));
  return n;
}
function Q_(e, t) {
  const n = [];
  for (let i, r = -1, s = -1, o = e.childrenLength(); ++r < o; )
    (i = e.children(r)) && (n[++s] = Te.decode(i, t));
  return n;
}
function G7(e, t) {
  let n, i, r, s, o, a;
  return !t || !(a = e.dictionary()) ? (r = e2(e, Q_(e, t)), i = new Te(e.name(), r, e.nullable(), Gh(e))) : t.has(n = pn(a.id())) ? (s = (s = a.indexType()) ? t2(s) : new Su(), o = new Ic(t.get(n), s, n, a.isOrdered()), i = new Te(e.name(), o, e.nullable(), Gh(e))) : (s = (s = a.indexType()) ? t2(s) : new Su(), t.set(n, r = e2(e, Q_(e, t))), o = new Ic(r, s, n, a.isOrdered()), i = new Te(e.name(), o, e.nullable(), Gh(e))), i || null;
}
function Gh(e) {
  const t = /* @__PURE__ */ new Map();
  if (e)
    for (let n, i, r = -1, s = Math.trunc(e.customMetadataLength()); ++r < s; )
      (n = e.customMetadata(r)) && (i = n.key()) != null && t.set(i, n.value());
  return t;
}
function t2(e) {
  return new Ps(e.isSigned(), e.bitWidth());
}
function e2(e, t) {
  const n = e.typeType();
  switch (n) {
    case he.NONE:
      return new zs();
    case he.Null:
      return new zs();
    case he.Binary:
      return new _d();
    case he.LargeBinary:
      return new Sd();
    case he.Utf8:
      return new xd();
    case he.LargeUtf8:
      return new Id();
    case he.Bool:
      return new Ad();
    case he.List:
      return new Bd((t || [])[0]);
    case he.Struct_:
      return new fn(t || []);
  }
  switch (n) {
    case he.Int: {
      const i = e.type(new Ja());
      return new Ps(i.isSigned(), i.bitWidth());
    }
    case he.FloatingPoint: {
      const i = e.type(new Ph());
      return new xu(i.precision());
    }
    case he.Decimal: {
      const i = e.type(new Oa());
      return new Md(i.scale(), i.precision(), i.bitWidth());
    }
    case he.Date: {
      const i = e.type(new Ch());
      return new $d(i.unit());
    }
    case he.Time: {
      const i = e.type(new zl());
      return new Iu(i.unit(), i.bitWidth());
    }
    case he.Timestamp: {
      const i = e.type(new Pl());
      return new Td(i.unit(), i.timezone());
    }
    case he.Interval: {
      const i = e.type(new Vh());
      return new Dd(i.unit());
    }
    case he.Duration: {
      const i = e.type(new kh());
      return new Nd(i.unit());
    }
    case he.Union: {
      const i = e.type(new Io());
      return new Od(i.mode(), i.typeIdsArray() || [], t || []);
    }
    case he.FixedSizeBinary: {
      const i = e.type(new Uh());
      return new Fd(i.byteWidth());
    }
    case he.FixedSizeList: {
      const i = e.type(new zh());
      return new Ed(i.listSize(), (t || [])[0]);
    }
    case he.Map: {
      const i = e.type(new jh());
      return new Ld((t || [])[0], i.keysSorted());
    }
  }
  throw new Error(`Unrecognized type: "${he[n]}" (${n})`);
}
function X7(e, t) {
  const n = t.fields.map((s) => Te.encode(e, s));
  Yi.startFieldsVector(e, n.length);
  const i = Yi.createFieldsVector(e, n), r = t.metadata && t.metadata.size > 0 ? Yi.createCustomMetadataVector(e, [...t.metadata].map(([s, o]) => {
    const a = e.createString(`${s}`), c = e.createString(`${o}`);
    return ii.startKeyValue(e), ii.addKey(e, a), ii.addValue(e, c), ii.endKeyValue(e);
  })) : -1;
  return Yi.startSchema(e), Yi.addFields(e, i), Yi.addEndianness(e, t9 ? xc.Little : xc.Big), r !== -1 && Yi.addCustomMetadata(e, r), Yi.endSchema(e);
}
function H7(e, t) {
  let n = -1, i = -1, r = -1;
  const s = t.type;
  let o = t.typeId;
  rt.isDictionary(s) ? (o = s.dictionary.typeId, r = rm.visit(s, e), i = rm.visit(s.dictionary, e)) : i = rm.visit(s, e);
  const a = (s.children || []).map((u) => Te.encode(e, u)), c = Xn.createChildrenVector(e, a), l = t.metadata && t.metadata.size > 0 ? Xn.createCustomMetadataVector(e, [...t.metadata].map(([u, f]) => {
    const h = e.createString(`${u}`), d = e.createString(`${f}`);
    return ii.startKeyValue(e), ii.addKey(e, h), ii.addValue(e, d), ii.endKeyValue(e);
  })) : -1;
  return t.name && (n = e.createString(t.name)), Xn.startField(e), Xn.addType(e, i), Xn.addTypeType(e, o), Xn.addChildren(e, c), Xn.addNullable(e, !!t.nullable), n !== -1 && Xn.addName(e, n), r !== -1 && Xn.addDictionary(e, r), l !== -1 && Xn.addCustomMetadata(e, l), Xn.endField(e);
}
function J7(e, t) {
  const n = t.nodes || [], i = t.buffers || [];
  Lr.startNodesVector(e, n.length);
  for (const o of n.slice().reverse())
    Qc.encode(e, o);
  const r = e.endVector();
  Lr.startBuffersVector(e, i.length);
  for (const o of i.slice().reverse())
    Yr.encode(e, o);
  const s = e.endVector();
  return Lr.startRecordBatch(e), Lr.addLength(e, BigInt(t.length)), Lr.addNodes(e, r), Lr.addBuffers(e, s), Lr.endRecordBatch(e);
}
function K7(e, t) {
  const n = Mi.encode(e, t.data);
  return Da.startDictionaryBatch(e), Da.addId(e, BigInt(t.id)), Da.addIsDelta(e, t.isDelta), Da.addData(e, n), Da.endDictionaryBatch(e);
}
function Z7(e, t) {
  return jI.createFieldNode(e, BigInt(t.length), BigInt(t.nullCount));
}
function Q7(e, t) {
  return VI.createBuffer(e, BigInt(t.offset), BigInt(t.length));
}
const t9 = (() => {
  const e = new ArrayBuffer(2);
  return new DataView(e).setInt16(
    0,
    256,
    !0
    /* littleEndian */
  ), new Int16Array(e)[0] === 256;
})(), Nb = (e) => `Expected ${Qt[e]} Message in stream, but was null or length 0.`, Bb = (e) => `Header pointer of flatbuffer-encoded ${Qt[e]} Message is null or length 0.`, B3 = (e, t) => `Expected to read ${e} metadata bytes, but only read ${t}.`, O3 = (e, t) => `Expected to read ${e} bytes for message body, but only read ${t}.`;
let F3 = class {
  constructor(t) {
    this.source = t instanceof Ud ? t : new Ud(t);
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    let t;
    return (t = this.readMetadataLength()).done || t.value === -1 && (t = this.readMetadataLength()).done || (t = this.readMetadata(t.value)).done ? Se : t;
  }
  throw(t) {
    return this.source.throw(t);
  }
  return(t) {
    return this.source.return(t);
  }
  readMessage(t) {
    let n;
    if ((n = this.next()).done)
      return null;
    if (t != null && n.value.headerType !== t)
      throw new Error(Nb(t));
    return n.value;
  }
  readMessageBody(t) {
    if (t <= 0)
      return new Uint8Array(0);
    const n = Yt(this.source.read(t));
    if (n.byteLength < t)
      throw new Error(O3(t, n.byteLength));
    return (
      /* 1. */
      n.byteOffset % 8 === 0 && /* 2. */
      n.byteOffset + n.byteLength <= n.buffer.byteLength ? n : n.slice()
    );
  }
  readSchema(t = !1) {
    const n = Qt.Schema, i = this.readMessage(n), r = i == null ? void 0 : i.header();
    if (t && !r)
      throw new Error(Bb(n));
    return r;
  }
  readMetadataLength() {
    const t = this.source.read(Uy), n = t && new ur(t), i = (n == null ? void 0 : n.readInt32(0)) || 0;
    return { done: i === 0, value: i };
  }
  readMetadata(t) {
    const n = this.source.read(t);
    if (!n)
      return Se;
    if (n.byteLength < t)
      throw new Error(B3(t, n.byteLength));
    return { done: !1, value: cu.decode(n) };
  }
}, e9 = class {
  constructor(t, n) {
    this.source = t instanceof zd ? t : LI(t) ? new Pd(t, n) : new zd(t);
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  next() {
    return W(this, void 0, void 0, function* () {
      let t;
      return (t = yield this.readMetadataLength()).done || t.value === -1 && (t = yield this.readMetadataLength()).done || (t = yield this.readMetadata(t.value)).done ? Se : t;
    });
  }
  throw(t) {
    return W(this, void 0, void 0, function* () {
      return yield this.source.throw(t);
    });
  }
  return(t) {
    return W(this, void 0, void 0, function* () {
      return yield this.source.return(t);
    });
  }
  readMessage(t) {
    return W(this, void 0, void 0, function* () {
      let n;
      if ((n = yield this.next()).done)
        return null;
      if (t != null && n.value.headerType !== t)
        throw new Error(Nb(t));
      return n.value;
    });
  }
  readMessageBody(t) {
    return W(this, void 0, void 0, function* () {
      if (t <= 0)
        return new Uint8Array(0);
      const n = Yt(yield this.source.read(t));
      if (n.byteLength < t)
        throw new Error(O3(t, n.byteLength));
      return (
        /* 1. */
        n.byteOffset % 8 === 0 && /* 2. */
        n.byteOffset + n.byteLength <= n.buffer.byteLength ? n : n.slice()
      );
    });
  }
  readSchema(t = !1) {
    return W(this, void 0, void 0, function* () {
      const n = Qt.Schema, i = yield this.readMessage(n), r = i == null ? void 0 : i.header();
      if (t && !r)
        throw new Error(Bb(n));
      return r;
    });
  }
  readMetadataLength() {
    return W(this, void 0, void 0, function* () {
      const t = yield this.source.read(Uy), n = t && new ur(t), i = (n == null ? void 0 : n.readInt32(0)) || 0;
      return { done: i === 0, value: i };
    });
  }
  readMetadata(t) {
    return W(this, void 0, void 0, function* () {
      const n = yield this.source.read(t);
      if (!n)
        return Se;
      if (n.byteLength < t)
        throw new Error(B3(t, n.byteLength));
      return { done: !1, value: cu.decode(n) };
    });
  }
}, n9 = class extends F3 {
  constructor(t) {
    super(new Uint8Array(0)), this._schema = !1, this._body = [], this._batchIndex = 0, this._dictionaryIndex = 0, this._json = t instanceof G_ ? t : new G_(t);
  }
  next() {
    const { _json: t } = this;
    if (!this._schema)
      return this._schema = !0, { done: !1, value: cu.fromJSON(t.schema, Qt.Schema) };
    if (this._dictionaryIndex < t.dictionaries.length) {
      const n = t.dictionaries[this._dictionaryIndex++];
      return this._body = n.data.columns, { done: !1, value: cu.fromJSON(n, Qt.DictionaryBatch) };
    }
    if (this._batchIndex < t.batches.length) {
      const n = t.batches[this._batchIndex++];
      return this._body = n.columns, { done: !1, value: cu.fromJSON(n, Qt.RecordBatch) };
    }
    return this._body = [], Se;
  }
  readMessageBody(t) {
    return n(this._body);
    function n(i) {
      return (i || []).reduce((r, s) => [
        ...r,
        ...s.VALIDITY && [s.VALIDITY] || [],
        ...s.TYPE_ID && [s.TYPE_ID] || [],
        ...s.OFFSET && [s.OFFSET] || [],
        ...s.DATA && [s.DATA] || [],
        ...n(s.children)
      ], []);
    }
  }
  readMessage(t) {
    let n;
    if ((n = this.next()).done)
      return null;
    if (t != null && n.value.headerType !== t)
      throw new Error(Nb(t));
    return n.value;
  }
  readSchema() {
    const t = Qt.Schema, n = this.readMessage(t), i = n == null ? void 0 : n.header();
    if (!n || !i)
      throw new Error(Bb(t));
    return i;
  }
};
const Uy = 4, Dg = "ARROW1", Vd = new Uint8Array(Dg.length);
for (let e = 0; e < Dg.length; e += 1)
  Vd[e] = Dg.codePointAt(e);
function Ob(e, t = 0) {
  for (let n = -1, i = Vd.length; ++n < i; )
    if (Vd[n] !== e[t + n])
      return !1;
  return !0;
}
const ff = Vd.length, E3 = ff + Uy, i9 = ff * 2 + Uy;
let hf = class Xh extends v3 {
  constructor(t) {
    super(), this._impl = t;
  }
  get closed() {
    return this._impl.closed;
  }
  get schema() {
    return this._impl.schema;
  }
  get autoDestroy() {
    return this._impl.autoDestroy;
  }
  get dictionaries() {
    return this._impl.dictionaries;
  }
  get numDictionaries() {
    return this._impl.numDictionaries;
  }
  get numRecordBatches() {
    return this._impl.numRecordBatches;
  }
  get footer() {
    return this._impl.isFile() ? this._impl.footer : null;
  }
  isSync() {
    return this._impl.isSync();
  }
  isAsync() {
    return this._impl.isAsync();
  }
  isFile() {
    return this._impl.isFile();
  }
  isStream() {
    return this._impl.isStream();
  }
  next() {
    return this._impl.next();
  }
  throw(t) {
    return this._impl.throw(t);
  }
  return(t) {
    return this._impl.return(t);
  }
  cancel() {
    return this._impl.cancel();
  }
  reset(t) {
    return this._impl.reset(t), this._DOMStream = void 0, this._nodeStream = void 0, this;
  }
  open(t) {
    const n = this._impl.open(t);
    return bu(n) ? n.then(() => this) : this;
  }
  readRecordBatch(t) {
    return this._impl.isFile() ? this._impl.readRecordBatch(t) : null;
  }
  [Symbol.iterator]() {
    return this._impl[Symbol.iterator]();
  }
  [Symbol.asyncIterator]() {
    return this._impl[Symbol.asyncIterator]();
  }
  toDOMStream() {
    return Jn.toDOMStream(this.isSync() ? { [Symbol.iterator]: () => this } : { [Symbol.asyncIterator]: () => this });
  }
  toNodeStream() {
    return Jn.toNodeStream(this.isSync() ? { [Symbol.iterator]: () => this } : { [Symbol.asyncIterator]: () => this }, { objectMode: !0 });
  }
  /** @nocollapse */
  // @ts-ignore
  static throughNode(t) {
    throw new Error('"throughNode" not available in this environment');
  }
  /** @nocollapse */
  static throughDOM(t, n) {
    throw new Error('"throughDOM" not available in this environment');
  }
  /** @nocollapse */
  static from(t) {
    return t instanceof Xh ? t : yg(t) ? a9(t) : LI(t) ? u9(t) : bu(t) ? W(this, void 0, void 0, function* () {
      return yield Xh.from(yield t);
    }) : RI(t) || pb(t) || kI(t) || db(t) ? l9(new zd(t)) : c9(new Ud(t));
  }
  /** @nocollapse */
  static readAll(t) {
    return t instanceof Xh ? t.isSync() ? n2(t) : i2(t) : yg(t) || ArrayBuffer.isView(t) || Ly(t) || EI(t) ? n2(t) : i2(t);
  }
}, jd = class extends hf {
  constructor(t) {
    super(t), this._impl = t;
  }
  readAll() {
    return [...this];
  }
  [Symbol.iterator]() {
    return this._impl[Symbol.iterator]();
  }
  [Symbol.asyncIterator]() {
    return Re(this, arguments, function* () {
      yield H(yield* ks(ci(this[Symbol.iterator]())));
    });
  }
}, qd = class extends hf {
  constructor(t) {
    super(t), this._impl = t;
  }
  readAll() {
    var t, n, i, r;
    return W(this, void 0, void 0, function* () {
      const s = new Array();
      try {
        for (var o = !0, a = ci(this), c; c = yield a.next(), t = c.done, !t; o = !0) {
          r = c.value, o = !1;
          const l = r;
          s.push(l);
        }
      } catch (l) {
        n = { error: l };
      } finally {
        try {
          !o && !t && (i = a.return) && (yield i.call(a));
        } finally {
          if (n)
            throw n.error;
        }
      }
      return s;
    });
  }
  [Symbol.iterator]() {
    throw new Error("AsyncRecordBatchStreamReader is not Iterable");
  }
  [Symbol.asyncIterator]() {
    return this._impl[Symbol.asyncIterator]();
  }
}, L3 = class extends jd {
  constructor(t) {
    super(t), this._impl = t;
  }
}, r9 = class extends qd {
  constructor(t) {
    super(t), this._impl = t;
  }
}, R3 = class {
  get numDictionaries() {
    return this._dictionaryIndex;
  }
  get numRecordBatches() {
    return this._recordBatchIndex;
  }
  constructor(t = /* @__PURE__ */ new Map()) {
    this.closed = !1, this.autoDestroy = !0, this._dictionaryIndex = 0, this._recordBatchIndex = 0, this.dictionaries = t;
  }
  isSync() {
    return !1;
  }
  isAsync() {
    return !1;
  }
  isFile() {
    return !1;
  }
  isStream() {
    return !1;
  }
  reset(t) {
    return this._dictionaryIndex = 0, this._recordBatchIndex = 0, this.schema = t, this.dictionaries = /* @__PURE__ */ new Map(), this;
  }
  _loadRecordBatch(t, n) {
    const i = this._loadVectors(t, n, this.schema.fields), r = Rt({ type: new fn(this.schema.fields), length: t.length, children: i });
    return new bi(this.schema, r);
  }
  _loadDictionaryBatch(t, n) {
    const { id: i, isDelta: r } = t, { dictionaries: s, schema: o } = this, a = s.get(i);
    if (r || !a) {
      const c = o.dictionaries.get(i), l = this._loadVectors(t.data, n, [c]);
      return (a && r ? a.concat(new Ne(l)) : new Ne(l)).memoize();
    }
    return a.memoize();
  }
  _loadVectors(t, n, i) {
    return new x3(n, t.nodes, t.buffers, this.dictionaries, this.schema.metadataVersion).visitMany(i);
  }
}, Yd = class extends R3 {
  constructor(t, n) {
    super(n), this._reader = yg(t) ? new n9(this._handle = t) : new F3(this._handle = t);
  }
  isSync() {
    return !0;
  }
  isStream() {
    return !0;
  }
  [Symbol.iterator]() {
    return this;
  }
  cancel() {
    !this.closed && (this.closed = !0) && (this.reset()._reader.return(), this._reader = null, this.dictionaries = null);
  }
  open(t) {
    return this.closed || (this.autoDestroy = k3(this, t), this.schema || (this.schema = this._reader.readSchema()) || this.cancel()), this;
  }
  throw(t) {
    return !this.closed && this.autoDestroy && (this.closed = !0) ? this.reset()._reader.throw(t) : Se;
  }
  return(t) {
    return !this.closed && this.autoDestroy && (this.closed = !0) ? this.reset()._reader.return(t) : Se;
  }
  next() {
    if (this.closed)
      return Se;
    let t;
    const { _reader: n } = this;
    for (; t = this._readNextMessageAndValidate(); )
      if (t.isSchema())
        this.reset(t.header());
      else if (t.isRecordBatch()) {
        this._recordBatchIndex++;
        const i = t.header(), r = n.readMessageBody(t.bodyLength);
        return { done: !1, value: this._loadRecordBatch(i, r) };
      } else if (t.isDictionaryBatch()) {
        this._dictionaryIndex++;
        const i = t.header(), r = n.readMessageBody(t.bodyLength), s = this._loadDictionaryBatch(i, r);
        this.dictionaries.set(i.id, s);
      }
    return this.schema && this._recordBatchIndex === 0 ? (this._recordBatchIndex++, { done: !1, value: new $3(this.schema) }) : this.return();
  }
  _readNextMessageAndValidate(t) {
    return this._reader.readMessage(t);
  }
}, Wd = class extends R3 {
  constructor(t, n) {
    super(n), this._reader = new e9(this._handle = t);
  }
  isAsync() {
    return !0;
  }
  isStream() {
    return !0;
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  cancel() {
    return W(this, void 0, void 0, function* () {
      !this.closed && (this.closed = !0) && (yield this.reset()._reader.return(), this._reader = null, this.dictionaries = null);
    });
  }
  open(t) {
    return W(this, void 0, void 0, function* () {
      return this.closed || (this.autoDestroy = k3(this, t), this.schema || (this.schema = yield this._reader.readSchema()) || (yield this.cancel())), this;
    });
  }
  throw(t) {
    return W(this, void 0, void 0, function* () {
      return !this.closed && this.autoDestroy && (this.closed = !0) ? yield this.reset()._reader.throw(t) : Se;
    });
  }
  return(t) {
    return W(this, void 0, void 0, function* () {
      return !this.closed && this.autoDestroy && (this.closed = !0) ? yield this.reset()._reader.return(t) : Se;
    });
  }
  next() {
    return W(this, void 0, void 0, function* () {
      if (this.closed)
        return Se;
      let t;
      const { _reader: n } = this;
      for (; t = yield this._readNextMessageAndValidate(); )
        if (t.isSchema())
          yield this.reset(t.header());
        else if (t.isRecordBatch()) {
          this._recordBatchIndex++;
          const i = t.header(), r = yield n.readMessageBody(t.bodyLength);
          return { done: !1, value: this._loadRecordBatch(i, r) };
        } else if (t.isDictionaryBatch()) {
          this._dictionaryIndex++;
          const i = t.header(), r = yield n.readMessageBody(t.bodyLength), s = this._loadDictionaryBatch(i, r);
          this.dictionaries.set(i.id, s);
        }
      return this.schema && this._recordBatchIndex === 0 ? (this._recordBatchIndex++, { done: !1, value: new $3(this.schema) }) : yield this.return();
    });
  }
  _readNextMessageAndValidate(t) {
    return W(this, void 0, void 0, function* () {
      return yield this._reader.readMessage(t);
    });
  }
}, C3 = class extends Yd {
  get footer() {
    return this._footer;
  }
  get numDictionaries() {
    return this._footer ? this._footer.numDictionaries : 0;
  }
  get numRecordBatches() {
    return this._footer ? this._footer.numRecordBatches : 0;
  }
  constructor(t, n) {
    super(t instanceof X_ ? t : new X_(t), n);
  }
  isSync() {
    return !0;
  }
  isFile() {
    return !0;
  }
  open(t) {
    if (!this.closed && !this._footer) {
      this.schema = (this._footer = this._readFooter()).schema;
      for (const n of this._footer.dictionaryBatches())
        n && this._readDictionaryBatch(this._dictionaryIndex++);
    }
    return super.open(t);
  }
  readRecordBatch(t) {
    var n;
    if (this.closed)
      return null;
    this._footer || this.open();
    const i = (n = this._footer) === null || n === void 0 ? void 0 : n.getRecordBatch(t);
    if (i && this._handle.seek(i.offset)) {
      const r = this._reader.readMessage(Qt.RecordBatch);
      if (r != null && r.isRecordBatch()) {
        const s = r.header(), o = this._reader.readMessageBody(r.bodyLength);
        return this._loadRecordBatch(s, o);
      }
    }
    return null;
  }
  _readDictionaryBatch(t) {
    var n;
    const i = (n = this._footer) === null || n === void 0 ? void 0 : n.getDictionaryBatch(t);
    if (i && this._handle.seek(i.offset)) {
      const r = this._reader.readMessage(Qt.DictionaryBatch);
      if (r != null && r.isDictionaryBatch()) {
        const s = r.header(), o = this._reader.readMessageBody(r.bodyLength), a = this._loadDictionaryBatch(s, o);
        this.dictionaries.set(s.id, a);
      }
    }
  }
  _readFooter() {
    const { _handle: t } = this, n = t.size - E3, i = t.readInt32(n), r = t.readAt(n - i, i);
    return Ab.decode(r);
  }
  _readNextMessageAndValidate(t) {
    var n;
    if (this._footer || this.open(), this._footer && this._recordBatchIndex < this.numRecordBatches) {
      const i = (n = this._footer) === null || n === void 0 ? void 0 : n.getRecordBatch(this._recordBatchIndex);
      if (i && this._handle.seek(i.offset))
        return this._reader.readMessage(t);
    }
    return null;
  }
}, s9 = class extends Wd {
  get footer() {
    return this._footer;
  }
  get numDictionaries() {
    return this._footer ? this._footer.numDictionaries : 0;
  }
  get numRecordBatches() {
    return this._footer ? this._footer.numRecordBatches : 0;
  }
  constructor(t, ...n) {
    const i = typeof n[0] != "number" ? n.shift() : void 0, r = n[0] instanceof Map ? n.shift() : void 0;
    super(t instanceof Pd ? t : new Pd(t, i), r);
  }
  isFile() {
    return !0;
  }
  isAsync() {
    return !0;
  }
  open(t) {
    const n = Object.create(null, {
      open: { get: () => super.open }
    });
    return W(this, void 0, void 0, function* () {
      if (!this.closed && !this._footer) {
        this.schema = (this._footer = yield this._readFooter()).schema;
        for (const i of this._footer.dictionaryBatches())
          i && (yield this._readDictionaryBatch(this._dictionaryIndex++));
      }
      return yield n.open.call(this, t);
    });
  }
  readRecordBatch(t) {
    var n;
    return W(this, void 0, void 0, function* () {
      if (this.closed)
        return null;
      this._footer || (yield this.open());
      const i = (n = this._footer) === null || n === void 0 ? void 0 : n.getRecordBatch(t);
      if (i && (yield this._handle.seek(i.offset))) {
        const r = yield this._reader.readMessage(Qt.RecordBatch);
        if (r != null && r.isRecordBatch()) {
          const s = r.header(), o = yield this._reader.readMessageBody(r.bodyLength);
          return this._loadRecordBatch(s, o);
        }
      }
      return null;
    });
  }
  _readDictionaryBatch(t) {
    var n;
    return W(this, void 0, void 0, function* () {
      const i = (n = this._footer) === null || n === void 0 ? void 0 : n.getDictionaryBatch(t);
      if (i && (yield this._handle.seek(i.offset))) {
        const r = yield this._reader.readMessage(Qt.DictionaryBatch);
        if (r != null && r.isDictionaryBatch()) {
          const s = r.header(), o = yield this._reader.readMessageBody(r.bodyLength), a = this._loadDictionaryBatch(s, o);
          this.dictionaries.set(s.id, a);
        }
      }
    });
  }
  _readFooter() {
    return W(this, void 0, void 0, function* () {
      const { _handle: t } = this;
      t._pending && (yield t._pending);
      const n = t.size - E3, i = yield t.readInt32(n), r = yield t.readAt(n - i, i);
      return Ab.decode(r);
    });
  }
  _readNextMessageAndValidate(t) {
    return W(this, void 0, void 0, function* () {
      if (this._footer || (yield this.open()), this._footer && this._recordBatchIndex < this.numRecordBatches) {
        const n = this._footer.getRecordBatch(this._recordBatchIndex);
        if (n && (yield this._handle.seek(n.offset)))
          return yield this._reader.readMessage(t);
      }
      return null;
    });
  }
}, o9 = class extends Yd {
  constructor(t, n) {
    super(t, n);
  }
  _loadVectors(t, n, i) {
    return new b7(n, t.nodes, t.buffers, this.dictionaries, this.schema.metadataVersion).visitMany(i);
  }
};
function k3(e, t) {
  return t && typeof t.autoDestroy == "boolean" ? t.autoDestroy : e.autoDestroy;
}
function* n2(e) {
  const t = hf.from(e);
  try {
    if (!t.open({ autoDestroy: !1 }).closed)
      do
        yield t;
      while (!t.reset().open().closed);
  } finally {
    t.cancel();
  }
}
function i2(e) {
  return Re(this, arguments, function* () {
    const n = yield H(hf.from(e));
    try {
      if (!(yield H(n.open({ autoDestroy: !1 }))).closed)
        do
          yield yield H(n);
        while (!(yield H(n.reset().open())).closed);
    } finally {
      yield H(n.cancel());
    }
  });
}
function a9(e) {
  return new jd(new o9(e));
}
function c9(e) {
  const t = e.peek(ff + 7 & -8);
  return t && t.byteLength >= 4 ? Ob(t) ? new L3(new C3(e.read())) : new jd(new Yd(e)) : new jd(new Yd(function* () {
  }()));
}
function l9(e) {
  return W(this, void 0, void 0, function* () {
    const t = yield e.peek(ff + 7 & -8);
    return t && t.byteLength >= 4 ? Ob(t) ? new L3(new C3(yield e.read())) : new qd(new Wd(e)) : new qd(new Wd(function() {
      return Re(this, arguments, function* () {
      });
    }()));
  });
}
function u9(e) {
  return W(this, void 0, void 0, function* () {
    const { size: t } = yield e.stat(), n = new Pd(e, t);
    return t >= i9 && Ob(yield n.readAt(0, ff + 7 & -8)) ? new r9(new s9(n)) : new qd(new Wd(n));
  });
}
function U3(e) {
  const t = hf.from(e);
  return bu(t) ? t.then((n) => U3(n)) : t.isAsync() ? t.readAll().then((n) => new Au(n)) : new Au(t.readAll());
}
function f9(e = "ws://localhost:3000/") {
  const t = [];
  let n = !1, i = null, r;
  const s = {
    open() {
      n = !0, c();
    },
    close() {
      for (n = !1, i = null, r = null; t.length; )
        t.shift().reject("Socket closed");
    },
    error(l) {
      if (i) {
        const { reject: u } = i;
        i = null, c(), u(l);
      } else
        console.error("WebSocket error: ", l);
    },
    message({ data: l }) {
      if (i) {
        const { query: u, resolve: f, reject: h } = i;
        if (i = null, c(), typeof l == "string") {
          const d = JSON.parse(l);
          d.error ? h(d.error) : f(d);
        } else if (u.type === "exec")
          f();
        else if (u.type === "arrow")
          f(U3(l.arrayBuffer()));
        else
          throw new Error(`Unexpected socket data: ${l}`);
      } else
        console.log("WebSocket message: ", l);
    }
  };
  function o() {
    r = new WebSocket(e);
    for (const l in s)
      r.addEventListener(l, s[l]);
  }
  function a(l, u, f) {
    r == null && o(), t.push({ query: l, resolve: u, reject: f }), n && !i && c();
  }
  function c() {
    t.length && (i = t.shift(), r.send(JSON.stringify(i.query)));
  }
  return {
    get connected() {
      return n;
    },
    query(l) {
      return new Promise(
        (u, f) => a(l, u, f)
      );
    }
  };
}
class js {
  /**
   * Create a new Ref instance.
   * @param {string|Ref|null} table The table name.
   * @param {string|null} [column] The column name.
   */
  constructor(t, n) {
    t && (this.table = String(t)), n && (this.column = n);
  }
  /**
   * Get the list of referenced columns. Either a single element array
   * if column is non-null, otherwise an empty array.
   */
  get columns() {
    return this.column ? [this.column] : [];
  }
  /**
   * Generate a SQL string for this reference.
   * @returns {string} The SQL string.
   */
  toString() {
    const { table: t, column: n } = this;
    if (n) {
      const i = n.startsWith("*") ? n : `"${n}"`;
      return `${t ? `${r2(t)}.` : ""}${i}`;
    } else
      return t ? r2(t) : "NULL";
  }
}
function r2(e) {
  return e.split(".").map((n) => `"${n}"`).join(".");
}
function h9(e, t) {
  return e instanceof js && e.column === t;
}
function oe(e) {
  return typeof e == "string" ? zy(e) : e;
}
function Hh(e) {
  return typeof e == "string" ? d9(e) : e;
}
function d9(e) {
  return new js(e);
}
function zy(e, t = null) {
  return arguments.length === 1 && (t = e, e = null), new js(e, t);
}
function df(e) {
  switch (typeof e) {
    case "boolean":
      return e ? "TRUE" : "FALSE";
    case "string":
      return `'${e}'`;
    case "number":
      return Number.isFinite(e) ? String(e) : "NULL";
    default:
      if (e == null)
        return "NULL";
      if (e instanceof Date) {
        const t = +e;
        if (Number.isNaN(t))
          return "NULL";
        const n = e.getUTCFullYear(), i = e.getUTCMonth(), r = e.getUTCDate();
        return t === Date.UTC(n, i, r) ? `MAKE_DATE(${n}, ${i + 1}, ${r})` : `EPOCH_MS(${t})`;
      } else
        return e instanceof RegExp ? `'${e.source}'` : String(e);
  }
}
const Mc = (e) => typeof (e == null ? void 0 : e.addEventListener) == "function";
function z3(e) {
  return e instanceof Py;
}
class Py {
  /**
   * Create a new SQL expression instance.
   * @param {(string | ParamLike | SQLExpression | import('./ref.js').Ref)[]} parts The parts of the expression.
   * @param {string[]} [columns=[]] The column dependencies
   * @param {object} [props] Additional properties for this expression.
   */
  constructor(t, n, i) {
    this._expr = Array.isArray(t) ? t : [t], this._deps = n || [], this.annotate(i);
    const r = this._expr.filter((s) => Mc(s));
    r.length > 0 ? (this._params = Array.from(new Set(r)), this._params.forEach((s) => {
      s.addEventListener("value", () => {
        var o;
        return p9(this, (o = this.map) == null ? void 0 : o.get("value"));
      });
    })) : this.addEventListener = void 0;
  }
  /**
   * A reference to this expression.
   * Provides compatibility with param-like objects.
   */
  get value() {
    return this;
  }
  /**
   * The column dependencies of this expression.
   * @returns {string[]} The columns dependencies.
   */
  get columns() {
    const { _params: t, _deps: n } = this;
    if (t) {
      const i = new Set(t.flatMap((r) => {
        var o;
        const s = (o = r.value) == null ? void 0 : o.columns;
        return Array.isArray(s) ? s : [];
      }));
      if (i.size) {
        const r = new Set(n);
        return i.forEach((s) => r.add(s)), Array.from(r);
      }
    }
    return n;
  }
  /**
   * The first column dependency in this expression, or undefined if none.
   * @returns {string} The first column dependency.
   */
  get column() {
    return this._deps.length ? this._deps[0] : this.columns[0];
  }
  /**
   * Annotate this expression instance with additional properties.
   * @param {object[]} [props] One or more objects with properties to add.
   * @returns {this} This SQL expression.
   */
  annotate(...t) {
    return Object.assign(this, ...t);
  }
  /**
   * Generate a SQL code string corresponding to this expression.
   * @returns {string} A SQL code string.
   */
  toString() {
    return this._expr.map((t) => Mc(t) && !z3(t) ? df(t.value) : t).join("");
  }
  /**
   * Add an event listener callback for the provided event type.
   * @param {string} type The event type to listen for (for example, "value").
   * @param {(a: SQLExpression) => Promise?} callback The callback function to
   *  invoke upon updates. A callback may optionally return a Promise that
   *  upstream listeners may await before proceeding.
   */
  addEventListener(t, n) {
    const i = this.map || (this.map = /* @__PURE__ */ new Map());
    (i.get(t) || (i.set(t, /* @__PURE__ */ new Set()), i.get(t))).add(n);
  }
}
function p9(e, t) {
  if (t != null && t.size)
    return Promise.allSettled(Array.from(t, (n) => n(e)));
}
function P3(e, t) {
  const n = [e[0]], i = /* @__PURE__ */ new Set(), r = t.length;
  for (let s = 0, o = 0; s < r; ) {
    const a = t[s];
    Mc(a) ? n[++o] = a : (Array.isArray(a == null ? void 0 : a.columns) && a.columns.forEach((l) => i.add(l)), n[o] += typeof a == "string" ? a : df(a));
    const c = e[++s];
    Mc(n[o]) ? n[++o] = c : n[o] += c;
  }
  return { spans: n, cols: Array.from(i) };
}
function q(e, ...t) {
  const { spans: n, cols: i } = P3(e, t);
  return new Py(n, i);
}
function y9(e) {
  const t = oe(e);
  return q`${t} DESC NULLS LAST`.annotate({ label: t == null ? void 0 : t.label, desc: !0 });
}
const tl = (e) => ({
  value: e,
  toString: () => df(e)
});
function pf(e) {
  var t;
  e(this.op, this), (t = this.children) == null || t.forEach((n) => n.visit(e));
}
function V3(e, t) {
  const n = t.filter((r) => r != null).map(oe), i = n.map((r, s) => s ? ` ${e} ` : "");
  return n.length === 1 ? i.push("") : n.length > 1 && (i[0] = "(", i.push(")")), q(i, ...n).annotate({ op: e, children: n, visit: pf });
}
const qs = (...e) => V3("AND", e.flat()), Fb = (...e) => V3("OR", e.flat()), m9 = (e) => (t) => q`(${e} ${oe(t)})`.annotate({ op: e, a: t, visit: pf }), g9 = m9("NOT"), j3 = (e) => (t) => q`(${oe(t)} ${e})`.annotate({ op: e, a: t, visit: pf }), Eb = j3("IS NULL"), Mu = j3("IS NOT NULL"), ro = (e) => (t, n) => q`(${oe(t)} ${e} ${oe(n)})`.annotate({ op: e, a: t, b: n, visit: pf }), Vy = ro("="), Lb = ro("<>"), $u = ro("<"), q3 = ro(">"), Tu = ro("<="), b9 = ro(">="), w9 = ro("IS DISTINCT FROM"), Y3 = ro("IS NOT DISTINCT FROM");
function W3(e, t, n, i) {
  t = oe(t);
  const r = e.startsWith("NOT ") ? "NOT " : "";
  return (n ? i ? q`${r}(${n[0]} <= ${t} AND ${t} < ${n[1]})` : q`(${t} ${e} ${n[0]} AND ${n[1]})` : q``).annotate({ op: e, visit: pf, field: t, range: n });
}
const Tn = (e, t, n) => W3("BETWEEN", e, t, n), v9 = (e, t, n) => W3("NOT BETWEEN", e, t, n);
function Gd(e, t) {
  return Array.from({ length: e }, () => t);
}
function us(e, t) {
  return (...n) => {
    const i = n.map(oe), r = t ? `::${t}` : "";
    return (i.length ? q([`${e}(`, ...Gd(i.length - 1, ", "), `)${r}`], ...i) : q`${e}()${r}`).annotate({ func: e, args: i });
  };
}
const _9 = us("REGEXP_MATCHES"), S9 = us("CONTAINS"), x9 = us("PREFIX"), I9 = us("SUFFIX");
class Ns extends Py {
  /**
   * Create a new WindowFunction instance.
   * @param {string} op The window operation indicator.
   * @param {*} func The window function expression.
   * @param {*} [type] The SQL data type to cast to.
   * @param {string} [name] The window definition name.
   * @param {*} [group] Grouping (partition by) expressions.
   * @param {*} [order] Sorting (order by) expressions.
   * @param {*} [frame] The window frame definition.
   */
  constructor(t, n, i, r, s = "", o = "", a = "") {
    let c;
    if (r && !(s || o || a))
      c = r ? q`${n} OVER "${r}"` : q`${n} OVER ()`;
    else {
      const h = s && o ? " " : "", d = (s || o) && a ? " " : "";
      c = q`${n} OVER (${r ? `"${r}" ` : ""}${s}${h}${o}${d}${a})`;
    }
    i && (c = q`(${c})::${i}`);
    const { _expr: u, _deps: f } = c;
    super(u, f), this.window = t, this.func = n, this.type = i, this.name = r, this.group = s, this.order = o, this.frame = a;
  }
  get basis() {
    return this.column;
  }
  get label() {
    const { func: t } = this;
    return t.label ?? t.toString();
  }
  /**
   * Return an updated window function over a named window definition.
   * @param {string} name The window definition name.
   * @returns {WindowFunction} A new window function.
   */
  over(t) {
    const { window: n, func: i, type: r, group: s, order: o, frame: a } = this;
    return new Ns(n, i, r, t, s, o, a);
  }
  /**
   * Return an updated window function with the given partitioning.
   * @param {*} expr The grouping (partition by) criteria for the window function.
   * @returns {WindowFunction} A new window function.
   */
  partitionby(...t) {
    const n = t.flat().filter((u) => u).map(oe), i = q(
      ["PARTITION BY ", Gd(n.length - 1, ", "), ""],
      ...n
    ), { window: r, func: s, type: o, name: a, order: c, frame: l } = this;
    return new Ns(r, s, o, a, i, c, l);
  }
  /**
   * Return an updated window function with the given ordering.
   * @param {*} expr The sorting (order by) criteria for the window function.
   * @returns {WindowFunction} A new window function.
   */
  orderby(...t) {
    const n = t.flat().filter((u) => u).map(oe), i = q(
      ["ORDER BY ", Gd(n.length - 1, ", "), ""],
      ...n
    ), { window: r, func: s, type: o, name: a, group: c, frame: l } = this;
    return new Ns(r, s, o, a, c, i, l);
  }
  /**
   * Return an updated window function with the given rows frame.
   * @param {(number|null)[] | import('./expression.js').ParamLike} expr The row-based window frame.
   * @returns {WindowFunction} A new window function.
   */
  rows(t) {
    const n = s2("ROWS", t), { window: i, func: r, type: s, name: o, group: a, order: c } = this;
    return new Ns(i, r, s, o, a, c, n);
  }
  /**
   * Return an updated window function with the given range frame.
   * @param {(number|null)[] | import('./expression.js').ParamLike} expr The range-based window frame.
   * @returns {WindowFunction} A new window function.
   */
  range(t) {
    const n = s2("RANGE", t), { window: i, func: r, type: s, name: o, group: a, order: c } = this;
    return new Ns(i, r, s, o, a, c, n);
  }
}
function s2(e, t) {
  if (Mc(t)) {
    const n = q`${t}`;
    return n.toString = () => `${e} ${o2(t.value)}`, n;
  }
  return `${e} ${o2(t)}`;
}
function o2(e) {
  const [t, n] = e, i = t === 0 ? "CURRENT ROW" : Number.isFinite(t) ? `${Math.abs(t)} PRECEDING` : "UNBOUNDED PRECEDING", r = n === 0 ? "CURRENT ROW" : Number.isFinite(n) ? `${Math.abs(n)} FOLLOWING` : "UNBOUNDED FOLLOWING";
  return `BETWEEN ${i} AND ${r}`;
}
function Ri(e, t) {
  return (...n) => {
    const i = us(e)(...n);
    return new Ns(e, i, t);
  };
}
const A9 = Ri("ROW_NUMBER", "INTEGER"), M9 = Ri("RANK", "INTEGER"), $9 = Ri("DENSE_RANK", "INTEGER"), T9 = Ri("PERCENT_RANK"), D9 = Ri("CUME_DIST"), N9 = Ri("NTILE"), B9 = Ri("LAG"), O9 = Ri("LEAD"), F9 = Ri("FIRST_VALUE"), E9 = Ri("LAST_VALUE"), L9 = Ri("NTH_VALUE");
function R9(e, ...t) {
  return q(e, ...t).annotate({ aggregate: !0 });
}
class lu extends Py {
  /**
   * Create a new AggregateFunction instance.
   * @param {*} op The aggregate operation.
   * @param {*} [args] The aggregate function arguments.
   * @param {*} [type] The SQL data type to cast to.
   * @param {boolean} [isDistinct] Flag indicating if this is a distinct value aggregate.
   * @param {*} [filter] Filtering expression to apply prior to aggregation.
   */
  constructor(t, n, i, r, s) {
    n = (n || []).map(oe);
    const { strings: o, exprs: a } = C9(t, n, i, r, s), { spans: c, cols: l } = P3(o, a);
    super(c, l), this.aggregate = t, this.args = n, this.type = i, this.isDistinct = r, this.filter = s;
  }
  get basis() {
    return this.column;
  }
  get label() {
    const { aggregate: t, args: n, isDistinct: i } = this, r = i ? "DISTINCT" + (n.length ? " " : "") : "", s = n.length ? `(${r}${n.map(k9).join(", ")})` : "";
    return `${t.toLowerCase()}${s}`;
  }
  /**
   * Return a new derived aggregate function over distinct values.
   * @returns {AggregateFunction} A new aggregate function.
   */
  distinct() {
    const { aggregate: t, args: n, type: i, filter: r } = this;
    return new lu(t, n, i, !0, r);
  }
  /**
   * Return a new derived aggregate function that filters values.
   * @param {*} filter The filter expresion.
   * @returns {AggregateFunction} A new aggregate function.
   */
  where(t) {
    const { aggregate: n, args: i, type: r, isDistinct: s } = this;
    return new lu(n, i, r, s, t);
  }
  /**
   * Return a new window function over this aggregate.
   * @returns {WindowFunction} A new aggregate function.
   */
  window() {
    const { aggregate: t, args: n, type: i, isDistinct: r } = this, s = new lu(t, n, null, r);
    return new Ns(t, s, i);
  }
  /**
   * Return a window function over this aggregate with the given partitioning.
   * @param {*} expr The grouping (partition by) criteria for the window function.
   * @returns {WindowFunction} A new window function.
   */
  partitionby(...t) {
    return this.window().partitionby(...t);
  }
  /**
   * Return a window function over this aggregate with the given ordering.
   * @param {*} expr The sorting (order by) criteria for the window function.
   * @returns {WindowFunction} A new window function.
   */
  orderby(...t) {
    return this.window().orderby(...t);
  }
  /**
   * Return a window function over this aggregate with the given row frame.
   * @param {(number|null)[] | import('./expression.js').ParamLike} frame The row-based window frame.
   * @returns {WindowFunction} A new window function.
   */
  rows(t) {
    return this.window().rows(t);
  }
  /**
   * Return a window function over this aggregate with the given range frame.
   * @param {(number|null)[] | import('./expression.js').ParamLike} frame The range-based window frame.
   * @returns {WindowFunction} A new window function.
   */
  range(t) {
    return this.window().range(t);
  }
}
function C9(e, t, n, i, r) {
  const s = `)${n ? `::${n}` : ""}`;
  let o = [`${e}(${i ? "DISTINCT " : ""}`], a = [];
  return t.length ? (o = o.concat([
    ...Gd(t.length - 1, ", "),
    `${s}${r ? " FILTER (WHERE " : ""}`,
    ...r ? [")"] : []
  ]), a = [...t, ...r ? [r] : []]) : o[0] += "*" + s, { exprs: a, strings: o };
}
function k9(e) {
  const t = df(e);
  return t && t.startsWith('"') && t.endsWith('"') ? t.slice(1, -1) : t;
}
function Kt(e, t) {
  return (...n) => new lu(e, n, t);
}
const Uo = Kt("COUNT", "INTEGER"), U9 = Kt("AVG"), z9 = Kt("MAD"), $c = Kt("MAX"), Tc = Kt("MIN"), oa = Kt("SUM", "DOUBLE"), P9 = Kt("PRODUCT"), V9 = Kt("MEDIAN"), j9 = Kt("QUANTILE"), q9 = Kt("MODE"), Y9 = Kt("VARIANCE"), W9 = Kt("STDDEV"), G9 = Kt("SKEWNESS"), X9 = Kt("KURTOSIS"), H9 = Kt("ENTROPY"), J9 = Kt("VAR_POP"), K9 = Kt("STDDEV_POP"), Z9 = Kt("CORR"), Q9 = Kt("COVAR_POP"), tU = Kt("REGR_INTERCEPT"), eU = Kt("REGR_SLOPE"), nU = Kt("REGR_COUNT"), iU = Kt("REGR_SYY"), rU = Kt("REGR_SXX"), sU = Kt("REGR_AVGX"), oU = Kt("FIRST"), aU = Kt("LAST"), Ng = Kt("ARG_MIN"), Bg = Kt("ARG_MAX"), cU = Kt("STRING_AGG"), lU = Kt("ARRAY_AGG");
function Rb(e, t) {
  const n = oe(e), i = q`CAST(${n} AS ${t})`;
  return Object.defineProperty(i, "label", {
    enumerable: !0,
    get() {
      return e.label;
    }
  }), Object.defineProperty(i, "aggregate", {
    enumerable: !0,
    get() {
      return e.aggregate || !1;
    }
  }), i;
}
const Og = (e) => Rb(e, "DOUBLE"), uU = (e) => Rb(e, "INTEGER"), fU = (e) => q`epoch_ms(${oe(e)})`, hU = (e) => {
  const t = oe(e);
  return q`MAKE_DATE(2012, MONTH(${t}), 1)`.annotate({ label: "month" });
}, dU = (e) => {
  const t = oe(e);
  return q`MAKE_DATE(2012, MONTH(${t}), DAY(${t}))`.annotate({ label: "date" });
}, pU = (e) => {
  const t = oe(e);
  return q`MAKE_DATE(2012, 1, DAY(${t}))`.annotate({ label: "date" });
}, G3 = us("ST_AsGeoJSON"), yU = us("ST_X"), mU = us("ST_Y"), Cb = us("ST_CENTROID"), gU = (e) => yU(Cb(e)), bU = (e) => mU(Cb(e));
class Lt {
  static select(...t) {
    return new Lt().select(...t);
  }
  static from(...t) {
    return new Lt().from(...t);
  }
  static with(...t) {
    return new Lt().with(...t);
  }
  static union(...t) {
    return new Oo("UNION", t.flat());
  }
  static unionAll(...t) {
    return new Oo("UNION ALL", t.flat());
  }
  static intersect(...t) {
    return new Oo("INTERSECT", t.flat());
  }
  static except(...t) {
    return new Oo("EXCEPT", t.flat());
  }
  static describe(t) {
    const n = t.clone(), { clone: i, toString: r } = n;
    return Object.assign(n, {
      describe: !0,
      clone: () => Lt.describe(i.call(n)),
      toString: () => `DESCRIBE ${r.call(n)}`
    });
  }
  constructor() {
    this.query = {
      with: [],
      select: [],
      from: [],
      where: [],
      groupby: [],
      having: [],
      window: [],
      qualify: [],
      orderby: []
    }, this.cteFor = null;
  }
  clone() {
    const t = new Lt();
    return t.query = { ...this.query }, t;
  }
  /**
   * Retrieve current WITH common table expressions (CTEs).
   * @returns {any[]}
   */
  /**
  * Add WITH common table expressions (CTEs).
  * @param  {...any} expr Expressions to add.
  * @returns {this}
  */
  with(...t) {
    const { query: n } = this;
    if (t.length === 0)
      return n.with;
    {
      const i = [], r = (s, o) => {
        const a = o.clone();
        a.cteFor = this, i.push({ as: s, query: a });
      };
      return t.flat().forEach((s) => {
        if (s != null)
          if (s.as && s.query)
            r(s.as, s.query);
          else
            for (const o in s)
              r(o, s[o]);
      }), n.with = n.with.concat(i), this;
    }
  }
  /**
   * Retrieve current SELECT expressions.
   * @returns {any[]}
   */
  /**
  * Add SELECT expressions.
  * @param {...any} expr Expressions to add.
  * @returns {this}
  */
  select(...t) {
    const { query: n } = this;
    if (t.length === 0)
      return n.select;
    {
      const i = [];
      for (const r of t.flat())
        if (r != null)
          if (typeof r == "string")
            i.push({ as: r, expr: oe(r) });
          else if (r instanceof js)
            i.push({ as: r.column, expr: r });
          else if (Array.isArray(r))
            i.push({ as: r[0], expr: r[1] });
          else
            for (const s in r)
              i.push({ as: ih(s), expr: oe(r[s]) });
      return n.select = n.select.concat(i), this;
    }
  }
  $select(...t) {
    return this.query.select = [], this.select(...t);
  }
  distinct(t = !0) {
    return this.query.distinct = !!t, this;
  }
  /**
   * Retrieve current from expressions.
   * @returns {any[]}
   */
  /**
  * Provide table from expressions.
  * @param  {...any} expr
  * @returns {this}
  */
  from(...t) {
    const { query: n } = this;
    if (t.length === 0)
      return n.from;
    {
      const i = [];
      return t.flat().forEach((r) => {
        if (r != null)
          if (typeof r == "string")
            i.push({ as: r, from: Hh(r) });
          else if (r instanceof js)
            i.push({ as: r.table, from: r });
          else if (Jh(r) || z3(r))
            i.push({ from: r });
          else if (Array.isArray(r))
            i.push({ as: ih(r[0]), from: Hh(r[1]) });
          else
            for (const s in r)
              i.push({ as: ih(s), from: Hh(r[s]) });
      }), n.from = n.from.concat(i), this;
    }
  }
  $from(...t) {
    return this.query.from = [], this.from(...t);
  }
  /**
   * Retrieve current SAMPLE settings.
   * @returns {any[]}
   */
  /**
  * Set SAMPLE settings.
  * @param {number|object} value The percentage or number of rows to sample.
  * @param {string} [method] The sampling method to use.
  * @returns {this}
  */
  sample(t, n) {
    const { query: i } = this;
    if (arguments.length === 0)
      return i.sample;
    {
      let r = t;
      return typeof t == "number" && (r = t > 0 && t < 1 ? { perc: 100 * t, method: n } : { rows: Math.round(t), method: n }), i.sample = r, this;
    }
  }
  /**
   * Retrieve current WHERE expressions.
   * @returns {any[]}
   */
  /**
  * Add WHERE expressions.
  * @param  {...any} expr Expressions to add.
  * @returns {this}
  */
  where(...t) {
    const { query: n } = this;
    return t.length === 0 ? n.where : (n.where = n.where.concat(
      t.flat().filter((i) => i)
    ), this);
  }
  $where(...t) {
    return this.query.where = [], this.where(...t);
  }
  /**
   * Retrieve current GROUP BY expressions.
   * @returns {any[]}
   */
  /**
  * Add GROUP BY expressions.
  * @param  {...any} expr Expressions to add.
  * @returns {this}
  */
  groupby(...t) {
    const { query: n } = this;
    return t.length === 0 ? n.groupby : (n.groupby = n.groupby.concat(
      t.flat().filter((i) => i).map(oe)
    ), this);
  }
  $groupby(...t) {
    return this.query.groupby = [], this.groupby(...t);
  }
  /**
   * Retrieve current HAVING expressions.
   * @returns {any[]}
   */
  /**
  * Add HAVING expressions.
  * @param  {...any} expr Expressions to add.
  * @returns {this}
  */
  having(...t) {
    const { query: n } = this;
    return t.length === 0 ? n.having : (n.having = n.having.concat(
      t.flat().filter((i) => i)
    ), this);
  }
  /**
   * Retrieve current WINDOW definitions.
   * @returns {any[]}
   */
  /**
  * Add WINDOW definitions.
  * @param  {...any} expr Expressions to add.
  * @returns {this}
  */
  window(...t) {
    const { query: n } = this;
    if (t.length === 0)
      return n.window;
    {
      const i = [];
      return t.flat().forEach((r) => {
        if (r != null)
          for (const s in r)
            i.push({ as: ih(s), expr: r[s] });
      }), n.window = n.window.concat(i), this;
    }
  }
  /**
   * Retrieve current QUALIFY expressions.
   * @returns {any[]}
   */
  /**
  * Add QUALIFY expressions.
  * @param  {...any} expr Expressions to add.
  * @returns {this}
  */
  qualify(...t) {
    const { query: n } = this;
    return t.length === 0 ? n.qualify : (n.qualify = n.qualify.concat(
      t.flat().filter((i) => i)
    ), this);
  }
  /**
   * Retrieve current ORDER BY expressions.
   * @returns {any[]}
   */
  /**
  * Add ORDER BY expressions.
  * @param  {...any} expr Expressions to add.
  * @returns {this}
  */
  orderby(...t) {
    const { query: n } = this;
    return t.length === 0 ? n.orderby : (n.orderby = n.orderby.concat(
      t.flat().filter((i) => i).map(oe)
    ), this);
  }
  /**
   * Retrieve current LIMIT value.
   * @returns {number|null}
   */
  /**
  * Set the query result LIMIT.
  * @param {number} value The limit value.
  * @returns {this}
  */
  limit(t) {
    const { query: n } = this;
    return arguments.length === 0 ? n.limit : (n.limit = Number.isFinite(t) ? t : void 0, this);
  }
  /**
   * Retrieve current OFFSET value.
   * @returns {number|null}
   */
  /**
  * Set the query result OFFSET.
  * @param {number} value The offset value.
  * @returns {this}
  */
  offset(t) {
    const { query: n } = this;
    return arguments.length === 0 ? n.offset : (n.offset = Number.isFinite(t) ? t : void 0, this);
  }
  get subqueries() {
    const { query: t, cteFor: n } = this, i = ((n == null ? void 0 : n.query) || t).with, r = i == null ? void 0 : i.reduce((o, { as: a, query: c }) => (o[a] = c, o), {}), s = [];
    return t.from.forEach(({ from: o }) => {
      if (Jh(o))
        s.push(o);
      else if (r[o.table]) {
        const a = r[o.table];
        s.push(a);
      }
    }), s;
  }
  toString() {
    const {
      with: t,
      select: n,
      distinct: i,
      from: r,
      sample: s,
      where: o,
      groupby: a,
      having: c,
      window: l,
      qualify: u,
      orderby: f,
      limit: h,
      offset: d
    } = this.query, p = [];
    if (t.length) {
      const m = t.map(({ as: g, query: b }) => `"${g}" AS (${b})`);
      p.push(`WITH ${m.join(", ")}`);
    }
    const y = n.map(
      ({ as: m, expr: g }) => h9(g, m) && !g.table ? `${g}` : `${g} AS "${m}"`
    );
    if (p.push(`SELECT${i ? " DISTINCT" : ""} ${y.join(", ")}`), r.length) {
      const m = r.map(({ as: g, from: b }) => {
        const w = Jh(b) ? `(${b})` : `${b}`;
        return !g || g === b.table ? w : `${w} AS "${g}"`;
      });
      p.push(`FROM ${m.join(", ")}`);
    }
    if (o.length) {
      const m = o.map(String).filter((g) => g).join(" AND ");
      m && p.push(`WHERE ${m}`);
    }
    if (s) {
      const { rows: m, perc: g, method: b, seed: w } = s, v = m ? `${m} ROWS` : `${g} PERCENT`, S = b ? ` (${b}${w != null ? `, ${w}` : ""})` : "";
      p.push(`USING SAMPLE ${v}${S}`);
    }
    if (a.length && p.push(`GROUP BY ${a.join(", ")}`), c.length) {
      const m = c.map(String).filter((g) => g).join(" AND ");
      m && p.push(`HAVING ${m}`);
    }
    if (l.length) {
      const m = l.map(({ as: g, expr: b }) => `"${g}" AS (${b})`);
      p.push(`WINDOW ${m.join(", ")}`);
    }
    if (u.length) {
      const m = u.map(String).filter((g) => g).join(" AND ");
      m && p.push(`QUALIFY ${m}`);
    }
    return f.length && p.push(`ORDER BY ${f.join(", ")}`), Number.isFinite(h) && p.push(`LIMIT ${h}`), Number.isFinite(d) && p.push(`OFFSET ${d}`), p.join(" ");
  }
}
class Oo {
  constructor(t, n) {
    this.op = t, this.queries = n.map((i) => i.clone()), this.query = { orderby: [] }, this.cteFor = null;
  }
  clone() {
    const t = new Oo(this.op, this.queries);
    return t.query = { ...this.query }, t;
  }
  orderby(...t) {
    const { query: n } = this;
    return t.length === 0 ? n.orderby : (n.orderby = n.orderby.concat(
      t.flat().filter((i) => i).map(oe)
    ), this);
  }
  limit(t) {
    const { query: n } = this;
    return arguments.length === 0 ? n.limit : (n.limit = Number.isFinite(t) ? t : void 0, this);
  }
  offset(t) {
    const { query: n } = this;
    return arguments.length === 0 ? n.offset : (n.offset = Number.isFinite(t) ? t : void 0, this);
  }
  get subqueries() {
    const { queries: t, cteFor: n } = this;
    return n && t.forEach((i) => i.cteFor = n), t;
  }
  toString() {
    const { op: t, queries: n, query: { orderby: i, limit: r, offset: s } } = this, o = [n.join(` ${t} `)];
    return i.length && o.push(`ORDER BY ${i.join(", ")}`), Number.isFinite(r) && o.push(`LIMIT ${r}`), Number.isFinite(s) && o.push(`OFFSET ${s}`), o.join(" ");
  }
}
function Jh(e) {
  return e instanceof Lt || e instanceof Oo;
}
function wU(e) {
  return Jh(e) && e.describe;
}
function ih(e) {
  return vU(e) ? e.slice(1, -1) : e;
}
function vU(e) {
  return e[0] === '"' && e[e.length - 1] === '"';
}
const Kh = (e) => e;
function _U() {
  return {
    apply: Kh,
    invert: Kh,
    sqlApply: oe,
    sqlInvert: Kh
  };
}
function SU({ base: e = null } = {}) {
  if (e == null || e === Math.E)
    return {
      apply: Math.log,
      invert: Math.exp,
      sqlApply: (t) => q`LN(${oe(t)})`,
      sqlInvert: (t) => q`EXP(${t})`
    };
  if (e === 10)
    return {
      apply: Math.log10,
      invert: (t) => Math.pow(10, t),
      sqlApply: (t) => q`LOG(${oe(t)})`,
      sqlInvert: (t) => q`POW(10, ${t})`
    };
  {
    const t = +e;
    return {
      apply: (n) => Math.log(n) / Math.log(t),
      invert: (n) => Math.pow(t, n),
      sqlApply: (n) => q`LN(${oe(n)}) / LN(${t})`,
      sqlInvert: (n) => q`POW(${t}, ${n})`
    };
  }
}
function xU({ constant: e = 1 } = {}) {
  const t = +e;
  return {
    apply: (n) => Math.sign(n) * Math.log1p(Math.abs(n)),
    invert: (n) => Math.sign(n) * Math.exp(Math.abs(n) - t),
    sqlApply: (n) => (n = oe(n), q`SIGN(${n}) * LN(${t} + ABS(${n}))`),
    sqlInvert: (n) => q`SIGN(${n}) * (EXP(ABS(${n})) - ${t})`
  };
}
function IU() {
  return {
    apply: (e) => Math.sign(e) * Math.sqrt(Math.abs(e)),
    invert: (e) => Math.sign(e) * e * e,
    sqlApply: (e) => (e = oe(e), q`SIGN(${e}) * SQRT(ABS(${e}))`),
    sqlInvert: (e) => q`SIGN(${e}) * (${e}) ** 2`
  };
}
function AU({ exponent: e = 1 } = {}) {
  const t = +e;
  return {
    apply: (n) => Math.sign(n) * Math.pow(Math.abs(n), t),
    invert: (n) => Math.sign(n) * Math.pow(Math.abs(n), 1 / t),
    sqlApply: (n) => (n = oe(n), q`SIGN(${n}) * POW(ABS(${n}), ${t})`),
    sqlInvert: (n) => q`SIGN(${n}) * POW(ABS(${n}), 1/${t})`
  };
}
function a2() {
  return {
    apply: (e) => +e,
    invert: (e) => new Date(e),
    sqlApply: (e) => e instanceof Date ? +e : fU(oe(e)),
    sqlInvert: Kh
  };
}
const MU = {
  linear: _U,
  log: SU,
  symlog: xU,
  sqrt: IU,
  pow: AU,
  time: a2,
  utc: a2
};
function X3(e) {
  const t = MU[e.type];
  return t ? { ...e, ...t(e) } : null;
}
function yf(e, t, {
  replace: n = !1,
  temp: i = !0,
  view: r = !1
} = {}) {
  return "CREATE" + (n ? " OR REPLACE " : " ") + (i ? "TEMP " : "") + (r ? "VIEW" : "TABLE") + (n ? " " : " IF NOT EXISTS ") + e + " AS " + t;
}
function H3(e) {
  return `INSTALL ${e}; LOAD ${e}`;
}
function $U(e, {
  columns: t = Object.keys((e == null ? void 0 : e[0]) || {})
} = {}) {
  let n = [];
  if (Array.isArray(t) ? (n = t, t = n.reduce((r, s) => (r[s] = s, r), {})) : t && (n = Object.keys(t)), !n.length)
    throw new Error("Can not create table from empty column set.");
  const i = [];
  for (const r of e) {
    const s = n.map((o) => `${df(r[o])} AS "${t[o]}"`);
    i.push(`(SELECT ${s.join(", ")})`);
  }
  return i.join(" UNION ALL ");
}
function jy(e, t, n, i = {}, r = {}) {
  const { select: s = ["*"], where: o, view: a, temp: c, replace: l, ...u } = i, f = FU({ ...r, ...u }), h = `${e}('${n}'${f ? ", " + f : ""})`, d = o ? ` WHERE ${o}` : "", p = `SELECT ${s.join(", ")} FROM ${h}${d}`;
  return yf(t, p, { view: a, temp: c, replace: l });
}
function TU(e, t, n) {
  return jy("read_csv", e, t, n, { auto_detect: !0, sample_size: -1 });
}
function DU(e, t, n) {
  return jy("read_json", e, t, n, { auto_detect: !0, json_format: "auto" });
}
function NU(e, t, n) {
  return jy("read_parquet", e, t, n);
}
function BU(e, t, n = {}) {
  const { options: i, ...r } = n;
  if (i) {
    const s = Array.isArray(i) ? i.join(", ") : typeof i == "string" ? i : Object.entries(i).map(([o, a]) => `${o}=${a}`).join(", ");
    Object.assign(r, { open_options: s.toUpperCase() });
  }
  return jy("st_read", e, t, r);
}
function OU(e, t, n = {}) {
  const { select: i = ["*"], ...r } = n, s = $U(t), o = i.length === 1 && i[0] === "*" ? s : `SELECT ${i} FROM ${s}`;
  return yf(e, o, r);
}
function FU(e) {
  return Object.entries(e).map(([t, n]) => `${t}=${Fg(n)}`).join(", ");
}
function Fg(e) {
  switch (typeof e) {
    case "boolean":
      return String(e);
    case "string":
      return `'${e}'`;
    case "undefined":
    case "object":
      return e == null ? "NULL" : Array.isArray(e) ? "[" + e.map((t) => Fg(t)).join(", ") + "]" : "{" + Object.entries(e).map(([t, n]) => `'${t}': ${Fg(n)}`).join(", ") + "}";
    default:
      return e;
  }
}
function EU(e) {
  let t = 2166136261;
  for (let n = 0, i = e.length; n < i; ++n) {
    const r = e.charCodeAt(n), s = r & 65280;
    s && (t = c2(t ^ s >> 8)), t = c2(t ^ r & 255);
  }
  return LU(t);
}
function c2(e) {
  return e + (e << 1) + (e << 4) + (e << 7) + (e << 8) + (e << 24);
}
function LU(e) {
  return e += e << 13, e ^= e >>> 7, e += e << 3, e ^= e >>> 17, e += e << 5, e & 4294967295;
}
class RU {
  /**
   *
   * @param {import('./Coordinator.js').Coordinator} mc a Mosaic coordinator
   * @param {*} options Options hash to configure the data cube indexes and pass selections to the coordinator.
   */
  constructor(t, { selection: n, temp: i = !0 }) {
    this.mc = t, this.selection = n, this.temp = i, this.reset();
  }
  reset() {
    this.enabled = !1, this.clients = null, this.indices = null, this.activeView = null;
  }
  clear() {
    this.indices && (this.mc.cancel(Array.from(this.indices.values(), (t) => t.result)), this.indices = null);
  }
  index(t, n) {
    var l, u;
    if (this.clients !== t) {
      const f = Array.from(t, u2), h = (l = f[0]) == null ? void 0 : l.from;
      this.enabled = f.every((d) => d && d.from === h), this.clients = t, this.activeView = null, this.clear();
    }
    if (!this.enabled)
      return !1;
    n = n || this.selection.active;
    const { source: i } = n;
    if (i && i === ((u = this.activeView) == null ? void 0 : u.source))
      return !0;
    if (this.clear(), !i)
      return !1;
    const r = this.activeView = CU(n);
    if (!r)
      return !1;
    this.mc.logger().warn("DATA CUBE INDEX CONSTRUCTION");
    const s = this.selection.remove(i), o = this.indices = /* @__PURE__ */ new Map(), { mc: a, temp: c } = this;
    for (const f of t) {
      if (s.skip(f, n))
        continue;
      const h = u2(f), d = f.query(s.predicate(f)).select({ ...r.columns, ...h.count }).groupby(Object.keys(r.columns)), [p] = d.subqueries;
      if (p) {
        const v = Object.values(r.columns).map((S) => S.columns[0]);
        UU(p, v);
      }
      const y = d.orderby();
      d.query.orderby = [];
      const m = d.toString(), b = `cube_index_${(EU(m) >>> 0).toString(16)}`, w = a.exec(yf(b, m, { temp: c }));
      o.set(f, { table: b, result: w, order: y, ...h });
    }
  }
  async update() {
    const { clients: t, selection: n, activeView: i } = this, r = i.predicate(n.active.predicate);
    return Promise.all(
      Array.from(t).map((s) => this.updateClient(s, r))
    );
  }
  async updateClient(t, n) {
    const i = this.indices.get(t);
    if (!i)
      return;
    n || (n = this.activeView.predicate(this.selection.active.predicate));
    const { table: r, dims: s, aggr: o, order: a = [] } = i, c = Lt.select(s, o).from(r).groupby(s).where(n).orderby(a);
    return this.mc.updateClient(t, c);
  }
}
function CU(e) {
  var c;
  const { source: t, schema: n } = e;
  let i = (c = e.predicate) == null ? void 0 : c.columns;
  if (!n || !i)
    return null;
  const { type: r, scales: s, pixelSize: o = 1 } = n;
  let a;
  if (r === "interval" && s) {
    const l = s.map((u) => kU(u, o));
    if (l.some((u) => u == null))
      return null;
    l.length === 1 ? (a = (u) => u ? Tn("active0", u.range.map(l[0])) : [], i = { active0: l[0](e.predicate.field) }) : (a = (u) => u ? qs(u.children.map(({ range: f }, h) => Tn(`active${h}`, f.map(l[h])))) : [], i = Object.fromEntries(
      e.predicate.children.map((u, f) => [`active${f}`, l[f](u.field)])
    ));
  } else if (r === "point")
    a = (l) => l, i = Object.fromEntries(i.map((l) => [l.toString(), l]));
  else
    return null;
  return { source: t, columns: i, predicate: a };
}
function kU(e, t) {
  const { apply: n, sqlApply: i } = X3(e);
  if (n) {
    const { domain: r, range: s } = e, o = n(Math.min(...r)), a = n(Math.max(...r)), c = Math.abs(s[1] - s[0]) / (a - o) / t, l = t === 1 ? "" : `${t}::INTEGER * `;
    return (u) => q`${l}FLOOR(${c}::DOUBLE * (${i(u)} - ${o}::DOUBLE))::INTEGER`;
  }
}
const l2 = { from: NaN };
function u2(e) {
  var a;
  if (!e.filterIndexable)
    return l2;
  const t = e.query(), n = Eg(t);
  if (!n || !t.groupby)
    return l2;
  const i = new Set(t.groupby().map((c) => c.column)), r = [], s = [];
  let o;
  for (const { as: c, expr: { aggregate: l } } of t.select())
    switch ((a = l == null ? void 0 : l.toUpperCase) == null ? void 0 : a.call(l)) {
      case "COUNT":
      case "SUM":
        r.push({ [c]: q`SUM("${c}")::DOUBLE` });
        break;
      case "AVG":
        o = "_count_", r.push({ [c]: q`(SUM("${c}" * ${o}) / SUM(${o}))::DOUBLE` });
        break;
      case "MAX":
        r.push({ [c]: q`MAX("${c}")` });
        break;
      case "MIN":
        r.push({ [c]: q`MIN("${c}")` });
        break;
      default:
        if (i.has(c))
          s.push(c);
        else
          return null;
    }
  return {
    aggr: r,
    dims: s,
    count: o ? { [o]: q`COUNT(*)` } : {},
    from: n
  };
}
function Eg(e) {
  const t = e.subqueries;
  if (e.select) {
    const i = e.from();
    if (!i.length)
      return;
    if (t.length === 0)
      return i[0].from.table;
  }
  const n = Eg(t[0]);
  for (let i = 1; i < t.length; ++i) {
    const r = Eg(t[i]);
    if (r !== void 0 && r !== n)
      return NaN;
  }
  return n;
}
function UU(e, t) {
  const n = /* @__PURE__ */ new Set(), i = (r) => {
    n.has(r) || (n.add(r), r.select && r.from().length && r.select(t), r.subqueries.forEach(i));
  };
  i(e);
}
class zU {
  /**
   * @param {import('./Coordinator.js').Coordinator} coordinator The Mosaic coordinator.
   * @param {*} selection The shared filter selection.
   * @param {*} index Boolean flag or options hash for data cube indexer.
   *  Falsy values disable indexing.
   */
  constructor(t, n, i = !0) {
    this.mc = t, this.selection = n, this.clients = /* @__PURE__ */ new Set(), this.indexer = i ? new RU(this.mc, { ...i, selection: n }) : null;
    const { value: r, activate: s } = this.handlers = {
      value: () => this.update(),
      activate: (o) => {
        var a;
        return (a = this.indexer) == null ? void 0 : a.index(this.clients, o);
      }
    };
    n.addEventListener("value", r), n.addEventListener("activate", s);
  }
  finalize() {
    const { value: t, activate: n } = this.handlers;
    this.selection.removeEventListener("value", t), this.selection.removeEventListener("activate", n);
  }
  reset() {
    var t;
    (t = this.indexer) == null || t.reset();
  }
  add(t) {
    return (this.clients = new Set(this.clients)).add(t), this;
  }
  remove(t) {
    return this.clients.has(t) && (this.clients = new Set(this.clients)).delete(t), this;
  }
  update() {
    const { mc: t, indexer: n, clients: i, selection: r } = this;
    return n != null && n.index(i) ? n.update() : PU(t, i, r);
  }
}
function PU(e, t, n) {
  return Promise.all(Array.from(t).map((i) => {
    const r = n.predicate(i);
    if (r != null)
      return e.updateClient(i, i.query(r));
  }));
}
function J3() {
  let e, t;
  const n = new Promise((i, r) => {
    e = i, t = r;
  });
  return Object.assign(n, {
    fulfill: (i) => (e(i), n),
    reject: (i) => (t(i), n)
  });
}
function VU(e) {
  return (typeof requestAnimationFrame < "u" ? requestAnimationFrame : typeof setImmediate < "u" ? setImmediate : setTimeout)(e);
}
function jU(e, t, n) {
  let i = [], r = 0;
  function s() {
    const o = qU(i, t);
    i = [], r = 0;
    for (const a of o)
      WU(a, e, n), HU(a, t);
  }
  return {
    add(o, a) {
      o.request.type === "arrow" ? (r = r || VU(() => s()), i.push({ entry: o, priority: a, index: i.length })) : e(o, a);
    }
  };
}
function qU(e, t) {
  const n = [], i = /* @__PURE__ */ new Map();
  for (const r of e) {
    const { entry: { request: s } } = r, o = YU(s.query, t);
    if (!i.has(o)) {
      const a = [];
      n.push(a), i.set(o, a);
    }
    i.get(o).push(r);
  }
  return n;
}
function YU(e, t) {
  const n = `${e}`;
  if (e instanceof Lt && !t.get(n)) {
    if (
      // @ts-ignore
      e.orderby().length || e.where().length || // @ts-ignore
      e.qualify().length || e.having().length
    )
      return n;
    const i = e.clone().$select("*"), r = e.groupby();
    if (r.length) {
      const s = {};
      e.select().forEach(({ as: o, expr: a }) => s[o] = a), i.$groupby(r.map((o) => o instanceof js && s[o.column] || o));
    }
    return `${i}`;
  } else
    return n;
}
function WU(e, t, n) {
  if (GU(e))
    t({
      request: {
        type: "arrow",
        cache: !1,
        record: !1,
        query: e.query = XU(e, n)
      },
      result: e.result = J3()
    });
  else
    for (const { entry: i, priority: r } of e)
      t(i, r);
}
function GU(e) {
  if (e.length > 1) {
    const t = `${e[0].entry.request.query}`;
    for (let n = 1; n < e.length; ++n)
      if (t !== `${e[n].entry.request.query}`)
        return !0;
  }
  return !1;
}
function XU(e, t) {
  const n = e.maps = [], i = /* @__PURE__ */ new Map();
  for (const o of e) {
    const { query: a } = o.entry.request, c = [];
    n.push(c);
    for (const { as: l, expr: u } of a.select()) {
      const f = `${u}`;
      i.has(f) || i.set(f, [`col${i.size}`, u]);
      const [h] = i.get(f);
      c.push([h, l]);
    }
    t(`${a}`);
  }
  const r = e[0].entry.request.query.clone(), s = r.groupby();
  if (s.length) {
    const o = {};
    e.maps[0].forEach(([a, c]) => o[c] = a), r.$groupby(s.map((a) => a instanceof js && o[a.column] || a));
  }
  return r.$select(Array.from(i.values()));
}
async function HU(e, t) {
  const { maps: n, query: i, result: r } = e;
  if (!n)
    return;
  let s;
  try {
    s = await r;
  } catch (a) {
    for (const { entry: c } of e)
      c.result.reject(a);
    return;
  }
  const o = wU(i);
  e.forEach(({ entry: a }, c) => {
    const { request: l, result: u } = a, f = n[c], h = o && f ? KU(s, f) : f ? JU(s, f) : s;
    l.cache && t.set(String(l.query), h), u.fulfill(h);
  });
}
function JU(e, t) {
  const n = {};
  for (const [i, r] of t)
    n[r] = e.getChild(i);
  return new e.constructor(n);
}
function KU(e, t) {
  const n = new Map(t), i = [];
  for (const r of e)
    n.has(r.column_name) && i.push({ ...r, column_name: n.get(r.column_name) });
  return i;
}
const ZU = typeof requestIdleCallback < "u" ? requestIdleCallback : setTimeout, QU = () => ({
  get: () => {
  },
  set: (e, t) => t,
  clear: () => {
  }
});
function tz({
  max: e = 1e3,
  // max entries
  ttl: t = 3 * 60 * 60 * 1e3
  // time-to-live, default 3 hours
} = {}) {
  let n = /* @__PURE__ */ new Map();
  function i() {
    const r = performance.now() - t;
    let s = null, o = 1 / 0;
    for (const [a, c] of n) {
      const { last: l } = c;
      l < o && (s = a, o = l), r > l && n.delete(a);
    }
    s && n.delete(s);
  }
  return {
    get(r) {
      const s = n.get(r);
      if (s)
        return s.last = performance.now(), s.value;
    },
    set(r, s) {
      return n.set(r, { last: performance.now(), value: s }), n.size > e && ZU(i), s;
    },
    clear() {
      n = /* @__PURE__ */ new Map();
    }
  };
}
function ez(e) {
  const t = Array.from(
    { length: e },
    () => ({ head: null, tail: null })
  );
  return {
    /**
     * Indicate if the queue is empty.
     * @returns [boolean] true if empty, false otherwise.
     */
    isEmpty() {
      return t.every((n) => !n.head);
    },
    /**
     * Insert an item into the queue with a given priority rank.
     * @param {*} item The item to add.
     * @param {number} rank The integer priority rank.
     *  Priority ranks are integers starting at zero.
     *  Lower ranks indicate higher priority.
     */
    insert(n, i) {
      const r = t[i];
      if (!r)
        throw new Error(`Invalid queue priority rank: ${i}`);
      const s = { item: n, next: null };
      r.head === null ? r.head = r.tail = s : r.tail = r.tail.next = s;
    },
    /**
     * Remove a set of items from the queue, regardless of priority rank.
     * If a provided item is not in the queue it will be ignored.
     * @param {(item: *) => boolean} test A predicate function to test
     * 	if an item should be removed (true to drop, false to keep).
     */
    remove(n) {
      for (const i of t) {
        let { head: r, tail: s } = i;
        for (let o = null, a = r; a; o = a, a = a.next)
          n(a.item) && (a === r ? r = a.next : o.next = a.next, a === s && (s = o || r));
        i.head = r, i.tail = s;
      }
    },
    /**
     * Remove and return the next highest priority item.
     * @returns {*} The next item in the queue,
     *  or undefined if this queue is empty.
     */
    next() {
      for (const n of t) {
        const { head: i } = n;
        if (i !== null)
          return n.head = i.next, n.tail === i && (n.tail = null), i.item;
      }
    }
  };
}
const $s = { High: 0, Normal: 1, Low: 2 };
function nz() {
  const e = ez(3);
  let t, n, i, r = [], s = null, o;
  function a() {
    if (s || e.isEmpty())
      return;
    const { request: f, result: h } = e.next();
    s = u(f, h), s.finally(() => {
      s = null, a();
    });
  }
  function c(f, h = $s.Normal) {
    e.insert(f, h), a();
  }
  function l(f) {
    r.length && f && r.forEach((h) => h.add(f));
  }
  async function u(f, h) {
    try {
      const { query: d, type: p, cache: y = !1, record: m = !0, options: g } = f, b = d ? `${d}` : null;
      if (m && l(b), y) {
        const S = n.get(b);
        if (S) {
          i.debug("Cache"), h.fulfill(S);
          return;
        }
      }
      const w = performance.now(), v = await t.query({ type: p, sql: b, ...g });
      y && n.set(b, v), i.debug(`Request: ${(performance.now() - w).toFixed(1)}`), h.fulfill(v);
    } catch (d) {
      h.reject(d);
    }
  }
  return {
    cache(f) {
      return f !== void 0 ? n = f === !0 ? tz() : f || QU() : n;
    },
    logger(f) {
      return f ? i = f : i;
    },
    connector(f) {
      return f ? t = f : t;
    },
    consolidate(f) {
      f && !o ? o = jU(c, n, l) : !f && o && (o = null);
    },
    request(f, h = $s.Normal) {
      const d = J3(), p = { request: f, result: d };
      return o ? o.add(p, h) : c(p, h), d;
    },
    cancel(f) {
      const h = new Set(f);
      e.remove(({ result: d }) => h.has(d));
    },
    clear() {
      e.remove(({ result: f }) => (f.reject("Cleared"), !0));
    },
    record() {
      let f = [];
      const h = {
        add(d) {
          f.push(d);
        },
        reset() {
          f = [];
        },
        snapshot() {
          return f.slice();
        },
        stop() {
          return r = r.filter((d) => d !== h), f;
        }
      };
      return r.push(h), h;
    }
  };
}
function K3(e) {
  switch (e) {
    case "BIGINT":
    case "HUGEINT":
    case "INTEGER":
    case "SMALLINT":
    case "TINYINT":
    case "UBIGINT":
    case "UINTEGER":
    case "USMALLINT":
    case "UTINYINT":
    case "DOUBLE":
    case "FLOAT":
    case "REAL":
      return "number";
    case "DATE":
    case "TIMESTAMP":
    case "TIMESTAMPTZ":
    case "TIMESTAMP WITH TIME ZONE":
    case "TIME":
    case "TIMESTAMP_NS":
      return "date";
    case "BOOLEAN":
      return "boolean";
    case "VARCHAR":
    case "UUID":
      return "string";
    case "ARRAY":
    case "LIST":
      return "array";
    case "BLOB":
    case "STRUCT":
    case "MAP":
    case "GEOMETRY":
      return "object";
    default:
      if (e.startsWith("DECIMAL"))
        return "number";
      if (e.startsWith("STRUCT") || e.startsWith("MAP"))
        return "object";
      if (e.endsWith("]"))
        return "array";
      throw new Error(`Unsupported type: ${e}`);
  }
}
function Z3(e) {
  return typeof (e == null ? void 0 : e.getChild) == "function";
}
function iz(e) {
  if (rt.isTimestamp(e))
    return (t) => t == null ? t : new Date(t);
  if (rt.isInt(e) && e.bitWidth >= 64)
    return (t) => t == null ? t : Number(t);
  if (rt.isDecimal(e)) {
    const t = 1 / Math.pow(10, e.scale);
    return (n) => n == null ? n : Q3(n, t);
  }
  return (t) => t;
}
function rz(e) {
  const { type: t } = e;
  if (rt.isTimestamp(t)) {
    const n = e.length, i = new Array(n);
    for (let r = 0; r < n; ++r) {
      const s = e.get(r);
      i[r] = s == null ? null : new Date(s);
    }
    return i;
  }
  if (rt.isInt(t) && t.bitWidth >= 64) {
    const n = e.length, i = new Float64Array(n);
    for (let r = 0; r < n; ++r) {
      const s = e.get(r);
      i[r] = s == null ? NaN : Number(s);
    }
    return i;
  }
  if (rt.isDecimal(t)) {
    const n = 1 / Math.pow(10, t.scale), i = e.length, r = new Float64Array(i);
    for (let s = 0; s < i; ++s) {
      const o = e.get(s);
      r[s] = o == null ? NaN : Q3(o, n);
    }
    return r;
  }
  return e.toArray();
}
const f2 = Array.from(
  { length: 8 },
  (e, t) => Math.pow(2, t * 32)
);
function Q3(e, t) {
  const n = e.length;
  let i = 0;
  if (e.signed && (e[n - 1] | 0) < 0) {
    for (let r = 0; r < n; ++r)
      i += ~e[r] * f2[r];
    i = -(i + 1);
  } else
    for (let r = 0; r < n; ++r)
      i += e[r] * f2[r];
  return i * t;
}
const sz = "count", oz = "nulls", az = "max", cz = "min", lz = "distinct", uz = {
  [sz]: Uo,
  [lz]: (e) => Uo(e).distinct(),
  [az]: $c,
  [cz]: Tc,
  [oz]: (e) => Uo().where(Eb(e))
};
function fz(e, t, n) {
  return Lt.from(e).select(Array.from(n, (i) => [i, uz[i](t)]));
}
async function hz(e, t) {
  return t.length === 1 && `${t[0].column}` == "*" ? pz(e, t[0].table) : (await Promise.all(t.map((n) => dz(e, n)))).filter((n) => n);
}
async function dz(e, { table: t, column: n, stats: i }) {
  const r = Lt.from({ source: t }).select({ column: n }).groupby(n.aggregate ? q`ALL` : []), [s] = Array.from(await e.query(Lt.describe(r))), o = {
    table: t,
    column: `${n}`,
    sqlType: s.column_type,
    type: K3(s.column_type),
    nullable: s.null === "YES"
  };
  if (!(i != null && i.length || i != null && i.size))
    return o;
  const a = await e.query(
    fz(t, n, i),
    { persist: !0 }
  );
  for (let c = 0; c < a.numCols; ++c) {
    const { name: l } = a.schema.fields[c], u = a.getChildAt(c), f = iz(u.type);
    o[l] = f(u.get(0));
  }
  return o;
}
async function pz(e, t) {
  const n = await e.query(`DESCRIBE ${Hh(t)}`);
  return Array.from(n).map((i) => ({
    table: t,
    column: i.column_name,
    sqlType: i.column_type,
    type: K3(i.column_type),
    nullable: i.null === "YES"
  }));
}
function yz() {
  return {
    debug() {
    },
    info() {
    },
    log() {
    },
    warn() {
    },
    error() {
    }
  };
}
let rh;
function Wr(e) {
  return e ? rh = e : rh == null && (rh = new mz()), rh;
}
class mz {
  constructor(t = f9(), n = {}) {
    const {
      logger: i = console,
      manager: r = nz()
    } = n;
    this.manager = r, this.logger(i), this.configure(n), this.databaseConnector(t), this.clear();
  }
  logger(t) {
    return arguments.length && (this._logger = t || yz(), this.manager.logger(this._logger)), this._logger;
  }
  /**
   * Set configuration options for this coordinator.
   * @param {object} [options] Configration options.
   * @param {boolean} [options.cache=true] Boolean flag to enable/disable query caching.
   * @param {boolean} [options.consolidate=true] Boolean flag to enable/disable query consolidation.
   * @param {boolean|object} [options.indexes=true] Boolean flag to enable/disable
   *  automatic data cube indexes or an index options object.
   */
  configure({ cache: t = !0, consolidate: n = !0, indexes: i = !0 } = {}) {
    this.manager.cache(t), this.manager.consolidate(n), this.indexes = i;
  }
  clear({ clients: t = !0, cache: n = !0 } = {}) {
    var i, r;
    this.manager.clear(), t && ((i = this.clients) == null || i.forEach((s) => this.disconnect(s)), (r = this.filterGroups) == null || r.forEach((s) => s.finalize()), this.clients = /* @__PURE__ */ new Set(), this.filterGroups = /* @__PURE__ */ new Map()), n && this.manager.cache().clear();
  }
  databaseConnector(t) {
    return this.manager.connector(t);
  }
  // -- Query Management ----
  cancel(t) {
    this.manager.cancel(t);
  }
  exec(t, { priority: n = $s.Normal } = {}) {
    return t = Array.isArray(t) ? t.join(`;
`) : t, this.manager.request({ type: "exec", query: t }, n);
  }
  query(t, {
    type: n = "arrow",
    cache: i = !0,
    priority: r = $s.Normal,
    ...s
  } = {}) {
    return this.manager.request({ type: n, query: t, cache: i, options: s }, r);
  }
  prefetch(t, n = {}) {
    return this.query(t, { ...n, cache: !0, priority: $s.Low });
  }
  createBundle(t, n, i = $s.Low) {
    const r = { name: t, queries: n };
    return this.manager.request({ type: "create-bundle", options: r }, i);
  }
  loadBundle(t, n = $s.High) {
    const i = { name: t };
    return this.manager.request({ type: "load-bundle", options: i }, n);
  }
  // -- Client Management ----
  updateClient(t, n, i = $s.Normal) {
    return t.queryPending(), this.query(n, { priority: i }).then(
      (r) => t.queryResult(r).update(),
      (r) => {
        t.queryError(r), this._logger.error(r);
      }
    );
  }
  requestQuery(t, n) {
    var i;
    return (i = this.filterGroups.get(t.filterBy)) == null || i.reset(), n ? this.updateClient(t, n) : t.update();
  }
  /**
   * Connect a client to the coordinator.
   * @param {import('./MosaicClient.js').MosaicClient} client the client to disconnect
   */
  async connect(t) {
    const { clients: n, filterGroups: i, indexes: r } = this;
    if (n.has(t))
      throw new Error("Client already connected.");
    n.add(t), t.coordinator = this;
    const s = t.fields();
    s != null && s.length && t.fieldInfo(await hz(this, s));
    const o = t.filterBy;
    if (o)
      if (i.has(o))
        i.get(o).add(t);
      else {
        const a = new zU(this, o, r);
        i.set(o, a.add(t));
      }
    t.requestQuery();
  }
  /**
   * Disconnect a client from the coordinator.
   *
   * @param {import('./MosaicClient.js').MosaicClient} client the client to disconnect
   */
  disconnect(t) {
    var r;
    const { clients: n, filterGroups: i } = this;
    n.has(t) && (n.delete(t), (r = i.get(t.filterBy)) == null || r.remove(t), t.coordinator = null);
  }
}
class gz {
  /**
   * Create a new asynchronous dispatcher instance.
   */
  constructor() {
    this._callbacks = /* @__PURE__ */ new Map();
  }
  /**
   * Add an event listener callback for the provided event type.
   * @param {string} type The event type.
   * @param {(value: *) => void | Promise} callback The event handler
   *  callback function to add. If the callback has already been
   *  added for the event type, this method has no effect.
   */
  addEventListener(t, n) {
    this._callbacks.has(t) || this._callbacks.set(t, {
      callbacks: /* @__PURE__ */ new Set(),
      pending: null,
      queue: new bz()
    }), this._callbacks.get(t).callbacks.add(n);
  }
  /**
   * Remove an event listener callback for the provided event type.
   * @param {string} type The event type.
   * @param {(value: *) => void | Promise} callback The event handler
   *  callback function to remove.
   */
  removeEventListener(t, n) {
    const i = this._callbacks.get(t);
    i && i.callbacks.delete(n);
  }
  /**
   * Lifecycle method that returns the event value to emit.
   * This default implementation simply returns the input value as-is.
   * Subclasses may override this method to implement custom transformations
   * prior to emitting an event value to all listeners.
   * @param {string} type The event type.
   * @param {*} value The event value.
   * @returns The (possibly transformed) event value to emit.
   */
  willEmit(t, n) {
    return n;
  }
  /**
   * Lifecycle method that returns a filter function for updating the
   * queue of unemitted event values prior to enqueueing a new value.
   * This default implementation simply returns null, indicating that
   * any other unemitted event values should be dropped (that is, all
   * queued events are filtered)
   * @param {string} type The event type.
   * @param {*} value The new event value that will be enqueued.
   * @returns {(value: *) => boolean|null} A dispatch queue filter
   *  function, or null if all unemitted event values should be filtered.
   */
  emitQueueFilter(t, n) {
    return null;
  }
  /**
   * Cancel all unemitted event values for the given event type.
   * @param {string} type The event type.
   */
  cancel(t) {
    const n = this._callbacks.get(t);
    n == null || n.queue.clear();
  }
  /**
   * Emit an event value to listeners for the given event type.
   * If a previous emit has not yet resolved, the event value
   * will be queued to be emitted later.
   * The actual event value given to listeners will be the result
   * of passing the input value through the emitValue() method.
   * @param {string} type The event type.
   * @param {*} value The event value.
   */
  emit(t, n) {
    const i = this._callbacks.get(t) || {};
    if (i.pending)
      i.queue.enqueue(n, this.emitQueueFilter(t, n));
    else {
      const r = this.willEmit(t, n), { callbacks: s, queue: o } = i;
      if (s != null && s.size) {
        const a = Promise.allSettled(Array.from(s, (c) => c(r))).then(() => {
          i.pending = null, o.isEmpty() || this.emit(t, o.dequeue());
        });
        i.pending = a;
      }
    }
  }
}
class bz {
  /**
   * Create a new dispatch queue instance.
   */
  constructor() {
    this.clear();
  }
  /**
   * Clear the queue state of all event values.
   */
  clear() {
    this.next = null;
  }
  /**
   * Indicate if the queue is empty.
   * @returns {boolean} True if queue is empty, false otherwise.
   */
  isEmpty() {
    return !this.next;
  }
  /**
   * Add a new value to the queue, and optionally filter the
   * current queue content in response.
   * @param {*} value The value to add.
   * @param {(value: *) => boolean} [filter] An optional filter
   *  function to apply to existing queue content. If unspecified
   *  or falsy, all previously queued values are removed. Otherwise,
   *  the provided function is applied to all queue entries. The
   *  entry is retained if the filter function returns a truthy value,
   *  otherwise the entry is removed.
   */
  enqueue(t, n) {
    const i = { value: t };
    if (n && this.next) {
      let r = this;
      for (; r.next; )
        n(r.next.value) ? r = r.next : r.next = r.next.next;
      r.next = i;
    } else
      this.next = i;
  }
  /**
   * Remove and return the next queued event value.
   * @returns {*} The next event value in the queue.
   */
  dequeue() {
    const { next: t } = this;
    return this.next = t == null ? void 0 : t.next, t == null ? void 0 : t.value;
  }
}
function tM(e, t) {
  return e === t ? !1 : e instanceof Date && t instanceof Date ? +e != +t : Array.isArray(e) && Array.isArray(t) ? wz(e, t) : !0;
}
function wz(e, t) {
  if (e.length !== t.length)
    return !0;
  for (let n = 0; n < e.length; ++n)
    if (e[n] !== t[n])
      return !0;
  return !1;
}
function Us(e) {
  return e instanceof zo;
}
class zo extends gz {
  /**
   * Create a new Param instance.
   * @param {*} value The initial value of the Param.
   */
  constructor(t) {
    super(), this._value = t;
  }
  /**
   * Create a new Param instance with the given initial value.
   * @param {*} value The initial value of the Param.
   * @returns {Param} The new Param instance.
   */
  static value(t) {
    return new zo(t);
  }
  /**
   * Create a new Param instance over an array of initial values,
   * which may contain nested Params.
   * @param {*} values The initial values of the Param.
   * @returns {Param} The new Param instance.
   */
  static array(t) {
    if (t.some((n) => Us(n))) {
      const n = new zo(), i = () => {
        n.update(t.map((r) => Us(r) ? r.value : r));
      };
      return i(), t.forEach((r) => Us(r) ? r.addEventListener("value", i) : 0), n;
    }
    return new zo(t);
  }
  /**
   * The current value of the Param.
   */
  get value() {
    return this._value;
  }
  /**
   * Update the Param value
   * @param {*} value The new value of the Param.
   * @param {object} [options] The update options.
   * @param {boolean} [options.force] A boolean flag indicating if the Param
   *  should emit a 'value' event even if the internal value is unchanged.
   * @returns {this} This Param instance.
   */
  update(t, { force: n } = {}) {
    return tM(this._value, t) || n ? this.emit("value", t) : this.cancel("value"), this;
  }
  /**
   * Upon value-typed updates, sets the current value to the input value
   * immediately prior to the event value being emitted to listeners.
   * @param {string} type The event type.
   * @param {*} value The input event value.
   * @returns {*} The input event value.
   */
  willEmit(t, n) {
    return t === "value" && (this._value = n), n;
  }
}
function rs(e) {
  return e instanceof Xd;
}
let Xd = class Pa extends zo {
  /**
   * Create a new Selection instance with an
   * intersect (conjunction) resolution strategy.
   * @param {object} [options] The selection options.
   * @param {boolean} [options.cross=false] Boolean flag indicating
   *  cross-filtered resolution. If true, selection clauses will not
   *  be applied to the clients they are associated with.
   * @returns {Selection} The new Selection instance.
   */
  static intersect({ cross: t = !1 } = {}) {
    return new Pa(new wl({ cross: t }));
  }
  /**
   * Create a new Selection instance with a
   * union (disjunction) resolution strategy.
   * @param {object} [options] The selection options.
   * @param {boolean} [options.cross=false] Boolean flag indicating
   *  cross-filtered resolution. If true, selection clauses will not
   *  be applied to the clients they are associated with.
   * @returns {Selection} The new Selection instance.
   */
  static union({ cross: t = !1 } = {}) {
    return new Pa(new wl({ cross: t, union: !0 }));
  }
  /**
   * Create a new Selection instance with a singular resolution strategy
   * that keeps only the most recent selection clause.
   * @param {object} [options] The selection options.
   * @param {boolean} [options.cross=false] Boolean flag indicating
   *  cross-filtered resolution. If true, selection clauses will not
   *  be applied to the clients they are associated with.
   * @returns {Selection} The new Selection instance.
   */
  static single({ cross: t = !1 } = {}) {
    return new Pa(new wl({ cross: t, single: !0 }));
  }
  /**
   * Create a new Selection instance with a
   * cross-filtered intersect resolution strategy.
   * @returns {Selection} The new Selection instance.
   */
  static crossfilter() {
    return new Pa(new wl({ cross: !0 }));
  }
  /**
   * Create a new Selection instance.
   * @param {SelectionResolver} resolver The selection resolution
   *  strategy to apply.
   */
  constructor(t = new wl()) {
    super([]), this._resolved = this._value, this._resolver = t;
  }
  /**
   * Create a cloned copy of this Selection instance.
   * @returns {Selection} A clone of this selection.
   */
  clone() {
    const t = new Pa(this._resolver);
    return t._value = t._resolved = this._value, t;
  }
  /**
   * Create a clone of this Selection with clauses corresponding
   * to the provided source removed.
   * @param {*} source The clause source to remove.
   * @returns {Selection} A cloned and updated Selection.
   */
  remove(t) {
    const n = this.clone();
    return n._value = n._resolved = n._resolver.resolve(this._resolved, { source: t }), n._value.active = { source: t }, n;
  }
  /**
   * The current active (most recently updated) selection clause.
   */
  get active() {
    return this.clauses.active;
  }
  /**
   * The value corresponding to the current active selection clause.
   * This method ensures compatibility where a normal Param is expected.
   */
  get value() {
    var t;
    return (t = this.active) == null ? void 0 : t.value;
  }
  /**
   * The current array of selection clauses.
   */
  get clauses() {
    return super.value;
  }
  /**
   * Indicate if this selection has a single resolution strategy.
   */
  get single() {
    return this._resolver.single;
  }
  /**
   * Emit an activate event with the given selection clause.
   * @param {*} clause The clause repesenting the potential activation.
   */
  activate(t) {
    this.emit("activate", t);
  }
  /**
   * Update the selection with a new selection clause.
   * @param {*} clause The selection clause to add.
   * @returns {this} This Selection instance.
   */
  update(t) {
    return this._resolved = this._resolver.resolve(this._resolved, t, !0), this._resolved.active = t, super.update(this._resolved);
  }
  /**
   * Upon value-typed updates, sets the current clause list to the
   * input value and returns the active clause value.
   * @param {string} type The event type.
   * @param {*} value The input event value.
   * @returns {*} For value-typed events, returns the active clause
   *  values. Otherwise returns the input event value as-is.
   */
  willEmit(t, n) {
    return t === "value" ? (this._value = n, this.value) : n;
  }
  /**
   * Upon value-typed updates, returns a dispatch queue filter function.
   * The return value depends on the selection resolution strategy.
   * @param {string} type The event type.
   * @param {*} value The new event value that will be enqueued.
   * @returns {(value: *) => boolean|null} For value-typed events,
   *  returns a dispatch queue filter function. Otherwise returns null.
   */
  emitQueueFilter(t, n) {
    return t === "value" ? this._resolver.queueFilter(n) : null;
  }
  /**
   * Indicates if a selection clause should not be applied to a given client.
   * The return value depends on the selection resolution strategy.
   * @param {*} client The selection clause.
   * @param {*} clause The client to test.
   * @returns True if the client should be skipped, false otherwise.
   */
  skip(t, n) {
    return this._resolver.skip(t, n);
  }
  /**
   * Return a selection query predicate for the given client.
   * @param {*} client The client whose data may be filtered.
   * @param {boolean} [noSkip=false] Disable skipping of active
   *  cross-filtered sources. If set true, the source of the active
   *  clause in a cross-filtered selection will not be skipped.
   * @returns {*} The query predicate for filtering client data,
   *  based on the current state of this selection.
   */
  predicate(t, n = !1) {
    const { clauses: i } = this, r = n ? null : i.active;
    return this._resolver.predicate(i, r, t);
  }
};
class wl {
  /**
   * Create a new selection resolved instance.
   * @param {object} [options] The resolution strategy options.
   * @param {boolean} [options.union=false] Boolean flag to indicate a union strategy.
   *  If false, an intersection strategy is used.
   * @param {boolean} [options.cross=false] Boolean flag to indicate cross-filtering.
   * @param {boolean} [options.single=false] Boolean flag to indicate single clauses only.
   */
  constructor({ union: t, cross: n, single: i } = {}) {
    this.union = !!t, this.cross = !!n, this.single = !!i;
  }
  /**
   * Resolve a list of selection clauses according to the resolution strategy.
   * @param {*[]} clauseList An array of selection clauses.
   * @param {*} clause A new selection clause to add.
   * @returns {*[]} An updated array of selection clauses.
   */
  resolve(t, n, i = !1) {
    const { source: r, predicate: s } = n, o = t.filter((c) => r !== c.source), a = this.single ? [] : o;
    return this.single && i && o.forEach((c) => {
      var l, u;
      return (u = (l = c.source) == null ? void 0 : l.reset) == null ? void 0 : u.call(l);
    }), s && a.push(n), a;
  }
  /**
   * Indicates if a selection clause should not be applied to a given client.
   * The return value depends on the resolution strategy.
   * @param {*} client The selection clause.
   * @param {*} clause The client to test.
   * @returns True if the client should be skipped, false otherwise.
   */
  skip(t, n) {
    var i;
    return this.cross && ((i = n == null ? void 0 : n.clients) == null ? void 0 : i.has(t));
  }
  /**
   * Return a selection query predicate for the given client.
   * @param {*[]} clauseList An array of selection clauses.
   * @param {*} active The current active selection clause.
   * @param {*} client The client whose data may be filtered.
   * @returns {*} The query predicate for filtering client data,
   *  based on the current state of this selection.
   */
  predicate(t, n, i) {
    const { union: r } = this;
    if (this.skip(i, n))
      return;
    const s = t.filter((o) => !this.skip(i, o)).map((o) => o.predicate);
    return r && s.length > 1 ? Fb(s) : s;
  }
  /**
   * Returns a filter function for queued selection updates.
   * @param {*} value The new event value that will be enqueued.
   * @returns {(value: *) => boolean|null} A dispatch queue filter
   *  function, or null if all unemitted event values should be filtered.
   */
  queueFilter(t) {
    var n;
    if (this.cross) {
      const i = (n = t.active) == null ? void 0 : n.source;
      return (r) => {
        var s;
        return ((s = r.active) == null ? void 0 : s.source) !== i;
      };
    }
    return null;
  }
}
function vz() {
  const e = /* @__PURE__ */ new Set();
  let t, n = new Promise((i) => t = i);
  return {
    /**
     * Mark an item as pending.
     * @param {*} item An item to synchronize on.
     */
    pending(i) {
      e.add(i);
    },
    /**
     * Mark a pending item as ready, indicating it is
     * ready for a synchronized update.
     * @param {*} item An item to synchronize on.
     * @returns {boolean} True if the synchronizer is ready to
     *  resolve, false otherwise.
     */
    ready(i) {
      return e.delete(i), e.size === 0;
    },
    /**
     * Resolve the current synchronization cycle, causing the synchronize
     * promise to resolve and thereby trigger downstream updates.
     */
    resolve() {
      n = new Promise((i) => {
        t(), t = i;
      });
    },
    /**
     * The promise for the current synchronization cycle.
     * @return {Promise} The synchronization promise.
     */
    get promise() {
      return n;
    }
  };
}
const mf = Symbol("Fixed"), $i = Symbol("Transient"), eM = Symbol("Transform");
function me(e, t) {
  return e == null || t == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function Ho(e, t) {
  return e == null || t == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function qy(e) {
  let t, n, i;
  e.length !== 2 ? (t = me, n = (a, c) => me(e(a), c), i = (a, c) => e(a) - c) : (t = e === me || e === Ho ? e : _z, n = e, i = e);
  function r(a, c, l = 0, u = a.length) {
    if (l < u) {
      if (t(c, c) !== 0)
        return u;
      do {
        const f = l + u >>> 1;
        n(a[f], c) < 0 ? l = f + 1 : u = f;
      } while (l < u);
    }
    return l;
  }
  function s(a, c, l = 0, u = a.length) {
    if (l < u) {
      if (t(c, c) !== 0)
        return u;
      do {
        const f = l + u >>> 1;
        n(a[f], c) <= 0 ? l = f + 1 : u = f;
      } while (l < u);
    }
    return l;
  }
  function o(a, c, l = 0, u = a.length) {
    const f = r(a, c, l, u - 1);
    return f > l && i(a[f - 1], c) > -i(a[f], c) ? f - 1 : f;
  }
  return { left: r, center: o, right: s };
}
function _z() {
  return 0;
}
function nM(e) {
  return e === null ? NaN : +e;
}
function* Sz(e, t) {
  if (t === void 0)
    for (let n of e)
      n != null && (n = +n) >= n && (yield n);
  else {
    let n = -1;
    for (let i of e)
      (i = t(i, ++n, e)) != null && (i = +i) >= i && (yield i);
  }
}
const xz = qy(me), Yy = xz.right;
qy(nM).center;
const iM = rM(sM), Iz = rM(Az);
function rM(e) {
  return function(t, n, i = n) {
    if (!((n = +n) >= 0))
      throw new RangeError("invalid rx");
    if (!((i = +i) >= 0))
      throw new RangeError("invalid ry");
    let { data: r, width: s, height: o } = t;
    if (!((s = Math.floor(s)) >= 0))
      throw new RangeError("invalid width");
    if (!((o = Math.floor(o !== void 0 ? o : r.length / s)) >= 0))
      throw new RangeError("invalid height");
    if (!s || !o || !n && !i)
      return t;
    const a = n && e(n), c = i && e(i), l = r.slice();
    return a && c ? (ga(a, l, r, s, o), ga(a, r, l, s, o), ga(a, l, r, s, o), ba(c, r, l, s, o), ba(c, l, r, s, o), ba(c, r, l, s, o)) : a ? (ga(a, r, l, s, o), ga(a, l, r, s, o), ga(a, r, l, s, o)) : c && (ba(c, r, l, s, o), ba(c, l, r, s, o), ba(c, r, l, s, o)), t;
  };
}
function ga(e, t, n, i, r) {
  for (let s = 0, o = i * r; s < o; )
    e(t, n, s, s += i, 1);
}
function ba(e, t, n, i, r) {
  for (let s = 0, o = i * r; s < i; ++s)
    e(t, n, s, s + o, i);
}
function Az(e) {
  const t = sM(e);
  return (n, i, r, s, o) => {
    r <<= 2, s <<= 2, o <<= 2, t(n, i, r + 0, s + 0, o), t(n, i, r + 1, s + 1, o), t(n, i, r + 2, s + 2, o), t(n, i, r + 3, s + 3, o);
  };
}
function sM(e) {
  const t = Math.floor(e);
  if (t === e)
    return Mz(e);
  const n = e - t, i = 2 * e + 1;
  return (r, s, o, a, c) => {
    if (!((a -= c) >= o))
      return;
    let l = t * s[o];
    const u = c * t, f = u + c;
    for (let h = o, d = o + u; h < d; h += c)
      l += s[Math.min(a, h)];
    for (let h = o, d = a; h <= d; h += c)
      l += s[Math.min(a, h + u)], r[h] = (l + n * (s[Math.max(o, h - f)] + s[Math.min(a, h + f)])) / i, l -= s[Math.max(o, h - u)];
  };
}
function Mz(e) {
  const t = 2 * e + 1;
  return (n, i, r, s, o) => {
    if (!((s -= o) >= r))
      return;
    let a = e * i[r];
    const c = o * e;
    for (let l = r, u = r + c; l < u; l += o)
      a += i[Math.min(s, l)];
    for (let l = r, u = s; l <= u; l += o)
      a += i[Math.min(s, l + c)], n[l] = a / t, a -= i[Math.max(r, l - c)];
  };
}
function Wy(e, t) {
  let n = 0;
  if (t === void 0)
    for (let i of e)
      i != null && (i = +i) >= i && ++n;
  else {
    let i = -1;
    for (let r of e)
      (r = t(r, ++i, e)) != null && (r = +r) >= r && ++n;
  }
  return n;
}
function $z(e) {
  return e.length | 0;
}
function Tz(e) {
  return !(e > 0);
}
function Dz(e) {
  return typeof e != "object" || "length" in e ? e : Array.from(e);
}
function Nz(e) {
  return (t) => e(...t);
}
function Bz(...e) {
  const t = typeof e[e.length - 1] == "function" && Nz(e.pop());
  e = e.map(Dz);
  const n = e.map($z), i = e.length - 1, r = new Array(i + 1).fill(0), s = [];
  if (i < 0 || n.some(Tz))
    return s;
  for (; ; ) {
    s.push(r.map((a, c) => e[c][a]));
    let o = i;
    for (; ++r[o] === n[o]; ) {
      if (o === 0)
        return t ? s.map(t) : s;
      r[o--] = 0;
    }
  }
}
function Oz(e, t) {
  var n = 0, i = 0;
  return Float64Array.from(e, t === void 0 ? (r) => n += +r || 0 : (r) => n += +t(r, i++, e) || 0);
}
function kb(e, t) {
  let n = 0, i, r = 0, s = 0;
  if (t === void 0)
    for (let o of e)
      o != null && (o = +o) >= o && (i = o - r, r += i / ++n, s += i * (o - r));
  else {
    let o = -1;
    for (let a of e)
      (a = t(a, ++o, e)) != null && (a = +a) >= a && (i = a - r, r += i / ++n, s += i * (a - r));
  }
  if (n > 1)
    return s / (n - 1);
}
function gf(e, t) {
  const n = kb(e, t);
  return n && Math.sqrt(n);
}
function ke(e, t) {
  let n, i;
  if (t === void 0)
    for (const r of e)
      r != null && (n === void 0 ? r >= r && (n = i = r) : (n > r && (n = r), i < r && (i = r)));
  else {
    let r = -1;
    for (let s of e)
      (s = t(s, ++r, e)) != null && (n === void 0 ? s >= s && (n = i = s) : (n > s && (n = s), i < s && (i = s)));
  }
  return [n, i];
}
class sr {
  constructor() {
    this._partials = new Float64Array(32), this._n = 0;
  }
  add(t) {
    const n = this._partials;
    let i = 0;
    for (let r = 0; r < this._n && r < 32; r++) {
      const s = n[r], o = t + s, a = Math.abs(t) < Math.abs(s) ? t - (o - s) : s - (o - t);
      a && (n[i++] = a), t = o;
    }
    return n[i] = t, this._n = i + 1, this;
  }
  valueOf() {
    const t = this._partials;
    let n = this._n, i, r, s, o = 0;
    if (n > 0) {
      for (o = t[--n]; n > 0 && (i = o, r = t[--n], o = i + r, s = r - (o - i), !s); )
        ;
      n > 0 && (s < 0 && t[n - 1] < 0 || s > 0 && t[n - 1] > 0) && (r = s * 2, i = o + r, r == i - o && (o = i));
    }
    return o;
  }
}
class Jo extends Map {
  constructor(t, n = cM) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: n } }), t != null)
      for (const [i, r] of t)
        this.set(i, r);
  }
  get(t) {
    return super.get(Lg(this, t));
  }
  has(t) {
    return super.has(Lg(this, t));
  }
  set(t, n) {
    return super.set(oM(this, t), n);
  }
  delete(t) {
    return super.delete(aM(this, t));
  }
}
class el extends Set {
  constructor(t, n = cM) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: n } }), t != null)
      for (const i of t)
        this.add(i);
  }
  has(t) {
    return super.has(Lg(this, t));
  }
  add(t) {
    return super.add(oM(this, t));
  }
  delete(t) {
    return super.delete(aM(this, t));
  }
}
function Lg({ _intern: e, _key: t }, n) {
  const i = t(n);
  return e.has(i) ? e.get(i) : n;
}
function oM({ _intern: e, _key: t }, n) {
  const i = t(n);
  return e.has(i) ? e.get(i) : (e.set(i, n), n);
}
function aM({ _intern: e, _key: t }, n) {
  const i = t(n);
  return e.has(i) && (n = e.get(i), e.delete(i)), n;
}
function cM(e) {
  return e !== null && typeof e == "object" ? e.valueOf() : e;
}
function Rg(e) {
  return e;
}
function fs(e, ...t) {
  return Ub(e, Rg, Rg, t);
}
function uc(e, t, ...n) {
  return Ub(e, Rg, t, n);
}
function Fz(e, t, ...n) {
  return Ub(e, Array.from, t, n);
}
function Ub(e, t, n, i) {
  return function r(s, o) {
    if (o >= i.length)
      return n(s);
    const a = new Jo(), c = i[o++];
    let l = -1;
    for (const u of s) {
      const f = c(u, ++l, s), h = a.get(f);
      h ? h.push(u) : a.set(f, [u]);
    }
    for (const [u, f] of a)
      a.set(u, r(f, o));
    return t(a);
  }(e, 0);
}
function Ez(e, t) {
  return Array.from(t, (n) => e[n]);
}
function Hd(e, ...t) {
  if (typeof e[Symbol.iterator] != "function")
    throw new TypeError("values is not iterable");
  e = Array.from(e);
  let [n] = t;
  if (n && n.length !== 2 || t.length > 1) {
    const i = Uint32Array.from(e, (r, s) => s);
    return t.length > 1 ? (t = t.map((r) => e.map(r)), i.sort((r, s) => {
      for (const o of t) {
        const a = Du(o[r], o[s]);
        if (a)
          return a;
      }
    })) : (n = e.map(n), i.sort((r, s) => Du(n[r], n[s]))), Ez(e, i);
  }
  return e.sort(zb(n));
}
function zb(e = me) {
  if (e === me)
    return Du;
  if (typeof e != "function")
    throw new TypeError("compare is not a function");
  return (t, n) => {
    const i = e(t, n);
    return i || i === 0 ? i : (e(n, n) === 0) - (e(t, t) === 0);
  };
}
function Du(e, t) {
  return (e == null || !(e >= e)) - (t == null || !(t >= t)) || (e < t ? -1 : e > t ? 1 : 0);
}
function Pb(e, t, n) {
  return (t.length !== 2 ? Hd(uc(e, t, n), ([i, r], [s, o]) => me(r, o) || me(i, s)) : Hd(fs(e, n), ([i, r], [s, o]) => t(r, o) || me(i, s))).map(([i]) => i);
}
const Lz = Math.sqrt(50), Rz = Math.sqrt(10), Cz = Math.sqrt(2);
function Jd(e, t, n) {
  const i = (t - e) / Math.max(0, n), r = Math.floor(Math.log10(i)), s = i / Math.pow(10, r), o = s >= Lz ? 10 : s >= Rz ? 5 : s >= Cz ? 2 : 1;
  let a, c, l;
  return r < 0 ? (l = Math.pow(10, -r) / o, a = Math.round(e * l), c = Math.round(t * l), a / l < e && ++a, c / l > t && --c, l = -l) : (l = Math.pow(10, r) * o, a = Math.round(e / l), c = Math.round(t / l), a * l < e && ++a, c * l > t && --c), c < a && 0.5 <= n && n < 2 ? Jd(e, t, n * 2) : [a, c, l];
}
function Ys(e, t, n) {
  if (t = +t, e = +e, n = +n, !(n > 0))
    return [];
  if (e === t)
    return [e];
  const i = t < e, [r, s, o] = i ? Jd(t, e, n) : Jd(e, t, n);
  if (!(s >= r))
    return [];
  const a = s - r + 1, c = new Array(a);
  if (i)
    if (o < 0)
      for (let l = 0; l < a; ++l)
        c[l] = (s - l) / -o;
    else
      for (let l = 0; l < a; ++l)
        c[l] = (s - l) * o;
  else if (o < 0)
    for (let l = 0; l < a; ++l)
      c[l] = (r + l) / -o;
  else
    for (let l = 0; l < a; ++l)
      c[l] = (r + l) * o;
  return c;
}
function Nu(e, t, n) {
  return t = +t, e = +e, n = +n, Jd(e, t, n)[2];
}
function Cg(e, t, n) {
  t = +t, e = +e, n = +n;
  const i = t < e, r = i ? Nu(t, e, n) : Nu(e, t, n);
  return (i ? -1 : 1) * (r < 0 ? 1 / -r : r);
}
function lM(e, t, n) {
  let i;
  for (; ; ) {
    const r = Nu(e, t, n);
    if (r === i || r === 0 || !isFinite(r))
      return [e, t];
    r > 0 ? (e = Math.floor(e / r) * r, t = Math.ceil(t / r) * r) : r < 0 && (e = Math.ceil(e * r) / r, t = Math.floor(t * r) / r), i = r;
  }
}
function Vb(e) {
  return Math.max(1, Math.ceil(Math.log(Wy(e)) / Math.LN2) + 1);
}
function De(e, t) {
  let n;
  if (t === void 0)
    for (const i of e)
      i != null && (n < i || n === void 0 && i >= i) && (n = i);
  else {
    let i = -1;
    for (let r of e)
      (r = t(r, ++i, e)) != null && (n < r || n === void 0 && r >= r) && (n = r);
  }
  return n;
}
function kz(e, t) {
  let n, i = -1, r = -1;
  if (t === void 0)
    for (const s of e)
      ++r, s != null && (n < s || n === void 0 && s >= s) && (n = s, i = r);
  else
    for (let s of e)
      (s = t(s, ++r, e)) != null && (n < s || n === void 0 && s >= s) && (n = s, i = r);
  return i;
}
function Ye(e, t) {
  let n;
  if (t === void 0)
    for (const i of e)
      i != null && (n > i || n === void 0 && i >= i) && (n = i);
  else {
    let i = -1;
    for (let r of e)
      (r = t(r, ++i, e)) != null && (n > r || n === void 0 && r >= r) && (n = r);
  }
  return n;
}
function Uz(e, t) {
  let n, i = -1, r = -1;
  if (t === void 0)
    for (const s of e)
      ++r, s != null && (n > s || n === void 0 && s >= s) && (n = s, i = r);
  else
    for (let s of e)
      (s = t(s, ++r, e)) != null && (n > s || n === void 0 && s >= s) && (n = s, i = r);
  return i;
}
function uM(e, t, n = 0, i = 1 / 0, r) {
  if (t = Math.floor(t), n = Math.floor(Math.max(0, n)), i = Math.floor(Math.min(e.length - 1, i)), !(n <= t && t <= i))
    return e;
  for (r = r === void 0 ? Du : zb(r); i > n; ) {
    if (i - n > 600) {
      const c = i - n + 1, l = t - n + 1, u = Math.log(c), f = 0.5 * Math.exp(2 * u / 3), h = 0.5 * Math.sqrt(u * f * (c - f) / c) * (l - c / 2 < 0 ? -1 : 1), d = Math.max(n, Math.floor(t - l * f / c + h)), p = Math.min(i, Math.floor(t + (c - l) * f / c + h));
      uM(e, t, d, p, r);
    }
    const s = e[t];
    let o = n, a = i;
    for (vl(e, n, t), r(e[i], s) > 0 && vl(e, n, i); o < a; ) {
      for (vl(e, o, a), ++o, --a; r(e[o], s) < 0; )
        ++o;
      for (; r(e[a], s) > 0; )
        --a;
    }
    r(e[n], s) === 0 ? vl(e, n, a) : (++a, vl(e, a, i)), a <= t && (n = a + 1), t <= a && (i = a - 1);
  }
  return e;
}
function vl(e, t, n) {
  const i = e[t];
  e[t] = e[n], e[n] = i;
}
function jb(e, t = me) {
  let n, i = !1;
  if (t.length === 1) {
    let r;
    for (const s of e) {
      const o = t(s);
      (i ? me(o, r) > 0 : me(o, o) === 0) && (n = s, r = o, i = !0);
    }
  } else
    for (const r of e)
      (i ? t(r, n) > 0 : t(r, r) === 0) && (n = r, i = !0);
  return n;
}
function Ws(e, t, n) {
  if (e = Float64Array.from(Sz(e, n)), !(!(i = e.length) || isNaN(t = +t))) {
    if (t <= 0 || i < 2)
      return Ye(e);
    if (t >= 1)
      return De(e);
    var i, r = (i - 1) * t, s = Math.floor(r), o = De(uM(e, s).subarray(0, s + 1)), a = Ye(e.subarray(s + 1));
    return o + (a - o) * (r - s);
  }
}
function zz(e, t, n = nM) {
  if (!(!(i = e.length) || isNaN(t = +t))) {
    if (t <= 0 || i < 2)
      return +n(e[0], 0, e);
    if (t >= 1)
      return +n(e[i - 1], i - 1, e);
    var i, r = (i - 1) * t, s = Math.floor(r), o = +n(e[s], s, e), a = +n(e[s + 1], s + 1, e);
    return o + (a - o) * (r - s);
  }
}
function Pz(e, t, n) {
  const i = Wy(e), r = Ws(e, 0.75) - Ws(e, 0.25);
  return i && r ? Math.ceil((n - t) / (2 * r * Math.pow(i, -1 / 3))) : 1;
}
function fM(e, t, n) {
  const i = Wy(e), r = gf(e);
  return i && r ? Math.ceil((n - t) * Math.cbrt(i) / (3.49 * r)) : 1;
}
function Gy(e, t) {
  let n = 0, i = 0;
  if (t === void 0)
    for (let r of e)
      r != null && (r = +r) >= r && (++n, i += r);
  else {
    let r = -1;
    for (let s of e)
      (s = t(s, ++r, e)) != null && (s = +s) >= s && (++n, i += s);
  }
  if (n)
    return i / n;
}
function Bu(e, t) {
  return Ws(e, 0.5, t);
}
function* Vz(e) {
  for (const t of e)
    yield* t;
}
function hM(e) {
  return Array.from(Vz(e));
}
function dM(e, t) {
  const n = new Jo();
  if (t === void 0)
    for (let s of e)
      s != null && s >= s && n.set(s, (n.get(s) || 0) + 1);
  else {
    let s = -1;
    for (let o of e)
      (o = t(o, ++s, e)) != null && o >= o && n.set(o, (n.get(o) || 0) + 1);
  }
  let i, r = 0;
  for (const [s, o] of n)
    o > r && (r = o, i = s);
  return i;
}
function jz(e, t = qz) {
  const n = [];
  let i, r = !1;
  for (const s of e)
    r && n.push(t(i, s)), i = s, r = !0;
  return n;
}
function qz(e, t) {
  return [e, t];
}
function kn(e, t, n) {
  e = +e, t = +t, n = (r = arguments.length) < 2 ? (t = e, e = 0, 1) : r < 3 ? 1 : +n;
  for (var i = -1, r = Math.max(0, Math.ceil((t - e) / n)) | 0, s = new Array(r); ++i < r; )
    s[i] = e + i * n;
  return s;
}
function pM(e, t = me) {
  if (typeof e[Symbol.iterator] != "function")
    throw new TypeError("values is not iterable");
  let n = Array.from(e);
  const i = new Float64Array(n.length);
  t.length !== 2 && (n = n.map(t), t = me);
  const r = (a, c) => t(n[a], n[c]);
  let s, o;
  return e = Uint32Array.from(n, (a, c) => c), e.sort(t === me ? (a, c) => Du(n[a], n[c]) : zb(r)), e.forEach((a, c) => {
    const l = r(a, s === void 0 ? a : s);
    l >= 0 ? ((s === void 0 || l > 0) && (s = a, o = c), i[a] = o) : i[a] = NaN;
  }), i;
}
function Yz(e, t = me) {
  let n, i = !1;
  if (t.length === 1) {
    let r;
    for (const s of e) {
      const o = t(s);
      (i ? me(o, r) < 0 : me(o, o) === 0) && (n = s, r = o, i = !0);
    }
  } else
    for (const r of e)
      (i ? t(r, n) < 0 : t(r, r) === 0) && (n = r, i = !0);
  return n;
}
function fr(e, t) {
  let n = 0;
  if (t === void 0)
    for (let i of e)
      (i = +i) && (n += i);
  else {
    let i = -1;
    for (let r of e)
      (r = +t(r, ++i, e)) && (n += r);
  }
  return n;
}
function Kd(e) {
  if (typeof e[Symbol.iterator] != "function")
    throw new TypeError("values is not iterable");
  return Array.from(e).reverse();
}
function Wz(e) {
  return e;
}
var sm = 1, om = 2, kg = 3, sh = 4, h2 = 1e-6;
function Gz(e) {
  return "translate(" + e + ",0)";
}
function Xz(e) {
  return "translate(0," + e + ")";
}
function Hz(e) {
  return (t) => +e(t);
}
function Jz(e, t) {
  return t = Math.max(0, e.bandwidth() - t * 2) / 2, e.round() && (t = Math.round(t)), (n) => +e(n) + t;
}
function Kz() {
  return !this.__axis;
}
function Zz(e, t) {
  var n = [], i = null, r = null, s = 6, o = 6, a = 3, c = typeof window < "u" && window.devicePixelRatio > 1 ? 0 : 0.5, l = e === sm || e === sh ? -1 : 1, u = e === sh || e === om ? "x" : "y", f = e === sm || e === kg ? Gz : Xz;
  function h(d) {
    var p = i ?? (t.ticks ? t.ticks.apply(t, n) : t.domain()), y = r ?? (t.tickFormat ? t.tickFormat.apply(t, n) : Wz), m = Math.max(s, 0) + a, g = t.range(), b = +g[0] + c, w = +g[g.length - 1] + c, v = (t.bandwidth ? Jz : Hz)(t.copy(), c), S = d.selection ? d.selection() : d, _ = S.selectAll(".domain").data([null]), I = S.selectAll(".tick").data(p, t).order(), T = I.exit(), M = I.enter().append("g").attr("class", "tick"), N = I.select("line"), A = I.select("text");
    _ = _.merge(_.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor")), I = I.merge(M), N = N.merge(M.append("line").attr("stroke", "currentColor").attr(u + "2", l * s)), A = A.merge(M.append("text").attr("fill", "currentColor").attr(u, l * m).attr("dy", e === sm ? "0em" : e === kg ? "0.71em" : "0.32em")), d !== S && (_ = _.transition(d), I = I.transition(d), N = N.transition(d), A = A.transition(d), T = T.transition(d).attr("opacity", h2).attr("transform", function(B) {
      return isFinite(B = v(B)) ? f(B + c) : this.getAttribute("transform");
    }), M.attr("opacity", h2).attr("transform", function(B) {
      var R = this.parentNode.__axis;
      return f((R && isFinite(R = R(B)) ? R : v(B)) + c);
    })), T.remove(), _.attr("d", e === sh || e === om ? o ? "M" + l * o + "," + b + "H" + c + "V" + w + "H" + l * o : "M" + c + "," + b + "V" + w : o ? "M" + b + "," + l * o + "V" + c + "H" + w + "V" + l * o : "M" + b + "," + c + "H" + w), I.attr("opacity", 1).attr("transform", function(B) {
      return f(v(B) + c);
    }), N.attr(u + "2", l * s), A.attr(u, l * m).text(y), S.filter(Kz).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", e === om ? "start" : e === sh ? "end" : "middle"), S.each(function() {
      this.__axis = v;
    });
  }
  return h.scale = function(d) {
    return arguments.length ? (t = d, h) : t;
  }, h.ticks = function() {
    return n = Array.from(arguments), h;
  }, h.tickArguments = function(d) {
    return arguments.length ? (n = d == null ? [] : Array.from(d), h) : n.slice();
  }, h.tickValues = function(d) {
    return arguments.length ? (i = d == null ? null : Array.from(d), h) : i && i.slice();
  }, h.tickFormat = function(d) {
    return arguments.length ? (r = d, h) : r;
  }, h.tickSize = function(d) {
    return arguments.length ? (s = o = +d, h) : s;
  }, h.tickSizeInner = function(d) {
    return arguments.length ? (s = +d, h) : s;
  }, h.tickSizeOuter = function(d) {
    return arguments.length ? (o = +d, h) : o;
  }, h.tickPadding = function(d) {
    return arguments.length ? (a = +d, h) : a;
  }, h.offset = function(d) {
    return arguments.length ? (c = +d, h) : c;
  }, h;
}
function Qz(e) {
  return Zz(kg, e);
}
var tP = { value: () => {
} };
function Xy() {
  for (var e = 0, t = arguments.length, n = {}, i; e < t; ++e) {
    if (!(i = arguments[e] + "") || i in n || /[\s.]/.test(i))
      throw new Error("illegal type: " + i);
    n[i] = [];
  }
  return new Zh(n);
}
function Zh(e) {
  this._ = e;
}
function eP(e, t) {
  return e.trim().split(/^|\s+/).map(function(n) {
    var i = "", r = n.indexOf(".");
    if (r >= 0 && (i = n.slice(r + 1), n = n.slice(0, r)), n && !t.hasOwnProperty(n))
      throw new Error("unknown type: " + n);
    return { type: n, name: i };
  });
}
Zh.prototype = Xy.prototype = {
  constructor: Zh,
  on: function(e, t) {
    var n = this._, i = eP(e + "", n), r, s = -1, o = i.length;
    if (arguments.length < 2) {
      for (; ++s < o; )
        if ((r = (e = i[s]).type) && (r = nP(n[r], e.name)))
          return r;
      return;
    }
    if (t != null && typeof t != "function")
      throw new Error("invalid callback: " + t);
    for (; ++s < o; )
      if (r = (e = i[s]).type)
        n[r] = d2(n[r], e.name, t);
      else if (t == null)
        for (r in n)
          n[r] = d2(n[r], e.name, null);
    return this;
  },
  copy: function() {
    var e = {}, t = this._;
    for (var n in t)
      e[n] = t[n].slice();
    return new Zh(e);
  },
  call: function(e, t) {
    if ((r = arguments.length - 2) > 0)
      for (var n = new Array(r), i = 0, r, s; i < r; ++i)
        n[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(e))
      throw new Error("unknown type: " + e);
    for (s = this._[e], i = 0, r = s.length; i < r; ++i)
      s[i].value.apply(t, n);
  },
  apply: function(e, t, n) {
    if (!this._.hasOwnProperty(e))
      throw new Error("unknown type: " + e);
    for (var i = this._[e], r = 0, s = i.length; r < s; ++r)
      i[r].value.apply(t, n);
  }
};
function nP(e, t) {
  for (var n = 0, i = e.length, r; n < i; ++n)
    if ((r = e[n]).name === t)
      return r.value;
}
function d2(e, t, n) {
  for (var i = 0, r = e.length; i < r; ++i)
    if (e[i].name === t) {
      e[i] = tP, e = e.slice(0, i).concat(e.slice(i + 1));
      break;
    }
  return n != null && e.push({ name: t, value: n }), e;
}
var Ug = "http://www.w3.org/1999/xhtml";
const Ko = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: Ug,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function Hy(e) {
  var t = e += "", n = t.indexOf(":");
  return n >= 0 && (t = e.slice(0, n)) !== "xmlns" && (e = e.slice(n + 1)), Ko.hasOwnProperty(t) ? { space: Ko[t], local: e } : e;
}
function iP(e) {
  return function() {
    var t = this.ownerDocument, n = this.namespaceURI;
    return n === Ug && t.documentElement.namespaceURI === Ug ? t.createElement(e) : t.createElementNS(n, e);
  };
}
function rP(e) {
  return function() {
    return this.ownerDocument.createElementNS(e.space, e.local);
  };
}
function Jy(e) {
  var t = Hy(e);
  return (t.local ? rP : iP)(t);
}
function sP() {
}
function qb(e) {
  return e == null ? sP : function() {
    return this.querySelector(e);
  };
}
function oP(e) {
  typeof e != "function" && (e = qb(e));
  for (var t = this._groups, n = t.length, i = new Array(n), r = 0; r < n; ++r)
    for (var s = t[r], o = s.length, a = i[r] = new Array(o), c, l, u = 0; u < o; ++u)
      (c = s[u]) && (l = e.call(c, c.__data__, u, s)) && ("__data__" in c && (l.__data__ = c.__data__), a[u] = l);
  return new Pn(i, this._parents);
}
function aP(e) {
  return e == null ? [] : Array.isArray(e) ? e : Array.from(e);
}
function cP() {
  return [];
}
function yM(e) {
  return e == null ? cP : function() {
    return this.querySelectorAll(e);
  };
}
function lP(e) {
  return function() {
    return aP(e.apply(this, arguments));
  };
}
function uP(e) {
  typeof e == "function" ? e = lP(e) : e = yM(e);
  for (var t = this._groups, n = t.length, i = [], r = [], s = 0; s < n; ++s)
    for (var o = t[s], a = o.length, c, l = 0; l < a; ++l)
      (c = o[l]) && (i.push(e.call(c, c.__data__, l, o)), r.push(c));
  return new Pn(i, r);
}
function mM(e) {
  return function() {
    return this.matches(e);
  };
}
function gM(e) {
  return function(t) {
    return t.matches(e);
  };
}
var fP = Array.prototype.find;
function hP(e) {
  return function() {
    return fP.call(this.children, e);
  };
}
function dP() {
  return this.firstElementChild;
}
function pP(e) {
  return this.select(e == null ? dP : hP(typeof e == "function" ? e : gM(e)));
}
var yP = Array.prototype.filter;
function mP() {
  return Array.from(this.children);
}
function gP(e) {
  return function() {
    return yP.call(this.children, e);
  };
}
function bP(e) {
  return this.selectAll(e == null ? mP : gP(typeof e == "function" ? e : gM(e)));
}
function wP(e) {
  typeof e != "function" && (e = mM(e));
  for (var t = this._groups, n = t.length, i = new Array(n), r = 0; r < n; ++r)
    for (var s = t[r], o = s.length, a = i[r] = [], c, l = 0; l < o; ++l)
      (c = s[l]) && e.call(c, c.__data__, l, s) && a.push(c);
  return new Pn(i, this._parents);
}
function bM(e) {
  return new Array(e.length);
}
function vP() {
  return new Pn(this._enter || this._groups.map(bM), this._parents);
}
function Zd(e, t) {
  this.ownerDocument = e.ownerDocument, this.namespaceURI = e.namespaceURI, this._next = null, this._parent = e, this.__data__ = t;
}
Zd.prototype = {
  constructor: Zd,
  appendChild: function(e) {
    return this._parent.insertBefore(e, this._next);
  },
  insertBefore: function(e, t) {
    return this._parent.insertBefore(e, t);
  },
  querySelector: function(e) {
    return this._parent.querySelector(e);
  },
  querySelectorAll: function(e) {
    return this._parent.querySelectorAll(e);
  }
};
function _P(e) {
  return function() {
    return e;
  };
}
function SP(e, t, n, i, r, s) {
  for (var o = 0, a, c = t.length, l = s.length; o < l; ++o)
    (a = t[o]) ? (a.__data__ = s[o], i[o] = a) : n[o] = new Zd(e, s[o]);
  for (; o < c; ++o)
    (a = t[o]) && (r[o] = a);
}
function xP(e, t, n, i, r, s, o) {
  var a, c, l = /* @__PURE__ */ new Map(), u = t.length, f = s.length, h = new Array(u), d;
  for (a = 0; a < u; ++a)
    (c = t[a]) && (h[a] = d = o.call(c, c.__data__, a, t) + "", l.has(d) ? r[a] = c : l.set(d, c));
  for (a = 0; a < f; ++a)
    d = o.call(e, s[a], a, s) + "", (c = l.get(d)) ? (i[a] = c, c.__data__ = s[a], l.delete(d)) : n[a] = new Zd(e, s[a]);
  for (a = 0; a < u; ++a)
    (c = t[a]) && l.get(h[a]) === c && (r[a] = c);
}
function IP(e) {
  return e.__data__;
}
function AP(e, t) {
  if (!arguments.length)
    return Array.from(this, IP);
  var n = t ? xP : SP, i = this._parents, r = this._groups;
  typeof e != "function" && (e = _P(e));
  for (var s = r.length, o = new Array(s), a = new Array(s), c = new Array(s), l = 0; l < s; ++l) {
    var u = i[l], f = r[l], h = f.length, d = MP(e.call(u, u && u.__data__, l, i)), p = d.length, y = a[l] = new Array(p), m = o[l] = new Array(p), g = c[l] = new Array(h);
    n(u, f, y, m, g, d, t);
    for (var b = 0, w = 0, v, S; b < p; ++b)
      if (v = y[b]) {
        for (b >= w && (w = b + 1); !(S = m[w]) && ++w < p; )
          ;
        v._next = S || null;
      }
  }
  return o = new Pn(o, i), o._enter = a, o._exit = c, o;
}
function MP(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function $P() {
  return new Pn(this._exit || this._groups.map(bM), this._parents);
}
function TP(e, t, n) {
  var i = this.enter(), r = this, s = this.exit();
  return typeof e == "function" ? (i = e(i), i && (i = i.selection())) : i = i.append(e + ""), t != null && (r = t(r), r && (r = r.selection())), n == null ? s.remove() : n(s), i && r ? i.merge(r).order() : r;
}
function DP(e) {
  for (var t = e.selection ? e.selection() : e, n = this._groups, i = t._groups, r = n.length, s = i.length, o = Math.min(r, s), a = new Array(r), c = 0; c < o; ++c)
    for (var l = n[c], u = i[c], f = l.length, h = a[c] = new Array(f), d, p = 0; p < f; ++p)
      (d = l[p] || u[p]) && (h[p] = d);
  for (; c < r; ++c)
    a[c] = n[c];
  return new Pn(a, this._parents);
}
function NP() {
  for (var e = this._groups, t = -1, n = e.length; ++t < n; )
    for (var i = e[t], r = i.length - 1, s = i[r], o; --r >= 0; )
      (o = i[r]) && (s && o.compareDocumentPosition(s) ^ 4 && s.parentNode.insertBefore(o, s), s = o);
  return this;
}
function BP(e) {
  e || (e = OP);
  function t(f, h) {
    return f && h ? e(f.__data__, h.__data__) : !f - !h;
  }
  for (var n = this._groups, i = n.length, r = new Array(i), s = 0; s < i; ++s) {
    for (var o = n[s], a = o.length, c = r[s] = new Array(a), l, u = 0; u < a; ++u)
      (l = o[u]) && (c[u] = l);
    c.sort(t);
  }
  return new Pn(r, this._parents).order();
}
function OP(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function FP() {
  var e = arguments[0];
  return arguments[0] = this, e.apply(null, arguments), this;
}
function EP() {
  return Array.from(this);
}
function LP() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var i = e[t], r = 0, s = i.length; r < s; ++r) {
      var o = i[r];
      if (o)
        return o;
    }
  return null;
}
function RP() {
  let e = 0;
  for (const t of this)
    ++e;
  return e;
}
function CP() {
  return !this.node();
}
function kP(e) {
  for (var t = this._groups, n = 0, i = t.length; n < i; ++n)
    for (var r = t[n], s = 0, o = r.length, a; s < o; ++s)
      (a = r[s]) && e.call(a, a.__data__, s, r);
  return this;
}
function UP(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function zP(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function PP(e, t) {
  return function() {
    this.setAttribute(e, t);
  };
}
function VP(e, t) {
  return function() {
    this.setAttributeNS(e.space, e.local, t);
  };
}
function jP(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttribute(e) : this.setAttribute(e, n);
  };
}
function qP(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, n);
  };
}
function YP(e, t) {
  var n = Hy(e);
  if (arguments.length < 2) {
    var i = this.node();
    return n.local ? i.getAttributeNS(n.space, n.local) : i.getAttribute(n);
  }
  return this.each((t == null ? n.local ? zP : UP : typeof t == "function" ? n.local ? qP : jP : n.local ? VP : PP)(n, t));
}
function wM(e) {
  return e.ownerDocument && e.ownerDocument.defaultView || e.document && e || e.defaultView;
}
function WP(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function GP(e, t, n) {
  return function() {
    this.style.setProperty(e, t, n);
  };
}
function XP(e, t, n) {
  return function() {
    var i = t.apply(this, arguments);
    i == null ? this.style.removeProperty(e) : this.style.setProperty(e, i, n);
  };
}
function HP(e, t, n) {
  return arguments.length > 1 ? this.each((t == null ? WP : typeof t == "function" ? XP : GP)(e, t, n ?? "")) : Dc(this.node(), e);
}
function Dc(e, t) {
  return e.style.getPropertyValue(t) || wM(e).getComputedStyle(e, null).getPropertyValue(t);
}
function JP(e) {
  return function() {
    delete this[e];
  };
}
function KP(e, t) {
  return function() {
    this[e] = t;
  };
}
function ZP(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? delete this[e] : this[e] = n;
  };
}
function QP(e, t) {
  return arguments.length > 1 ? this.each((t == null ? JP : typeof t == "function" ? ZP : KP)(e, t)) : this.node()[e];
}
function vM(e) {
  return e.trim().split(/^|\s+/);
}
function Yb(e) {
  return e.classList || new _M(e);
}
function _M(e) {
  this._node = e, this._names = vM(e.getAttribute("class") || "");
}
_M.prototype = {
  add: function(e) {
    var t = this._names.indexOf(e);
    t < 0 && (this._names.push(e), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(e) {
    var t = this._names.indexOf(e);
    t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(e) {
    return this._names.indexOf(e) >= 0;
  }
};
function SM(e, t) {
  for (var n = Yb(e), i = -1, r = t.length; ++i < r; )
    n.add(t[i]);
}
function xM(e, t) {
  for (var n = Yb(e), i = -1, r = t.length; ++i < r; )
    n.remove(t[i]);
}
function tV(e) {
  return function() {
    SM(this, e);
  };
}
function eV(e) {
  return function() {
    xM(this, e);
  };
}
function nV(e, t) {
  return function() {
    (t.apply(this, arguments) ? SM : xM)(this, e);
  };
}
function iV(e, t) {
  var n = vM(e + "");
  if (arguments.length < 2) {
    for (var i = Yb(this.node()), r = -1, s = n.length; ++r < s; )
      if (!i.contains(n[r]))
        return !1;
    return !0;
  }
  return this.each((typeof t == "function" ? nV : t ? tV : eV)(n, t));
}
function rV() {
  this.textContent = "";
}
function sV(e) {
  return function() {
    this.textContent = e;
  };
}
function oV(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.textContent = t ?? "";
  };
}
function aV(e) {
  return arguments.length ? this.each(e == null ? rV : (typeof e == "function" ? oV : sV)(e)) : this.node().textContent;
}
function cV() {
  this.innerHTML = "";
}
function lV(e) {
  return function() {
    this.innerHTML = e;
  };
}
function uV(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.innerHTML = t ?? "";
  };
}
function fV(e) {
  return arguments.length ? this.each(e == null ? cV : (typeof e == "function" ? uV : lV)(e)) : this.node().innerHTML;
}
function hV() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function dV() {
  return this.each(hV);
}
function pV() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function yV() {
  return this.each(pV);
}
function mV(e) {
  var t = typeof e == "function" ? e : Jy(e);
  return this.select(function() {
    return this.appendChild(t.apply(this, arguments));
  });
}
function gV() {
  return null;
}
function bV(e, t) {
  var n = typeof e == "function" ? e : Jy(e), i = t == null ? gV : typeof t == "function" ? t : qb(t);
  return this.select(function() {
    return this.insertBefore(n.apply(this, arguments), i.apply(this, arguments) || null);
  });
}
function wV() {
  var e = this.parentNode;
  e && e.removeChild(this);
}
function vV() {
  return this.each(wV);
}
function _V() {
  var e = this.cloneNode(!1), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function SV() {
  var e = this.cloneNode(!0), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function xV(e) {
  return this.select(e ? SV : _V);
}
function IV(e) {
  return arguments.length ? this.property("__data__", e) : this.node().__data__;
}
function AV(e) {
  return function(t) {
    e.call(this, t, this.__data__);
  };
}
function MV(e) {
  return e.trim().split(/^|\s+/).map(function(t) {
    var n = "", i = t.indexOf(".");
    return i >= 0 && (n = t.slice(i + 1), t = t.slice(0, i)), { type: t, name: n };
  });
}
function $V(e) {
  return function() {
    var t = this.__on;
    if (t) {
      for (var n = 0, i = -1, r = t.length, s; n < r; ++n)
        s = t[n], (!e.type || s.type === e.type) && s.name === e.name ? this.removeEventListener(s.type, s.listener, s.options) : t[++i] = s;
      ++i ? t.length = i : delete this.__on;
    }
  };
}
function TV(e, t, n) {
  return function() {
    var i = this.__on, r, s = AV(t);
    if (i) {
      for (var o = 0, a = i.length; o < a; ++o)
        if ((r = i[o]).type === e.type && r.name === e.name) {
          this.removeEventListener(r.type, r.listener, r.options), this.addEventListener(r.type, r.listener = s, r.options = n), r.value = t;
          return;
        }
    }
    this.addEventListener(e.type, s, n), r = { type: e.type, name: e.name, value: t, listener: s, options: n }, i ? i.push(r) : this.__on = [r];
  };
}
function DV(e, t, n) {
  var i = MV(e + ""), r, s = i.length, o;
  if (arguments.length < 2) {
    var a = this.node().__on;
    if (a) {
      for (var c = 0, l = a.length, u; c < l; ++c)
        for (r = 0, u = a[c]; r < s; ++r)
          if ((o = i[r]).type === u.type && o.name === u.name)
            return u.value;
    }
    return;
  }
  for (a = t ? TV : $V, r = 0; r < s; ++r)
    this.each(a(i[r], t, n));
  return this;
}
function IM(e, t, n) {
  var i = wM(e), r = i.CustomEvent;
  typeof r == "function" ? r = new r(t, n) : (r = i.document.createEvent("Event"), n ? (r.initEvent(t, n.bubbles, n.cancelable), r.detail = n.detail) : r.initEvent(t, !1, !1)), e.dispatchEvent(r);
}
function NV(e, t) {
  return function() {
    return IM(this, e, t);
  };
}
function BV(e, t) {
  return function() {
    return IM(this, e, t.apply(this, arguments));
  };
}
function OV(e, t) {
  return this.each((typeof t == "function" ? BV : NV)(e, t));
}
function* FV() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var i = e[t], r = 0, s = i.length, o; r < s; ++r)
      (o = i[r]) && (yield o);
}
var AM = [null];
function Pn(e, t) {
  this._groups = e, this._parents = t;
}
function bf() {
  return new Pn([[document.documentElement]], AM);
}
function EV() {
  return this;
}
Pn.prototype = bf.prototype = {
  constructor: Pn,
  select: oP,
  selectAll: uP,
  selectChild: pP,
  selectChildren: bP,
  filter: wP,
  data: AP,
  enter: vP,
  exit: $P,
  join: TP,
  merge: DP,
  selection: EV,
  order: NP,
  sort: BP,
  call: FP,
  nodes: EP,
  node: LP,
  size: RP,
  empty: CP,
  each: kP,
  attr: YP,
  style: HP,
  property: QP,
  classed: iV,
  text: aV,
  html: fV,
  raise: dV,
  lower: yV,
  append: mV,
  insert: bV,
  remove: vV,
  clone: xV,
  datum: IV,
  on: DV,
  dispatch: OV,
  [Symbol.iterator]: FV
};
function ce(e) {
  return typeof e == "string" ? new Pn([[document.querySelector(e)]], [document.documentElement]) : new Pn([[e]], AM);
}
function LV(e) {
  let t;
  for (; t = e.sourceEvent; )
    e = t;
  return e;
}
function mi(e, t) {
  if (e = LV(e), t === void 0 && (t = e.currentTarget), t) {
    var n = t.ownerSVGElement || t;
    if (n.createSVGPoint) {
      var i = n.createSVGPoint();
      return i.x = e.clientX, i.y = e.clientY, i = i.matrixTransform(t.getScreenCTM().inverse()), [i.x, i.y];
    }
    if (t.getBoundingClientRect) {
      var r = t.getBoundingClientRect();
      return [e.clientX - r.left - t.clientLeft, e.clientY - r.top - t.clientTop];
    }
  }
  return [e.pageX, e.pageY];
}
const zg = { capture: !0, passive: !1 };
function Pg(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
function MM(e) {
  var t = e.document.documentElement, n = ce(e).on("dragstart.drag", Pg, zg);
  "onselectstart" in t ? n.on("selectstart.drag", Pg, zg) : (t.__noselect = t.style.MozUserSelect, t.style.MozUserSelect = "none");
}
function $M(e, t) {
  var n = e.document.documentElement, i = ce(e).on("dragstart.drag", null);
  t && (i.on("click.drag", Pg, zg), setTimeout(function() {
    i.on("click.drag", null);
  }, 0)), "onselectstart" in n ? i.on("selectstart.drag", null) : (n.style.MozUserSelect = n.__noselect, delete n.__noselect);
}
function nl(e, t, n) {
  e.prototype = t.prototype = n, n.constructor = e;
}
function wf(e, t) {
  var n = Object.create(e.prototype);
  for (var i in t)
    n[i] = t[i];
  return n;
}
function so() {
}
var Zo = 0.7, Nc = 1 / Zo, fc = "\\s*([+-]?\\d+)\\s*", Ou = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", or = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", RV = /^#([0-9a-f]{3,8})$/, CV = new RegExp(`^rgb\\(${fc},${fc},${fc}\\)$`), kV = new RegExp(`^rgb\\(${or},${or},${or}\\)$`), UV = new RegExp(`^rgba\\(${fc},${fc},${fc},${Ou}\\)$`), zV = new RegExp(`^rgba\\(${or},${or},${or},${Ou}\\)$`), PV = new RegExp(`^hsl\\(${Ou},${or},${or}\\)$`), VV = new RegExp(`^hsla\\(${Ou},${or},${or},${Ou}\\)$`), p2 = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
nl(so, Gs, {
  copy(e) {
    return Object.assign(new this.constructor(), this, e);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: y2,
  // Deprecated! Use color.formatHex.
  formatHex: y2,
  formatHex8: jV,
  formatHsl: qV,
  formatRgb: m2,
  toString: m2
});
function y2() {
  return this.rgb().formatHex();
}
function jV() {
  return this.rgb().formatHex8();
}
function qV() {
  return TM(this).formatHsl();
}
function m2() {
  return this.rgb().formatRgb();
}
function Gs(e) {
  var t, n;
  return e = (e + "").trim().toLowerCase(), (t = RV.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? g2(t) : n === 3 ? new qe(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? oh(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? oh(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = CV.exec(e)) ? new qe(t[1], t[2], t[3], 1) : (t = kV.exec(e)) ? new qe(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = UV.exec(e)) ? oh(t[1], t[2], t[3], t[4]) : (t = zV.exec(e)) ? oh(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = PV.exec(e)) ? v2(t[1], t[2] / 100, t[3] / 100, 1) : (t = VV.exec(e)) ? v2(t[1], t[2] / 100, t[3] / 100, t[4]) : p2.hasOwnProperty(e) ? g2(p2[e]) : e === "transparent" ? new qe(NaN, NaN, NaN, 0) : null;
}
function g2(e) {
  return new qe(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
}
function oh(e, t, n, i) {
  return i <= 0 && (e = t = n = NaN), new qe(e, t, n, i);
}
function Wb(e) {
  return e instanceof so || (e = Gs(e)), e ? (e = e.rgb(), new qe(e.r, e.g, e.b, e.opacity)) : new qe();
}
function Vn(e, t, n, i) {
  return arguments.length === 1 ? Wb(e) : new qe(e, t, n, i ?? 1);
}
function qe(e, t, n, i) {
  this.r = +e, this.g = +t, this.b = +n, this.opacity = +i;
}
nl(qe, Vn, wf(so, {
  brighter(e) {
    return e = e == null ? Nc : Math.pow(Nc, e), new qe(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? Zo : Math.pow(Zo, e), new qe(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new qe(Po(this.r), Po(this.g), Po(this.b), Qd(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: b2,
  // Deprecated! Use color.formatHex.
  formatHex: b2,
  formatHex8: YV,
  formatRgb: w2,
  toString: w2
}));
function b2() {
  return `#${Fo(this.r)}${Fo(this.g)}${Fo(this.b)}`;
}
function YV() {
  return `#${Fo(this.r)}${Fo(this.g)}${Fo(this.b)}${Fo((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function w2() {
  const e = Qd(this.opacity);
  return `${e === 1 ? "rgb(" : "rgba("}${Po(this.r)}, ${Po(this.g)}, ${Po(this.b)}${e === 1 ? ")" : `, ${e})`}`;
}
function Qd(e) {
  return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
}
function Po(e) {
  return Math.max(0, Math.min(255, Math.round(e) || 0));
}
function Fo(e) {
  return e = Po(e), (e < 16 ? "0" : "") + e.toString(16);
}
function v2(e, t, n, i) {
  return i <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new vi(e, t, n, i);
}
function TM(e) {
  if (e instanceof vi)
    return new vi(e.h, e.s, e.l, e.opacity);
  if (e instanceof so || (e = Gs(e)), !e)
    return new vi();
  if (e instanceof vi)
    return e;
  e = e.rgb();
  var t = e.r / 255, n = e.g / 255, i = e.b / 255, r = Math.min(t, n, i), s = Math.max(t, n, i), o = NaN, a = s - r, c = (s + r) / 2;
  return a ? (t === s ? o = (n - i) / a + (n < i) * 6 : n === s ? o = (i - t) / a + 2 : o = (t - n) / a + 4, a /= c < 0.5 ? s + r : 2 - s - r, o *= 60) : a = c > 0 && c < 1 ? 0 : o, new vi(o, a, c, e.opacity);
}
function Vg(e, t, n, i) {
  return arguments.length === 1 ? TM(e) : new vi(e, t, n, i ?? 1);
}
function vi(e, t, n, i) {
  this.h = +e, this.s = +t, this.l = +n, this.opacity = +i;
}
nl(vi, Vg, wf(so, {
  brighter(e) {
    return e = e == null ? Nc : Math.pow(Nc, e), new vi(this.h, this.s, this.l * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? Zo : Math.pow(Zo, e), new vi(this.h, this.s, this.l * e, this.opacity);
  },
  rgb() {
    var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, n = this.l, i = n + (n < 0.5 ? n : 1 - n) * t, r = 2 * n - i;
    return new qe(
      am(e >= 240 ? e - 240 : e + 120, r, i),
      am(e, r, i),
      am(e < 120 ? e + 240 : e - 120, r, i),
      this.opacity
    );
  },
  clamp() {
    return new vi(_2(this.h), ah(this.s), ah(this.l), Qd(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const e = Qd(this.opacity);
    return `${e === 1 ? "hsl(" : "hsla("}${_2(this.h)}, ${ah(this.s) * 100}%, ${ah(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
  }
}));
function _2(e) {
  return e = (e || 0) % 360, e < 0 ? e + 360 : e;
}
function ah(e) {
  return Math.max(0, Math.min(1, e || 0));
}
function am(e, t, n) {
  return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255;
}
const DM = Math.PI / 180, NM = 180 / Math.PI, tp = 18, BM = 0.96422, OM = 1, FM = 0.82521, EM = 4 / 29, hc = 6 / 29, LM = 3 * hc * hc, WV = hc * hc * hc;
function RM(e) {
  if (e instanceof ar)
    return new ar(e.l, e.a, e.b, e.opacity);
  if (e instanceof Gr)
    return CM(e);
  e instanceof qe || (e = Wb(e));
  var t = fm(e.r), n = fm(e.g), i = fm(e.b), r = cm((0.2225045 * t + 0.7168786 * n + 0.0606169 * i) / OM), s, o;
  return t === n && n === i ? s = o = r : (s = cm((0.4360747 * t + 0.3850649 * n + 0.1430804 * i) / BM), o = cm((0.0139322 * t + 0.0971045 * n + 0.7141733 * i) / FM)), new ar(116 * r - 16, 500 * (s - r), 200 * (r - o), e.opacity);
}
function jg(e, t, n, i) {
  return arguments.length === 1 ? RM(e) : new ar(e, t, n, i ?? 1);
}
function ar(e, t, n, i) {
  this.l = +e, this.a = +t, this.b = +n, this.opacity = +i;
}
nl(ar, jg, wf(so, {
  brighter(e) {
    return new ar(this.l + tp * (e ?? 1), this.a, this.b, this.opacity);
  },
  darker(e) {
    return new ar(this.l - tp * (e ?? 1), this.a, this.b, this.opacity);
  },
  rgb() {
    var e = (this.l + 16) / 116, t = isNaN(this.a) ? e : e + this.a / 500, n = isNaN(this.b) ? e : e - this.b / 200;
    return t = BM * lm(t), e = OM * lm(e), n = FM * lm(n), new qe(
      um(3.1338561 * t - 1.6168667 * e - 0.4906146 * n),
      um(-0.9787684 * t + 1.9161415 * e + 0.033454 * n),
      um(0.0719453 * t - 0.2289914 * e + 1.4052427 * n),
      this.opacity
    );
  }
}));
function cm(e) {
  return e > WV ? Math.pow(e, 1 / 3) : e / LM + EM;
}
function lm(e) {
  return e > hc ? e * e * e : LM * (e - EM);
}
function um(e) {
  return 255 * (e <= 31308e-7 ? 12.92 * e : 1.055 * Math.pow(e, 1 / 2.4) - 0.055);
}
function fm(e) {
  return (e /= 255) <= 0.04045 ? e / 12.92 : Math.pow((e + 0.055) / 1.055, 2.4);
}
function GV(e) {
  if (e instanceof Gr)
    return new Gr(e.h, e.c, e.l, e.opacity);
  if (e instanceof ar || (e = RM(e)), e.a === 0 && e.b === 0)
    return new Gr(NaN, 0 < e.l && e.l < 100 ? 0 : NaN, e.l, e.opacity);
  var t = Math.atan2(e.b, e.a) * NM;
  return new Gr(t < 0 ? t + 360 : t, Math.sqrt(e.a * e.a + e.b * e.b), e.l, e.opacity);
}
function qg(e, t, n, i) {
  return arguments.length === 1 ? GV(e) : new Gr(e, t, n, i ?? 1);
}
function Gr(e, t, n, i) {
  this.h = +e, this.c = +t, this.l = +n, this.opacity = +i;
}
function CM(e) {
  if (isNaN(e.h))
    return new ar(e.l, 0, 0, e.opacity);
  var t = e.h * DM;
  return new ar(e.l, Math.cos(t) * e.c, Math.sin(t) * e.c, e.opacity);
}
nl(Gr, qg, wf(so, {
  brighter(e) {
    return new Gr(this.h, this.c, this.l + tp * (e ?? 1), this.opacity);
  },
  darker(e) {
    return new Gr(this.h, this.c, this.l - tp * (e ?? 1), this.opacity);
  },
  rgb() {
    return CM(this).rgb();
  }
}));
var kM = -0.14861, Gb = 1.78277, Xb = -0.29227, Ky = -0.90649, Fu = 1.97294, S2 = Fu * Ky, x2 = Fu * Gb, I2 = Gb * Xb - Ky * kM;
function XV(e) {
  if (e instanceof Vo)
    return new Vo(e.h, e.s, e.l, e.opacity);
  e instanceof qe || (e = Wb(e));
  var t = e.r / 255, n = e.g / 255, i = e.b / 255, r = (I2 * i + S2 * t - x2 * n) / (I2 + S2 - x2), s = i - r, o = (Fu * (n - r) - Xb * s) / Ky, a = Math.sqrt(o * o + s * s) / (Fu * r * (1 - r)), c = a ? Math.atan2(o, s) * NM - 120 : NaN;
  return new Vo(c < 0 ? c + 360 : c, a, r, e.opacity);
}
function hr(e, t, n, i) {
  return arguments.length === 1 ? XV(e) : new Vo(e, t, n, i ?? 1);
}
function Vo(e, t, n, i) {
  this.h = +e, this.s = +t, this.l = +n, this.opacity = +i;
}
nl(Vo, hr, wf(so, {
  brighter(e) {
    return e = e == null ? Nc : Math.pow(Nc, e), new Vo(this.h, this.s, this.l * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? Zo : Math.pow(Zo, e), new Vo(this.h, this.s, this.l * e, this.opacity);
  },
  rgb() {
    var e = isNaN(this.h) ? 0 : (this.h + 120) * DM, t = +this.l, n = isNaN(this.s) ? 0 : this.s * t * (1 - t), i = Math.cos(e), r = Math.sin(e);
    return new qe(
      255 * (t + n * (kM * i + Gb * r)),
      255 * (t + n * (Xb * i + Ky * r)),
      255 * (t + n * (Fu * i)),
      this.opacity
    );
  }
}));
function HV(e, t, n, i, r) {
  var s = e * e, o = s * e;
  return ((1 - 3 * e + 3 * s - o) * t + (4 - 6 * s + 3 * o) * n + (1 + 3 * e + 3 * s - 3 * o) * i + o * r) / 6;
}
function JV(e) {
  var t = e.length - 1;
  return function(n) {
    var i = n <= 0 ? n = 0 : n >= 1 ? (n = 1, t - 1) : Math.floor(n * t), r = e[i], s = e[i + 1], o = i > 0 ? e[i - 1] : 2 * r - s, a = i < t - 1 ? e[i + 2] : 2 * s - r;
    return HV((n - i / t) * t, o, r, s, a);
  };
}
const Zy = (e) => () => e;
function UM(e, t) {
  return function(n) {
    return e + n * t;
  };
}
function KV(e, t, n) {
  return e = Math.pow(e, n), t = Math.pow(t, n) - e, n = 1 / n, function(i) {
    return Math.pow(e + i * t, n);
  };
}
function Hb(e, t) {
  var n = t - e;
  return n ? UM(e, n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n) : Zy(isNaN(e) ? t : e);
}
function ZV(e) {
  return (e = +e) == 1 ? en : function(t, n) {
    return n - t ? KV(t, n, e) : Zy(isNaN(t) ? n : t);
  };
}
function en(e, t) {
  var n = t - e;
  return n ? UM(e, n) : Zy(isNaN(e) ? t : e);
}
const Qo = function e(t) {
  var n = ZV(t);
  function i(r, s) {
    var o = n((r = Vn(r)).r, (s = Vn(s)).r), a = n(r.g, s.g), c = n(r.b, s.b), l = en(r.opacity, s.opacity);
    return function(u) {
      return r.r = o(u), r.g = a(u), r.b = c(u), r.opacity = l(u), r + "";
    };
  }
  return i.gamma = e, i;
}(1);
function QV(e) {
  return function(t) {
    var n = t.length, i = new Array(n), r = new Array(n), s = new Array(n), o, a;
    for (o = 0; o < n; ++o)
      a = Vn(t[o]), i[o] = a.r || 0, r[o] = a.g || 0, s[o] = a.b || 0;
    return i = e(i), r = e(r), s = e(s), a.opacity = 1, function(c) {
      return a.r = i(c), a.g = r(c), a.b = s(c), a + "";
    };
  };
}
var tj = QV(JV);
function ej(e, t) {
  t || (t = []);
  var n = e ? Math.min(t.length, e.length) : 0, i = t.slice(), r;
  return function(s) {
    for (r = 0; r < n; ++r)
      i[r] = e[r] * (1 - s) + t[r] * s;
    return i;
  };
}
function nj(e) {
  return ArrayBuffer.isView(e) && !(e instanceof DataView);
}
function ij(e, t) {
  var n = t ? t.length : 0, i = e ? Math.min(n, e.length) : 0, r = new Array(i), s = new Array(n), o;
  for (o = 0; o < i; ++o)
    r[o] = il(e[o], t[o]);
  for (; o < n; ++o)
    s[o] = t[o];
  return function(a) {
    for (o = 0; o < i; ++o)
      s[o] = r[o](a);
    return s;
  };
}
function rj(e, t) {
  var n = /* @__PURE__ */ new Date();
  return e = +e, t = +t, function(i) {
    return n.setTime(e * (1 - i) + t * i), n;
  };
}
function Qe(e, t) {
  return e = +e, t = +t, function(n) {
    return e * (1 - n) + t * n;
  };
}
function sj(e, t) {
  var n = {}, i = {}, r;
  (e === null || typeof e != "object") && (e = {}), (t === null || typeof t != "object") && (t = {});
  for (r in t)
    r in e ? n[r] = il(e[r], t[r]) : i[r] = t[r];
  return function(s) {
    for (r in n)
      i[r] = n[r](s);
    return i;
  };
}
var Yg = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, hm = new RegExp(Yg.source, "g");
function oj(e) {
  return function() {
    return e;
  };
}
function aj(e) {
  return function(t) {
    return e(t) + "";
  };
}
function zM(e, t) {
  var n = Yg.lastIndex = hm.lastIndex = 0, i, r, s, o = -1, a = [], c = [];
  for (e = e + "", t = t + ""; (i = Yg.exec(e)) && (r = hm.exec(t)); )
    (s = r.index) > n && (s = t.slice(n, s), a[o] ? a[o] += s : a[++o] = s), (i = i[0]) === (r = r[0]) ? a[o] ? a[o] += r : a[++o] = r : (a[++o] = null, c.push({ i: o, x: Qe(i, r) })), n = hm.lastIndex;
  return n < t.length && (s = t.slice(n), a[o] ? a[o] += s : a[++o] = s), a.length < 2 ? c[0] ? aj(c[0].x) : oj(t) : (t = c.length, function(l) {
    for (var u = 0, f; u < t; ++u)
      a[(f = c[u]).i] = f.x(l);
    return a.join("");
  });
}
function il(e, t) {
  var n = typeof t, i;
  return t == null || n === "boolean" ? Zy(t) : (n === "number" ? Qe : n === "string" ? (i = Gs(t)) ? (t = i, Qo) : zM : t instanceof Gs ? Qo : t instanceof Date ? rj : nj(t) ? ej : Array.isArray(t) ? ij : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? sj : Qe)(e, t);
}
function Jb(e, t) {
  return e = +e, t = +t, function(n) {
    return Math.round(e * (1 - n) + t * n);
  };
}
var A2 = 180 / Math.PI, Wg = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function PM(e, t, n, i, r, s) {
  var o, a, c;
  return (o = Math.sqrt(e * e + t * t)) && (e /= o, t /= o), (c = e * n + t * i) && (n -= e * c, i -= t * c), (a = Math.sqrt(n * n + i * i)) && (n /= a, i /= a, c /= a), e * i < t * n && (e = -e, t = -t, c = -c, o = -o), {
    translateX: r,
    translateY: s,
    rotate: Math.atan2(t, e) * A2,
    skewX: Math.atan(c) * A2,
    scaleX: o,
    scaleY: a
  };
}
var ch;
function cj(e) {
  const t = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(e + "");
  return t.isIdentity ? Wg : PM(t.a, t.b, t.c, t.d, t.e, t.f);
}
function lj(e) {
  return e == null || (ch || (ch = document.createElementNS("http://www.w3.org/2000/svg", "g")), ch.setAttribute("transform", e), !(e = ch.transform.baseVal.consolidate())) ? Wg : (e = e.matrix, PM(e.a, e.b, e.c, e.d, e.e, e.f));
}
function VM(e, t, n, i) {
  function r(l) {
    return l.length ? l.pop() + " " : "";
  }
  function s(l, u, f, h, d, p) {
    if (l !== f || u !== h) {
      var y = d.push("translate(", null, t, null, n);
      p.push({ i: y - 4, x: Qe(l, f) }, { i: y - 2, x: Qe(u, h) });
    } else
      (f || h) && d.push("translate(" + f + t + h + n);
  }
  function o(l, u, f, h) {
    l !== u ? (l - u > 180 ? u += 360 : u - l > 180 && (l += 360), h.push({ i: f.push(r(f) + "rotate(", null, i) - 2, x: Qe(l, u) })) : u && f.push(r(f) + "rotate(" + u + i);
  }
  function a(l, u, f, h) {
    l !== u ? h.push({ i: f.push(r(f) + "skewX(", null, i) - 2, x: Qe(l, u) }) : u && f.push(r(f) + "skewX(" + u + i);
  }
  function c(l, u, f, h, d, p) {
    if (l !== f || u !== h) {
      var y = d.push(r(d) + "scale(", null, ",", null, ")");
      p.push({ i: y - 4, x: Qe(l, f) }, { i: y - 2, x: Qe(u, h) });
    } else
      (f !== 1 || h !== 1) && d.push(r(d) + "scale(" + f + "," + h + ")");
  }
  return function(l, u) {
    var f = [], h = [];
    return l = e(l), u = e(u), s(l.translateX, l.translateY, u.translateX, u.translateY, f, h), o(l.rotate, u.rotate, f, h), a(l.skewX, u.skewX, f, h), c(l.scaleX, l.scaleY, u.scaleX, u.scaleY, f, h), l = u = null, function(d) {
      for (var p = -1, y = h.length, m; ++p < y; )
        f[(m = h[p]).i] = m.x(d);
      return f.join("");
    };
  };
}
var uj = VM(cj, "px, ", "px)", "deg)"), fj = VM(lj, ", ", ")", ")"), hj = 1e-12;
function M2(e) {
  return ((e = Math.exp(e)) + 1 / e) / 2;
}
function dj(e) {
  return ((e = Math.exp(e)) - 1 / e) / 2;
}
function pj(e) {
  return ((e = Math.exp(2 * e)) - 1) / (e + 1);
}
const yj = function e(t, n, i) {
  function r(s, o) {
    var a = s[0], c = s[1], l = s[2], u = o[0], f = o[1], h = o[2], d = u - a, p = f - c, y = d * d + p * p, m, g;
    if (y < hj)
      g = Math.log(h / l) / t, m = function(I) {
        return [
          a + I * d,
          c + I * p,
          l * Math.exp(t * I * g)
        ];
      };
    else {
      var b = Math.sqrt(y), w = (h * h - l * l + i * y) / (2 * l * n * b), v = (h * h - l * l - i * y) / (2 * h * n * b), S = Math.log(Math.sqrt(w * w + 1) - w), _ = Math.log(Math.sqrt(v * v + 1) - v);
      g = (_ - S) / t, m = function(I) {
        var T = I * g, M = M2(S), N = l / (n * b) * (M * pj(t * T + S) - dj(S));
        return [
          a + N * d,
          c + N * p,
          l * M / M2(t * T + S)
        ];
      };
    }
    return m.duration = g * 1e3 * t / Math.SQRT2, m;
  }
  return r.rho = function(s) {
    var o = Math.max(1e-3, +s), a = o * o, c = a * a;
    return e(o, a, c);
  }, r;
}(Math.SQRT2, 2, 4);
function mj(e) {
  return function(t, n) {
    var i = e((t = Vg(t)).h, (n = Vg(n)).h), r = en(t.s, n.s), s = en(t.l, n.l), o = en(t.opacity, n.opacity);
    return function(a) {
      return t.h = i(a), t.s = r(a), t.l = s(a), t.opacity = o(a), t + "";
    };
  };
}
const gj = mj(Hb);
function bj(e, t) {
  var n = en((e = jg(e)).l, (t = jg(t)).l), i = en(e.a, t.a), r = en(e.b, t.b), s = en(e.opacity, t.opacity);
  return function(o) {
    return e.l = n(o), e.a = i(o), e.b = r(o), e.opacity = s(o), e + "";
  };
}
function wj(e) {
  return function(t, n) {
    var i = e((t = qg(t)).h, (n = qg(n)).h), r = en(t.c, n.c), s = en(t.l, n.l), o = en(t.opacity, n.opacity);
    return function(a) {
      return t.h = i(a), t.c = r(a), t.l = s(a), t.opacity = o(a), t + "";
    };
  };
}
const vj = wj(Hb);
function jM(e) {
  return function t(n) {
    n = +n;
    function i(r, s) {
      var o = e((r = hr(r)).h, (s = hr(s)).h), a = en(r.s, s.s), c = en(r.l, s.l), l = en(r.opacity, s.opacity);
      return function(u) {
        return r.h = o(u), r.s = a(u), r.l = c(Math.pow(u, n)), r.opacity = l(u), r + "";
      };
    }
    return i.gamma = t, i;
  }(1);
}
jM(Hb);
var Kb = jM(en);
function Qy(e, t) {
  t === void 0 && (t = e, e = il);
  for (var n = 0, i = t.length - 1, r = t[0], s = new Array(i < 0 ? 0 : i); n < i; )
    s[n] = e(r, r = t[++n]);
  return function(o) {
    var a = Math.max(0, Math.min(i - 1, Math.floor(o *= i)));
    return s[a](o - a);
  };
}
function Ti(e, t) {
  for (var n = new Array(t), i = 0; i < t; ++i)
    n[i] = e(i / (t - 1));
  return n;
}
var Bc = 0, ql = 0, _l = 0, qM = 1e3, ep, Yl, np = 0, ta = 0, t0 = 0, Eu = typeof performance == "object" && performance.now ? performance : Date, YM = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
  setTimeout(e, 17);
};
function Zb() {
  return ta || (YM(_j), ta = Eu.now() + t0);
}
function _j() {
  ta = 0;
}
function ip() {
  this._call = this._time = this._next = null;
}
ip.prototype = WM.prototype = {
  constructor: ip,
  restart: function(e, t, n) {
    if (typeof e != "function")
      throw new TypeError("callback is not a function");
    n = (n == null ? Zb() : +n) + (t == null ? 0 : +t), !this._next && Yl !== this && (Yl ? Yl._next = this : ep = this, Yl = this), this._call = e, this._time = n, Gg();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, Gg());
  }
};
function WM(e, t, n) {
  var i = new ip();
  return i.restart(e, t, n), i;
}
function Sj() {
  Zb(), ++Bc;
  for (var e = ep, t; e; )
    (t = ta - e._time) >= 0 && e._call.call(void 0, t), e = e._next;
  --Bc;
}
function $2() {
  ta = (np = Eu.now()) + t0, Bc = ql = 0;
  try {
    Sj();
  } finally {
    Bc = 0, Ij(), ta = 0;
  }
}
function xj() {
  var e = Eu.now(), t = e - np;
  t > qM && (t0 -= t, np = e);
}
function Ij() {
  for (var e, t = ep, n, i = 1 / 0; t; )
    t._call ? (i > t._time && (i = t._time), e = t, t = t._next) : (n = t._next, t._next = null, t = e ? e._next = n : ep = n);
  Yl = e, Gg(i);
}
function Gg(e) {
  if (!Bc) {
    ql && (ql = clearTimeout(ql));
    var t = e - ta;
    t > 24 ? (e < 1 / 0 && (ql = setTimeout($2, e - Eu.now() - t0)), _l && (_l = clearInterval(_l))) : (_l || (np = Eu.now(), _l = setInterval(xj, qM)), Bc = 1, YM($2));
  }
}
function T2(e, t, n) {
  var i = new ip();
  return t = t == null ? 0 : +t, i.restart((r) => {
    i.stop(), e(r + t);
  }, t, n), i;
}
var Aj = Xy("start", "end", "cancel", "interrupt"), Mj = [], GM = 0, D2 = 1, Xg = 2, Qh = 3, N2 = 4, Hg = 5, td = 6;
function e0(e, t, n, i, r, s) {
  var o = e.__transition;
  if (!o)
    e.__transition = {};
  else if (n in o)
    return;
  $j(e, n, {
    name: t,
    index: i,
    // For context during callback.
    group: r,
    // For context during callback.
    on: Aj,
    tween: Mj,
    time: s.time,
    delay: s.delay,
    duration: s.duration,
    ease: s.ease,
    timer: null,
    state: GM
  });
}
function Qb(e, t) {
  var n = Ci(e, t);
  if (n.state > GM)
    throw new Error("too late; already scheduled");
  return n;
}
function gr(e, t) {
  var n = Ci(e, t);
  if (n.state > Qh)
    throw new Error("too late; already running");
  return n;
}
function Ci(e, t) {
  var n = e.__transition;
  if (!n || !(n = n[t]))
    throw new Error("transition not found");
  return n;
}
function $j(e, t, n) {
  var i = e.__transition, r;
  i[t] = n, n.timer = WM(s, 0, n.time);
  function s(l) {
    n.state = D2, n.timer.restart(o, n.delay, n.time), n.delay <= l && o(l - n.delay);
  }
  function o(l) {
    var u, f, h, d;
    if (n.state !== D2)
      return c();
    for (u in i)
      if (d = i[u], d.name === n.name) {
        if (d.state === Qh)
          return T2(o);
        d.state === N2 ? (d.state = td, d.timer.stop(), d.on.call("interrupt", e, e.__data__, d.index, d.group), delete i[u]) : +u < t && (d.state = td, d.timer.stop(), d.on.call("cancel", e, e.__data__, d.index, d.group), delete i[u]);
      }
    if (T2(function() {
      n.state === Qh && (n.state = N2, n.timer.restart(a, n.delay, n.time), a(l));
    }), n.state = Xg, n.on.call("start", e, e.__data__, n.index, n.group), n.state === Xg) {
      for (n.state = Qh, r = new Array(h = n.tween.length), u = 0, f = -1; u < h; ++u)
        (d = n.tween[u].value.call(e, e.__data__, n.index, n.group)) && (r[++f] = d);
      r.length = f + 1;
    }
  }
  function a(l) {
    for (var u = l < n.duration ? n.ease.call(null, l / n.duration) : (n.timer.restart(c), n.state = Hg, 1), f = -1, h = r.length; ++f < h; )
      r[f].call(e, u);
    n.state === Hg && (n.on.call("end", e, e.__data__, n.index, n.group), c());
  }
  function c() {
    n.state = td, n.timer.stop(), delete i[t];
    for (var l in i)
      return;
    delete e.__transition;
  }
}
function dc(e, t) {
  var n = e.__transition, i, r, s = !0, o;
  if (n) {
    t = t == null ? null : t + "";
    for (o in n) {
      if ((i = n[o]).name !== t) {
        s = !1;
        continue;
      }
      r = i.state > Xg && i.state < Hg, i.state = td, i.timer.stop(), i.on.call(r ? "interrupt" : "cancel", e, e.__data__, i.index, i.group), delete n[o];
    }
    s && delete e.__transition;
  }
}
function Tj(e) {
  return this.each(function() {
    dc(this, e);
  });
}
function Dj(e, t) {
  var n, i;
  return function() {
    var r = gr(this, e), s = r.tween;
    if (s !== n) {
      i = n = s;
      for (var o = 0, a = i.length; o < a; ++o)
        if (i[o].name === t) {
          i = i.slice(), i.splice(o, 1);
          break;
        }
    }
    r.tween = i;
  };
}
function Nj(e, t, n) {
  var i, r;
  if (typeof n != "function")
    throw new Error();
  return function() {
    var s = gr(this, e), o = s.tween;
    if (o !== i) {
      r = (i = o).slice();
      for (var a = { name: t, value: n }, c = 0, l = r.length; c < l; ++c)
        if (r[c].name === t) {
          r[c] = a;
          break;
        }
      c === l && r.push(a);
    }
    s.tween = r;
  };
}
function Bj(e, t) {
  var n = this._id;
  if (e += "", arguments.length < 2) {
    for (var i = Ci(this.node(), n).tween, r = 0, s = i.length, o; r < s; ++r)
      if ((o = i[r]).name === e)
        return o.value;
    return null;
  }
  return this.each((t == null ? Dj : Nj)(n, e, t));
}
function tw(e, t, n) {
  var i = e._id;
  return e.each(function() {
    var r = gr(this, i);
    (r.value || (r.value = {}))[t] = n.apply(this, arguments);
  }), function(r) {
    return Ci(r, i).value[t];
  };
}
function XM(e, t) {
  var n;
  return (typeof t == "number" ? Qe : t instanceof Gs ? Qo : (n = Gs(t)) ? (t = n, Qo) : zM)(e, t);
}
function Oj(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function Fj(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function Ej(e, t, n) {
  var i, r = n + "", s;
  return function() {
    var o = this.getAttribute(e);
    return o === r ? null : o === i ? s : s = t(i = o, n);
  };
}
function Lj(e, t, n) {
  var i, r = n + "", s;
  return function() {
    var o = this.getAttributeNS(e.space, e.local);
    return o === r ? null : o === i ? s : s = t(i = o, n);
  };
}
function Rj(e, t, n) {
  var i, r, s;
  return function() {
    var o, a = n(this), c;
    return a == null ? void this.removeAttribute(e) : (o = this.getAttribute(e), c = a + "", o === c ? null : o === i && c === r ? s : (r = c, s = t(i = o, a)));
  };
}
function Cj(e, t, n) {
  var i, r, s;
  return function() {
    var o, a = n(this), c;
    return a == null ? void this.removeAttributeNS(e.space, e.local) : (o = this.getAttributeNS(e.space, e.local), c = a + "", o === c ? null : o === i && c === r ? s : (r = c, s = t(i = o, a)));
  };
}
function kj(e, t) {
  var n = Hy(e), i = n === "transform" ? fj : XM;
  return this.attrTween(e, typeof t == "function" ? (n.local ? Cj : Rj)(n, i, tw(this, "attr." + e, t)) : t == null ? (n.local ? Fj : Oj)(n) : (n.local ? Lj : Ej)(n, i, t));
}
function Uj(e, t) {
  return function(n) {
    this.setAttribute(e, t.call(this, n));
  };
}
function zj(e, t) {
  return function(n) {
    this.setAttributeNS(e.space, e.local, t.call(this, n));
  };
}
function Pj(e, t) {
  var n, i;
  function r() {
    var s = t.apply(this, arguments);
    return s !== i && (n = (i = s) && zj(e, s)), n;
  }
  return r._value = t, r;
}
function Vj(e, t) {
  var n, i;
  function r() {
    var s = t.apply(this, arguments);
    return s !== i && (n = (i = s) && Uj(e, s)), n;
  }
  return r._value = t, r;
}
function jj(e, t) {
  var n = "attr." + e;
  if (arguments.length < 2)
    return (n = this.tween(n)) && n._value;
  if (t == null)
    return this.tween(n, null);
  if (typeof t != "function")
    throw new Error();
  var i = Hy(e);
  return this.tween(n, (i.local ? Pj : Vj)(i, t));
}
function qj(e, t) {
  return function() {
    Qb(this, e).delay = +t.apply(this, arguments);
  };
}
function Yj(e, t) {
  return t = +t, function() {
    Qb(this, e).delay = t;
  };
}
function Wj(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? qj : Yj)(t, e)) : Ci(this.node(), t).delay;
}
function Gj(e, t) {
  return function() {
    gr(this, e).duration = +t.apply(this, arguments);
  };
}
function Xj(e, t) {
  return t = +t, function() {
    gr(this, e).duration = t;
  };
}
function Hj(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? Gj : Xj)(t, e)) : Ci(this.node(), t).duration;
}
function Jj(e, t) {
  if (typeof t != "function")
    throw new Error();
  return function() {
    gr(this, e).ease = t;
  };
}
function Kj(e) {
  var t = this._id;
  return arguments.length ? this.each(Jj(t, e)) : Ci(this.node(), t).ease;
}
function Zj(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    if (typeof n != "function")
      throw new Error();
    gr(this, e).ease = n;
  };
}
function Qj(e) {
  if (typeof e != "function")
    throw new Error();
  return this.each(Zj(this._id, e));
}
function tq(e) {
  typeof e != "function" && (e = mM(e));
  for (var t = this._groups, n = t.length, i = new Array(n), r = 0; r < n; ++r)
    for (var s = t[r], o = s.length, a = i[r] = [], c, l = 0; l < o; ++l)
      (c = s[l]) && e.call(c, c.__data__, l, s) && a.push(c);
  return new ss(i, this._parents, this._name, this._id);
}
function eq(e) {
  if (e._id !== this._id)
    throw new Error();
  for (var t = this._groups, n = e._groups, i = t.length, r = n.length, s = Math.min(i, r), o = new Array(i), a = 0; a < s; ++a)
    for (var c = t[a], l = n[a], u = c.length, f = o[a] = new Array(u), h, d = 0; d < u; ++d)
      (h = c[d] || l[d]) && (f[d] = h);
  for (; a < i; ++a)
    o[a] = t[a];
  return new ss(o, this._parents, this._name, this._id);
}
function nq(e) {
  return (e + "").trim().split(/^|\s+/).every(function(t) {
    var n = t.indexOf(".");
    return n >= 0 && (t = t.slice(0, n)), !t || t === "start";
  });
}
function iq(e, t, n) {
  var i, r, s = nq(t) ? Qb : gr;
  return function() {
    var o = s(this, e), a = o.on;
    a !== i && (r = (i = a).copy()).on(t, n), o.on = r;
  };
}
function rq(e, t) {
  var n = this._id;
  return arguments.length < 2 ? Ci(this.node(), n).on.on(e) : this.each(iq(n, e, t));
}
function sq(e) {
  return function() {
    var t = this.parentNode;
    for (var n in this.__transition)
      if (+n !== e)
        return;
    t && t.removeChild(this);
  };
}
function oq() {
  return this.on("end.remove", sq(this._id));
}
function aq(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = qb(e));
  for (var i = this._groups, r = i.length, s = new Array(r), o = 0; o < r; ++o)
    for (var a = i[o], c = a.length, l = s[o] = new Array(c), u, f, h = 0; h < c; ++h)
      (u = a[h]) && (f = e.call(u, u.__data__, h, a)) && ("__data__" in u && (f.__data__ = u.__data__), l[h] = f, e0(l[h], t, n, h, l, Ci(u, n)));
  return new ss(s, this._parents, t, n);
}
function cq(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = yM(e));
  for (var i = this._groups, r = i.length, s = [], o = [], a = 0; a < r; ++a)
    for (var c = i[a], l = c.length, u, f = 0; f < l; ++f)
      if (u = c[f]) {
        for (var h = e.call(u, u.__data__, f, c), d, p = Ci(u, n), y = 0, m = h.length; y < m; ++y)
          (d = h[y]) && e0(d, t, n, y, h, p);
        s.push(h), o.push(u);
      }
  return new ss(s, o, t, n);
}
var lq = bf.prototype.constructor;
function uq() {
  return new lq(this._groups, this._parents);
}
function fq(e, t) {
  var n, i, r;
  return function() {
    var s = Dc(this, e), o = (this.style.removeProperty(e), Dc(this, e));
    return s === o ? null : s === n && o === i ? r : r = t(n = s, i = o);
  };
}
function HM(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function hq(e, t, n) {
  var i, r = n + "", s;
  return function() {
    var o = Dc(this, e);
    return o === r ? null : o === i ? s : s = t(i = o, n);
  };
}
function dq(e, t, n) {
  var i, r, s;
  return function() {
    var o = Dc(this, e), a = n(this), c = a + "";
    return a == null && (c = a = (this.style.removeProperty(e), Dc(this, e))), o === c ? null : o === i && c === r ? s : (r = c, s = t(i = o, a));
  };
}
function pq(e, t) {
  var n, i, r, s = "style." + t, o = "end." + s, a;
  return function() {
    var c = gr(this, e), l = c.on, u = c.value[s] == null ? a || (a = HM(t)) : void 0;
    (l !== n || r !== u) && (i = (n = l).copy()).on(o, r = u), c.on = i;
  };
}
function yq(e, t, n) {
  var i = (e += "") == "transform" ? uj : XM;
  return t == null ? this.styleTween(e, fq(e, i)).on("end.style." + e, HM(e)) : typeof t == "function" ? this.styleTween(e, dq(e, i, tw(this, "style." + e, t))).each(pq(this._id, e)) : this.styleTween(e, hq(e, i, t), n).on("end.style." + e, null);
}
function mq(e, t, n) {
  return function(i) {
    this.style.setProperty(e, t.call(this, i), n);
  };
}
function gq(e, t, n) {
  var i, r;
  function s() {
    var o = t.apply(this, arguments);
    return o !== r && (i = (r = o) && mq(e, o, n)), i;
  }
  return s._value = t, s;
}
function bq(e, t, n) {
  var i = "style." + (e += "");
  if (arguments.length < 2)
    return (i = this.tween(i)) && i._value;
  if (t == null)
    return this.tween(i, null);
  if (typeof t != "function")
    throw new Error();
  return this.tween(i, gq(e, t, n ?? ""));
}
function wq(e) {
  return function() {
    this.textContent = e;
  };
}
function vq(e) {
  return function() {
    var t = e(this);
    this.textContent = t ?? "";
  };
}
function _q(e) {
  return this.tween("text", typeof e == "function" ? vq(tw(this, "text", e)) : wq(e == null ? "" : e + ""));
}
function Sq(e) {
  return function(t) {
    this.textContent = e.call(this, t);
  };
}
function xq(e) {
  var t, n;
  function i() {
    var r = e.apply(this, arguments);
    return r !== n && (t = (n = r) && Sq(r)), t;
  }
  return i._value = e, i;
}
function Iq(e) {
  var t = "text";
  if (arguments.length < 1)
    return (t = this.tween(t)) && t._value;
  if (e == null)
    return this.tween(t, null);
  if (typeof e != "function")
    throw new Error();
  return this.tween(t, xq(e));
}
function Aq() {
  for (var e = this._name, t = this._id, n = JM(), i = this._groups, r = i.length, s = 0; s < r; ++s)
    for (var o = i[s], a = o.length, c, l = 0; l < a; ++l)
      if (c = o[l]) {
        var u = Ci(c, t);
        e0(c, e, n, l, o, {
          time: u.time + u.delay + u.duration,
          delay: 0,
          duration: u.duration,
          ease: u.ease
        });
      }
  return new ss(i, this._parents, e, n);
}
function Mq() {
  var e, t, n = this, i = n._id, r = n.size();
  return new Promise(function(s, o) {
    var a = { value: o }, c = { value: function() {
      --r === 0 && s();
    } };
    n.each(function() {
      var l = gr(this, i), u = l.on;
      u !== e && (t = (e = u).copy(), t._.cancel.push(a), t._.interrupt.push(a), t._.end.push(c)), l.on = t;
    }), r === 0 && s();
  });
}
var $q = 0;
function ss(e, t, n, i) {
  this._groups = e, this._parents = t, this._name = n, this._id = i;
}
function JM() {
  return ++$q;
}
var xr = bf.prototype;
ss.prototype = {
  constructor: ss,
  select: aq,
  selectAll: cq,
  selectChild: xr.selectChild,
  selectChildren: xr.selectChildren,
  filter: tq,
  merge: eq,
  selection: uq,
  transition: Aq,
  call: xr.call,
  nodes: xr.nodes,
  node: xr.node,
  size: xr.size,
  empty: xr.empty,
  each: xr.each,
  on: rq,
  attr: kj,
  attrTween: jj,
  style: yq,
  styleTween: bq,
  text: _q,
  textTween: Iq,
  remove: oq,
  tween: Bj,
  delay: Wj,
  duration: Hj,
  ease: Kj,
  easeVarying: Qj,
  end: Mq,
  [Symbol.iterator]: xr[Symbol.iterator]
};
function Tq(e) {
  return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2;
}
var Dq = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: Tq
};
function Nq(e, t) {
  for (var n; !(n = e.__transition) || !(n = n[t]); )
    if (!(e = e.parentNode))
      throw new Error(`transition ${t} not found`);
  return n;
}
function Bq(e) {
  var t, n;
  e instanceof ss ? (t = e._id, e = e._name) : (t = JM(), (n = Dq).time = Zb(), e = e == null ? null : e + "");
  for (var i = this._groups, r = i.length, s = 0; s < r; ++s)
    for (var o = i[s], a = o.length, c, l = 0; l < a; ++l)
      (c = o[l]) && e0(c, e, t, l, o, n || Nq(c, t));
  return new ss(i, this._parents, e, t);
}
bf.prototype.interrupt = Tj;
bf.prototype.transition = Bq;
const dm = (e) => () => e;
function Oq(e, {
  sourceEvent: t,
  target: n,
  selection: i,
  mode: r,
  dispatch: s
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    target: { value: n, enumerable: !0, configurable: !0 },
    selection: { value: i, enumerable: !0, configurable: !0 },
    mode: { value: r, enumerable: !0, configurable: !0 },
    _: { value: s }
  });
}
function Fq(e) {
  e.stopImmediatePropagation();
}
function pm(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
var B2 = { name: "drag" }, ym = { name: "space" }, wa = { name: "handle" }, va = { name: "center" };
const { abs: O2, max: Je, min: Ke } = Math;
function F2(e) {
  return [+e[0], +e[1]];
}
function Jg(e) {
  return [F2(e[0]), F2(e[1])];
}
var ed = {
  name: "x",
  handles: ["w", "e"].map(Lu),
  input: function(e, t) {
    return e == null ? null : [[+e[0], t[0][1]], [+e[1], t[1][1]]];
  },
  output: function(e) {
    return e && [e[0][0], e[1][0]];
  }
}, nd = {
  name: "y",
  handles: ["n", "s"].map(Lu),
  input: function(e, t) {
    return e == null ? null : [[t[0][0], +e[0]], [t[1][0], +e[1]]];
  },
  output: function(e) {
    return e && [e[0][1], e[1][1]];
  }
}, Eq = {
  name: "xy",
  handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(Lu),
  input: function(e) {
    return e == null ? null : Jg(e);
  },
  output: function(e) {
    return e;
  }
}, Ir = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
}, E2 = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
}, L2 = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
}, Lq = {
  overlay: 1,
  selection: 1,
  n: null,
  e: 1,
  s: null,
  w: -1,
  nw: -1,
  ne: 1,
  se: 1,
  sw: -1
}, Rq = {
  overlay: 1,
  selection: 1,
  n: -1,
  e: null,
  s: 1,
  w: null,
  nw: -1,
  ne: -1,
  se: 1,
  sw: 1
};
function Lu(e) {
  return { type: e };
}
function Cq(e) {
  return !e.ctrlKey && !e.button;
}
function kq() {
  var e = this.ownerSVGElement || this;
  return e.hasAttribute("viewBox") ? (e = e.viewBox.baseVal, [[e.x, e.y], [e.x + e.width, e.y + e.height]]) : [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
}
function Uq() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function mm(e) {
  for (; !e.__brush; )
    if (!(e = e.parentNode))
      return;
  return e.__brush;
}
function zq(e) {
  return e[0][0] === e[1][0] || e[0][1] === e[1][1];
}
function Pq() {
  return ew(ed);
}
function Vq() {
  return ew(nd);
}
function jq() {
  return ew(Eq);
}
function ew(e) {
  var t = kq, n = Cq, i = Uq, r = !0, s = Xy("start", "brush", "end"), o = 6, a;
  function c(m) {
    var g = m.property("__brush", y).selectAll(".overlay").data([Lu("overlay")]);
    g.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", Ir.overlay).merge(g).each(function() {
      var w = mm(this).extent;
      ce(this).attr("x", w[0][0]).attr("y", w[0][1]).attr("width", w[1][0] - w[0][0]).attr("height", w[1][1] - w[0][1]);
    }), m.selectAll(".selection").data([Lu("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", Ir.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");
    var b = m.selectAll(".handle").data(e.handles, function(w) {
      return w.type;
    });
    b.exit().remove(), b.enter().append("rect").attr("class", function(w) {
      return "handle handle--" + w.type;
    }).attr("cursor", function(w) {
      return Ir[w.type];
    }), m.each(l).attr("fill", "none").attr("pointer-events", "all").on("mousedown.brush", h).filter(i).on("touchstart.brush", h).on("touchmove.brush", d).on("touchend.brush touchcancel.brush", p).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  c.move = function(m, g, b) {
    m.tween ? m.on("start.brush", function(w) {
      u(this, arguments).beforestart().start(w);
    }).on("interrupt.brush end.brush", function(w) {
      u(this, arguments).end(w);
    }).tween("brush", function() {
      var w = this, v = w.__brush, S = u(w, arguments), _ = v.selection, I = e.input(typeof g == "function" ? g.apply(this, arguments) : g, v.extent), T = il(_, I);
      function M(N) {
        v.selection = N === 1 && I === null ? null : T(N), l.call(w), S.brush();
      }
      return _ !== null && I !== null ? M : M(1);
    }) : m.each(function() {
      var w = this, v = arguments, S = w.__brush, _ = e.input(typeof g == "function" ? g.apply(w, v) : g, S.extent), I = u(w, v).beforestart();
      dc(w), S.selection = _ === null ? null : _, l.call(w), I.start(b).brush(b).end(b);
    });
  }, c.clear = function(m, g) {
    c.move(m, null, g);
  };
  function l() {
    var m = ce(this), g = mm(this).selection;
    g ? (m.selectAll(".selection").style("display", null).attr("x", g[0][0]).attr("y", g[0][1]).attr("width", g[1][0] - g[0][0]).attr("height", g[1][1] - g[0][1]), m.selectAll(".handle").style("display", null).attr("x", function(b) {
      return b.type[b.type.length - 1] === "e" ? g[1][0] - o / 2 : g[0][0] - o / 2;
    }).attr("y", function(b) {
      return b.type[0] === "s" ? g[1][1] - o / 2 : g[0][1] - o / 2;
    }).attr("width", function(b) {
      return b.type === "n" || b.type === "s" ? g[1][0] - g[0][0] + o : o;
    }).attr("height", function(b) {
      return b.type === "e" || b.type === "w" ? g[1][1] - g[0][1] + o : o;
    })) : m.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
  }
  function u(m, g, b) {
    var w = m.__brush.emitter;
    return w && (!b || !w.clean) ? w : new f(m, g, b);
  }
  function f(m, g, b) {
    this.that = m, this.args = g, this.state = m.__brush, this.active = 0, this.clean = b;
  }
  f.prototype = {
    beforestart: function() {
      return ++this.active === 1 && (this.state.emitter = this, this.starting = !0), this;
    },
    start: function(m, g) {
      return this.starting ? (this.starting = !1, this.emit("start", m, g)) : this.emit("brush", m), this;
    },
    brush: function(m, g) {
      return this.emit("brush", m, g), this;
    },
    end: function(m, g) {
      return --this.active === 0 && (delete this.state.emitter, this.emit("end", m, g)), this;
    },
    emit: function(m, g, b) {
      var w = ce(this.that).datum();
      s.call(
        m,
        this.that,
        new Oq(m, {
          sourceEvent: g,
          target: c,
          selection: e.output(this.state.selection),
          mode: b,
          dispatch: s
        }),
        w
      );
    }
  };
  function h(m) {
    if (a && !m.touches || !n.apply(this, arguments))
      return;
    var g = this, b = m.target.__data__.type, w = (r && m.metaKey ? b = "overlay" : b) === "selection" ? B2 : r && m.altKey ? va : wa, v = e === nd ? null : Lq[b], S = e === ed ? null : Rq[b], _ = mm(g), I = _.extent, T = _.selection, M = I[0][0], N, A, B = I[0][1], R, x, $ = I[1][0], D, L, k = I[1][1], U, C, z = 0, P = 0, G, K = v && S && r && m.shiftKey, et, Z, Y = Array.from(m.touches || [m], (Q) => {
      const Zt = Q.identifier;
      return Q = mi(Q, g), Q.point0 = Q.slice(), Q.identifier = Zt, Q;
    });
    dc(g);
    var X = u(g, arguments, !0).beforestart();
    if (b === "overlay") {
      T && (G = !0);
      const Q = [Y[0], Y[1] || Y[0]];
      _.selection = T = [[
        N = e === nd ? M : Ke(Q[0][0], Q[1][0]),
        R = e === ed ? B : Ke(Q[0][1], Q[1][1])
      ], [
        D = e === nd ? $ : Je(Q[0][0], Q[1][0]),
        U = e === ed ? k : Je(Q[0][1], Q[1][1])
      ]], Y.length > 1 && Ft(m);
    } else
      N = T[0][0], R = T[0][1], D = T[1][0], U = T[1][1];
    A = N, x = R, L = D, C = U;
    var j = ce(g).attr("pointer-events", "none"), J = j.selectAll(".overlay").attr("cursor", Ir[b]);
    if (m.touches)
      X.moved = V, X.ended = st;
    else {
      var tt = ce(m.view).on("mousemove.brush", V, !0).on("mouseup.brush", st, !0);
      r && tt.on("keydown.brush", Vt, !0).on("keyup.brush", jt, !0), MM(m.view);
    }
    l.call(g), X.start(m, w.name);
    function V(Q) {
      for (const Zt of Q.changedTouches || [Q])
        for (const En of Y)
          En.identifier === Zt.identifier && (En.cur = mi(Zt, g));
      if (K && !et && !Z && Y.length === 1) {
        const Zt = Y[0];
        O2(Zt.cur[0] - Zt[0]) > O2(Zt.cur[1] - Zt[1]) ? Z = !0 : et = !0;
      }
      for (const Zt of Y)
        Zt.cur && (Zt[0] = Zt.cur[0], Zt[1] = Zt.cur[1]);
      G = !0, pm(Q), Ft(Q);
    }
    function Ft(Q) {
      const Zt = Y[0], En = Zt.point0;
      var zi;
      switch (z = Zt[0] - En[0], P = Zt[1] - En[1], w) {
        case ym:
        case B2: {
          v && (z = Je(M - N, Ke($ - D, z)), A = N + z, L = D + z), S && (P = Je(B - R, Ke(k - U, P)), x = R + P, C = U + P);
          break;
        }
        case wa: {
          Y[1] ? (v && (A = Je(M, Ke($, Y[0][0])), L = Je(M, Ke($, Y[1][0])), v = 1), S && (x = Je(B, Ke(k, Y[0][1])), C = Je(B, Ke(k, Y[1][1])), S = 1)) : (v < 0 ? (z = Je(M - N, Ke($ - N, z)), A = N + z, L = D) : v > 0 && (z = Je(M - D, Ke($ - D, z)), A = N, L = D + z), S < 0 ? (P = Je(B - R, Ke(k - R, P)), x = R + P, C = U) : S > 0 && (P = Je(B - U, Ke(k - U, P)), x = R, C = U + P));
          break;
        }
        case va: {
          v && (A = Je(M, Ke($, N - z * v)), L = Je(M, Ke($, D + z * v))), S && (x = Je(B, Ke(k, R - P * S)), C = Je(B, Ke(k, U + P * S)));
          break;
        }
      }
      L < A && (v *= -1, zi = N, N = D, D = zi, zi = A, A = L, L = zi, b in E2 && J.attr("cursor", Ir[b = E2[b]])), C < x && (S *= -1, zi = R, R = U, U = zi, zi = x, x = C, C = zi, b in L2 && J.attr("cursor", Ir[b = L2[b]])), _.selection && (T = _.selection), et && (A = T[0][0], L = T[1][0]), Z && (x = T[0][1], C = T[1][1]), (T[0][0] !== A || T[0][1] !== x || T[1][0] !== L || T[1][1] !== C) && (_.selection = [[A, x], [L, C]], l.call(g), X.brush(Q, w.name));
    }
    function st(Q) {
      if (Fq(Q), Q.touches) {
        if (Q.touches.length)
          return;
        a && clearTimeout(a), a = setTimeout(function() {
          a = null;
        }, 500);
      } else
        $M(Q.view, G), tt.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      j.attr("pointer-events", "all"), J.attr("cursor", Ir.overlay), _.selection && (T = _.selection), zq(T) && (_.selection = null, l.call(g)), X.end(Q, w.name);
    }
    function Vt(Q) {
      switch (Q.keyCode) {
        case 16: {
          K = v && S;
          break;
        }
        case 18: {
          w === wa && (v && (D = L - z * v, N = A + z * v), S && (U = C - P * S, R = x + P * S), w = va, Ft(Q));
          break;
        }
        case 32: {
          (w === wa || w === va) && (v < 0 ? D = L - z : v > 0 && (N = A - z), S < 0 ? U = C - P : S > 0 && (R = x - P), w = ym, J.attr("cursor", Ir.selection), Ft(Q));
          break;
        }
        default:
          return;
      }
      pm(Q);
    }
    function jt(Q) {
      switch (Q.keyCode) {
        case 16: {
          K && (et = Z = K = !1, Ft(Q));
          break;
        }
        case 18: {
          w === va && (v < 0 ? D = L : v > 0 && (N = A), S < 0 ? U = C : S > 0 && (R = x), w = wa, Ft(Q));
          break;
        }
        case 32: {
          w === ym && (Q.altKey ? (v && (D = L - z * v, N = A + z * v), S && (U = C - P * S, R = x + P * S), w = va) : (v < 0 ? D = L : v > 0 && (N = A), S < 0 ? U = C : S > 0 && (R = x), w = wa), J.attr("cursor", Ir[b]), Ft(Q));
          break;
        }
        default:
          return;
      }
      pm(Q);
    }
  }
  function d(m) {
    u(this, arguments).moved(m);
  }
  function p(m) {
    u(this, arguments).ended(m);
  }
  function y() {
    var m = this.__brush || { selection: null };
    return m.extent = Jg(t.apply(this, arguments)), m.dim = e, m;
  }
  return c.extent = function(m) {
    return arguments.length ? (t = typeof m == "function" ? m : dm(Jg(m)), c) : t;
  }, c.filter = function(m) {
    return arguments.length ? (n = typeof m == "function" ? m : dm(!!m), c) : n;
  }, c.touchable = function(m) {
    return arguments.length ? (i = typeof m == "function" ? m : dm(!!m), c) : i;
  }, c.handleSize = function(m) {
    return arguments.length ? (o = +m, c) : o;
  }, c.keyModifiers = function(m) {
    return arguments.length ? (r = !!m, c) : r;
  }, c.on = function() {
    var m = s.on.apply(s, arguments);
    return m === s ? c : m;
  }, c;
}
const Kg = Math.PI, Zg = 2 * Kg, Do = 1e-6, qq = Zg - Do;
function KM(e) {
  this._ += e[0];
  for (let t = 1, n = e.length; t < n; ++t)
    this._ += arguments[t] + e[t];
}
function Yq(e) {
  let t = Math.floor(e);
  if (!(t >= 0))
    throw new Error(`invalid digits: ${e}`);
  if (t > 15)
    return KM;
  const n = 10 ** t;
  return function(i) {
    this._ += i[0];
    for (let r = 1, s = i.length; r < s; ++r)
      this._ += Math.round(arguments[r] * n) / n + i[r];
  };
}
let ZM = class {
  constructor(t) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = t == null ? KM : Yq(t);
  }
  moveTo(t, n) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(t, n) {
    this._append`L${this._x1 = +t},${this._y1 = +n}`;
  }
  quadraticCurveTo(t, n, i, r) {
    this._append`Q${+t},${+n},${this._x1 = +i},${this._y1 = +r}`;
  }
  bezierCurveTo(t, n, i, r, s, o) {
    this._append`C${+t},${+n},${+i},${+r},${this._x1 = +s},${this._y1 = +o}`;
  }
  arcTo(t, n, i, r, s) {
    if (t = +t, n = +n, i = +i, r = +r, s = +s, s < 0)
      throw new Error(`negative radius: ${s}`);
    let o = this._x1, a = this._y1, c = i - t, l = r - n, u = o - t, f = a - n, h = u * u + f * f;
    if (this._x1 === null)
      this._append`M${this._x1 = t},${this._y1 = n}`;
    else if (h > Do)
      if (!(Math.abs(f * c - l * u) > Do) || !s)
        this._append`L${this._x1 = t},${this._y1 = n}`;
      else {
        let d = i - o, p = r - a, y = c * c + l * l, m = d * d + p * p, g = Math.sqrt(y), b = Math.sqrt(h), w = s * Math.tan((Kg - Math.acos((y + h - m) / (2 * g * b))) / 2), v = w / b, S = w / g;
        Math.abs(v - 1) > Do && this._append`L${t + v * u},${n + v * f}`, this._append`A${s},${s},0,0,${+(f * d > u * p)},${this._x1 = t + S * c},${this._y1 = n + S * l}`;
      }
  }
  arc(t, n, i, r, s, o) {
    if (t = +t, n = +n, i = +i, o = !!o, i < 0)
      throw new Error(`negative radius: ${i}`);
    let a = i * Math.cos(r), c = i * Math.sin(r), l = t + a, u = n + c, f = 1 ^ o, h = o ? r - s : s - r;
    this._x1 === null ? this._append`M${l},${u}` : (Math.abs(this._x1 - l) > Do || Math.abs(this._y1 - u) > Do) && this._append`L${l},${u}`, i && (h < 0 && (h = h % Zg + Zg), h > qq ? this._append`A${i},${i},0,1,${f},${t - a},${n - c}A${i},${i},0,1,${f},${this._x1 = l},${this._y1 = u}` : h > Do && this._append`A${i},${i},0,${+(h >= Kg)},${f},${this._x1 = t + i * Math.cos(s)},${this._y1 = n + i * Math.sin(s)}`);
  }
  rect(t, n, i, r) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}h${i = +i}v${+r}h${-i}Z`;
  }
  toString() {
    return this._;
  }
};
function Xr(e = 3) {
  return new ZM(+e);
}
var Wq = Array.prototype, QM = Wq.slice;
function Gq(e, t) {
  return e - t;
}
function Xq(e) {
  for (var t = 0, n = e.length, i = e[n - 1][1] * e[0][0] - e[n - 1][0] * e[0][1]; ++t < n; )
    i += e[t - 1][1] * e[t][0] - e[t - 1][0] * e[t][1];
  return i;
}
const Ts = (e) => () => e;
function Hq(e, t) {
  for (var n = -1, i = t.length, r; ++n < i; )
    if (r = Jq(e, t[n]))
      return r;
  return 0;
}
function Jq(e, t) {
  for (var n = t[0], i = t[1], r = -1, s = 0, o = e.length, a = o - 1; s < o; a = s++) {
    var c = e[s], l = c[0], u = c[1], f = e[a], h = f[0], d = f[1];
    if (Kq(c, f, t))
      return 0;
    u > i != d > i && n < (h - l) * (i - u) / (d - u) + l && (r = -r);
  }
  return r;
}
function Kq(e, t, n) {
  var i;
  return Zq(e, t, n) && Qq(e[i = +(e[0] === t[0])], n[i], t[i]);
}
function Zq(e, t, n) {
  return (t[0] - e[0]) * (n[1] - e[1]) === (n[0] - e[0]) * (t[1] - e[1]);
}
function Qq(e, t, n) {
  return e <= t && t <= n || n <= t && t <= e;
}
function tY() {
}
var Ar = [
  [],
  [[[1, 1.5], [0.5, 1]]],
  [[[1.5, 1], [1, 1.5]]],
  [[[1.5, 1], [0.5, 1]]],
  [[[1, 0.5], [1.5, 1]]],
  [[[1, 1.5], [0.5, 1]], [[1, 0.5], [1.5, 1]]],
  [[[1, 0.5], [1, 1.5]]],
  [[[1, 0.5], [0.5, 1]]],
  [[[0.5, 1], [1, 0.5]]],
  [[[1, 1.5], [1, 0.5]]],
  [[[0.5, 1], [1, 0.5]], [[1.5, 1], [1, 1.5]]],
  [[[1.5, 1], [1, 0.5]]],
  [[[0.5, 1], [1.5, 1]]],
  [[[1, 1.5], [1.5, 1]]],
  [[[0.5, 1], [1, 1.5]]],
  []
];
function rp() {
  var e = 1, t = 1, n = Vb, i = c;
  function r(l) {
    var u = n(l);
    if (Array.isArray(u))
      u = u.slice().sort(Gq);
    else {
      const f = ke(l, eY);
      for (u = Ys(...lM(f[0], f[1], u), u); u[u.length - 1] >= f[1]; )
        u.pop();
      for (; u[1] < f[0]; )
        u.shift();
    }
    return u.map((f) => s(l, f));
  }
  function s(l, u) {
    const f = u == null ? NaN : +u;
    if (isNaN(f))
      throw new Error(`invalid value: ${u}`);
    var h = [], d = [];
    return o(l, f, function(p) {
      i(p, l, f), Xq(p) > 0 ? h.push([p]) : d.push(p);
    }), d.forEach(function(p) {
      for (var y = 0, m = h.length, g; y < m; ++y)
        if (Hq((g = h[y])[0], p) !== -1) {
          g.push(p);
          return;
        }
    }), {
      type: "MultiPolygon",
      value: u,
      coordinates: h
    };
  }
  function o(l, u, f) {
    var h = new Array(), d = new Array(), p, y, m, g, b, w;
    for (p = y = -1, g = go(l[0], u), Ar[g << 1].forEach(v); ++p < e - 1; )
      m = g, g = go(l[p + 1], u), Ar[m | g << 1].forEach(v);
    for (Ar[g << 0].forEach(v); ++y < t - 1; ) {
      for (p = -1, g = go(l[y * e + e], u), b = go(l[y * e], u), Ar[g << 1 | b << 2].forEach(v); ++p < e - 1; )
        m = g, g = go(l[y * e + e + p + 1], u), w = b, b = go(l[y * e + p + 1], u), Ar[m | g << 1 | b << 2 | w << 3].forEach(v);
      Ar[g | b << 3].forEach(v);
    }
    for (p = -1, b = l[y * e] >= u, Ar[b << 2].forEach(v); ++p < e - 1; )
      w = b, b = go(l[y * e + p + 1], u), Ar[b << 2 | w << 3].forEach(v);
    Ar[b << 3].forEach(v);
    function v(S) {
      var _ = [S[0][0] + p, S[0][1] + y], I = [S[1][0] + p, S[1][1] + y], T = a(_), M = a(I), N, A;
      (N = d[T]) ? (A = h[M]) ? (delete d[N.end], delete h[A.start], N === A ? (N.ring.push(I), f(N.ring)) : h[N.start] = d[A.end] = { start: N.start, end: A.end, ring: N.ring.concat(A.ring) }) : (delete d[N.end], N.ring.push(I), d[N.end = M] = N) : (N = h[M]) ? (A = d[T]) ? (delete h[N.start], delete d[A.end], N === A ? (N.ring.push(I), f(N.ring)) : h[A.start] = d[N.end] = { start: A.start, end: N.end, ring: A.ring.concat(N.ring) }) : (delete h[N.start], N.ring.unshift(_), h[N.start = T] = N) : h[T] = d[M] = { start: T, end: M, ring: [_, I] };
    }
  }
  function a(l) {
    return l[0] * 2 + l[1] * (e + 1) * 4;
  }
  function c(l, u, f) {
    l.forEach(function(h) {
      var d = h[0], p = h[1], y = d | 0, m = p | 0, g = gm(u[m * e + y]);
      d > 0 && d < e && y === d && (h[0] = R2(d, gm(u[m * e + y - 1]), g, f)), p > 0 && p < t && m === p && (h[1] = R2(p, gm(u[(m - 1) * e + y]), g, f));
    });
  }
  return r.contour = s, r.size = function(l) {
    if (!arguments.length)
      return [e, t];
    var u = Math.floor(l[0]), f = Math.floor(l[1]);
    if (!(u >= 0 && f >= 0))
      throw new Error("invalid size");
    return e = u, t = f, r;
  }, r.thresholds = function(l) {
    return arguments.length ? (n = typeof l == "function" ? l : Array.isArray(l) ? Ts(QM.call(l)) : Ts(l), r) : n;
  }, r.smooth = function(l) {
    return arguments.length ? (i = l ? c : tY, r) : i === c;
  }, r;
}
function eY(e) {
  return isFinite(e) ? e : NaN;
}
function go(e, t) {
  return e == null ? !1 : +e >= t;
}
function gm(e) {
  return e == null || isNaN(e = +e) ? -1 / 0 : e;
}
function R2(e, t, n, i) {
  const r = i - t, s = n - t, o = isFinite(r) || isFinite(s) ? r / s : Math.sign(r) / Math.sign(s);
  return isNaN(o) ? e : e + o - 0.5;
}
function nY(e) {
  return e[0];
}
function iY(e) {
  return e[1];
}
function rY() {
  return 1;
}
function sY() {
  var e = nY, t = iY, n = rY, i = 960, r = 500, s = 20, o = 2, a = s * 3, c = i + a * 2 >> o, l = r + a * 2 >> o, u = Ts(20);
  function f(b) {
    var w = new Float32Array(c * l), v = Math.pow(2, -o), S = -1;
    for (const R of b) {
      var _ = (e(R, ++S, b) + a) * v, I = (t(R, S, b) + a) * v, T = +n(R, S, b);
      if (T && _ >= 0 && _ < c && I >= 0 && I < l) {
        var M = Math.floor(_), N = Math.floor(I), A = _ - M - 0.5, B = I - N - 0.5;
        w[M + N * c] += (1 - A) * (1 - B) * T, w[M + 1 + N * c] += A * (1 - B) * T, w[M + 1 + (N + 1) * c] += A * B * T, w[M + (N + 1) * c] += (1 - A) * B * T;
      }
    }
    return iM({ data: w, width: c, height: l }, s * v), w;
  }
  function h(b) {
    var w = f(b), v = u(w), S = Math.pow(2, 2 * o);
    return Array.isArray(v) || (v = Ys(Number.MIN_VALUE, De(w) / S, v)), rp().size([c, l]).thresholds(v.map((_) => _ * S))(w).map((_, I) => (_.value = +v[I], d(_)));
  }
  h.contours = function(b) {
    var w = f(b), v = rp().size([c, l]), S = Math.pow(2, 2 * o), _ = (I) => {
      I = +I;
      var T = d(v.contour(w, I * S));
      return T.value = I, T;
    };
    return Object.defineProperty(_, "max", { get: () => De(w) / S }), _;
  };
  function d(b) {
    return b.coordinates.forEach(p), b;
  }
  function p(b) {
    b.forEach(y);
  }
  function y(b) {
    b.forEach(m);
  }
  function m(b) {
    b[0] = b[0] * Math.pow(2, o) - a, b[1] = b[1] * Math.pow(2, o) - a;
  }
  function g() {
    return a = s * 3, c = i + a * 2 >> o, l = r + a * 2 >> o, h;
  }
  return h.x = function(b) {
    return arguments.length ? (e = typeof b == "function" ? b : Ts(+b), h) : e;
  }, h.y = function(b) {
    return arguments.length ? (t = typeof b == "function" ? b : Ts(+b), h) : t;
  }, h.weight = function(b) {
    return arguments.length ? (n = typeof b == "function" ? b : Ts(+b), h) : n;
  }, h.size = function(b) {
    if (!arguments.length)
      return [i, r];
    var w = +b[0], v = +b[1];
    if (!(w >= 0 && v >= 0))
      throw new Error("invalid size");
    return i = w, r = v, g();
  }, h.cellSize = function(b) {
    if (!arguments.length)
      return 1 << o;
    if (!((b = +b) >= 1))
      throw new Error("invalid cell size");
    return o = Math.floor(Math.log(b) / Math.LN2), g();
  }, h.thresholds = function(b) {
    return arguments.length ? (u = typeof b == "function" ? b : Array.isArray(b) ? Ts(QM.call(b)) : Ts(b), h) : u;
  }, h.bandwidth = function(b) {
    if (!arguments.length)
      return Math.sqrt(s * (s + 1));
    if (!((b = +b) >= 0))
      throw new Error("invalid bandwidth");
    return s = (Math.sqrt(4 * b * b + 1) - 1) / 2, g();
  }, h;
}
const Zr = 11102230246251565e-32, Ze = 134217729, oY = (3 + 8 * Zr) * Zr;
function bm(e, t, n, i, r) {
  let s, o, a, c, l = t[0], u = i[0], f = 0, h = 0;
  u > l == u > -l ? (s = l, l = t[++f]) : (s = u, u = i[++h]);
  let d = 0;
  if (f < e && h < n)
    for (u > l == u > -l ? (o = l + s, a = s - (o - l), l = t[++f]) : (o = u + s, a = s - (o - u), u = i[++h]), s = o, a !== 0 && (r[d++] = a); f < e && h < n; )
      u > l == u > -l ? (o = s + l, c = o - s, a = s - (o - c) + (l - c), l = t[++f]) : (o = s + u, c = o - s, a = s - (o - c) + (u - c), u = i[++h]), s = o, a !== 0 && (r[d++] = a);
  for (; f < e; )
    o = s + l, c = o - s, a = s - (o - c) + (l - c), l = t[++f], s = o, a !== 0 && (r[d++] = a);
  for (; h < n; )
    o = s + u, c = o - s, a = s - (o - c) + (u - c), u = i[++h], s = o, a !== 0 && (r[d++] = a);
  return (s !== 0 || d === 0) && (r[d++] = s), d;
}
function aY(e, t) {
  let n = t[0];
  for (let i = 1; i < e; i++)
    n += t[i];
  return n;
}
function vf(e) {
  return new Float64Array(e);
}
const cY = (3 + 16 * Zr) * Zr, lY = (2 + 12 * Zr) * Zr, uY = (9 + 64 * Zr) * Zr * Zr, _a = vf(4), C2 = vf(8), k2 = vf(12), U2 = vf(16), sn = vf(4);
function fY(e, t, n, i, r, s, o) {
  let a, c, l, u, f, h, d, p, y, m, g, b, w, v, S, _, I, T;
  const M = e - r, N = n - r, A = t - s, B = i - s;
  v = M * B, h = Ze * M, d = h - (h - M), p = M - d, h = Ze * B, y = h - (h - B), m = B - y, S = p * m - (v - d * y - p * y - d * m), _ = A * N, h = Ze * A, d = h - (h - A), p = A - d, h = Ze * N, y = h - (h - N), m = N - y, I = p * m - (_ - d * y - p * y - d * m), g = S - I, f = S - g, _a[0] = S - (g + f) + (f - I), b = v + g, f = b - v, w = v - (b - f) + (g - f), g = w - _, f = w - g, _a[1] = w - (g + f) + (f - _), T = b + g, f = T - b, _a[2] = b - (T - f) + (g - f), _a[3] = T;
  let R = aY(4, _a), x = lY * o;
  if (R >= x || -R >= x || (f = e - M, a = e - (M + f) + (f - r), f = n - N, l = n - (N + f) + (f - r), f = t - A, c = t - (A + f) + (f - s), f = i - B, u = i - (B + f) + (f - s), a === 0 && c === 0 && l === 0 && u === 0) || (x = uY * o + oY * Math.abs(R), R += M * u + B * a - (A * l + N * c), R >= x || -R >= x))
    return R;
  v = a * B, h = Ze * a, d = h - (h - a), p = a - d, h = Ze * B, y = h - (h - B), m = B - y, S = p * m - (v - d * y - p * y - d * m), _ = c * N, h = Ze * c, d = h - (h - c), p = c - d, h = Ze * N, y = h - (h - N), m = N - y, I = p * m - (_ - d * y - p * y - d * m), g = S - I, f = S - g, sn[0] = S - (g + f) + (f - I), b = v + g, f = b - v, w = v - (b - f) + (g - f), g = w - _, f = w - g, sn[1] = w - (g + f) + (f - _), T = b + g, f = T - b, sn[2] = b - (T - f) + (g - f), sn[3] = T;
  const $ = bm(4, _a, 4, sn, C2);
  v = M * u, h = Ze * M, d = h - (h - M), p = M - d, h = Ze * u, y = h - (h - u), m = u - y, S = p * m - (v - d * y - p * y - d * m), _ = A * l, h = Ze * A, d = h - (h - A), p = A - d, h = Ze * l, y = h - (h - l), m = l - y, I = p * m - (_ - d * y - p * y - d * m), g = S - I, f = S - g, sn[0] = S - (g + f) + (f - I), b = v + g, f = b - v, w = v - (b - f) + (g - f), g = w - _, f = w - g, sn[1] = w - (g + f) + (f - _), T = b + g, f = T - b, sn[2] = b - (T - f) + (g - f), sn[3] = T;
  const D = bm($, C2, 4, sn, k2);
  v = a * u, h = Ze * a, d = h - (h - a), p = a - d, h = Ze * u, y = h - (h - u), m = u - y, S = p * m - (v - d * y - p * y - d * m), _ = c * l, h = Ze * c, d = h - (h - c), p = c - d, h = Ze * l, y = h - (h - l), m = l - y, I = p * m - (_ - d * y - p * y - d * m), g = S - I, f = S - g, sn[0] = S - (g + f) + (f - I), b = v + g, f = b - v, w = v - (b - f) + (g - f), g = w - _, f = w - g, sn[1] = w - (g + f) + (f - _), T = b + g, f = T - b, sn[2] = b - (T - f) + (g - f), sn[3] = T;
  const L = bm(D, k2, 4, sn, U2);
  return U2[L - 1];
}
function lh(e, t, n, i, r, s) {
  const o = (t - s) * (n - r), a = (e - r) * (i - s), c = o - a, l = Math.abs(o + a);
  return Math.abs(c) >= cY * l ? c : -fY(e, t, n, i, r, s, l);
}
const z2 = Math.pow(2, -52), uh = new Uint32Array(512);
class sp {
  static from(t, n = mY, i = gY) {
    const r = t.length, s = new Float64Array(r * 2);
    for (let o = 0; o < r; o++) {
      const a = t[o];
      s[2 * o] = n(a), s[2 * o + 1] = i(a);
    }
    return new sp(s);
  }
  constructor(t) {
    const n = t.length >> 1;
    if (n > 0 && typeof t[0] != "number")
      throw new Error("Expected coords to contain numbers.");
    this.coords = t;
    const i = Math.max(2 * n - 5, 0);
    this._triangles = new Uint32Array(i * 3), this._halfedges = new Int32Array(i * 3), this._hashSize = Math.ceil(Math.sqrt(n)), this._hullPrev = new Uint32Array(n), this._hullNext = new Uint32Array(n), this._hullTri = new Uint32Array(n), this._hullHash = new Int32Array(this._hashSize), this._ids = new Uint32Array(n), this._dists = new Float64Array(n), this.update();
  }
  update() {
    const { coords: t, _hullPrev: n, _hullNext: i, _hullTri: r, _hullHash: s } = this, o = t.length >> 1;
    let a = 1 / 0, c = 1 / 0, l = -1 / 0, u = -1 / 0;
    for (let M = 0; M < o; M++) {
      const N = t[2 * M], A = t[2 * M + 1];
      N < a && (a = N), A < c && (c = A), N > l && (l = N), A > u && (u = A), this._ids[M] = M;
    }
    const f = (a + l) / 2, h = (c + u) / 2;
    let d, p, y;
    for (let M = 0, N = 1 / 0; M < o; M++) {
      const A = wm(f, h, t[2 * M], t[2 * M + 1]);
      A < N && (d = M, N = A);
    }
    const m = t[2 * d], g = t[2 * d + 1];
    for (let M = 0, N = 1 / 0; M < o; M++) {
      if (M === d)
        continue;
      const A = wm(m, g, t[2 * M], t[2 * M + 1]);
      A < N && A > 0 && (p = M, N = A);
    }
    let b = t[2 * p], w = t[2 * p + 1], v = 1 / 0;
    for (let M = 0; M < o; M++) {
      if (M === d || M === p)
        continue;
      const N = pY(m, g, b, w, t[2 * M], t[2 * M + 1]);
      N < v && (y = M, v = N);
    }
    let S = t[2 * y], _ = t[2 * y + 1];
    if (v === 1 / 0) {
      for (let A = 0; A < o; A++)
        this._dists[A] = t[2 * A] - t[0] || t[2 * A + 1] - t[1];
      Za(this._ids, this._dists, 0, o - 1);
      const M = new Uint32Array(o);
      let N = 0;
      for (let A = 0, B = -1 / 0; A < o; A++) {
        const R = this._ids[A], x = this._dists[R];
        x > B && (M[N++] = R, B = x);
      }
      this.hull = M.subarray(0, N), this.triangles = new Uint32Array(0), this.halfedges = new Uint32Array(0);
      return;
    }
    if (lh(m, g, b, w, S, _) < 0) {
      const M = p, N = b, A = w;
      p = y, b = S, w = _, y = M, S = N, _ = A;
    }
    const I = yY(m, g, b, w, S, _);
    this._cx = I.x, this._cy = I.y;
    for (let M = 0; M < o; M++)
      this._dists[M] = wm(t[2 * M], t[2 * M + 1], I.x, I.y);
    Za(this._ids, this._dists, 0, o - 1), this._hullStart = d;
    let T = 3;
    i[d] = n[y] = p, i[p] = n[d] = y, i[y] = n[p] = d, r[d] = 0, r[p] = 1, r[y] = 2, s.fill(-1), s[this._hashKey(m, g)] = d, s[this._hashKey(b, w)] = p, s[this._hashKey(S, _)] = y, this.trianglesLen = 0, this._addTriangle(d, p, y, -1, -1, -1);
    for (let M = 0, N, A; M < this._ids.length; M++) {
      const B = this._ids[M], R = t[2 * B], x = t[2 * B + 1];
      if (M > 0 && Math.abs(R - N) <= z2 && Math.abs(x - A) <= z2 || (N = R, A = x, B === d || B === p || B === y))
        continue;
      let $ = 0;
      for (let C = 0, z = this._hashKey(R, x); C < this._hashSize && ($ = s[(z + C) % this._hashSize], !($ !== -1 && $ !== i[$])); C++)
        ;
      $ = n[$];
      let D = $, L;
      for (; L = i[D], lh(R, x, t[2 * D], t[2 * D + 1], t[2 * L], t[2 * L + 1]) >= 0; )
        if (D = L, D === $) {
          D = -1;
          break;
        }
      if (D === -1)
        continue;
      let k = this._addTriangle(D, B, i[D], -1, -1, r[D]);
      r[B] = this._legalize(k + 2), r[D] = k, T++;
      let U = i[D];
      for (; L = i[U], lh(R, x, t[2 * U], t[2 * U + 1], t[2 * L], t[2 * L + 1]) < 0; )
        k = this._addTriangle(U, B, L, r[B], -1, r[U]), r[B] = this._legalize(k + 2), i[U] = U, T--, U = L;
      if (D === $)
        for (; L = n[D], lh(R, x, t[2 * L], t[2 * L + 1], t[2 * D], t[2 * D + 1]) < 0; )
          k = this._addTriangle(L, B, D, -1, r[D], r[L]), this._legalize(k + 2), r[L] = k, i[D] = D, T--, D = L;
      this._hullStart = n[B] = D, i[D] = n[U] = B, i[B] = U, s[this._hashKey(R, x)] = B, s[this._hashKey(t[2 * D], t[2 * D + 1])] = D;
    }
    this.hull = new Uint32Array(T);
    for (let M = 0, N = this._hullStart; M < T; M++)
      this.hull[M] = N, N = i[N];
    this.triangles = this._triangles.subarray(0, this.trianglesLen), this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
  }
  _hashKey(t, n) {
    return Math.floor(hY(t - this._cx, n - this._cy) * this._hashSize) % this._hashSize;
  }
  _legalize(t) {
    const { _triangles: n, _halfedges: i, coords: r } = this;
    let s = 0, o = 0;
    for (; ; ) {
      const a = i[t], c = t - t % 3;
      if (o = c + (t + 2) % 3, a === -1) {
        if (s === 0)
          break;
        t = uh[--s];
        continue;
      }
      const l = a - a % 3, u = c + (t + 1) % 3, f = l + (a + 2) % 3, h = n[o], d = n[t], p = n[u], y = n[f];
      if (dY(
        r[2 * h],
        r[2 * h + 1],
        r[2 * d],
        r[2 * d + 1],
        r[2 * p],
        r[2 * p + 1],
        r[2 * y],
        r[2 * y + 1]
      )) {
        n[t] = y, n[a] = h;
        const g = i[f];
        if (g === -1) {
          let w = this._hullStart;
          do {
            if (this._hullTri[w] === f) {
              this._hullTri[w] = t;
              break;
            }
            w = this._hullPrev[w];
          } while (w !== this._hullStart);
        }
        this._link(t, g), this._link(a, i[o]), this._link(o, f);
        const b = l + (a + 1) % 3;
        s < uh.length && (uh[s++] = b);
      } else {
        if (s === 0)
          break;
        t = uh[--s];
      }
    }
    return o;
  }
  _link(t, n) {
    this._halfedges[t] = n, n !== -1 && (this._halfedges[n] = t);
  }
  // add a new triangle given vertex indices and adjacent half-edge ids
  _addTriangle(t, n, i, r, s, o) {
    const a = this.trianglesLen;
    return this._triangles[a] = t, this._triangles[a + 1] = n, this._triangles[a + 2] = i, this._link(a, r), this._link(a + 1, s), this._link(a + 2, o), this.trianglesLen += 3, a;
  }
}
function hY(e, t) {
  const n = e / (Math.abs(e) + Math.abs(t));
  return (t > 0 ? 3 - n : 1 + n) / 4;
}
function wm(e, t, n, i) {
  const r = e - n, s = t - i;
  return r * r + s * s;
}
function dY(e, t, n, i, r, s, o, a) {
  const c = e - o, l = t - a, u = n - o, f = i - a, h = r - o, d = s - a, p = c * c + l * l, y = u * u + f * f, m = h * h + d * d;
  return c * (f * m - y * d) - l * (u * m - y * h) + p * (u * d - f * h) < 0;
}
function pY(e, t, n, i, r, s) {
  const o = n - e, a = i - t, c = r - e, l = s - t, u = o * o + a * a, f = c * c + l * l, h = 0.5 / (o * l - a * c), d = (l * u - a * f) * h, p = (o * f - c * u) * h;
  return d * d + p * p;
}
function yY(e, t, n, i, r, s) {
  const o = n - e, a = i - t, c = r - e, l = s - t, u = o * o + a * a, f = c * c + l * l, h = 0.5 / (o * l - a * c), d = e + (l * u - a * f) * h, p = t + (o * f - c * u) * h;
  return { x: d, y: p };
}
function Za(e, t, n, i) {
  if (i - n <= 20)
    for (let r = n + 1; r <= i; r++) {
      const s = e[r], o = t[s];
      let a = r - 1;
      for (; a >= n && t[e[a]] > o; )
        e[a + 1] = e[a--];
      e[a + 1] = s;
    }
  else {
    const r = n + i >> 1;
    let s = n + 1, o = i;
    Sl(e, r, s), t[e[n]] > t[e[i]] && Sl(e, n, i), t[e[s]] > t[e[i]] && Sl(e, s, i), t[e[n]] > t[e[s]] && Sl(e, n, s);
    const a = e[s], c = t[a];
    for (; ; ) {
      do
        s++;
      while (t[e[s]] < c);
      do
        o--;
      while (t[e[o]] > c);
      if (o < s)
        break;
      Sl(e, s, o);
    }
    e[n + 1] = e[o], e[o] = a, i - s + 1 >= o - n ? (Za(e, t, s, i), Za(e, t, n, o - 1)) : (Za(e, t, n, o - 1), Za(e, t, s, i));
  }
}
function Sl(e, t, n) {
  const i = e[t];
  e[t] = e[n], e[n] = i;
}
function mY(e) {
  return e[0];
}
function gY(e) {
  return e[1];
}
const P2 = 1e-6;
class Eo {
  constructor() {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "";
  }
  moveTo(t, n) {
    this._ += `M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._ += "Z");
  }
  lineTo(t, n) {
    this._ += `L${this._x1 = +t},${this._y1 = +n}`;
  }
  arc(t, n, i) {
    t = +t, n = +n, i = +i;
    const r = t + i, s = n;
    if (i < 0)
      throw new Error("negative radius");
    this._x1 === null ? this._ += `M${r},${s}` : (Math.abs(this._x1 - r) > P2 || Math.abs(this._y1 - s) > P2) && (this._ += "L" + r + "," + s), i && (this._ += `A${i},${i},0,1,1,${t - i},${n}A${i},${i},0,1,1,${this._x1 = r},${this._y1 = s}`);
  }
  rect(t, n, i, r) {
    this._ += `M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}h${+i}v${+r}h${-i}Z`;
  }
  value() {
    return this._ || null;
  }
}
class Qg {
  constructor() {
    this._ = [];
  }
  moveTo(t, n) {
    this._.push([t, n]);
  }
  closePath() {
    this._.push(this._[0].slice());
  }
  lineTo(t, n) {
    this._.push([t, n]);
  }
  value() {
    return this._.length ? this._ : null;
  }
}
let bY = class {
  constructor(t, [n, i, r, s] = [0, 0, 960, 500]) {
    if (!((r = +r) >= (n = +n)) || !((s = +s) >= (i = +i)))
      throw new Error("invalid bounds");
    this.delaunay = t, this._circumcenters = new Float64Array(t.points.length * 2), this.vectors = new Float64Array(t.points.length * 2), this.xmax = r, this.xmin = n, this.ymax = s, this.ymin = i, this._init();
  }
  update() {
    return this.delaunay.update(), this._init(), this;
  }
  _init() {
    const { delaunay: { points: t, hull: n, triangles: i }, vectors: r } = this;
    let s, o;
    const a = this.circumcenters = this._circumcenters.subarray(0, i.length / 3 * 2);
    for (let y = 0, m = 0, g = i.length, b, w; y < g; y += 3, m += 2) {
      const v = i[y] * 2, S = i[y + 1] * 2, _ = i[y + 2] * 2, I = t[v], T = t[v + 1], M = t[S], N = t[S + 1], A = t[_], B = t[_ + 1], R = M - I, x = N - T, $ = A - I, D = B - T, L = (R * D - x * $) * 2;
      if (Math.abs(L) < 1e-9) {
        if (s === void 0) {
          s = o = 0;
          for (const U of n)
            s += t[U * 2], o += t[U * 2 + 1];
          s /= n.length, o /= n.length;
        }
        const k = 1e9 * Math.sign((s - I) * D - (o - T) * $);
        b = (I + A) / 2 - k * D, w = (T + B) / 2 + k * $;
      } else {
        const k = 1 / L, U = R * R + x * x, C = $ * $ + D * D;
        b = I + (D * U - x * C) * k, w = T + (R * C - $ * U) * k;
      }
      a[m] = b, a[m + 1] = w;
    }
    let c = n[n.length - 1], l, u = c * 4, f, h = t[2 * c], d, p = t[2 * c + 1];
    r.fill(0);
    for (let y = 0; y < n.length; ++y)
      c = n[y], l = u, f = h, d = p, u = c * 4, h = t[2 * c], p = t[2 * c + 1], r[l + 2] = r[u] = d - p, r[l + 3] = r[u + 1] = h - f;
  }
  render(t) {
    const n = t == null ? t = new Eo() : void 0, { delaunay: { halfedges: i, inedges: r, hull: s }, circumcenters: o, vectors: a } = this;
    if (s.length <= 1)
      return null;
    for (let u = 0, f = i.length; u < f; ++u) {
      const h = i[u];
      if (h < u)
        continue;
      const d = Math.floor(u / 3) * 2, p = Math.floor(h / 3) * 2, y = o[d], m = o[d + 1], g = o[p], b = o[p + 1];
      this._renderSegment(y, m, g, b, t);
    }
    let c, l = s[s.length - 1];
    for (let u = 0; u < s.length; ++u) {
      c = l, l = s[u];
      const f = Math.floor(r[l] / 3) * 2, h = o[f], d = o[f + 1], p = c * 4, y = this._project(h, d, a[p + 2], a[p + 3]);
      y && this._renderSegment(h, d, y[0], y[1], t);
    }
    return n && n.value();
  }
  renderBounds(t) {
    const n = t == null ? t = new Eo() : void 0;
    return t.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin), n && n.value();
  }
  renderCell(t, n) {
    const i = n == null ? n = new Eo() : void 0, r = this._clip(t);
    if (r === null || !r.length)
      return;
    n.moveTo(r[0], r[1]);
    let s = r.length;
    for (; r[0] === r[s - 2] && r[1] === r[s - 1] && s > 1; )
      s -= 2;
    for (let o = 2; o < s; o += 2)
      (r[o] !== r[o - 2] || r[o + 1] !== r[o - 1]) && n.lineTo(r[o], r[o + 1]);
    return n.closePath(), i && i.value();
  }
  *cellPolygons() {
    const { delaunay: { points: t } } = this;
    for (let n = 0, i = t.length / 2; n < i; ++n) {
      const r = this.cellPolygon(n);
      r && (r.index = n, yield r);
    }
  }
  cellPolygon(t) {
    const n = new Qg();
    return this.renderCell(t, n), n.value();
  }
  _renderSegment(t, n, i, r, s) {
    let o;
    const a = this._regioncode(t, n), c = this._regioncode(i, r);
    a === 0 && c === 0 ? (s.moveTo(t, n), s.lineTo(i, r)) : (o = this._clipSegment(t, n, i, r, a, c)) && (s.moveTo(o[0], o[1]), s.lineTo(o[2], o[3]));
  }
  contains(t, n, i) {
    return n = +n, n !== n || (i = +i, i !== i) ? !1 : this.delaunay._step(t, n, i) === t;
  }
  *neighbors(t) {
    const n = this._clip(t);
    if (n)
      for (const i of this.delaunay.neighbors(t)) {
        const r = this._clip(i);
        if (r) {
          t:
            for (let s = 0, o = n.length; s < o; s += 2)
              for (let a = 0, c = r.length; a < c; a += 2)
                if (n[s] === r[a] && n[s + 1] === r[a + 1] && n[(s + 2) % o] === r[(a + c - 2) % c] && n[(s + 3) % o] === r[(a + c - 1) % c]) {
                  yield i;
                  break t;
                }
        }
      }
  }
  _cell(t) {
    const { circumcenters: n, delaunay: { inedges: i, halfedges: r, triangles: s } } = this, o = i[t];
    if (o === -1)
      return null;
    const a = [];
    let c = o;
    do {
      const l = Math.floor(c / 3);
      if (a.push(n[l * 2], n[l * 2 + 1]), c = c % 3 === 2 ? c - 2 : c + 1, s[c] !== t)
        break;
      c = r[c];
    } while (c !== o && c !== -1);
    return a;
  }
  _clip(t) {
    if (t === 0 && this.delaunay.hull.length === 1)
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    const n = this._cell(t);
    if (n === null)
      return null;
    const { vectors: i } = this, r = t * 4;
    return this._simplify(i[r] || i[r + 1] ? this._clipInfinite(t, n, i[r], i[r + 1], i[r + 2], i[r + 3]) : this._clipFinite(t, n));
  }
  _clipFinite(t, n) {
    const i = n.length;
    let r = null, s, o, a = n[i - 2], c = n[i - 1], l, u = this._regioncode(a, c), f, h = 0;
    for (let d = 0; d < i; d += 2)
      if (s = a, o = c, a = n[d], c = n[d + 1], l = u, u = this._regioncode(a, c), l === 0 && u === 0)
        f = h, h = 0, r ? r.push(a, c) : r = [a, c];
      else {
        let p, y, m, g, b;
        if (l === 0) {
          if ((p = this._clipSegment(s, o, a, c, l, u)) === null)
            continue;
          [y, m, g, b] = p;
        } else {
          if ((p = this._clipSegment(a, c, s, o, u, l)) === null)
            continue;
          [g, b, y, m] = p, f = h, h = this._edgecode(y, m), f && h && this._edge(t, f, h, r, r.length), r ? r.push(y, m) : r = [y, m];
        }
        f = h, h = this._edgecode(g, b), f && h && this._edge(t, f, h, r, r.length), r ? r.push(g, b) : r = [g, b];
      }
    if (r)
      f = h, h = this._edgecode(r[0], r[1]), f && h && this._edge(t, f, h, r, r.length);
    else if (this.contains(t, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2))
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    return r;
  }
  _clipSegment(t, n, i, r, s, o) {
    const a = s < o;
    for (a && ([t, n, i, r, s, o] = [i, r, t, n, o, s]); ; ) {
      if (s === 0 && o === 0)
        return a ? [i, r, t, n] : [t, n, i, r];
      if (s & o)
        return null;
      let c, l, u = s || o;
      u & 8 ? (c = t + (i - t) * (this.ymax - n) / (r - n), l = this.ymax) : u & 4 ? (c = t + (i - t) * (this.ymin - n) / (r - n), l = this.ymin) : u & 2 ? (l = n + (r - n) * (this.xmax - t) / (i - t), c = this.xmax) : (l = n + (r - n) * (this.xmin - t) / (i - t), c = this.xmin), s ? (t = c, n = l, s = this._regioncode(t, n)) : (i = c, r = l, o = this._regioncode(i, r));
    }
  }
  _clipInfinite(t, n, i, r, s, o) {
    let a = Array.from(n), c;
    if ((c = this._project(a[0], a[1], i, r)) && a.unshift(c[0], c[1]), (c = this._project(a[a.length - 2], a[a.length - 1], s, o)) && a.push(c[0], c[1]), a = this._clipFinite(t, a))
      for (let l = 0, u = a.length, f, h = this._edgecode(a[u - 2], a[u - 1]); l < u; l += 2)
        f = h, h = this._edgecode(a[l], a[l + 1]), f && h && (l = this._edge(t, f, h, a, l), u = a.length);
    else
      this.contains(t, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2) && (a = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax]);
    return a;
  }
  _edge(t, n, i, r, s) {
    for (; n !== i; ) {
      let o, a;
      switch (n) {
        case 5:
          n = 4;
          continue;
        case 4:
          n = 6, o = this.xmax, a = this.ymin;
          break;
        case 6:
          n = 2;
          continue;
        case 2:
          n = 10, o = this.xmax, a = this.ymax;
          break;
        case 10:
          n = 8;
          continue;
        case 8:
          n = 9, o = this.xmin, a = this.ymax;
          break;
        case 9:
          n = 1;
          continue;
        case 1:
          n = 5, o = this.xmin, a = this.ymin;
          break;
      }
      (r[s] !== o || r[s + 1] !== a) && this.contains(t, o, a) && (r.splice(s, 0, o, a), s += 2);
    }
    return s;
  }
  _project(t, n, i, r) {
    let s = 1 / 0, o, a, c;
    if (r < 0) {
      if (n <= this.ymin)
        return null;
      (o = (this.ymin - n) / r) < s && (c = this.ymin, a = t + (s = o) * i);
    } else if (r > 0) {
      if (n >= this.ymax)
        return null;
      (o = (this.ymax - n) / r) < s && (c = this.ymax, a = t + (s = o) * i);
    }
    if (i > 0) {
      if (t >= this.xmax)
        return null;
      (o = (this.xmax - t) / i) < s && (a = this.xmax, c = n + (s = o) * r);
    } else if (i < 0) {
      if (t <= this.xmin)
        return null;
      (o = (this.xmin - t) / i) < s && (a = this.xmin, c = n + (s = o) * r);
    }
    return [a, c];
  }
  _edgecode(t, n) {
    return (t === this.xmin ? 1 : t === this.xmax ? 2 : 0) | (n === this.ymin ? 4 : n === this.ymax ? 8 : 0);
  }
  _regioncode(t, n) {
    return (t < this.xmin ? 1 : t > this.xmax ? 2 : 0) | (n < this.ymin ? 4 : n > this.ymax ? 8 : 0);
  }
  _simplify(t) {
    if (t && t.length > 4) {
      for (let n = 0; n < t.length; n += 2) {
        const i = (n + 2) % t.length, r = (n + 4) % t.length;
        (t[n] === t[i] && t[i] === t[r] || t[n + 1] === t[i + 1] && t[i + 1] === t[r + 1]) && (t.splice(i, 2), n -= 2);
      }
      t.length || (t = null);
    }
    return t;
  }
};
const wY = 2 * Math.PI, Sa = Math.pow;
function vY(e) {
  return e[0];
}
function _Y(e) {
  return e[1];
}
function SY(e) {
  const { triangles: t, coords: n } = e;
  for (let i = 0; i < t.length; i += 3) {
    const r = 2 * t[i], s = 2 * t[i + 1], o = 2 * t[i + 2];
    if ((n[o] - n[r]) * (n[s + 1] - n[r + 1]) - (n[s] - n[r]) * (n[o + 1] - n[r + 1]) > 1e-10)
      return !1;
  }
  return !0;
}
function xY(e, t, n) {
  return [e + Math.sin(e + t) * n, t + Math.cos(e - t) * n];
}
class oo {
  static from(t, n = vY, i = _Y, r) {
    return new oo("length" in t ? IY(t, n, i, r) : Float64Array.from(AY(t, n, i, r)));
  }
  constructor(t) {
    this._delaunator = new sp(t), this.inedges = new Int32Array(t.length / 2), this._hullIndex = new Int32Array(t.length / 2), this.points = this._delaunator.coords, this._init();
  }
  update() {
    return this._delaunator.update(), this._init(), this;
  }
  _init() {
    const t = this._delaunator, n = this.points;
    if (t.hull && t.hull.length > 2 && SY(t)) {
      this.collinear = Int32Array.from({ length: n.length / 2 }, (h, d) => d).sort((h, d) => n[2 * h] - n[2 * d] || n[2 * h + 1] - n[2 * d + 1]);
      const c = this.collinear[0], l = this.collinear[this.collinear.length - 1], u = [n[2 * c], n[2 * c + 1], n[2 * l], n[2 * l + 1]], f = 1e-8 * Math.hypot(u[3] - u[1], u[2] - u[0]);
      for (let h = 0, d = n.length / 2; h < d; ++h) {
        const p = xY(n[2 * h], n[2 * h + 1], f);
        n[2 * h] = p[0], n[2 * h + 1] = p[1];
      }
      this._delaunator = new sp(n);
    } else
      delete this.collinear;
    const i = this.halfedges = this._delaunator.halfedges, r = this.hull = this._delaunator.hull, s = this.triangles = this._delaunator.triangles, o = this.inedges.fill(-1), a = this._hullIndex.fill(-1);
    for (let c = 0, l = i.length; c < l; ++c) {
      const u = s[c % 3 === 2 ? c - 2 : c + 1];
      (i[c] === -1 || o[u] === -1) && (o[u] = c);
    }
    for (let c = 0, l = r.length; c < l; ++c)
      a[r[c]] = c;
    r.length <= 2 && r.length > 0 && (this.triangles = new Int32Array(3).fill(-1), this.halfedges = new Int32Array(3).fill(-1), this.triangles[0] = r[0], o[r[0]] = 1, r.length === 2 && (o[r[1]] = 0, this.triangles[1] = r[1], this.triangles[2] = r[1]));
  }
  voronoi(t) {
    return new bY(this, t);
  }
  *neighbors(t) {
    const { inedges: n, hull: i, _hullIndex: r, halfedges: s, triangles: o, collinear: a } = this;
    if (a) {
      const f = a.indexOf(t);
      f > 0 && (yield a[f - 1]), f < a.length - 1 && (yield a[f + 1]);
      return;
    }
    const c = n[t];
    if (c === -1)
      return;
    let l = c, u = -1;
    do {
      if (yield u = o[l], l = l % 3 === 2 ? l - 2 : l + 1, o[l] !== t)
        return;
      if (l = s[l], l === -1) {
        const f = i[(r[t] + 1) % i.length];
        f !== u && (yield f);
        return;
      }
    } while (l !== c);
  }
  find(t, n, i = 0) {
    if (t = +t, t !== t || (n = +n, n !== n))
      return -1;
    const r = i;
    let s;
    for (; (s = this._step(i, t, n)) >= 0 && s !== i && s !== r; )
      i = s;
    return s;
  }
  _step(t, n, i) {
    const { inedges: r, hull: s, _hullIndex: o, halfedges: a, triangles: c, points: l } = this;
    if (r[t] === -1 || !l.length)
      return (t + 1) % (l.length >> 1);
    let u = t, f = Sa(n - l[t * 2], 2) + Sa(i - l[t * 2 + 1], 2);
    const h = r[t];
    let d = h;
    do {
      let p = c[d];
      const y = Sa(n - l[p * 2], 2) + Sa(i - l[p * 2 + 1], 2);
      if (y < f && (f = y, u = p), d = d % 3 === 2 ? d - 2 : d + 1, c[d] !== t)
        break;
      if (d = a[d], d === -1) {
        if (d = s[(o[t] + 1) % s.length], d !== p && Sa(n - l[d * 2], 2) + Sa(i - l[d * 2 + 1], 2) < f)
          return d;
        break;
      }
    } while (d !== h);
    return u;
  }
  render(t) {
    const n = t == null ? t = new Eo() : void 0, { points: i, halfedges: r, triangles: s } = this;
    for (let o = 0, a = r.length; o < a; ++o) {
      const c = r[o];
      if (c < o)
        continue;
      const l = s[o] * 2, u = s[c] * 2;
      t.moveTo(i[l], i[l + 1]), t.lineTo(i[u], i[u + 1]);
    }
    return this.renderHull(t), n && n.value();
  }
  renderPoints(t, n) {
    n === void 0 && (!t || typeof t.moveTo != "function") && (n = t, t = null), n = n == null ? 2 : +n;
    const i = t == null ? t = new Eo() : void 0, { points: r } = this;
    for (let s = 0, o = r.length; s < o; s += 2) {
      const a = r[s], c = r[s + 1];
      t.moveTo(a + n, c), t.arc(a, c, n, 0, wY);
    }
    return i && i.value();
  }
  renderHull(t) {
    const n = t == null ? t = new Eo() : void 0, { hull: i, points: r } = this, s = i[0] * 2, o = i.length;
    t.moveTo(r[s], r[s + 1]);
    for (let a = 1; a < o; ++a) {
      const c = 2 * i[a];
      t.lineTo(r[c], r[c + 1]);
    }
    return t.closePath(), n && n.value();
  }
  hullPolygon() {
    const t = new Qg();
    return this.renderHull(t), t.value();
  }
  renderTriangle(t, n) {
    const i = n == null ? n = new Eo() : void 0, { points: r, triangles: s } = this, o = s[t *= 3] * 2, a = s[t + 1] * 2, c = s[t + 2] * 2;
    return n.moveTo(r[o], r[o + 1]), n.lineTo(r[a], r[a + 1]), n.lineTo(r[c], r[c + 1]), n.closePath(), i && i.value();
  }
  *trianglePolygons() {
    const { triangles: t } = this;
    for (let n = 0, i = t.length / 3; n < i; ++n)
      yield this.trianglePolygon(n);
  }
  trianglePolygon(t) {
    const n = new Qg();
    return this.renderTriangle(t, n), n.value();
  }
}
function IY(e, t, n, i) {
  const r = e.length, s = new Float64Array(r * 2);
  for (let o = 0; o < r; ++o) {
    const a = e[o];
    s[o * 2] = t.call(i, a, o, e), s[o * 2 + 1] = n.call(i, a, o, e);
  }
  return s;
}
function* AY(e, t, n, i) {
  let r = 0;
  for (const s of e)
    yield t.call(i, s, r, e), yield n.call(i, s, r, e), ++r;
}
function MY(e) {
  return Math.abs(e = Math.round(e)) >= 1e21 ? e.toLocaleString("en").replace(/,/g, "") : e.toString(10);
}
function op(e, t) {
  if ((n = (e = t ? e.toExponential(t - 1) : e.toExponential()).indexOf("e")) < 0)
    return null;
  var n, i = e.slice(0, n);
  return [
    i.length > 1 ? i[0] + i.slice(2) : i,
    +e.slice(n + 1)
  ];
}
function Oc(e) {
  return e = op(Math.abs(e)), e ? e[1] : NaN;
}
function $Y(e, t) {
  return function(n, i) {
    for (var r = n.length, s = [], o = 0, a = e[0], c = 0; r > 0 && a > 0 && (c + a + 1 > i && (a = Math.max(1, i - c)), s.push(n.substring(r -= a, r + a)), !((c += a + 1) > i)); )
      a = e[o = (o + 1) % e.length];
    return s.reverse().join(t);
  };
}
function TY(e) {
  return function(t) {
    return t.replace(/[0-9]/g, function(n) {
      return e[+n];
    });
  };
}
var DY = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function Ru(e) {
  if (!(t = DY.exec(e)))
    throw new Error("invalid format: " + e);
  var t;
  return new nw({
    fill: t[1],
    align: t[2],
    sign: t[3],
    symbol: t[4],
    zero: t[5],
    width: t[6],
    comma: t[7],
    precision: t[8] && t[8].slice(1),
    trim: t[9],
    type: t[10]
  });
}
Ru.prototype = nw.prototype;
function nw(e) {
  this.fill = e.fill === void 0 ? " " : e.fill + "", this.align = e.align === void 0 ? ">" : e.align + "", this.sign = e.sign === void 0 ? "-" : e.sign + "", this.symbol = e.symbol === void 0 ? "" : e.symbol + "", this.zero = !!e.zero, this.width = e.width === void 0 ? void 0 : +e.width, this.comma = !!e.comma, this.precision = e.precision === void 0 ? void 0 : +e.precision, this.trim = !!e.trim, this.type = e.type === void 0 ? "" : e.type + "";
}
nw.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function NY(e) {
  t:
    for (var t = e.length, n = 1, i = -1, r; n < t; ++n)
      switch (e[n]) {
        case ".":
          i = r = n;
          break;
        case "0":
          i === 0 && (i = n), r = n;
          break;
        default:
          if (!+e[n])
            break t;
          i > 0 && (i = 0);
          break;
      }
  return i > 0 ? e.slice(0, i) + e.slice(r + 1) : e;
}
var t$;
function BY(e, t) {
  var n = op(e, t);
  if (!n)
    return e + "";
  var i = n[0], r = n[1], s = r - (t$ = Math.max(-8, Math.min(8, Math.floor(r / 3))) * 3) + 1, o = i.length;
  return s === o ? i : s > o ? i + new Array(s - o + 1).join("0") : s > 0 ? i.slice(0, s) + "." + i.slice(s) : "0." + new Array(1 - s).join("0") + op(e, Math.max(0, t + s - 1))[0];
}
function V2(e, t) {
  var n = op(e, t);
  if (!n)
    return e + "";
  var i = n[0], r = n[1];
  return r < 0 ? "0." + new Array(-r).join("0") + i : i.length > r + 1 ? i.slice(0, r + 1) + "." + i.slice(r + 1) : i + new Array(r - i.length + 2).join("0");
}
const j2 = {
  "%": (e, t) => (e * 100).toFixed(t),
  b: (e) => Math.round(e).toString(2),
  c: (e) => e + "",
  d: MY,
  e: (e, t) => e.toExponential(t),
  f: (e, t) => e.toFixed(t),
  g: (e, t) => e.toPrecision(t),
  o: (e) => Math.round(e).toString(8),
  p: (e, t) => V2(e * 100, t),
  r: V2,
  s: BY,
  X: (e) => Math.round(e).toString(16).toUpperCase(),
  x: (e) => Math.round(e).toString(16)
};
function q2(e) {
  return e;
}
var Y2 = Array.prototype.map, W2 = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function OY(e) {
  var t = e.grouping === void 0 || e.thousands === void 0 ? q2 : $Y(Y2.call(e.grouping, Number), e.thousands + ""), n = e.currency === void 0 ? "" : e.currency[0] + "", i = e.currency === void 0 ? "" : e.currency[1] + "", r = e.decimal === void 0 ? "." : e.decimal + "", s = e.numerals === void 0 ? q2 : TY(Y2.call(e.numerals, String)), o = e.percent === void 0 ? "%" : e.percent + "", a = e.minus === void 0 ? "" : e.minus + "", c = e.nan === void 0 ? "NaN" : e.nan + "";
  function l(f) {
    f = Ru(f);
    var h = f.fill, d = f.align, p = f.sign, y = f.symbol, m = f.zero, g = f.width, b = f.comma, w = f.precision, v = f.trim, S = f.type;
    S === "n" ? (b = !0, S = "g") : j2[S] || (w === void 0 && (w = 12), v = !0, S = "g"), (m || h === "0" && d === "=") && (m = !0, h = "0", d = "=");
    var _ = y === "$" ? n : y === "#" && /[boxX]/.test(S) ? "0" + S.toLowerCase() : "", I = y === "$" ? i : /[%p]/.test(S) ? o : "", T = j2[S], M = /[defgprs%]/.test(S);
    w = w === void 0 ? 6 : /[gprs]/.test(S) ? Math.max(1, Math.min(21, w)) : Math.max(0, Math.min(20, w));
    function N(A) {
      var B = _, R = I, x, $, D;
      if (S === "c")
        R = T(A) + R, A = "";
      else {
        A = +A;
        var L = A < 0 || 1 / A < 0;
        if (A = isNaN(A) ? c : T(Math.abs(A), w), v && (A = NY(A)), L && +A == 0 && p !== "+" && (L = !1), B = (L ? p === "(" ? p : a : p === "-" || p === "(" ? "" : p) + B, R = (S === "s" ? W2[8 + t$ / 3] : "") + R + (L && p === "(" ? ")" : ""), M) {
          for (x = -1, $ = A.length; ++x < $; )
            if (D = A.charCodeAt(x), 48 > D || D > 57) {
              R = (D === 46 ? r + A.slice(x + 1) : A.slice(x)) + R, A = A.slice(0, x);
              break;
            }
        }
      }
      b && !m && (A = t(A, 1 / 0));
      var k = B.length + A.length + R.length, U = k < g ? new Array(g - k + 1).join(h) : "";
      switch (b && m && (A = t(U + A, U.length ? g - R.length : 1 / 0), U = ""), d) {
        case "<":
          A = B + A + R + U;
          break;
        case "=":
          A = B + U + A + R;
          break;
        case "^":
          A = U.slice(0, k = U.length >> 1) + B + A + R + U.slice(k);
          break;
        default:
          A = U + B + A + R;
          break;
      }
      return s(A);
    }
    return N.toString = function() {
      return f + "";
    }, N;
  }
  function u(f, h) {
    var d = l((f = Ru(f), f.type = "f", f)), p = Math.max(-8, Math.min(8, Math.floor(Oc(h) / 3))) * 3, y = Math.pow(10, -p), m = W2[8 + p / 3];
    return function(g) {
      return d(y * g) + m;
    };
  }
  return {
    format: l,
    formatPrefix: u
  };
}
var fh, rl, e$;
FY({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function FY(e) {
  return fh = OY(e), rl = fh.format, e$ = fh.formatPrefix, fh;
}
function EY(e) {
  return Math.max(0, -Oc(Math.abs(e)));
}
function LY(e, t) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(Oc(t) / 3))) * 3 - Oc(Math.abs(e)));
}
function RY(e, t) {
  return e = Math.abs(e), t = Math.abs(t) - e, Math.max(0, Oc(t) - Oc(e)) + 1;
}
var wt = 1e-6, ap = 1e-12, kt = Math.PI, $e = kt / 2, G2 = kt / 4, jn = kt * 2, Xe = 180 / kt, Xt = kt / 180, Jt = Math.abs, sl = Math.atan, Di = Math.atan2, $t = Math.cos, hh = Math.ceil, n$ = Math.exp, t1 = Math.hypot, cp = Math.log, vm = Math.pow, at = Math.sin, ri = Math.sign || function(e) {
  return e > 0 ? 1 : e < 0 ? -1 : 0;
}, yn = Math.sqrt, iw = Math.tan;
function i$(e) {
  return e > 1 ? 0 : e < -1 ? kt : Math.acos(e);
}
function Dn(e) {
  return e > 1 ? $e : e < -1 ? -$e : Math.asin(e);
}
function Un() {
}
function lp(e, t) {
  e && H2.hasOwnProperty(e.type) && H2[e.type](e, t);
}
var X2 = {
  Feature: function(e, t) {
    lp(e.geometry, t);
  },
  FeatureCollection: function(e, t) {
    for (var n = e.features, i = -1, r = n.length; ++i < r; )
      lp(n[i].geometry, t);
  }
}, H2 = {
  Sphere: function(e, t) {
    t.sphere();
  },
  Point: function(e, t) {
    e = e.coordinates, t.point(e[0], e[1], e[2]);
  },
  MultiPoint: function(e, t) {
    for (var n = e.coordinates, i = -1, r = n.length; ++i < r; )
      e = n[i], t.point(e[0], e[1], e[2]);
  },
  LineString: function(e, t) {
    e1(e.coordinates, t, 0);
  },
  MultiLineString: function(e, t) {
    for (var n = e.coordinates, i = -1, r = n.length; ++i < r; )
      e1(n[i], t, 0);
  },
  Polygon: function(e, t) {
    J2(e.coordinates, t);
  },
  MultiPolygon: function(e, t) {
    for (var n = e.coordinates, i = -1, r = n.length; ++i < r; )
      J2(n[i], t);
  },
  GeometryCollection: function(e, t) {
    for (var n = e.geometries, i = -1, r = n.length; ++i < r; )
      lp(n[i], t);
  }
};
function e1(e, t, n) {
  var i = -1, r = e.length - n, s;
  for (t.lineStart(); ++i < r; )
    s = e[i], t.point(s[0], s[1], s[2]);
  t.lineEnd();
}
function J2(e, t) {
  var n = -1, i = e.length;
  for (t.polygonStart(); ++n < i; )
    e1(e[n], t, 1);
  t.polygonEnd();
}
function Bs(e, t) {
  e && X2.hasOwnProperty(e.type) ? X2[e.type](e, t) : lp(e, t);
}
function n1(e) {
  return [Di(e[1], e[0]), Dn(e[2])];
}
function Fc(e) {
  var t = e[0], n = e[1], i = $t(n);
  return [i * $t(t), i * at(t), at(n)];
}
function dh(e, t) {
  return e[0] * t[0] + e[1] * t[1] + e[2] * t[2];
}
function up(e, t) {
  return [e[1] * t[2] - e[2] * t[1], e[2] * t[0] - e[0] * t[2], e[0] * t[1] - e[1] * t[0]];
}
function _m(e, t) {
  e[0] += t[0], e[1] += t[1], e[2] += t[2];
}
function ph(e, t) {
  return [e[0] * t, e[1] * t, e[2] * t];
}
function i1(e) {
  var t = yn(e[0] * e[0] + e[1] * e[1] + e[2] * e[2]);
  e[0] /= t, e[1] /= t, e[2] /= t;
}
var Wl, fp, hp, dp, pp, yp, mp, gp, r1, s1, o1, r$, s$, cn, ln, un, Si = {
  sphere: Un,
  point: rw,
  lineStart: K2,
  lineEnd: Z2,
  polygonStart: function() {
    Si.lineStart = UY, Si.lineEnd = zY;
  },
  polygonEnd: function() {
    Si.lineStart = K2, Si.lineEnd = Z2;
  }
};
function rw(e, t) {
  e *= Xt, t *= Xt;
  var n = $t(t);
  _f(n * $t(e), n * at(e), at(t));
}
function _f(e, t, n) {
  ++Wl, hp += (e - hp) / Wl, dp += (t - dp) / Wl, pp += (n - pp) / Wl;
}
function K2() {
  Si.point = CY;
}
function CY(e, t) {
  e *= Xt, t *= Xt;
  var n = $t(t);
  cn = n * $t(e), ln = n * at(e), un = at(t), Si.point = kY, _f(cn, ln, un);
}
function kY(e, t) {
  e *= Xt, t *= Xt;
  var n = $t(t), i = n * $t(e), r = n * at(e), s = at(t), o = Di(yn((o = ln * s - un * r) * o + (o = un * i - cn * s) * o + (o = cn * r - ln * i) * o), cn * i + ln * r + un * s);
  fp += o, yp += o * (cn + (cn = i)), mp += o * (ln + (ln = r)), gp += o * (un + (un = s)), _f(cn, ln, un);
}
function Z2() {
  Si.point = rw;
}
function UY() {
  Si.point = PY;
}
function zY() {
  o$(r$, s$), Si.point = rw;
}
function PY(e, t) {
  r$ = e, s$ = t, e *= Xt, t *= Xt, Si.point = o$;
  var n = $t(t);
  cn = n * $t(e), ln = n * at(e), un = at(t), _f(cn, ln, un);
}
function o$(e, t) {
  e *= Xt, t *= Xt;
  var n = $t(t), i = n * $t(e), r = n * at(e), s = at(t), o = ln * s - un * r, a = un * i - cn * s, c = cn * r - ln * i, l = t1(o, a, c), u = Dn(l), f = l && -u / l;
  r1.add(f * o), s1.add(f * a), o1.add(f * c), fp += u, yp += u * (cn + (cn = i)), mp += u * (ln + (ln = r)), gp += u * (un + (un = s)), _f(cn, ln, un);
}
function VY(e) {
  Wl = fp = hp = dp = pp = yp = mp = gp = 0, r1 = new sr(), s1 = new sr(), o1 = new sr(), Bs(e, Si);
  var t = +r1, n = +s1, i = +o1, r = t1(t, n, i);
  return r < ap && (t = yp, n = mp, i = gp, fp < wt && (t = hp, n = dp, i = pp), r = t1(t, n, i), r < ap) ? [NaN, NaN] : [Di(n, t) * Xe, Dn(i / r) * Xe];
}
function a1(e, t) {
  function n(i, r) {
    return i = e(i, r), t(i[0], i[1]);
  }
  return e.invert && t.invert && (n.invert = function(i, r) {
    return i = t.invert(i, r), i && e.invert(i[0], i[1]);
  }), n;
}
function c1(e, t) {
  return Jt(e) > kt && (e -= Math.round(e / jn) * jn), [e, t];
}
c1.invert = c1;
function a$(e, t, n) {
  return (e %= jn) ? t || n ? a1(tS(e), eS(t, n)) : tS(e) : t || n ? eS(t, n) : c1;
}
function Q2(e) {
  return function(t, n) {
    return t += e, Jt(t) > kt && (t -= Math.round(t / jn) * jn), [t, n];
  };
}
function tS(e) {
  var t = Q2(e);
  return t.invert = Q2(-e), t;
}
function eS(e, t) {
  var n = $t(e), i = at(e), r = $t(t), s = at(t);
  function o(a, c) {
    var l = $t(c), u = $t(a) * l, f = at(a) * l, h = at(c), d = h * n + u * i;
    return [
      Di(f * r - d * s, u * n - h * i),
      Dn(d * r + f * s)
    ];
  }
  return o.invert = function(a, c) {
    var l = $t(c), u = $t(a) * l, f = at(a) * l, h = at(c), d = h * r - f * s;
    return [
      Di(f * r + h * s, u * n + d * i),
      Dn(d * n - u * i)
    ];
  }, o;
}
function jY(e) {
  e = a$(e[0] * Xt, e[1] * Xt, e.length > 2 ? e[2] * Xt : 0);
  function t(n) {
    return n = e(n[0] * Xt, n[1] * Xt), n[0] *= Xe, n[1] *= Xe, n;
  }
  return t.invert = function(n) {
    return n = e.invert(n[0] * Xt, n[1] * Xt), n[0] *= Xe, n[1] *= Xe, n;
  }, t;
}
function qY(e, t, n, i, r, s) {
  if (n) {
    var o = $t(t), a = at(t), c = i * n;
    r == null ? (r = t + i * jn, s = t - c / 2) : (r = nS(o, r), s = nS(o, s), (i > 0 ? r < s : r > s) && (r += i * jn));
    for (var l, u = r; i > 0 ? u > s : u < s; u -= c)
      l = n1([o, -a * $t(u), -a * at(u)]), e.point(l[0], l[1]);
  }
}
function nS(e, t) {
  t = Fc(t), t[0] -= e, i1(t);
  var n = i$(-t[1]);
  return ((-t[2] < 0 ? -n : n) + jn - wt) % jn;
}
function c$() {
  var e = [], t;
  return {
    point: function(n, i, r) {
      t.push([n, i, r]);
    },
    lineStart: function() {
      e.push(t = []);
    },
    lineEnd: Un,
    rejoin: function() {
      e.length > 1 && e.push(e.pop().concat(e.shift()));
    },
    result: function() {
      var n = e;
      return e = [], t = null, n;
    }
  };
}
function id(e, t) {
  return Jt(e[0] - t[0]) < wt && Jt(e[1] - t[1]) < wt;
}
function yh(e, t, n, i) {
  this.x = e, this.z = t, this.o = n, this.e = i, this.v = !1, this.n = this.p = null;
}
function l$(e, t, n, i, r) {
  var s = [], o = [], a, c;
  if (e.forEach(function(p) {
    if (!((y = p.length - 1) <= 0)) {
      var y, m = p[0], g = p[y], b;
      if (id(m, g)) {
        if (!m[2] && !g[2]) {
          for (r.lineStart(), a = 0; a < y; ++a)
            r.point((m = p[a])[0], m[1]);
          r.lineEnd();
          return;
        }
        g[0] += 2 * wt;
      }
      s.push(b = new yh(m, p, null, !0)), o.push(b.o = new yh(m, null, b, !1)), s.push(b = new yh(g, p, null, !1)), o.push(b.o = new yh(g, null, b, !0));
    }
  }), !!s.length) {
    for (o.sort(t), iS(s), iS(o), a = 0, c = o.length; a < c; ++a)
      o[a].e = n = !n;
    for (var l = s[0], u, f; ; ) {
      for (var h = l, d = !0; h.v; )
        if ((h = h.n) === l)
          return;
      u = h.z, r.lineStart();
      do {
        if (h.v = h.o.v = !0, h.e) {
          if (d)
            for (a = 0, c = u.length; a < c; ++a)
              r.point((f = u[a])[0], f[1]);
          else
            i(h.x, h.n.x, 1, r);
          h = h.n;
        } else {
          if (d)
            for (u = h.p.z, a = u.length - 1; a >= 0; --a)
              r.point((f = u[a])[0], f[1]);
          else
            i(h.x, h.p.x, -1, r);
          h = h.p;
        }
        h = h.o, u = h.z, d = !d;
      } while (!h.v);
      r.lineEnd();
    }
  }
}
function iS(e) {
  if (t = e.length) {
    for (var t, n = 0, i = e[0], r; ++n < t; )
      i.n = r = e[n], r.p = i, i = r;
    i.n = r = e[0], r.p = i;
  }
}
function Sm(e) {
  return Jt(e[0]) <= kt ? e[0] : ri(e[0]) * ((Jt(e[0]) + kt) % jn - kt);
}
function YY(e, t) {
  var n = Sm(t), i = t[1], r = at(i), s = [at(n), -$t(n), 0], o = 0, a = 0, c = new sr();
  r === 1 ? i = $e + wt : r === -1 && (i = -$e - wt);
  for (var l = 0, u = e.length; l < u; ++l)
    if (h = (f = e[l]).length)
      for (var f, h, d = f[h - 1], p = Sm(d), y = d[1] / 2 + G2, m = at(y), g = $t(y), b = 0; b < h; ++b, p = v, m = _, g = I, d = w) {
        var w = f[b], v = Sm(w), S = w[1] / 2 + G2, _ = at(S), I = $t(S), T = v - p, M = T >= 0 ? 1 : -1, N = M * T, A = N > kt, B = m * _;
        if (c.add(Di(B * M * at(N), g * I + B * $t(N))), o += A ? T + M * jn : T, A ^ p >= n ^ v >= n) {
          var R = up(Fc(d), Fc(w));
          i1(R);
          var x = up(s, R);
          i1(x);
          var $ = (A ^ T >= 0 ? -1 : 1) * Dn(x[2]);
          (i > $ || i === $ && (R[0] || R[1])) && (a += A ^ T >= 0 ? 1 : -1);
        }
      }
  return (o < -wt || o < wt && c < -ap) ^ a & 1;
}
function u$(e, t, n, i) {
  return function(r) {
    var s = t(r), o = c$(), a = t(o), c = !1, l, u, f, h = {
      point: d,
      lineStart: y,
      lineEnd: m,
      polygonStart: function() {
        h.point = g, h.lineStart = b, h.lineEnd = w, u = [], l = [];
      },
      polygonEnd: function() {
        h.point = d, h.lineStart = y, h.lineEnd = m, u = hM(u);
        var v = YY(l, i);
        u.length ? (c || (r.polygonStart(), c = !0), l$(u, GY, v, n, r)) : v && (c || (r.polygonStart(), c = !0), r.lineStart(), n(null, null, 1, r), r.lineEnd()), c && (r.polygonEnd(), c = !1), u = l = null;
      },
      sphere: function() {
        r.polygonStart(), r.lineStart(), n(null, null, 1, r), r.lineEnd(), r.polygonEnd();
      }
    };
    function d(v, S) {
      e(v, S) && r.point(v, S);
    }
    function p(v, S) {
      s.point(v, S);
    }
    function y() {
      h.point = p, s.lineStart();
    }
    function m() {
      h.point = d, s.lineEnd();
    }
    function g(v, S) {
      f.push([v, S]), a.point(v, S);
    }
    function b() {
      a.lineStart(), f = [];
    }
    function w() {
      g(f[0][0], f[0][1]), a.lineEnd();
      var v = a.clean(), S = o.result(), _, I = S.length, T, M, N;
      if (f.pop(), l.push(f), f = null, !!I) {
        if (v & 1) {
          if (M = S[0], (T = M.length - 1) > 0) {
            for (c || (r.polygonStart(), c = !0), r.lineStart(), _ = 0; _ < T; ++_)
              r.point((N = M[_])[0], N[1]);
            r.lineEnd();
          }
          return;
        }
        I > 1 && v & 2 && S.push(S.pop().concat(S.shift())), u.push(S.filter(WY));
      }
    }
    return h;
  };
}
function WY(e) {
  return e.length > 1;
}
function GY(e, t) {
  return ((e = e.x)[0] < 0 ? e[1] - $e - wt : $e - e[1]) - ((t = t.x)[0] < 0 ? t[1] - $e - wt : $e - t[1]);
}
const rS = u$(
  function() {
    return !0;
  },
  XY,
  JY,
  [-kt, -$e]
);
function XY(e) {
  var t = NaN, n = NaN, i = NaN, r;
  return {
    lineStart: function() {
      e.lineStart(), r = 1;
    },
    point: function(s, o) {
      var a = s > 0 ? kt : -kt, c = Jt(s - t);
      Jt(c - kt) < wt ? (e.point(t, n = (n + o) / 2 > 0 ? $e : -$e), e.point(i, n), e.lineEnd(), e.lineStart(), e.point(a, n), e.point(s, n), r = 0) : i !== a && c >= kt && (Jt(t - i) < wt && (t -= i * wt), Jt(s - a) < wt && (s -= a * wt), n = HY(t, n, s, o), e.point(i, n), e.lineEnd(), e.lineStart(), e.point(a, n), r = 0), e.point(t = s, n = o), i = a;
    },
    lineEnd: function() {
      e.lineEnd(), t = n = NaN;
    },
    clean: function() {
      return 2 - r;
    }
  };
}
function HY(e, t, n, i) {
  var r, s, o = at(e - n);
  return Jt(o) > wt ? sl((at(t) * (s = $t(i)) * at(n) - at(i) * (r = $t(t)) * at(e)) / (r * s * o)) : (t + i) / 2;
}
function JY(e, t, n, i) {
  var r;
  if (e == null)
    r = n * $e, i.point(-kt, r), i.point(0, r), i.point(kt, r), i.point(kt, 0), i.point(kt, -r), i.point(0, -r), i.point(-kt, -r), i.point(-kt, 0), i.point(-kt, r);
  else if (Jt(e[0] - t[0]) > wt) {
    var s = e[0] < t[0] ? kt : -kt;
    r = n * s / 2, i.point(-s, r), i.point(0, r), i.point(s, r);
  } else
    i.point(t[0], t[1]);
}
function KY(e) {
  var t = $t(e), n = 6 * Xt, i = t > 0, r = Jt(t) > wt;
  function s(u, f, h, d) {
    qY(d, e, n, h, u, f);
  }
  function o(u, f) {
    return $t(u) * $t(f) > t;
  }
  function a(u) {
    var f, h, d, p, y;
    return {
      lineStart: function() {
        p = d = !1, y = 1;
      },
      point: function(m, g) {
        var b = [m, g], w, v = o(m, g), S = i ? v ? 0 : l(m, g) : v ? l(m + (m < 0 ? kt : -kt), g) : 0;
        if (!f && (p = d = v) && u.lineStart(), v !== d && (w = c(f, b), (!w || id(f, w) || id(b, w)) && (b[2] = 1)), v !== d)
          y = 0, v ? (u.lineStart(), w = c(b, f), u.point(w[0], w[1])) : (w = c(f, b), u.point(w[0], w[1], 2), u.lineEnd()), f = w;
        else if (r && f && i ^ v) {
          var _;
          !(S & h) && (_ = c(b, f, !0)) && (y = 0, i ? (u.lineStart(), u.point(_[0][0], _[0][1]), u.point(_[1][0], _[1][1]), u.lineEnd()) : (u.point(_[1][0], _[1][1]), u.lineEnd(), u.lineStart(), u.point(_[0][0], _[0][1], 3)));
        }
        v && (!f || !id(f, b)) && u.point(b[0], b[1]), f = b, d = v, h = S;
      },
      lineEnd: function() {
        d && u.lineEnd(), f = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return y | (p && d) << 1;
      }
    };
  }
  function c(u, f, h) {
    var d = Fc(u), p = Fc(f), y = [1, 0, 0], m = up(d, p), g = dh(m, m), b = m[0], w = g - b * b;
    if (!w)
      return !h && u;
    var v = t * g / w, S = -t * b / w, _ = up(y, m), I = ph(y, v), T = ph(m, S);
    _m(I, T);
    var M = _, N = dh(I, M), A = dh(M, M), B = N * N - A * (dh(I, I) - 1);
    if (!(B < 0)) {
      var R = yn(B), x = ph(M, (-N - R) / A);
      if (_m(x, I), x = n1(x), !h)
        return x;
      var $ = u[0], D = f[0], L = u[1], k = f[1], U;
      D < $ && (U = $, $ = D, D = U);
      var C = D - $, z = Jt(C - kt) < wt, P = z || C < wt;
      if (!z && k < L && (U = L, L = k, k = U), P ? z ? L + k > 0 ^ x[1] < (Jt(x[0] - $) < wt ? L : k) : L <= x[1] && x[1] <= k : C > kt ^ ($ <= x[0] && x[0] <= D)) {
        var G = ph(M, (-N + R) / A);
        return _m(G, I), [x, n1(G)];
      }
    }
  }
  function l(u, f) {
    var h = i ? e : kt - e, d = 0;
    return u < -h ? d |= 1 : u > h && (d |= 2), f < -h ? d |= 4 : f > h && (d |= 8), d;
  }
  return u$(o, a, s, i ? [0, -e] : [-kt, e - kt]);
}
function ZY(e, t, n, i, r, s) {
  var o = e[0], a = e[1], c = t[0], l = t[1], u = 0, f = 1, h = c - o, d = l - a, p;
  if (p = n - o, !(!h && p > 0)) {
    if (p /= h, h < 0) {
      if (p < u)
        return;
      p < f && (f = p);
    } else if (h > 0) {
      if (p > f)
        return;
      p > u && (u = p);
    }
    if (p = r - o, !(!h && p < 0)) {
      if (p /= h, h < 0) {
        if (p > f)
          return;
        p > u && (u = p);
      } else if (h > 0) {
        if (p < u)
          return;
        p < f && (f = p);
      }
      if (p = i - a, !(!d && p > 0)) {
        if (p /= d, d < 0) {
          if (p < u)
            return;
          p < f && (f = p);
        } else if (d > 0) {
          if (p > f)
            return;
          p > u && (u = p);
        }
        if (p = s - a, !(!d && p < 0)) {
          if (p /= d, d < 0) {
            if (p > f)
              return;
            p > u && (u = p);
          } else if (d > 0) {
            if (p < u)
              return;
            p < f && (f = p);
          }
          return u > 0 && (e[0] = o + u * h, e[1] = a + u * d), f < 1 && (t[0] = o + f * h, t[1] = a + f * d), !0;
        }
      }
    }
  }
}
var Gl = 1e9, mh = -Gl;
function f$(e, t, n, i) {
  function r(l, u) {
    return e <= l && l <= n && t <= u && u <= i;
  }
  function s(l, u, f, h) {
    var d = 0, p = 0;
    if (l == null || (d = o(l, f)) !== (p = o(u, f)) || c(l, u) < 0 ^ f > 0)
      do
        h.point(d === 0 || d === 3 ? e : n, d > 1 ? i : t);
      while ((d = (d + f + 4) % 4) !== p);
    else
      h.point(u[0], u[1]);
  }
  function o(l, u) {
    return Jt(l[0] - e) < wt ? u > 0 ? 0 : 3 : Jt(l[0] - n) < wt ? u > 0 ? 2 : 1 : Jt(l[1] - t) < wt ? u > 0 ? 1 : 0 : u > 0 ? 3 : 2;
  }
  function a(l, u) {
    return c(l.x, u.x);
  }
  function c(l, u) {
    var f = o(l, 1), h = o(u, 1);
    return f !== h ? f - h : f === 0 ? u[1] - l[1] : f === 1 ? l[0] - u[0] : f === 2 ? l[1] - u[1] : u[0] - l[0];
  }
  return function(l) {
    var u = l, f = c$(), h, d, p, y, m, g, b, w, v, S, _, I = {
      point: T,
      lineStart: B,
      lineEnd: R,
      polygonStart: N,
      polygonEnd: A
    };
    function T($, D) {
      r($, D) && u.point($, D);
    }
    function M() {
      for (var $ = 0, D = 0, L = d.length; D < L; ++D)
        for (var k = d[D], U = 1, C = k.length, z = k[0], P, G, K = z[0], et = z[1]; U < C; ++U)
          P = K, G = et, z = k[U], K = z[0], et = z[1], G <= i ? et > i && (K - P) * (i - G) > (et - G) * (e - P) && ++$ : et <= i && (K - P) * (i - G) < (et - G) * (e - P) && --$;
      return $;
    }
    function N() {
      u = f, h = [], d = [], _ = !0;
    }
    function A() {
      var $ = M(), D = _ && $, L = (h = hM(h)).length;
      (D || L) && (l.polygonStart(), D && (l.lineStart(), s(null, null, 1, l), l.lineEnd()), L && l$(h, a, $, s, l), l.polygonEnd()), u = l, h = d = p = null;
    }
    function B() {
      I.point = x, d && d.push(p = []), S = !0, v = !1, b = w = NaN;
    }
    function R() {
      h && (x(y, m), g && v && f.rejoin(), h.push(f.result())), I.point = T, v && u.lineEnd();
    }
    function x($, D) {
      var L = r($, D);
      if (d && p.push([$, D]), S)
        y = $, m = D, g = L, S = !1, L && (u.lineStart(), u.point($, D));
      else if (L && v)
        u.point($, D);
      else {
        var k = [b = Math.max(mh, Math.min(Gl, b)), w = Math.max(mh, Math.min(Gl, w))], U = [$ = Math.max(mh, Math.min(Gl, $)), D = Math.max(mh, Math.min(Gl, D))];
        ZY(k, U, e, t, n, i) ? (v || (u.lineStart(), u.point(k[0], k[1])), u.point(U[0], U[1]), L || u.lineEnd(), _ = !1) : L && (u.lineStart(), u.point($, D), _ = !1);
      }
      b = $, w = D, v = L;
    }
    return I;
  };
}
function sS(e, t, n) {
  var i = kn(e, t - wt, n).concat(t);
  return function(r) {
    return i.map(function(s) {
      return [r, s];
    });
  };
}
function oS(e, t, n) {
  var i = kn(e, t - wt, n).concat(t);
  return function(r) {
    return i.map(function(s) {
      return [s, r];
    });
  };
}
function QY() {
  var e, t, n, i, r, s, o, a, c = 10, l = c, u = 90, f = 360, h, d, p, y, m = 2.5;
  function g() {
    return { type: "MultiLineString", coordinates: b() };
  }
  function b() {
    return kn(hh(i / u) * u, n, u).map(p).concat(kn(hh(a / f) * f, o, f).map(y)).concat(kn(hh(t / c) * c, e, c).filter(function(w) {
      return Jt(w % u) > wt;
    }).map(h)).concat(kn(hh(s / l) * l, r, l).filter(function(w) {
      return Jt(w % f) > wt;
    }).map(d));
  }
  return g.lines = function() {
    return b().map(function(w) {
      return { type: "LineString", coordinates: w };
    });
  }, g.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        p(i).concat(
          y(o).slice(1),
          p(n).reverse().slice(1),
          y(a).reverse().slice(1)
        )
      ]
    };
  }, g.extent = function(w) {
    return arguments.length ? g.extentMajor(w).extentMinor(w) : g.extentMinor();
  }, g.extentMajor = function(w) {
    return arguments.length ? (i = +w[0][0], n = +w[1][0], a = +w[0][1], o = +w[1][1], i > n && (w = i, i = n, n = w), a > o && (w = a, a = o, o = w), g.precision(m)) : [[i, a], [n, o]];
  }, g.extentMinor = function(w) {
    return arguments.length ? (t = +w[0][0], e = +w[1][0], s = +w[0][1], r = +w[1][1], t > e && (w = t, t = e, e = w), s > r && (w = s, s = r, r = w), g.precision(m)) : [[t, s], [e, r]];
  }, g.step = function(w) {
    return arguments.length ? g.stepMajor(w).stepMinor(w) : g.stepMinor();
  }, g.stepMajor = function(w) {
    return arguments.length ? (u = +w[0], f = +w[1], g) : [u, f];
  }, g.stepMinor = function(w) {
    return arguments.length ? (c = +w[0], l = +w[1], g) : [c, l];
  }, g.precision = function(w) {
    return arguments.length ? (m = +w, h = sS(s, r, 90), d = oS(t, e, m), p = sS(a, o, 90), y = oS(i, n, m), g) : m;
  }, g.extentMajor([[-180, -90 + wt], [180, 90 - wt]]).extentMinor([[-180, -80 - wt], [180, 80 + wt]]);
}
function tW() {
  return QY()();
}
const l1 = (e) => e;
var xm = new sr(), u1 = new sr(), h$, d$, f1, h1, jr = {
  point: Un,
  lineStart: Un,
  lineEnd: Un,
  polygonStart: function() {
    jr.lineStart = eW, jr.lineEnd = iW;
  },
  polygonEnd: function() {
    jr.lineStart = jr.lineEnd = jr.point = Un, xm.add(Jt(u1)), u1 = new sr();
  },
  result: function() {
    var e = xm / 2;
    return xm = new sr(), e;
  }
};
function eW() {
  jr.point = nW;
}
function nW(e, t) {
  jr.point = p$, h$ = f1 = e, d$ = h1 = t;
}
function p$(e, t) {
  u1.add(h1 * e - f1 * t), f1 = e, h1 = t;
}
function iW() {
  p$(h$, d$);
}
var Ec = 1 / 0, bp = Ec, Cu = -Ec, wp = Cu, vp = {
  point: rW,
  lineStart: Un,
  lineEnd: Un,
  polygonStart: Un,
  polygonEnd: Un,
  result: function() {
    var e = [[Ec, bp], [Cu, wp]];
    return Cu = wp = -(bp = Ec = 1 / 0), e;
  }
};
function rW(e, t) {
  e < Ec && (Ec = e), e > Cu && (Cu = e), t < bp && (bp = t), t > wp && (wp = t);
}
var d1 = 0, p1 = 0, Xl = 0, _p = 0, Sp = 0, Qa = 0, y1 = 0, m1 = 0, Hl = 0, y$, m$, Zi, Qi, ni = {
  point: ea,
  lineStart: aS,
  lineEnd: cS,
  polygonStart: function() {
    ni.lineStart = aW, ni.lineEnd = cW;
  },
  polygonEnd: function() {
    ni.point = ea, ni.lineStart = aS, ni.lineEnd = cS;
  },
  result: function() {
    var e = Hl ? [y1 / Hl, m1 / Hl] : Qa ? [_p / Qa, Sp / Qa] : Xl ? [d1 / Xl, p1 / Xl] : [NaN, NaN];
    return d1 = p1 = Xl = _p = Sp = Qa = y1 = m1 = Hl = 0, e;
  }
};
function ea(e, t) {
  d1 += e, p1 += t, ++Xl;
}
function aS() {
  ni.point = sW;
}
function sW(e, t) {
  ni.point = oW, ea(Zi = e, Qi = t);
}
function oW(e, t) {
  var n = e - Zi, i = t - Qi, r = yn(n * n + i * i);
  _p += r * (Zi + e) / 2, Sp += r * (Qi + t) / 2, Qa += r, ea(Zi = e, Qi = t);
}
function cS() {
  ni.point = ea;
}
function aW() {
  ni.point = lW;
}
function cW() {
  g$(y$, m$);
}
function lW(e, t) {
  ni.point = g$, ea(y$ = Zi = e, m$ = Qi = t);
}
function g$(e, t) {
  var n = e - Zi, i = t - Qi, r = yn(n * n + i * i);
  _p += r * (Zi + e) / 2, Sp += r * (Qi + t) / 2, Qa += r, r = Qi * e - Zi * t, y1 += r * (Zi + e), m1 += r * (Qi + t), Hl += r * 3, ea(Zi = e, Qi = t);
}
function b$(e) {
  this._context = e;
}
b$.prototype = {
  _radius: 4.5,
  pointRadius: function(e) {
    return this._radius = e, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._line === 0 && this._context.closePath(), this._point = NaN;
  },
  point: function(e, t) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(e, t), this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(e, t);
        break;
      }
      default: {
        this._context.moveTo(e + this._radius, t), this._context.arc(e, t, this._radius, 0, jn);
        break;
      }
    }
  },
  result: Un
};
var g1 = new sr(), Im, w$, v$, Jl, Kl, ku = {
  point: Un,
  lineStart: function() {
    ku.point = uW;
  },
  lineEnd: function() {
    Im && _$(w$, v$), ku.point = Un;
  },
  polygonStart: function() {
    Im = !0;
  },
  polygonEnd: function() {
    Im = null;
  },
  result: function() {
    var e = +g1;
    return g1 = new sr(), e;
  }
};
function uW(e, t) {
  ku.point = _$, w$ = Jl = e, v$ = Kl = t;
}
function _$(e, t) {
  Jl -= e, Kl -= t, g1.add(yn(Jl * Jl + Kl * Kl)), Jl = e, Kl = t;
}
let lS, xp, uS, fS;
class hS {
  constructor(t) {
    this._append = t == null ? S$ : fW(t), this._radius = 4.5, this._ = "";
  }
  pointRadius(t) {
    return this._radius = +t, this;
  }
  polygonStart() {
    this._line = 0;
  }
  polygonEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    this._line === 0 && (this._ += "Z"), this._point = NaN;
  }
  point(t, n) {
    switch (this._point) {
      case 0: {
        this._append`M${t},${n}`, this._point = 1;
        break;
      }
      case 1: {
        this._append`L${t},${n}`;
        break;
      }
      default: {
        if (this._append`M${t},${n}`, this._radius !== uS || this._append !== xp) {
          const i = this._radius, r = this._;
          this._ = "", this._append`m0,${i}a${i},${i} 0 1,1 0,${-2 * i}a${i},${i} 0 1,1 0,${2 * i}z`, uS = i, xp = this._append, fS = this._, this._ = r;
        }
        this._ += fS;
        break;
      }
    }
  }
  result() {
    const t = this._;
    return this._ = "", t.length ? t : null;
  }
}
function S$(e) {
  let t = 1;
  this._ += e[0];
  for (const n = e.length; t < n; ++t)
    this._ += arguments[t] + e[t];
}
function fW(e) {
  const t = Math.floor(e);
  if (!(t >= 0))
    throw new RangeError(`invalid digits: ${e}`);
  if (t > 15)
    return S$;
  if (t !== lS) {
    const n = 10 ** t;
    lS = t, xp = function(r) {
      let s = 1;
      this._ += r[0];
      for (const o = r.length; s < o; ++s)
        this._ += Math.round(arguments[s] * n) / n + r[s];
    };
  }
  return xp;
}
function ao(e, t) {
  let n = 3, i = 4.5, r, s;
  function o(a) {
    return a && (typeof i == "function" && s.pointRadius(+i.apply(this, arguments)), Bs(a, r(s))), s.result();
  }
  return o.area = function(a) {
    return Bs(a, r(jr)), jr.result();
  }, o.measure = function(a) {
    return Bs(a, r(ku)), ku.result();
  }, o.bounds = function(a) {
    return Bs(a, r(vp)), vp.result();
  }, o.centroid = function(a) {
    return Bs(a, r(ni)), ni.result();
  }, o.projection = function(a) {
    return arguments.length ? (r = a == null ? (e = null, l1) : (e = a).stream, o) : e;
  }, o.context = function(a) {
    return arguments.length ? (s = a == null ? (t = null, new hS(n)) : new b$(t = a), typeof i != "function" && s.pointRadius(i), o) : t;
  }, o.pointRadius = function(a) {
    return arguments.length ? (i = typeof a == "function" ? a : (s.pointRadius(+a), +a), o) : i;
  }, o.digits = function(a) {
    if (!arguments.length)
      return n;
    if (a == null)
      n = null;
    else {
      const c = Math.floor(a);
      if (!(c >= 0))
        throw new RangeError(`invalid digits: ${a}`);
      n = c;
    }
    return t === null && (s = new hS(n)), o;
  }, o.projection(e).digits(n).context(t);
}
function Ip(e) {
  return {
    stream: n0(e)
  };
}
function n0(e) {
  return function(t) {
    var n = new b1();
    for (var i in e)
      n[i] = e[i];
    return n.stream = t, n;
  };
}
function b1() {
}
b1.prototype = {
  constructor: b1,
  point: function(e, t) {
    this.stream.point(e, t);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};
function sw(e, t, n) {
  var i = e.clipExtent && e.clipExtent();
  return e.scale(150).translate([0, 0]), i != null && e.clipExtent(null), Bs(n, e.stream(vp)), t(vp.result()), i != null && e.clipExtent(i), e;
}
function ow(e, t, n) {
  return sw(e, function(i) {
    var r = t[1][0] - t[0][0], s = t[1][1] - t[0][1], o = Math.min(r / (i[1][0] - i[0][0]), s / (i[1][1] - i[0][1])), a = +t[0][0] + (r - o * (i[1][0] + i[0][0])) / 2, c = +t[0][1] + (s - o * (i[1][1] + i[0][1])) / 2;
    e.scale(150 * o).translate([a, c]);
  }, n);
}
function x$(e, t, n) {
  return ow(e, [[0, 0], t], n);
}
function I$(e, t, n) {
  return sw(e, function(i) {
    var r = +t, s = r / (i[1][0] - i[0][0]), o = (r - s * (i[1][0] + i[0][0])) / 2, a = -s * i[0][1];
    e.scale(150 * s).translate([o, a]);
  }, n);
}
function A$(e, t, n) {
  return sw(e, function(i) {
    var r = +t, s = r / (i[1][1] - i[0][1]), o = -s * i[0][0], a = (r - s * (i[1][1] + i[0][1])) / 2;
    e.scale(150 * s).translate([o, a]);
  }, n);
}
var dS = 16, hW = $t(30 * Xt);
function pS(e, t) {
  return +t ? pW(e, t) : dW(e);
}
function dW(e) {
  return n0({
    point: function(t, n) {
      t = e(t, n), this.stream.point(t[0], t[1]);
    }
  });
}
function pW(e, t) {
  function n(i, r, s, o, a, c, l, u, f, h, d, p, y, m) {
    var g = l - i, b = u - r, w = g * g + b * b;
    if (w > 4 * t && y--) {
      var v = o + h, S = a + d, _ = c + p, I = yn(v * v + S * S + _ * _), T = Dn(_ /= I), M = Jt(Jt(_) - 1) < wt || Jt(s - f) < wt ? (s + f) / 2 : Di(S, v), N = e(M, T), A = N[0], B = N[1], R = A - i, x = B - r, $ = b * R - g * x;
      ($ * $ / w > t || Jt((g * R + b * x) / w - 0.5) > 0.3 || o * h + a * d + c * p < hW) && (n(i, r, s, o, a, c, A, B, M, v /= I, S /= I, _, y, m), m.point(A, B), n(A, B, M, v, S, _, l, u, f, h, d, p, y, m));
    }
  }
  return function(i) {
    var r, s, o, a, c, l, u, f, h, d, p, y, m = {
      point: g,
      lineStart: b,
      lineEnd: v,
      polygonStart: function() {
        i.polygonStart(), m.lineStart = S;
      },
      polygonEnd: function() {
        i.polygonEnd(), m.lineStart = b;
      }
    };
    function g(T, M) {
      T = e(T, M), i.point(T[0], T[1]);
    }
    function b() {
      f = NaN, m.point = w, i.lineStart();
    }
    function w(T, M) {
      var N = Fc([T, M]), A = e(T, M);
      n(f, h, u, d, p, y, f = A[0], h = A[1], u = T, d = N[0], p = N[1], y = N[2], dS, i), i.point(f, h);
    }
    function v() {
      m.point = g, i.lineEnd();
    }
    function S() {
      b(), m.point = _, m.lineEnd = I;
    }
    function _(T, M) {
      w(r = T, M), s = f, o = h, a = d, c = p, l = y, m.point = w;
    }
    function I() {
      n(f, h, u, d, p, y, s, o, r, a, c, l, dS, i), m.lineEnd = v, v();
    }
    return m;
  };
}
var yW = n0({
  point: function(e, t) {
    this.stream.point(e * Xt, t * Xt);
  }
});
function mW(e) {
  return n0({
    point: function(t, n) {
      var i = e(t, n);
      return this.stream.point(i[0], i[1]);
    }
  });
}
function gW(e, t, n, i, r) {
  function s(o, a) {
    return o *= i, a *= r, [t + e * o, n - e * a];
  }
  return s.invert = function(o, a) {
    return [(o - t) / e * i, (n - a) / e * r];
  }, s;
}
function yS(e, t, n, i, r, s) {
  if (!s)
    return gW(e, t, n, i, r);
  var o = $t(s), a = at(s), c = o * e, l = a * e, u = o / e, f = a / e, h = (a * n - o * t) / e, d = (a * t + o * n) / e;
  function p(y, m) {
    return y *= i, m *= r, [c * y - l * m + t, n - l * y - c * m];
  }
  return p.invert = function(y, m) {
    return [i * (u * y - f * m + h), r * (d - f * y - u * m)];
  }, p;
}
function co(e) {
  return M$(function() {
    return e;
  })();
}
function M$(e) {
  var t, n = 150, i = 480, r = 250, s = 0, o = 0, a = 0, c = 0, l = 0, u, f = 0, h = 1, d = 1, p = null, y = rS, m = null, g, b, w, v = l1, S = 0.5, _, I, T, M, N;
  function A($) {
    return T($[0] * Xt, $[1] * Xt);
  }
  function B($) {
    return $ = T.invert($[0], $[1]), $ && [$[0] * Xe, $[1] * Xe];
  }
  A.stream = function($) {
    return M && N === $ ? M : M = yW(mW(u)(y(_(v(N = $)))));
  }, A.preclip = function($) {
    return arguments.length ? (y = $, p = void 0, x()) : y;
  }, A.postclip = function($) {
    return arguments.length ? (v = $, m = g = b = w = null, x()) : v;
  }, A.clipAngle = function($) {
    return arguments.length ? (y = +$ ? KY(p = $ * Xt) : (p = null, rS), x()) : p * Xe;
  }, A.clipExtent = function($) {
    return arguments.length ? (v = $ == null ? (m = g = b = w = null, l1) : f$(m = +$[0][0], g = +$[0][1], b = +$[1][0], w = +$[1][1]), x()) : m == null ? null : [[m, g], [b, w]];
  }, A.scale = function($) {
    return arguments.length ? (n = +$, R()) : n;
  }, A.translate = function($) {
    return arguments.length ? (i = +$[0], r = +$[1], R()) : [i, r];
  }, A.center = function($) {
    return arguments.length ? (s = $[0] % 360 * Xt, o = $[1] % 360 * Xt, R()) : [s * Xe, o * Xe];
  }, A.rotate = function($) {
    return arguments.length ? (a = $[0] % 360 * Xt, c = $[1] % 360 * Xt, l = $.length > 2 ? $[2] % 360 * Xt : 0, R()) : [a * Xe, c * Xe, l * Xe];
  }, A.angle = function($) {
    return arguments.length ? (f = $ % 360 * Xt, R()) : f * Xe;
  }, A.reflectX = function($) {
    return arguments.length ? (h = $ ? -1 : 1, R()) : h < 0;
  }, A.reflectY = function($) {
    return arguments.length ? (d = $ ? -1 : 1, R()) : d < 0;
  }, A.precision = function($) {
    return arguments.length ? (_ = pS(I, S = $ * $), x()) : yn(S);
  }, A.fitExtent = function($, D) {
    return ow(A, $, D);
  }, A.fitSize = function($, D) {
    return x$(A, $, D);
  }, A.fitWidth = function($, D) {
    return I$(A, $, D);
  }, A.fitHeight = function($, D) {
    return A$(A, $, D);
  };
  function R() {
    var $ = yS(n, 0, 0, h, d, f).apply(null, t(s, o)), D = yS(n, i - $[0], r - $[1], h, d, f);
    return u = a$(a, c, l), I = a1(t, D), T = a1(u, I), _ = pS(I, S), x();
  }
  function x() {
    return M = N = null, A;
  }
  return function() {
    return t = e.apply(this, arguments), A.invert = t.invert && B, R();
  };
}
function aw(e) {
  var t = 0, n = kt / 3, i = M$(e), r = i(t, n);
  return r.parallels = function(s) {
    return arguments.length ? i(t = s[0] * Xt, n = s[1] * Xt) : [t * Xe, n * Xe];
  }, r;
}
function bW(e) {
  var t = $t(e);
  function n(i, r) {
    return [i * t, at(r) / t];
  }
  return n.invert = function(i, r) {
    return [i / t, Dn(r * t)];
  }, n;
}
function wW(e, t) {
  var n = at(e), i = (n + at(t)) / 2;
  if (Jt(i) < wt)
    return bW(e);
  var r = 1 + n * (2 * i - n), s = yn(r) / i;
  function o(a, c) {
    var l = yn(r - 2 * i * at(c)) / i;
    return [l * at(a *= i), s - l * $t(a)];
  }
  return o.invert = function(a, c) {
    var l = s - c, u = Di(a, Jt(l)) * ri(l);
    return l * i < 0 && (u -= kt * ri(a) * ri(l)), [u / i, Dn((r - (a * a + l * l) * i * i) / (2 * i))];
  }, o;
}
function Ap() {
  return aw(wW).scale(155.424).center([0, 33.6442]);
}
function $$() {
  return Ap().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
}
function vW(e) {
  var t = e.length;
  return {
    point: function(n, i) {
      for (var r = -1; ++r < t; )
        e[r].point(n, i);
    },
    sphere: function() {
      for (var n = -1; ++n < t; )
        e[n].sphere();
    },
    lineStart: function() {
      for (var n = -1; ++n < t; )
        e[n].lineStart();
    },
    lineEnd: function() {
      for (var n = -1; ++n < t; )
        e[n].lineEnd();
    },
    polygonStart: function() {
      for (var n = -1; ++n < t; )
        e[n].polygonStart();
    },
    polygonEnd: function() {
      for (var n = -1; ++n < t; )
        e[n].polygonEnd();
    }
  };
}
function _W() {
  var e, t, n = $$(), i, r = Ap().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), s, o = Ap().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), a, c, l = { point: function(h, d) {
    c = [h, d];
  } };
  function u(h) {
    var d = h[0], p = h[1];
    return c = null, i.point(d, p), c || (s.point(d, p), c) || (a.point(d, p), c);
  }
  u.invert = function(h) {
    var d = n.scale(), p = n.translate(), y = (h[0] - p[0]) / d, m = (h[1] - p[1]) / d;
    return (m >= 0.12 && m < 0.234 && y >= -0.425 && y < -0.214 ? r : m >= 0.166 && m < 0.234 && y >= -0.214 && y < -0.115 ? o : n).invert(h);
  }, u.stream = function(h) {
    return e && t === h ? e : e = vW([n.stream(t = h), r.stream(h), o.stream(h)]);
  }, u.precision = function(h) {
    return arguments.length ? (n.precision(h), r.precision(h), o.precision(h), f()) : n.precision();
  }, u.scale = function(h) {
    return arguments.length ? (n.scale(h), r.scale(h * 0.35), o.scale(h), u.translate(n.translate())) : n.scale();
  }, u.translate = function(h) {
    if (!arguments.length)
      return n.translate();
    var d = n.scale(), p = +h[0], y = +h[1];
    return i = n.translate(h).clipExtent([[p - 0.455 * d, y - 0.238 * d], [p + 0.455 * d, y + 0.238 * d]]).stream(l), s = r.translate([p - 0.307 * d, y + 0.201 * d]).clipExtent([[p - 0.425 * d + wt, y + 0.12 * d + wt], [p - 0.214 * d - wt, y + 0.234 * d - wt]]).stream(l), a = o.translate([p - 0.205 * d, y + 0.212 * d]).clipExtent([[p - 0.214 * d + wt, y + 0.166 * d + wt], [p - 0.115 * d - wt, y + 0.234 * d - wt]]).stream(l), f();
  }, u.fitExtent = function(h, d) {
    return ow(u, h, d);
  }, u.fitSize = function(h, d) {
    return x$(u, h, d);
  }, u.fitWidth = function(h, d) {
    return I$(u, h, d);
  }, u.fitHeight = function(h, d) {
    return A$(u, h, d);
  };
  function f() {
    return e = t = null, u;
  }
  return u.scale(1070);
}
function T$(e) {
  return function(t, n) {
    var i = $t(t), r = $t(n), s = e(i * r);
    return s === 1 / 0 ? [2, 0] : [
      s * r * at(t),
      s * at(n)
    ];
  };
}
function Sf(e) {
  return function(t, n) {
    var i = yn(t * t + n * n), r = e(i), s = at(r), o = $t(r);
    return [
      Di(t * s, i * o),
      Dn(i && n * s / i)
    ];
  };
}
var D$ = T$(function(e) {
  return yn(2 / (1 + e));
});
D$.invert = Sf(function(e) {
  return 2 * Dn(e / 2);
});
function SW() {
  return co(D$).scale(124.75).clipAngle(180 - 1e-3);
}
var N$ = T$(function(e) {
  return (e = i$(e)) && e / at(e);
});
N$.invert = Sf(function(e) {
  return e;
});
function xW() {
  return co(N$).scale(79.4188).clipAngle(180 - 1e-3);
}
function i0(e, t) {
  return [e, cp(iw(($e + t) / 2))];
}
i0.invert = function(e, t) {
  return [e, 2 * sl(n$(t)) - $e];
};
function IW() {
  return B$(i0).scale(961 / jn);
}
function B$(e) {
  var t = co(e), n = t.center, i = t.scale, r = t.translate, s = t.clipExtent, o = null, a, c, l;
  t.scale = function(f) {
    return arguments.length ? (i(f), u()) : i();
  }, t.translate = function(f) {
    return arguments.length ? (r(f), u()) : r();
  }, t.center = function(f) {
    return arguments.length ? (n(f), u()) : n();
  }, t.clipExtent = function(f) {
    return arguments.length ? (f == null ? o = a = c = l = null : (o = +f[0][0], a = +f[0][1], c = +f[1][0], l = +f[1][1]), u()) : o == null ? null : [[o, a], [c, l]];
  };
  function u() {
    var f = kt * i(), h = t(jY(t.rotate()).invert([0, 0]));
    return s(o == null ? [[h[0] - f, h[1] - f], [h[0] + f, h[1] + f]] : e === i0 ? [[Math.max(h[0] - f, o), a], [Math.min(h[0] + f, c), l]] : [[o, Math.max(h[1] - f, a)], [c, Math.min(h[1] + f, l)]]);
  }
  return u();
}
function gh(e) {
  return iw(($e + e) / 2);
}
function AW(e, t) {
  var n = $t(e), i = e === t ? at(e) : cp(n / $t(t)) / cp(gh(t) / gh(e)), r = n * vm(gh(e), i) / i;
  if (!i)
    return i0;
  function s(o, a) {
    r > 0 ? a < -$e + wt && (a = -$e + wt) : a > $e - wt && (a = $e - wt);
    var c = r / vm(gh(a), i);
    return [c * at(i * o), r - c * $t(i * o)];
  }
  return s.invert = function(o, a) {
    var c = r - a, l = ri(i) * yn(o * o + c * c), u = Di(o, Jt(c)) * ri(c);
    return c * i < 0 && (u -= kt * ri(o) * ri(c)), [u / i, 2 * sl(vm(r / l, 1 / i)) - $e];
  }, s;
}
function MW() {
  return aw(AW).scale(109.5).parallels([30, 30]);
}
function Mp(e, t) {
  return [e, t];
}
Mp.invert = Mp;
function $W() {
  return co(Mp).scale(152.63);
}
function TW(e, t) {
  var n = $t(e), i = e === t ? at(e) : (n - $t(t)) / (t - e), r = n / i + e;
  if (Jt(i) < wt)
    return Mp;
  function s(o, a) {
    var c = r - a, l = i * o;
    return [c * at(l), r - c * $t(l)];
  }
  return s.invert = function(o, a) {
    var c = r - a, l = Di(o, Jt(c)) * ri(c);
    return c * i < 0 && (l -= kt * ri(o) * ri(c)), [l / i, r - ri(i) * yn(o * o + c * c)];
  }, s;
}
function DW() {
  return aw(TW).scale(131.154).center([0, 13.9389]);
}
var uu = 1.340264, fu = -0.081106, hu = 893e-6, du = 3796e-6, $p = yn(3) / 2, NW = 12;
function O$(e, t) {
  var n = Dn($p * at(t)), i = n * n, r = i * i * i;
  return [
    e * $t(n) / ($p * (uu + 3 * fu * i + r * (7 * hu + 9 * du * i))),
    n * (uu + fu * i + r * (hu + du * i))
  ];
}
O$.invert = function(e, t) {
  for (var n = t, i = n * n, r = i * i * i, s = 0, o, a, c; s < NW && (a = n * (uu + fu * i + r * (hu + du * i)) - t, c = uu + 3 * fu * i + r * (7 * hu + 9 * du * i), n -= o = a / c, i = n * n, r = i * i * i, !(Jt(o) < ap)); ++s)
    ;
  return [
    $p * e * (uu + 3 * fu * i + r * (7 * hu + 9 * du * i)) / $t(n),
    Dn(at(n) / $p)
  ];
};
function BW() {
  return co(O$).scale(177.158);
}
function F$(e, t) {
  var n = $t(t), i = $t(e) * n;
  return [n * at(e) / i, at(t) / i];
}
F$.invert = Sf(sl);
function OW() {
  return co(F$).scale(144.049).clipAngle(60);
}
function E$(e, t) {
  return [$t(t) * at(e), at(t)];
}
E$.invert = Sf(Dn);
function FW() {
  return co(E$).scale(249.5).clipAngle(90 + wt);
}
function L$(e, t) {
  var n = $t(t), i = 1 + $t(e) * n;
  return [n * at(e) / i, at(t) / i];
}
L$.invert = Sf(function(e) {
  return 2 * sl(e);
});
function EW() {
  return co(L$).scale(250).clipAngle(142);
}
function R$(e, t) {
  return [cp(iw(($e + t) / 2)), -e];
}
R$.invert = function(e, t) {
  return [-t, 2 * sl(n$(e)) - $e];
};
function LW() {
  var e = B$(R$), t = e.center, n = e.rotate;
  return e.center = function(i) {
    return arguments.length ? t([-i[1], i[0]]) : (i = t(), [i[1], -i[0]]);
  }, e.rotate = function(i) {
    return arguments.length ? n([i[0], i[1], i.length > 2 ? i[2] + 90 : 90]) : (i = n(), [i[0], i[1], i[2] - 90]);
  }, n([0, 0, 90]).scale(159.155);
}
function RW(e, t) {
  return e.parent === t.parent ? 1 : 2;
}
function CW(e) {
  return e.reduce(kW, 0) / e.length;
}
function kW(e, t) {
  return e + t.x;
}
function UW(e) {
  return 1 + e.reduce(zW, 0);
}
function zW(e, t) {
  return Math.max(e, t.y);
}
function PW(e) {
  for (var t; t = e.children; )
    e = t[0];
  return e;
}
function VW(e) {
  for (var t; t = e.children; )
    e = t[t.length - 1];
  return e;
}
function C$() {
  var e = RW, t = 1, n = 1, i = !1;
  function r(s) {
    var o, a = 0;
    s.eachAfter(function(h) {
      var d = h.children;
      d ? (h.x = CW(d), h.y = UW(d)) : (h.x = o ? a += e(h, o) : 0, h.y = 0, o = h);
    });
    var c = PW(s), l = VW(s), u = c.x - e(c, l) / 2, f = l.x + e(l, c) / 2;
    return s.eachAfter(i ? function(h) {
      h.x = (h.x - s.x) * t, h.y = (s.y - h.y) * n;
    } : function(h) {
      h.x = (h.x - u) / (f - u) * t, h.y = (1 - (s.y ? h.y / s.y : 1)) * n;
    });
  }
  return r.separation = function(s) {
    return arguments.length ? (e = s, r) : e;
  }, r.size = function(s) {
    return arguments.length ? (i = !1, t = +s[0], n = +s[1], r) : i ? null : [t, n];
  }, r.nodeSize = function(s) {
    return arguments.length ? (i = !0, t = +s[0], n = +s[1], r) : i ? [t, n] : null;
  }, r;
}
function jW(e) {
  var t = 0, n = e.children, i = n && n.length;
  if (!i)
    t = 1;
  else
    for (; --i >= 0; )
      t += n[i].value;
  e.value = t;
}
function qW() {
  return this.eachAfter(jW);
}
function YW(e, t) {
  let n = -1;
  for (const i of this)
    e.call(t, i, ++n, this);
  return this;
}
function WW(e, t) {
  for (var n = this, i = [n], r, s, o = -1; n = i.pop(); )
    if (e.call(t, n, ++o, this), r = n.children)
      for (s = r.length - 1; s >= 0; --s)
        i.push(r[s]);
  return this;
}
function GW(e, t) {
  for (var n = this, i = [n], r = [], s, o, a, c = -1; n = i.pop(); )
    if (r.push(n), s = n.children)
      for (o = 0, a = s.length; o < a; ++o)
        i.push(s[o]);
  for (; n = r.pop(); )
    e.call(t, n, ++c, this);
  return this;
}
function XW(e, t) {
  let n = -1;
  for (const i of this)
    if (e.call(t, i, ++n, this))
      return i;
}
function HW(e) {
  return this.eachAfter(function(t) {
    for (var n = +e(t.data) || 0, i = t.children, r = i && i.length; --r >= 0; )
      n += i[r].value;
    t.value = n;
  });
}
function JW(e) {
  return this.eachBefore(function(t) {
    t.children && t.children.sort(e);
  });
}
function KW(e) {
  for (var t = this, n = ZW(t, e), i = [t]; t !== n; )
    t = t.parent, i.push(t);
  for (var r = i.length; e !== n; )
    i.splice(r, 0, e), e = e.parent;
  return i;
}
function ZW(e, t) {
  if (e === t)
    return e;
  var n = e.ancestors(), i = t.ancestors(), r = null;
  for (e = n.pop(), t = i.pop(); e === t; )
    r = e, e = n.pop(), t = i.pop();
  return r;
}
function QW() {
  for (var e = this, t = [e]; e = e.parent; )
    t.push(e);
  return t;
}
function tG() {
  return Array.from(this);
}
function eG() {
  var e = [];
  return this.eachBefore(function(t) {
    t.children || e.push(t);
  }), e;
}
function nG() {
  var e = this, t = [];
  return e.each(function(n) {
    n !== e && t.push({ source: n.parent, target: n });
  }), t;
}
function* iG() {
  var e = this, t, n = [e], i, r, s;
  do
    for (t = n.reverse(), n = []; e = t.pop(); )
      if (yield e, i = e.children)
        for (r = 0, s = i.length; r < s; ++r)
          n.push(i[r]);
  while (n.length);
}
function k$(e, t) {
  e instanceof Map ? (e = [void 0, e], t === void 0 && (t = oG)) : t === void 0 && (t = sG);
  for (var n = new Lc(e), i, r = [n], s, o, a, c; i = r.pop(); )
    if ((o = t(i.data)) && (c = (o = Array.from(o)).length))
      for (i.children = o, a = c - 1; a >= 0; --a)
        r.push(s = o[a] = new Lc(o[a])), s.parent = i, s.depth = i.depth + 1;
  return n.eachBefore(U$);
}
function rG() {
  return k$(this).eachBefore(aG);
}
function sG(e) {
  return e.children;
}
function oG(e) {
  return Array.isArray(e) ? e[1] : null;
}
function aG(e) {
  e.data.value !== void 0 && (e.value = e.data.value), e.data = e.data.data;
}
function U$(e) {
  var t = 0;
  do
    e.height = t;
  while ((e = e.parent) && e.height < ++t);
}
function Lc(e) {
  this.data = e, this.depth = this.height = 0, this.parent = null;
}
Lc.prototype = k$.prototype = {
  constructor: Lc,
  count: qW,
  each: YW,
  eachAfter: GW,
  eachBefore: WW,
  find: XW,
  sum: HW,
  sort: JW,
  path: KW,
  ancestors: QW,
  descendants: tG,
  leaves: eG,
  links: nG,
  copy: rG,
  [Symbol.iterator]: iG
};
function Am(e) {
  return e == null ? null : cG(e);
}
function cG(e) {
  if (typeof e != "function")
    throw new Error();
  return e;
}
var lG = { depth: -1 }, mS = {}, Mm = {};
function uG(e) {
  return e.id;
}
function fG(e) {
  return e.parentId;
}
function z$() {
  var e = uG, t = fG, n;
  function i(r) {
    var s = Array.from(r), o = e, a = t, c, l, u, f, h, d, p, y, m = /* @__PURE__ */ new Map();
    if (n != null) {
      const g = s.map((v, S) => hG(n(v, S, r))), b = g.map(gS), w = new Set(g).add("");
      for (const v of b)
        w.has(v) || (w.add(v), g.push(v), b.push(gS(v)), s.push(Mm));
      o = (v, S) => g[S], a = (v, S) => b[S];
    }
    for (u = 0, c = s.length; u < c; ++u)
      l = s[u], d = s[u] = new Lc(l), (p = o(l, u, r)) != null && (p += "") && (y = d.id = p, m.set(y, m.has(y) ? mS : d)), (p = a(l, u, r)) != null && (p += "") && (d.parent = p);
    for (u = 0; u < c; ++u)
      if (d = s[u], p = d.parent) {
        if (h = m.get(p), !h)
          throw new Error("missing: " + p);
        if (h === mS)
          throw new Error("ambiguous: " + p);
        h.children ? h.children.push(d) : h.children = [d], d.parent = h;
      } else {
        if (f)
          throw new Error("multiple roots");
        f = d;
      }
    if (!f)
      throw new Error("no root");
    if (n != null) {
      for (; f.data === Mm && f.children.length === 1; )
        f = f.children[0], --c;
      for (let g = s.length - 1; g >= 0 && (d = s[g], d.data === Mm); --g)
        d.data = null;
    }
    if (f.parent = lG, f.eachBefore(function(g) {
      g.depth = g.parent.depth + 1, --c;
    }).eachBefore(U$), f.parent = null, c > 0)
      throw new Error("cycle");
    return f;
  }
  return i.id = function(r) {
    return arguments.length ? (e = Am(r), i) : e;
  }, i.parentId = function(r) {
    return arguments.length ? (t = Am(r), i) : t;
  }, i.path = function(r) {
    return arguments.length ? (n = Am(r), i) : n;
  }, i;
}
function hG(e) {
  e = `${e}`;
  let t = e.length;
  return w1(e, t - 1) && !w1(e, t - 2) && (e = e.slice(0, -1)), e[0] === "/" ? e : `/${e}`;
}
function gS(e) {
  let t = e.length;
  if (t < 2)
    return "";
  for (; --t > 1 && !w1(e, t); )
    ;
  return e.slice(0, t);
}
function w1(e, t) {
  if (e[t] === "/") {
    let n = 0;
    for (; t > 0 && e[--t] === "\\"; )
      ++n;
    if (!(n & 1))
      return !0;
  }
  return !1;
}
function dG(e, t) {
  return e.parent === t.parent ? 1 : 2;
}
function $m(e) {
  var t = e.children;
  return t ? t[0] : e.t;
}
function Tm(e) {
  var t = e.children;
  return t ? t[t.length - 1] : e.t;
}
function pG(e, t, n) {
  var i = n / (t.i - e.i);
  t.c -= i, t.s += n, e.c += i, t.z += n, t.m += n;
}
function yG(e) {
  for (var t = 0, n = 0, i = e.children, r = i.length, s; --r >= 0; )
    s = i[r], s.z += t, s.m += t, t += s.s + (n += s.c);
}
function mG(e, t, n) {
  return e.a.parent === t.parent ? e.a : n;
}
function rd(e, t) {
  this._ = e, this.parent = null, this.children = null, this.A = null, this.a = this, this.z = 0, this.m = 0, this.c = 0, this.s = 0, this.t = null, this.i = t;
}
rd.prototype = Object.create(Lc.prototype);
function gG(e) {
  for (var t = new rd(e, 0), n, i = [t], r, s, o, a; n = i.pop(); )
    if (s = n._.children)
      for (n.children = new Array(a = s.length), o = a - 1; o >= 0; --o)
        i.push(r = n.children[o] = new rd(s[o], o)), r.parent = n;
  return (t.parent = new rd(null, 0)).children = [t], t;
}
function Tp() {
  var e = dG, t = 1, n = 1, i = null;
  function r(l) {
    var u = gG(l);
    if (u.eachAfter(s), u.parent.m = -u.z, u.eachBefore(o), i)
      l.eachBefore(c);
    else {
      var f = l, h = l, d = l;
      l.eachBefore(function(b) {
        b.x < f.x && (f = b), b.x > h.x && (h = b), b.depth > d.depth && (d = b);
      });
      var p = f === h ? 1 : e(f, h) / 2, y = p - f.x, m = t / (h.x + p + y), g = n / (d.depth || 1);
      l.eachBefore(function(b) {
        b.x = (b.x + y) * m, b.y = b.depth * g;
      });
    }
    return l;
  }
  function s(l) {
    var u = l.children, f = l.parent.children, h = l.i ? f[l.i - 1] : null;
    if (u) {
      yG(l);
      var d = (u[0].z + u[u.length - 1].z) / 2;
      h ? (l.z = h.z + e(l._, h._), l.m = l.z - d) : l.z = d;
    } else
      h && (l.z = h.z + e(l._, h._));
    l.parent.A = a(l, h, l.parent.A || f[0]);
  }
  function o(l) {
    l._.x = l.z + l.parent.m, l.m += l.parent.m;
  }
  function a(l, u, f) {
    if (u) {
      for (var h = l, d = l, p = u, y = h.parent.children[0], m = h.m, g = d.m, b = p.m, w = y.m, v; p = Tm(p), h = $m(h), p && h; )
        y = $m(y), d = Tm(d), d.a = l, v = p.z + b - h.z - m + e(p._, h._), v > 0 && (pG(mG(p, l, f), l, v), m += v, g += v), b += p.m, m += h.m, w += y.m, g += d.m;
      p && !Tm(d) && (d.t = p, d.m += b - g), h && !$m(y) && (y.t = h, y.m += m - w, f = l);
    }
    return f;
  }
  function c(l) {
    l.x *= t, l.y = l.depth * n;
  }
  return r.separation = function(l) {
    return arguments.length ? (e = l, r) : e;
  }, r.size = function(l) {
    return arguments.length ? (i = !1, t = +l[0], n = +l[1], r) : i ? null : [t, n];
  }, r.nodeSize = function(l) {
    return arguments.length ? (i = !0, t = +l[0], n = +l[1], r) : i ? [t, n] : null;
  }, r;
}
const bG = 1664525, wG = 1013904223, bS = 1 / 4294967296;
function cw(e = Math.random()) {
  let t = (0 <= e && e < 1 ? e / bS : Math.abs(e)) | 0;
  return () => (t = bG * t + wG | 0, bS * (t >>> 0));
}
function br(e, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(e);
      break;
    default:
      this.range(t).domain(e);
      break;
  }
  return this;
}
function r0(e, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      typeof e == "function" ? this.interpolator(e) : this.range(e);
      break;
    }
    default: {
      this.domain(e), typeof t == "function" ? this.interpolator(t) : this.range(t);
      break;
    }
  }
  return this;
}
const v1 = Symbol("implicit");
function lw() {
  var e = new Jo(), t = [], n = [], i = v1;
  function r(s) {
    let o = e.get(s);
    if (o === void 0) {
      if (i !== v1)
        return i;
      e.set(s, o = t.push(s) - 1);
    }
    return n[o % n.length];
  }
  return r.domain = function(s) {
    if (!arguments.length)
      return t.slice();
    t = [], e = new Jo();
    for (const o of s)
      e.has(o) || e.set(o, t.push(o) - 1);
    return r;
  }, r.range = function(s) {
    return arguments.length ? (n = Array.from(s), r) : n.slice();
  }, r.unknown = function(s) {
    return arguments.length ? (i = s, r) : i;
  }, r.copy = function() {
    return lw(t, n).unknown(i);
  }, br.apply(r, arguments), r;
}
function s0() {
  var e = lw().unknown(void 0), t = e.domain, n = e.range, i = 0, r = 1, s, o, a = !1, c = 0, l = 0, u = 0.5;
  delete e.unknown;
  function f() {
    var h = t().length, d = r < i, p = d ? r : i, y = d ? i : r;
    s = (y - p) / Math.max(1, h - c + l * 2), a && (s = Math.floor(s)), p += (y - p - s * (h - c)) * u, o = s * (1 - c), a && (p = Math.round(p), o = Math.round(o));
    var m = kn(h).map(function(g) {
      return p + s * g;
    });
    return n(d ? m.reverse() : m);
  }
  return e.domain = function(h) {
    return arguments.length ? (t(h), f()) : t();
  }, e.range = function(h) {
    return arguments.length ? ([i, r] = h, i = +i, r = +r, f()) : [i, r];
  }, e.rangeRound = function(h) {
    return [i, r] = h, i = +i, r = +r, a = !0, f();
  }, e.bandwidth = function() {
    return o;
  }, e.step = function() {
    return s;
  }, e.round = function(h) {
    return arguments.length ? (a = !!h, f()) : a;
  }, e.padding = function(h) {
    return arguments.length ? (c = Math.min(1, l = +h), f()) : c;
  }, e.paddingInner = function(h) {
    return arguments.length ? (c = Math.min(1, h), f()) : c;
  }, e.paddingOuter = function(h) {
    return arguments.length ? (l = +h, f()) : l;
  }, e.align = function(h) {
    return arguments.length ? (u = Math.max(0, Math.min(1, h)), f()) : u;
  }, e.copy = function() {
    return s0(t(), [i, r]).round(a).paddingInner(c).paddingOuter(l).align(u);
  }, br.apply(f(), arguments);
}
function P$(e) {
  var t = e.copy;
  return e.padding = e.paddingOuter, delete e.paddingInner, delete e.paddingOuter, e.copy = function() {
    return P$(t());
  }, e;
}
function vG() {
  return P$(s0.apply(null, arguments).paddingInner(1));
}
function _G(e) {
  return function() {
    return e;
  };
}
function _1(e) {
  return +e;
}
var wS = [0, 1];
function si(e) {
  return e;
}
function S1(e, t) {
  return (t -= e = +e) ? function(n) {
    return (n - e) / t;
  } : _G(isNaN(t) ? NaN : 0.5);
}
function SG(e, t) {
  var n;
  return e > t && (n = e, e = t, t = n), function(i) {
    return Math.max(e, Math.min(t, i));
  };
}
function xG(e, t, n) {
  var i = e[0], r = e[1], s = t[0], o = t[1];
  return r < i ? (i = S1(r, i), s = n(o, s)) : (i = S1(i, r), s = n(s, o)), function(a) {
    return s(i(a));
  };
}
function IG(e, t, n) {
  var i = Math.min(e.length, t.length) - 1, r = new Array(i), s = new Array(i), o = -1;
  for (e[i] < e[0] && (e = e.slice().reverse(), t = t.slice().reverse()); ++o < i; )
    r[o] = S1(e[o], e[o + 1]), s[o] = n(t[o], t[o + 1]);
  return function(a) {
    var c = Yy(e, a, 1, i) - 1;
    return s[c](r[c](a));
  };
}
function xf(e, t) {
  return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown());
}
function o0() {
  var e = wS, t = wS, n = il, i, r, s, o = si, a, c, l;
  function u() {
    var h = Math.min(e.length, t.length);
    return o !== si && (o = SG(e[0], e[h - 1])), a = h > 2 ? IG : xG, c = l = null, f;
  }
  function f(h) {
    return h == null || isNaN(h = +h) ? s : (c || (c = a(e.map(i), t, n)))(i(o(h)));
  }
  return f.invert = function(h) {
    return o(r((l || (l = a(t, e.map(i), Qe)))(h)));
  }, f.domain = function(h) {
    return arguments.length ? (e = Array.from(h, _1), u()) : e.slice();
  }, f.range = function(h) {
    return arguments.length ? (t = Array.from(h), u()) : t.slice();
  }, f.rangeRound = function(h) {
    return t = Array.from(h), n = Jb, u();
  }, f.clamp = function(h) {
    return arguments.length ? (o = h ? !0 : si, u()) : o !== si;
  }, f.interpolate = function(h) {
    return arguments.length ? (n = h, u()) : n;
  }, f.unknown = function(h) {
    return arguments.length ? (s = h, f) : s;
  }, function(h, d) {
    return i = h, r = d, u();
  };
}
function V$() {
  return o0()(si, si);
}
function AG(e, t, n, i) {
  var r = Cg(e, t, n), s;
  switch (i = Ru(i ?? ",f"), i.type) {
    case "s": {
      var o = Math.max(Math.abs(e), Math.abs(t));
      return i.precision == null && !isNaN(s = LY(r, o)) && (i.precision = s), e$(i, o);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      i.precision == null && !isNaN(s = RY(r, Math.max(Math.abs(e), Math.abs(t)))) && (i.precision = s - (i.type === "e"));
      break;
    }
    case "f":
    case "%": {
      i.precision == null && !isNaN(s = EY(r)) && (i.precision = s - (i.type === "%") * 2);
      break;
    }
  }
  return rl(i);
}
function If(e) {
  var t = e.domain;
  return e.ticks = function(n) {
    var i = t();
    return Ys(i[0], i[i.length - 1], n ?? 10);
  }, e.tickFormat = function(n, i) {
    var r = t();
    return AG(r[0], r[r.length - 1], n ?? 10, i);
  }, e.nice = function(n) {
    n == null && (n = 10);
    var i = t(), r = 0, s = i.length - 1, o = i[r], a = i[s], c, l, u = 10;
    for (a < o && (l = o, o = a, a = l, l = r, r = s, s = l); u-- > 0; ) {
      if (l = Nu(o, a, n), l === c)
        return i[r] = o, i[s] = a, t(i);
      if (l > 0)
        o = Math.floor(o / l) * l, a = Math.ceil(a / l) * l;
      else if (l < 0)
        o = Math.ceil(o * l) / l, a = Math.floor(a * l) / l;
      else
        break;
      c = l;
    }
    return e;
  }, e;
}
function a0() {
  var e = V$();
  return e.copy = function() {
    return xf(e, a0());
  }, br.apply(e, arguments), If(e);
}
function j$(e) {
  var t;
  function n(i) {
    return i == null || isNaN(i = +i) ? t : i;
  }
  return n.invert = n, n.domain = n.range = function(i) {
    return arguments.length ? (e = Array.from(i, _1), n) : e.slice();
  }, n.unknown = function(i) {
    return arguments.length ? (t = i, n) : t;
  }, n.copy = function() {
    return j$(e).unknown(t);
  }, e = arguments.length ? Array.from(e, _1) : [0, 1], If(n);
}
function q$(e, t) {
  e = e.slice();
  var n = 0, i = e.length - 1, r = e[n], s = e[i], o;
  return s < r && (o = n, n = i, i = o, o = r, r = s, s = o), e[n] = t.floor(r), e[i] = t.ceil(s), e;
}
function vS(e) {
  return Math.log(e);
}
function _S(e) {
  return Math.exp(e);
}
function MG(e) {
  return -Math.log(-e);
}
function $G(e) {
  return -Math.exp(-e);
}
function TG(e) {
  return isFinite(e) ? +("1e" + e) : e < 0 ? 0 : e;
}
function DG(e) {
  return e === 10 ? TG : e === Math.E ? Math.exp : (t) => Math.pow(e, t);
}
function NG(e) {
  return e === Math.E ? Math.log : e === 10 && Math.log10 || e === 2 && Math.log2 || (e = Math.log(e), (t) => Math.log(t) / e);
}
function SS(e) {
  return (t, n) => -e(-t, n);
}
function Y$(e) {
  const t = e(vS, _S), n = t.domain;
  let i = 10, r, s;
  function o() {
    return r = NG(i), s = DG(i), n()[0] < 0 ? (r = SS(r), s = SS(s), e(MG, $G)) : e(vS, _S), t;
  }
  return t.base = function(a) {
    return arguments.length ? (i = +a, o()) : i;
  }, t.domain = function(a) {
    return arguments.length ? (n(a), o()) : n();
  }, t.ticks = (a) => {
    const c = n();
    let l = c[0], u = c[c.length - 1];
    const f = u < l;
    f && ([l, u] = [u, l]);
    let h = r(l), d = r(u), p, y;
    const m = a == null ? 10 : +a;
    let g = [];
    if (!(i % 1) && d - h < m) {
      if (h = Math.floor(h), d = Math.ceil(d), l > 0) {
        for (; h <= d; ++h)
          for (p = 1; p < i; ++p)
            if (y = h < 0 ? p / s(-h) : p * s(h), !(y < l)) {
              if (y > u)
                break;
              g.push(y);
            }
      } else
        for (; h <= d; ++h)
          for (p = i - 1; p >= 1; --p)
            if (y = h > 0 ? p / s(-h) : p * s(h), !(y < l)) {
              if (y > u)
                break;
              g.push(y);
            }
      g.length * 2 < m && (g = Ys(l, u, m));
    } else
      g = Ys(h, d, Math.min(d - h, m)).map(s);
    return f ? g.reverse() : g;
  }, t.tickFormat = (a, c) => {
    if (a == null && (a = 10), c == null && (c = i === 10 ? "s" : ","), typeof c != "function" && (!(i % 1) && (c = Ru(c)).precision == null && (c.trim = !0), c = rl(c)), a === 1 / 0)
      return c;
    const l = Math.max(1, i * a / t.ticks().length);
    return (u) => {
      let f = u / s(Math.round(r(u)));
      return f * i < i - 0.5 && (f *= i), f <= l ? c(u) : "";
    };
  }, t.nice = () => n(q$(n(), {
    floor: (a) => s(Math.floor(r(a))),
    ceil: (a) => s(Math.ceil(r(a)))
  })), t;
}
function W$() {
  const e = Y$(o0()).domain([1, 10]);
  return e.copy = () => xf(e, W$()).base(e.base()), br.apply(e, arguments), e;
}
function xS(e) {
  return function(t) {
    return Math.sign(t) * Math.log1p(Math.abs(t / e));
  };
}
function IS(e) {
  return function(t) {
    return Math.sign(t) * Math.expm1(Math.abs(t)) * e;
  };
}
function G$(e) {
  var t = 1, n = e(xS(t), IS(t));
  return n.constant = function(i) {
    return arguments.length ? e(xS(t = +i), IS(t)) : t;
  }, If(n);
}
function X$() {
  var e = G$(o0());
  return e.copy = function() {
    return xf(e, X$()).constant(e.constant());
  }, br.apply(e, arguments);
}
function AS(e) {
  return function(t) {
    return t < 0 ? -Math.pow(-t, e) : Math.pow(t, e);
  };
}
function BG(e) {
  return e < 0 ? -Math.sqrt(-e) : Math.sqrt(e);
}
function OG(e) {
  return e < 0 ? -e * e : e * e;
}
function H$(e) {
  var t = e(si, si), n = 1;
  function i() {
    return n === 1 ? e(si, si) : n === 0.5 ? e(BG, OG) : e(AS(n), AS(1 / n));
  }
  return t.exponent = function(r) {
    return arguments.length ? (n = +r, i()) : n;
  }, If(t);
}
function J$() {
  var e = H$(o0());
  return e.copy = function() {
    return xf(e, J$()).exponent(e.exponent());
  }, br.apply(e, arguments), e;
}
function K$() {
  var e = [], t = [], n = [], i;
  function r() {
    var o = 0, a = Math.max(1, t.length);
    for (n = new Array(a - 1); ++o < a; )
      n[o - 1] = zz(e, o / a);
    return s;
  }
  function s(o) {
    return o == null || isNaN(o = +o) ? i : t[Yy(n, o)];
  }
  return s.invertExtent = function(o) {
    var a = t.indexOf(o);
    return a < 0 ? [NaN, NaN] : [
      a > 0 ? n[a - 1] : e[0],
      a < n.length ? n[a] : e[e.length - 1]
    ];
  }, s.domain = function(o) {
    if (!arguments.length)
      return e.slice();
    e = [];
    for (let a of o)
      a != null && !isNaN(a = +a) && e.push(a);
    return e.sort(me), r();
  }, s.range = function(o) {
    return arguments.length ? (t = Array.from(o), r()) : t.slice();
  }, s.unknown = function(o) {
    return arguments.length ? (i = o, s) : i;
  }, s.quantiles = function() {
    return n.slice();
  }, s.copy = function() {
    return K$().domain(e).range(t).unknown(i);
  }, br.apply(s, arguments);
}
function Z$() {
  var e = [0.5], t = [0, 1], n, i = 1;
  function r(s) {
    return s != null && s <= s ? t[Yy(e, s, 0, i)] : n;
  }
  return r.domain = function(s) {
    return arguments.length ? (e = Array.from(s), i = Math.min(e.length, t.length - 1), r) : e.slice();
  }, r.range = function(s) {
    return arguments.length ? (t = Array.from(s), i = Math.min(e.length, t.length - 1), r) : t.slice();
  }, r.invertExtent = function(s) {
    var o = t.indexOf(s);
    return [e[o - 1], e[o]];
  }, r.unknown = function(s) {
    return arguments.length ? (n = s, r) : n;
  }, r.copy = function() {
    return Z$().domain(e).range(t).unknown(n);
  }, br.apply(r, arguments);
}
const Dm = /* @__PURE__ */ new Date(), Nm = /* @__PURE__ */ new Date();
function Ue(e, t, n, i) {
  function r(s) {
    return e(s = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+s)), s;
  }
  return r.floor = (s) => (e(s = /* @__PURE__ */ new Date(+s)), s), r.ceil = (s) => (e(s = new Date(s - 1)), t(s, 1), e(s), s), r.round = (s) => {
    const o = r(s), a = r.ceil(s);
    return s - o < a - s ? o : a;
  }, r.offset = (s, o) => (t(s = /* @__PURE__ */ new Date(+s), o == null ? 1 : Math.floor(o)), s), r.range = (s, o, a) => {
    const c = [];
    if (s = r.ceil(s), a = a == null ? 1 : Math.floor(a), !(s < o) || !(a > 0))
      return c;
    let l;
    do
      c.push(l = /* @__PURE__ */ new Date(+s)), t(s, a), e(s);
    while (l < s && s < o);
    return c;
  }, r.filter = (s) => Ue((o) => {
    if (o >= o)
      for (; e(o), !s(o); )
        o.setTime(o - 1);
  }, (o, a) => {
    if (o >= o)
      if (a < 0)
        for (; ++a <= 0; )
          for (; t(o, -1), !s(o); )
            ;
      else
        for (; --a >= 0; )
          for (; t(o, 1), !s(o); )
            ;
  }), n && (r.count = (s, o) => (Dm.setTime(+s), Nm.setTime(+o), e(Dm), e(Nm), Math.floor(n(Dm, Nm))), r.every = (s) => (s = Math.floor(s), !isFinite(s) || !(s > 0) ? null : s > 1 ? r.filter(i ? (o) => i(o) % s === 0 : (o) => r.count(0, o) % s === 0) : r)), r;
}
const Dp = Ue(() => {
}, (e, t) => {
  e.setTime(+e + t);
}, (e, t) => t - e);
Dp.every = (e) => (e = Math.floor(e), !isFinite(e) || !(e > 0) ? null : e > 1 ? Ue((t) => {
  t.setTime(Math.floor(t / e) * e);
}, (t, n) => {
  t.setTime(+t + n * e);
}, (t, n) => (n - t) / e) : Dp);
Dp.range;
const Hr = 1e3, oi = Hr * 60, Jr = oi * 60, os = Jr * 24, uw = os * 7, MS = os * 30, Bm = os * 365, xi = Ue((e) => {
  e.setTime(e - e.getMilliseconds());
}, (e, t) => {
  e.setTime(+e + t * Hr);
}, (e, t) => (t - e) / Hr, (e) => e.getUTCSeconds());
xi.range;
const Af = Ue((e) => {
  e.setTime(e - e.getMilliseconds() - e.getSeconds() * Hr);
}, (e, t) => {
  e.setTime(+e + t * oi);
}, (e, t) => (t - e) / oi, (e) => e.getMinutes());
Af.range;
const Mf = Ue((e) => {
  e.setUTCSeconds(0, 0);
}, (e, t) => {
  e.setTime(+e + t * oi);
}, (e, t) => (t - e) / oi, (e) => e.getUTCMinutes());
Mf.range;
const $f = Ue((e) => {
  e.setTime(e - e.getMilliseconds() - e.getSeconds() * Hr - e.getMinutes() * oi);
}, (e, t) => {
  e.setTime(+e + t * Jr);
}, (e, t) => (t - e) / Jr, (e) => e.getHours());
$f.range;
const Tf = Ue((e) => {
  e.setUTCMinutes(0, 0, 0);
}, (e, t) => {
  e.setTime(+e + t * Jr);
}, (e, t) => (t - e) / Jr, (e) => e.getUTCHours());
Tf.range;
const aa = Ue(
  (e) => e.setHours(0, 0, 0, 0),
  (e, t) => e.setDate(e.getDate() + t),
  (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * oi) / os,
  (e) => e.getDate() - 1
);
aa.range;
const c0 = Ue((e) => {
  e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCDate(e.getUTCDate() + t);
}, (e, t) => (t - e) / os, (e) => e.getUTCDate() - 1);
c0.range;
const l0 = Ue((e) => {
  e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCDate(e.getUTCDate() + t);
}, (e, t) => (t - e) / os, (e) => Math.floor(e / os));
l0.range;
function ca(e) {
  return Ue((t) => {
    t.setDate(t.getDate() - (t.getDay() + 7 - e) % 7), t.setHours(0, 0, 0, 0);
  }, (t, n) => {
    t.setDate(t.getDate() + n * 7);
  }, (t, n) => (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * oi) / uw);
}
const Rc = ca(0), Uu = ca(1), Q$ = ca(2), t6 = ca(3), na = ca(4), e6 = ca(5), n6 = ca(6);
Rc.range;
Uu.range;
Q$.range;
t6.range;
na.range;
e6.range;
n6.range;
function la(e) {
  return Ue((t) => {
    t.setUTCDate(t.getUTCDate() - (t.getUTCDay() + 7 - e) % 7), t.setUTCHours(0, 0, 0, 0);
  }, (t, n) => {
    t.setUTCDate(t.getUTCDate() + n * 7);
  }, (t, n) => (n - t) / uw);
}
const Cc = la(0), zu = la(1), i6 = la(2), r6 = la(3), ia = la(4), s6 = la(5), o6 = la(6);
Cc.range;
zu.range;
i6.range;
r6.range;
ia.range;
s6.range;
o6.range;
const Df = Ue((e) => {
  e.setDate(1), e.setHours(0, 0, 0, 0);
}, (e, t) => {
  e.setMonth(e.getMonth() + t);
}, (e, t) => t.getMonth() - e.getMonth() + (t.getFullYear() - e.getFullYear()) * 12, (e) => e.getMonth());
Df.range;
const Nf = Ue((e) => {
  e.setUTCDate(1), e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCMonth(e.getUTCMonth() + t);
}, (e, t) => t.getUTCMonth() - e.getUTCMonth() + (t.getUTCFullYear() - e.getUTCFullYear()) * 12, (e) => e.getUTCMonth());
Nf.range;
const Ni = Ue((e) => {
  e.setMonth(0, 1), e.setHours(0, 0, 0, 0);
}, (e, t) => {
  e.setFullYear(e.getFullYear() + t);
}, (e, t) => t.getFullYear() - e.getFullYear(), (e) => e.getFullYear());
Ni.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : Ue((t) => {
  t.setFullYear(Math.floor(t.getFullYear() / e) * e), t.setMonth(0, 1), t.setHours(0, 0, 0, 0);
}, (t, n) => {
  t.setFullYear(t.getFullYear() + n * e);
});
Ni.range;
const Bi = Ue((e) => {
  e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCFullYear(e.getUTCFullYear() + t);
}, (e, t) => t.getUTCFullYear() - e.getUTCFullYear(), (e) => e.getUTCFullYear());
Bi.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : Ue((t) => {
  t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e), t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
}, (t, n) => {
  t.setUTCFullYear(t.getUTCFullYear() + n * e);
});
Bi.range;
function a6(e, t, n, i, r, s) {
  const o = [
    [xi, 1, Hr],
    [xi, 5, 5 * Hr],
    [xi, 15, 15 * Hr],
    [xi, 30, 30 * Hr],
    [s, 1, oi],
    [s, 5, 5 * oi],
    [s, 15, 15 * oi],
    [s, 30, 30 * oi],
    [r, 1, Jr],
    [r, 3, 3 * Jr],
    [r, 6, 6 * Jr],
    [r, 12, 12 * Jr],
    [i, 1, os],
    [i, 2, 2 * os],
    [n, 1, uw],
    [t, 1, MS],
    [t, 3, 3 * MS],
    [e, 1, Bm]
  ];
  function a(l, u, f) {
    const h = u < l;
    h && ([l, u] = [u, l]);
    const d = f && typeof f.range == "function" ? f : c(l, u, f), p = d ? d.range(l, +u + 1) : [];
    return h ? p.reverse() : p;
  }
  function c(l, u, f) {
    const h = Math.abs(u - l) / f, d = qy(([, , m]) => m).right(o, h);
    if (d === o.length)
      return e.every(Cg(l / Bm, u / Bm, f));
    if (d === 0)
      return Dp.every(Math.max(Cg(l, u, f), 1));
    const [p, y] = o[h / o[d - 1][2] < o[d][2] / h ? d - 1 : d];
    return p.every(y);
  }
  return [a, c];
}
const [FG, c6] = a6(Bi, Nf, Cc, l0, Tf, Mf), [EG, LG] = a6(Ni, Df, Rc, aa, $f, Af);
function Om(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(-1, e.m, e.d, e.H, e.M, e.S, e.L);
    return t.setFullYear(e.y), t;
  }
  return new Date(e.y, e.m, e.d, e.H, e.M, e.S, e.L);
}
function Fm(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(Date.UTC(-1, e.m, e.d, e.H, e.M, e.S, e.L));
    return t.setUTCFullYear(e.y), t;
  }
  return new Date(Date.UTC(e.y, e.m, e.d, e.H, e.M, e.S, e.L));
}
function xl(e, t, n) {
  return { y: e, m: t, d: n, H: 0, M: 0, S: 0, L: 0 };
}
function RG(e) {
  var t = e.dateTime, n = e.date, i = e.time, r = e.periods, s = e.days, o = e.shortDays, a = e.months, c = e.shortMonths, l = Il(r), u = Al(r), f = Il(s), h = Al(s), d = Il(o), p = Al(o), y = Il(a), m = Al(a), g = Il(c), b = Al(c), w = {
    a: L,
    A: k,
    b: U,
    B: C,
    c: null,
    d: OS,
    e: OS,
    f: sX,
    g: yX,
    G: gX,
    H: nX,
    I: iX,
    j: rX,
    L: l6,
    m: oX,
    M: aX,
    p: z,
    q: P,
    Q: LS,
    s: RS,
    S: cX,
    u: lX,
    U: uX,
    V: fX,
    w: hX,
    W: dX,
    x: null,
    X: null,
    y: pX,
    Y: mX,
    Z: bX,
    "%": ES
  }, v = {
    a: G,
    A: K,
    b: et,
    B: Z,
    c: null,
    d: FS,
    e: FS,
    f: SX,
    g: OX,
    G: EX,
    H: wX,
    I: vX,
    j: _X,
    L: f6,
    m: xX,
    M: IX,
    p: Y,
    q: X,
    Q: LS,
    s: RS,
    S: AX,
    u: MX,
    U: $X,
    V: TX,
    w: DX,
    W: NX,
    x: null,
    X: null,
    y: BX,
    Y: FX,
    Z: LX,
    "%": ES
  }, S = {
    a: N,
    A,
    b: B,
    B: R,
    c: x,
    d: NS,
    e: NS,
    f: ZG,
    g: DS,
    G: TS,
    H: BS,
    I: BS,
    j: XG,
    L: KG,
    m: GG,
    M: HG,
    p: M,
    q: WG,
    Q: tX,
    s: eX,
    S: JG,
    u: PG,
    U: VG,
    V: jG,
    w: zG,
    W: qG,
    x: $,
    X: D,
    y: DS,
    Y: TS,
    Z: YG,
    "%": QG
  };
  w.x = _(n, w), w.X = _(i, w), w.c = _(t, w), v.x = _(n, v), v.X = _(i, v), v.c = _(t, v);
  function _(j, J) {
    return function(tt) {
      var V = [], Ft = -1, st = 0, Vt = j.length, jt, Q, Zt;
      for (tt instanceof Date || (tt = /* @__PURE__ */ new Date(+tt)); ++Ft < Vt; )
        j.charCodeAt(Ft) === 37 && (V.push(j.slice(st, Ft)), (Q = $S[jt = j.charAt(++Ft)]) != null ? jt = j.charAt(++Ft) : Q = jt === "e" ? " " : "0", (Zt = J[jt]) && (jt = Zt(tt, Q)), V.push(jt), st = Ft + 1);
      return V.push(j.slice(st, Ft)), V.join("");
    };
  }
  function I(j, J) {
    return function(tt) {
      var V = xl(1900, void 0, 1), Ft = T(V, j, tt += "", 0), st, Vt;
      if (Ft != tt.length)
        return null;
      if ("Q" in V)
        return new Date(V.Q);
      if ("s" in V)
        return new Date(V.s * 1e3 + ("L" in V ? V.L : 0));
      if (J && !("Z" in V) && (V.Z = 0), "p" in V && (V.H = V.H % 12 + V.p * 12), V.m === void 0 && (V.m = "q" in V ? V.q : 0), "V" in V) {
        if (V.V < 1 || V.V > 53)
          return null;
        "w" in V || (V.w = 1), "Z" in V ? (st = Fm(xl(V.y, 0, 1)), Vt = st.getUTCDay(), st = Vt > 4 || Vt === 0 ? zu.ceil(st) : zu(st), st = c0.offset(st, (V.V - 1) * 7), V.y = st.getUTCFullYear(), V.m = st.getUTCMonth(), V.d = st.getUTCDate() + (V.w + 6) % 7) : (st = Om(xl(V.y, 0, 1)), Vt = st.getDay(), st = Vt > 4 || Vt === 0 ? Uu.ceil(st) : Uu(st), st = aa.offset(st, (V.V - 1) * 7), V.y = st.getFullYear(), V.m = st.getMonth(), V.d = st.getDate() + (V.w + 6) % 7);
      } else
        ("W" in V || "U" in V) && ("w" in V || (V.w = "u" in V ? V.u % 7 : "W" in V ? 1 : 0), Vt = "Z" in V ? Fm(xl(V.y, 0, 1)).getUTCDay() : Om(xl(V.y, 0, 1)).getDay(), V.m = 0, V.d = "W" in V ? (V.w + 6) % 7 + V.W * 7 - (Vt + 5) % 7 : V.w + V.U * 7 - (Vt + 6) % 7);
      return "Z" in V ? (V.H += V.Z / 100 | 0, V.M += V.Z % 100, Fm(V)) : Om(V);
    };
  }
  function T(j, J, tt, V) {
    for (var Ft = 0, st = J.length, Vt = tt.length, jt, Q; Ft < st; ) {
      if (V >= Vt)
        return -1;
      if (jt = J.charCodeAt(Ft++), jt === 37) {
        if (jt = J.charAt(Ft++), Q = S[jt in $S ? J.charAt(Ft++) : jt], !Q || (V = Q(j, tt, V)) < 0)
          return -1;
      } else if (jt != tt.charCodeAt(V++))
        return -1;
    }
    return V;
  }
  function M(j, J, tt) {
    var V = l.exec(J.slice(tt));
    return V ? (j.p = u.get(V[0].toLowerCase()), tt + V[0].length) : -1;
  }
  function N(j, J, tt) {
    var V = d.exec(J.slice(tt));
    return V ? (j.w = p.get(V[0].toLowerCase()), tt + V[0].length) : -1;
  }
  function A(j, J, tt) {
    var V = f.exec(J.slice(tt));
    return V ? (j.w = h.get(V[0].toLowerCase()), tt + V[0].length) : -1;
  }
  function B(j, J, tt) {
    var V = g.exec(J.slice(tt));
    return V ? (j.m = b.get(V[0].toLowerCase()), tt + V[0].length) : -1;
  }
  function R(j, J, tt) {
    var V = y.exec(J.slice(tt));
    return V ? (j.m = m.get(V[0].toLowerCase()), tt + V[0].length) : -1;
  }
  function x(j, J, tt) {
    return T(j, t, J, tt);
  }
  function $(j, J, tt) {
    return T(j, n, J, tt);
  }
  function D(j, J, tt) {
    return T(j, i, J, tt);
  }
  function L(j) {
    return o[j.getDay()];
  }
  function k(j) {
    return s[j.getDay()];
  }
  function U(j) {
    return c[j.getMonth()];
  }
  function C(j) {
    return a[j.getMonth()];
  }
  function z(j) {
    return r[+(j.getHours() >= 12)];
  }
  function P(j) {
    return 1 + ~~(j.getMonth() / 3);
  }
  function G(j) {
    return o[j.getUTCDay()];
  }
  function K(j) {
    return s[j.getUTCDay()];
  }
  function et(j) {
    return c[j.getUTCMonth()];
  }
  function Z(j) {
    return a[j.getUTCMonth()];
  }
  function Y(j) {
    return r[+(j.getUTCHours() >= 12)];
  }
  function X(j) {
    return 1 + ~~(j.getUTCMonth() / 3);
  }
  return {
    format: function(j) {
      var J = _(j += "", w);
      return J.toString = function() {
        return j;
      }, J;
    },
    parse: function(j) {
      var J = I(j += "", !1);
      return J.toString = function() {
        return j;
      }, J;
    },
    utcFormat: function(j) {
      var J = _(j += "", v);
      return J.toString = function() {
        return j;
      }, J;
    },
    utcParse: function(j) {
      var J = I(j += "", !0);
      return J.toString = function() {
        return j;
      }, J;
    }
  };
}
var $S = { "-": "", _: " ", 0: "0" }, We = /^\s*\d+/, CG = /^%/, kG = /[\\^$*+?|[\]().{}]/g;
function Ht(e, t, n) {
  var i = e < 0 ? "-" : "", r = (i ? -e : e) + "", s = r.length;
  return i + (s < n ? new Array(n - s + 1).join(t) + r : r);
}
function UG(e) {
  return e.replace(kG, "\\$&");
}
function Il(e) {
  return new RegExp("^(?:" + e.map(UG).join("|") + ")", "i");
}
function Al(e) {
  return new Map(e.map((t, n) => [t.toLowerCase(), n]));
}
function zG(e, t, n) {
  var i = We.exec(t.slice(n, n + 1));
  return i ? (e.w = +i[0], n + i[0].length) : -1;
}
function PG(e, t, n) {
  var i = We.exec(t.slice(n, n + 1));
  return i ? (e.u = +i[0], n + i[0].length) : -1;
}
function VG(e, t, n) {
  var i = We.exec(t.slice(n, n + 2));
  return i ? (e.U = +i[0], n + i[0].length) : -1;
}
function jG(e, t, n) {
  var i = We.exec(t.slice(n, n + 2));
  return i ? (e.V = +i[0], n + i[0].length) : -1;
}
function qG(e, t, n) {
  var i = We.exec(t.slice(n, n + 2));
  return i ? (e.W = +i[0], n + i[0].length) : -1;
}
function TS(e, t, n) {
  var i = We.exec(t.slice(n, n + 4));
  return i ? (e.y = +i[0], n + i[0].length) : -1;
}
function DS(e, t, n) {
  var i = We.exec(t.slice(n, n + 2));
  return i ? (e.y = +i[0] + (+i[0] > 68 ? 1900 : 2e3), n + i[0].length) : -1;
}
function YG(e, t, n) {
  var i = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(n, n + 6));
  return i ? (e.Z = i[1] ? 0 : -(i[2] + (i[3] || "00")), n + i[0].length) : -1;
}
function WG(e, t, n) {
  var i = We.exec(t.slice(n, n + 1));
  return i ? (e.q = i[0] * 3 - 3, n + i[0].length) : -1;
}
function GG(e, t, n) {
  var i = We.exec(t.slice(n, n + 2));
  return i ? (e.m = i[0] - 1, n + i[0].length) : -1;
}
function NS(e, t, n) {
  var i = We.exec(t.slice(n, n + 2));
  return i ? (e.d = +i[0], n + i[0].length) : -1;
}
function XG(e, t, n) {
  var i = We.exec(t.slice(n, n + 3));
  return i ? (e.m = 0, e.d = +i[0], n + i[0].length) : -1;
}
function BS(e, t, n) {
  var i = We.exec(t.slice(n, n + 2));
  return i ? (e.H = +i[0], n + i[0].length) : -1;
}
function HG(e, t, n) {
  var i = We.exec(t.slice(n, n + 2));
  return i ? (e.M = +i[0], n + i[0].length) : -1;
}
function JG(e, t, n) {
  var i = We.exec(t.slice(n, n + 2));
  return i ? (e.S = +i[0], n + i[0].length) : -1;
}
function KG(e, t, n) {
  var i = We.exec(t.slice(n, n + 3));
  return i ? (e.L = +i[0], n + i[0].length) : -1;
}
function ZG(e, t, n) {
  var i = We.exec(t.slice(n, n + 6));
  return i ? (e.L = Math.floor(i[0] / 1e3), n + i[0].length) : -1;
}
function QG(e, t, n) {
  var i = CG.exec(t.slice(n, n + 1));
  return i ? n + i[0].length : -1;
}
function tX(e, t, n) {
  var i = We.exec(t.slice(n));
  return i ? (e.Q = +i[0], n + i[0].length) : -1;
}
function eX(e, t, n) {
  var i = We.exec(t.slice(n));
  return i ? (e.s = +i[0], n + i[0].length) : -1;
}
function OS(e, t) {
  return Ht(e.getDate(), t, 2);
}
function nX(e, t) {
  return Ht(e.getHours(), t, 2);
}
function iX(e, t) {
  return Ht(e.getHours() % 12 || 12, t, 2);
}
function rX(e, t) {
  return Ht(1 + aa.count(Ni(e), e), t, 3);
}
function l6(e, t) {
  return Ht(e.getMilliseconds(), t, 3);
}
function sX(e, t) {
  return l6(e, t) + "000";
}
function oX(e, t) {
  return Ht(e.getMonth() + 1, t, 2);
}
function aX(e, t) {
  return Ht(e.getMinutes(), t, 2);
}
function cX(e, t) {
  return Ht(e.getSeconds(), t, 2);
}
function lX(e) {
  var t = e.getDay();
  return t === 0 ? 7 : t;
}
function uX(e, t) {
  return Ht(Rc.count(Ni(e) - 1, e), t, 2);
}
function u6(e) {
  var t = e.getDay();
  return t >= 4 || t === 0 ? na(e) : na.ceil(e);
}
function fX(e, t) {
  return e = u6(e), Ht(na.count(Ni(e), e) + (Ni(e).getDay() === 4), t, 2);
}
function hX(e) {
  return e.getDay();
}
function dX(e, t) {
  return Ht(Uu.count(Ni(e) - 1, e), t, 2);
}
function pX(e, t) {
  return Ht(e.getFullYear() % 100, t, 2);
}
function yX(e, t) {
  return e = u6(e), Ht(e.getFullYear() % 100, t, 2);
}
function mX(e, t) {
  return Ht(e.getFullYear() % 1e4, t, 4);
}
function gX(e, t) {
  var n = e.getDay();
  return e = n >= 4 || n === 0 ? na(e) : na.ceil(e), Ht(e.getFullYear() % 1e4, t, 4);
}
function bX(e) {
  var t = e.getTimezoneOffset();
  return (t > 0 ? "-" : (t *= -1, "+")) + Ht(t / 60 | 0, "0", 2) + Ht(t % 60, "0", 2);
}
function FS(e, t) {
  return Ht(e.getUTCDate(), t, 2);
}
function wX(e, t) {
  return Ht(e.getUTCHours(), t, 2);
}
function vX(e, t) {
  return Ht(e.getUTCHours() % 12 || 12, t, 2);
}
function _X(e, t) {
  return Ht(1 + c0.count(Bi(e), e), t, 3);
}
function f6(e, t) {
  return Ht(e.getUTCMilliseconds(), t, 3);
}
function SX(e, t) {
  return f6(e, t) + "000";
}
function xX(e, t) {
  return Ht(e.getUTCMonth() + 1, t, 2);
}
function IX(e, t) {
  return Ht(e.getUTCMinutes(), t, 2);
}
function AX(e, t) {
  return Ht(e.getUTCSeconds(), t, 2);
}
function MX(e) {
  var t = e.getUTCDay();
  return t === 0 ? 7 : t;
}
function $X(e, t) {
  return Ht(Cc.count(Bi(e) - 1, e), t, 2);
}
function h6(e) {
  var t = e.getUTCDay();
  return t >= 4 || t === 0 ? ia(e) : ia.ceil(e);
}
function TX(e, t) {
  return e = h6(e), Ht(ia.count(Bi(e), e) + (Bi(e).getUTCDay() === 4), t, 2);
}
function DX(e) {
  return e.getUTCDay();
}
function NX(e, t) {
  return Ht(zu.count(Bi(e) - 1, e), t, 2);
}
function BX(e, t) {
  return Ht(e.getUTCFullYear() % 100, t, 2);
}
function OX(e, t) {
  return e = h6(e), Ht(e.getUTCFullYear() % 100, t, 2);
}
function FX(e, t) {
  return Ht(e.getUTCFullYear() % 1e4, t, 4);
}
function EX(e, t) {
  var n = e.getUTCDay();
  return e = n >= 4 || n === 0 ? ia(e) : ia.ceil(e), Ht(e.getUTCFullYear() % 1e4, t, 4);
}
function LX() {
  return "+0000";
}
function ES() {
  return "%";
}
function LS(e) {
  return +e;
}
function RS(e) {
  return Math.floor(+e / 1e3);
}
var xa, fw, Bf;
RX({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function RX(e) {
  return xa = RG(e), fw = xa.format, xa.parse, Bf = xa.utcFormat, xa.utcParse, xa;
}
function CX(e) {
  return new Date(e);
}
function kX(e) {
  return e instanceof Date ? +e : +/* @__PURE__ */ new Date(+e);
}
function hw(e, t, n, i, r, s, o, a, c, l) {
  var u = V$(), f = u.invert, h = u.domain, d = l(".%L"), p = l(":%S"), y = l("%I:%M"), m = l("%I %p"), g = l("%a %d"), b = l("%b %d"), w = l("%B"), v = l("%Y");
  function S(_) {
    return (c(_) < _ ? d : a(_) < _ ? p : o(_) < _ ? y : s(_) < _ ? m : i(_) < _ ? r(_) < _ ? g : b : n(_) < _ ? w : v)(_);
  }
  return u.invert = function(_) {
    return new Date(f(_));
  }, u.domain = function(_) {
    return arguments.length ? h(Array.from(_, kX)) : h().map(CX);
  }, u.ticks = function(_) {
    var I = h();
    return e(I[0], I[I.length - 1], _ ?? 10);
  }, u.tickFormat = function(_, I) {
    return I == null ? S : l(I);
  }, u.nice = function(_) {
    var I = h();
    return (!_ || typeof _.range != "function") && (_ = t(I[0], I[I.length - 1], _ ?? 10)), _ ? h(q$(I, _)) : u;
  }, u.copy = function() {
    return xf(u, hw(e, t, n, i, r, s, o, a, c, l));
  }, u;
}
function UX() {
  return br.apply(hw(EG, LG, Ni, Df, Rc, aa, $f, Af, xi, fw).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
function zX() {
  return br.apply(hw(FG, c6, Bi, Nf, Cc, c0, Tf, Mf, xi, Bf).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}
function u0(e, t) {
  return t.domain(e.domain()).interpolator(e.interpolator()).clamp(e.clamp()).unknown(e.unknown());
}
function f0() {
  var e = 0, t = 0.5, n = 1, i = 1, r, s, o, a, c, l = si, u, f = !1, h;
  function d(y) {
    return isNaN(y = +y) ? h : (y = 0.5 + ((y = +u(y)) - s) * (i * y < i * s ? a : c), l(f ? Math.max(0, Math.min(1, y)) : y));
  }
  d.domain = function(y) {
    return arguments.length ? ([e, t, n] = y, r = u(e = +e), s = u(t = +t), o = u(n = +n), a = r === s ? 0 : 0.5 / (s - r), c = s === o ? 0 : 0.5 / (o - s), i = s < r ? -1 : 1, d) : [e, t, n];
  }, d.clamp = function(y) {
    return arguments.length ? (f = !!y, d) : f;
  }, d.interpolator = function(y) {
    return arguments.length ? (l = y, d) : l;
  };
  function p(y) {
    return function(m) {
      var g, b, w;
      return arguments.length ? ([g, b, w] = m, l = Qy(y, [g, b, w]), d) : [l(0), l(0.5), l(1)];
    };
  }
  return d.range = p(il), d.rangeRound = p(Jb), d.unknown = function(y) {
    return arguments.length ? (h = y, d) : h;
  }, function(y) {
    return u = y, r = y(e), s = y(t), o = y(n), a = r === s ? 0 : 0.5 / (s - r), c = s === o ? 0 : 0.5 / (o - s), i = s < r ? -1 : 1, d;
  };
}
function d6() {
  var e = If(f0()(si));
  return e.copy = function() {
    return u0(e, d6());
  }, r0.apply(e, arguments);
}
function p6() {
  var e = Y$(f0()).domain([0.1, 1, 10]);
  return e.copy = function() {
    return u0(e, p6()).base(e.base());
  }, r0.apply(e, arguments);
}
function y6() {
  var e = G$(f0());
  return e.copy = function() {
    return u0(e, y6()).constant(e.constant());
  }, r0.apply(e, arguments);
}
function m6() {
  var e = H$(f0());
  return e.copy = function() {
    return u0(e, m6()).exponent(e.exponent());
  }, r0.apply(e, arguments);
}
function Et(e) {
  for (var t = e.length / 6 | 0, n = new Array(t), i = 0; i < t; )
    n[i] = "#" + e.slice(i * 6, ++i * 6);
  return n;
}
const PX = Et("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf"), VX = Et("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666"), jX = Et("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666"), qX = Et("4269d0efb118ff725c6cc5b03ca951ff8ab7a463f297bbf59c6b4e9498a0"), YX = Et("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928"), WX = Et("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2"), GX = Et("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc"), XX = Et("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999"), HX = Et("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3"), JX = Et("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f"), KX = Et("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab"), le = (e) => tj(e[e.length - 1]);
var g6 = new Array(3).concat(
  "d8b365f5f5f55ab4ac",
  "a6611adfc27d80cdc1018571",
  "a6611adfc27df5f5f580cdc1018571",
  "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
  "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
  "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
  "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
  "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
  "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
).map(Et);
const b6 = le(g6);
var w6 = new Array(3).concat(
  "af8dc3f7f7f77fbf7b",
  "7b3294c2a5cfa6dba0008837",
  "7b3294c2a5cff7f7f7a6dba0008837",
  "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
  "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
  "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
  "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
  "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
  "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
).map(Et);
const v6 = le(w6);
var _6 = new Array(3).concat(
  "e9a3c9f7f7f7a1d76a",
  "d01c8bf1b6dab8e1864dac26",
  "d01c8bf1b6daf7f7f7b8e1864dac26",
  "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
  "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
  "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
  "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
  "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
  "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
).map(Et);
const S6 = le(_6);
var x6 = new Array(3).concat(
  "998ec3f7f7f7f1a340",
  "5e3c99b2abd2fdb863e66101",
  "5e3c99b2abd2f7f7f7fdb863e66101",
  "542788998ec3d8daebfee0b6f1a340b35806",
  "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
  "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
  "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
  "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
  "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
).map(Et);
const I6 = le(x6);
var x1 = new Array(3).concat(
  "ef8a62f7f7f767a9cf",
  "ca0020f4a58292c5de0571b0",
  "ca0020f4a582f7f7f792c5de0571b0",
  "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
  "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
  "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
  "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
  "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
  "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
).map(Et);
const Np = le(x1);
var A6 = new Array(3).concat(
  "ef8a62ffffff999999",
  "ca0020f4a582bababa404040",
  "ca0020f4a582ffffffbababa404040",
  "b2182bef8a62fddbc7e0e0e09999994d4d4d",
  "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
  "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
  "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
  "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
  "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
).map(Et);
const M6 = le(A6);
var I1 = new Array(3).concat(
  "fc8d59ffffbf91bfdb",
  "d7191cfdae61abd9e92c7bb6",
  "d7191cfdae61ffffbfabd9e92c7bb6",
  "d73027fc8d59fee090e0f3f891bfdb4575b4",
  "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
  "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
  "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
  "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
  "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
).map(Et);
const Bp = le(I1);
var $6 = new Array(3).concat(
  "fc8d59ffffbf91cf60",
  "d7191cfdae61a6d96a1a9641",
  "d7191cfdae61ffffbfa6d96a1a9641",
  "d73027fc8d59fee08bd9ef8b91cf601a9850",
  "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
  "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
  "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
  "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
  "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
).map(Et);
const T6 = le($6);
var D6 = new Array(3).concat(
  "fc8d59ffffbf99d594",
  "d7191cfdae61abdda42b83ba",
  "d7191cfdae61ffffbfabdda42b83ba",
  "d53e4ffc8d59fee08be6f59899d5943288bd",
  "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
  "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
  "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
  "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
  "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
).map(Et);
const N6 = le(D6);
var B6 = new Array(3).concat(
  "e5f5f999d8c92ca25f",
  "edf8fbb2e2e266c2a4238b45",
  "edf8fbb2e2e266c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
).map(Et);
const O6 = le(B6);
var F6 = new Array(3).concat(
  "e0ecf49ebcda8856a7",
  "edf8fbb3cde38c96c688419d",
  "edf8fbb3cde38c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
).map(Et);
const E6 = le(F6);
var L6 = new Array(3).concat(
  "e0f3dba8ddb543a2ca",
  "f0f9e8bae4bc7bccc42b8cbe",
  "f0f9e8bae4bc7bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
).map(Et);
const R6 = le(L6);
var C6 = new Array(3).concat(
  "fee8c8fdbb84e34a33",
  "fef0d9fdcc8afc8d59d7301f",
  "fef0d9fdcc8afc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
).map(Et);
const k6 = le(C6);
var U6 = new Array(3).concat(
  "ece2f0a6bddb1c9099",
  "f6eff7bdc9e167a9cf02818a",
  "f6eff7bdc9e167a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
).map(Et);
const z6 = le(U6);
var P6 = new Array(3).concat(
  "ece7f2a6bddb2b8cbe",
  "f1eef6bdc9e174a9cf0570b0",
  "f1eef6bdc9e174a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
).map(Et);
const V6 = le(P6);
var j6 = new Array(3).concat(
  "e7e1efc994c7dd1c77",
  "f1eef6d7b5d8df65b0ce1256",
  "f1eef6d7b5d8df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
).map(Et);
const q6 = le(j6);
var Y6 = new Array(3).concat(
  "fde0ddfa9fb5c51b8a",
  "feebe2fbb4b9f768a1ae017e",
  "feebe2fbb4b9f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
).map(Et);
const W6 = le(Y6);
var G6 = new Array(3).concat(
  "edf8b17fcdbb2c7fb8",
  "ffffcca1dab441b6c4225ea8",
  "ffffcca1dab441b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
).map(Et);
const X6 = le(G6);
var H6 = new Array(3).concat(
  "f7fcb9addd8e31a354",
  "ffffccc2e69978c679238443",
  "ffffccc2e69978c67931a354006837",
  "ffffccd9f0a3addd8e78c67931a354006837",
  "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
).map(Et);
const J6 = le(H6);
var K6 = new Array(3).concat(
  "fff7bcfec44fd95f0e",
  "ffffd4fed98efe9929cc4c02",
  "ffffd4fed98efe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
).map(Et);
const Z6 = le(K6);
var Q6 = new Array(3).concat(
  "ffeda0feb24cf03b20",
  "ffffb2fecc5cfd8d3ce31a1c",
  "ffffb2fecc5cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
).map(Et);
const tT = le(Q6);
var eT = new Array(3).concat(
  "deebf79ecae13182bd",
  "eff3ffbdd7e76baed62171b5",
  "eff3ffbdd7e76baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
).map(Et);
const nT = le(eT);
var iT = new Array(3).concat(
  "e5f5e0a1d99b31a354",
  "edf8e9bae4b374c476238b45",
  "edf8e9bae4b374c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
).map(Et);
const rT = le(iT);
var sT = new Array(3).concat(
  "f0f0f0bdbdbd636363",
  "f7f7f7cccccc969696525252",
  "f7f7f7cccccc969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
).map(Et);
const oT = le(sT);
var aT = new Array(3).concat(
  "efedf5bcbddc756bb1",
  "f2f0f7cbc9e29e9ac86a51a3",
  "f2f0f7cbc9e29e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
).map(Et);
const cT = le(aT);
var lT = new Array(3).concat(
  "fee0d2fc9272de2d26",
  "fee5d9fcae91fb6a4acb181d",
  "fee5d9fcae91fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
).map(Et);
const uT = le(lT);
var fT = new Array(3).concat(
  "fee6cefdae6be6550d",
  "feeddefdbe85fd8d3cd94701",
  "feeddefdbe85fd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
).map(Et);
const hT = le(fT);
function dT(e) {
  return e = Math.max(0, Math.min(1, e)), "rgb(" + Math.max(0, Math.min(255, Math.round(-4.54 - e * (35.34 - e * (2381.73 - e * (6402.7 - e * (7024.72 - e * 2710.57))))))) + ", " + Math.max(0, Math.min(255, Math.round(32.49 + e * (170.73 + e * (52.82 - e * (131.46 - e * (176.58 - e * 67.37))))))) + ", " + Math.max(0, Math.min(255, Math.round(81.24 + e * (442.36 - e * (2482.43 - e * (6167.24 - e * (6614.94 - e * 2475.67))))))) + ")";
}
const pT = Kb(hr(300, 0.5, 0), hr(-240, 0.5, 1));
var yT = Kb(hr(-100, 0.75, 0.35), hr(80, 1.5, 0.8)), mT = Kb(hr(260, 0.75, 0.35), hr(80, 1.5, 0.8)), bh = hr();
function gT(e) {
  (e < 0 || e > 1) && (e -= Math.floor(e));
  var t = Math.abs(e - 0.5);
  return bh.h = 360 * e - 100, bh.s = 1.5 - 1.5 * t, bh.l = 0.8 - 0.9 * t, bh + "";
}
var wh = Vn(), ZX = Math.PI / 3, QX = Math.PI * 2 / 3;
function bT(e) {
  var t;
  return e = (0.5 - e) * Math.PI, wh.r = 255 * (t = Math.sin(e)) * t, wh.g = 255 * (t = Math.sin(e + ZX)) * t, wh.b = 255 * (t = Math.sin(e + QX)) * t, wh + "";
}
function wT(e) {
  return e = Math.max(0, Math.min(1, e)), "rgb(" + Math.max(0, Math.min(255, Math.round(34.61 + e * (1172.33 - e * (10793.56 - e * (33300.12 - e * (38394.49 - e * 14825.05))))))) + ", " + Math.max(0, Math.min(255, Math.round(23.31 + e * (557.33 + e * (1225.33 - e * (3574.96 - e * (1073.77 + e * 707.56))))))) + ", " + Math.max(0, Math.min(255, Math.round(27.2 + e * (3211.1 - e * (15327.97 - e * (27814 - e * (22569.18 - e * 6838.66))))))) + ")";
}
function h0(e) {
  var t = e.length;
  return function(n) {
    return e[Math.max(0, Math.min(t - 1, Math.floor(n * t)))];
  };
}
const vT = h0(Et("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
var _T = h0(Et("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf")), ST = h0(Et("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4")), xT = h0(Et("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));
function je(e) {
  return function() {
    return e;
  };
}
const IT = Math.cos, dw = Math.min, Op = Math.sin, ze = Math.sqrt, CS = 1e-12, Fp = Math.PI, d0 = 2 * Fp;
function AT(e) {
  let t = 3;
  return e.digits = function(n) {
    if (!arguments.length)
      return t;
    if (n == null)
      t = null;
    else {
      const i = Math.floor(n);
      if (!(i >= 0))
        throw new RangeError(`invalid digits: ${n}`);
      t = i;
    }
    return e;
  }, () => new ZM(t);
}
function MT(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function $T(e) {
  this._context = e;
}
$T.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(e, t);
        break;
    }
  }
};
function Of(e) {
  return new $T(e);
}
function TT(e) {
  return e[0];
}
function DT(e) {
  return e[1];
}
function NT(e, t) {
  var n = je(!0), i = null, r = Of, s = null, o = AT(a);
  e = typeof e == "function" ? e : e === void 0 ? TT : je(e), t = typeof t == "function" ? t : t === void 0 ? DT : je(t);
  function a(c) {
    var l, u = (c = MT(c)).length, f, h = !1, d;
    for (i == null && (s = r(d = o())), l = 0; l <= u; ++l)
      !(l < u && n(f = c[l], l, c)) === h && ((h = !h) ? s.lineStart() : s.lineEnd()), h && s.point(+e(f, l, c), +t(f, l, c));
    if (d)
      return s = null, d + "" || null;
  }
  return a.x = function(c) {
    return arguments.length ? (e = typeof c == "function" ? c : je(+c), a) : e;
  }, a.y = function(c) {
    return arguments.length ? (t = typeof c == "function" ? c : je(+c), a) : t;
  }, a.defined = function(c) {
    return arguments.length ? (n = typeof c == "function" ? c : je(!!c), a) : n;
  }, a.curve = function(c) {
    return arguments.length ? (r = c, i != null && (s = r(i)), a) : r;
  }, a.context = function(c) {
    return arguments.length ? (c == null ? i = s = null : s = r(i = c), a) : i;
  }, a;
}
function pw(e, t, n) {
  var i = null, r = je(!0), s = null, o = Of, a = null, c = AT(l);
  e = typeof e == "function" ? e : e === void 0 ? TT : je(+e), t = typeof t == "function" ? t : je(t === void 0 ? 0 : +t), n = typeof n == "function" ? n : n === void 0 ? DT : je(+n);
  function l(f) {
    var h, d, p, y = (f = MT(f)).length, m, g = !1, b, w = new Array(y), v = new Array(y);
    for (s == null && (a = o(b = c())), h = 0; h <= y; ++h) {
      if (!(h < y && r(m = f[h], h, f)) === g)
        if (g = !g)
          d = h, a.areaStart(), a.lineStart();
        else {
          for (a.lineEnd(), a.lineStart(), p = h - 1; p >= d; --p)
            a.point(w[p], v[p]);
          a.lineEnd(), a.areaEnd();
        }
      g && (w[h] = +e(m, h, f), v[h] = +t(m, h, f), a.point(i ? +i(m, h, f) : w[h], n ? +n(m, h, f) : v[h]));
    }
    if (b)
      return a = null, b + "" || null;
  }
  function u() {
    return NT().defined(r).curve(o).context(s);
  }
  return l.x = function(f) {
    return arguments.length ? (e = typeof f == "function" ? f : je(+f), i = null, l) : e;
  }, l.x0 = function(f) {
    return arguments.length ? (e = typeof f == "function" ? f : je(+f), l) : e;
  }, l.x1 = function(f) {
    return arguments.length ? (i = f == null ? null : typeof f == "function" ? f : je(+f), l) : i;
  }, l.y = function(f) {
    return arguments.length ? (t = typeof f == "function" ? f : je(+f), n = null, l) : t;
  }, l.y0 = function(f) {
    return arguments.length ? (t = typeof f == "function" ? f : je(+f), l) : t;
  }, l.y1 = function(f) {
    return arguments.length ? (n = f == null ? null : typeof f == "function" ? f : je(+f), l) : n;
  }, l.lineX0 = l.lineY0 = function() {
    return u().x(e).y(t);
  }, l.lineY1 = function() {
    return u().x(e).y(n);
  }, l.lineX1 = function() {
    return u().x(i).y(t);
  }, l.defined = function(f) {
    return arguments.length ? (r = typeof f == "function" ? f : je(!!f), l) : r;
  }, l.curve = function(f) {
    return arguments.length ? (o = f, s != null && (a = o(s)), l) : o;
  }, l.context = function(f) {
    return arguments.length ? (f == null ? s = a = null : a = o(s = f), l) : s;
  }, l;
}
class BT {
  constructor(t, n) {
    this._context = t, this._x = n;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  }
  point(t, n) {
    switch (t = +t, n = +n, this._point) {
      case 0: {
        this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n);
        break;
      }
      case 1:
        this._point = 2;
      default: {
        this._x ? this._context.bezierCurveTo(this._x0 = (this._x0 + t) / 2, this._y0, this._x0, n, t, n) : this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + n) / 2, t, this._y0, t, n);
        break;
      }
    }
    this._x0 = t, this._y0 = n;
  }
}
function tH(e) {
  return new BT(e, !0);
}
function eH(e) {
  return new BT(e, !1);
}
const nH = ze(3), OT = {
  draw(e, t) {
    const n = ze(t + dw(t / 28, 0.75)) * 0.59436, i = n / 2, r = i * nH;
    e.moveTo(0, n), e.lineTo(0, -n), e.moveTo(-r, -i), e.lineTo(r, i), e.moveTo(-r, i), e.lineTo(r, -i);
  }
}, Pu = {
  draw(e, t) {
    const n = ze(t / Fp);
    e.moveTo(n, 0), e.arc(0, 0, n, 0, d0);
  }
}, FT = {
  draw(e, t) {
    const n = ze(t / 5) / 2;
    e.moveTo(-3 * n, -n), e.lineTo(-n, -n), e.lineTo(-n, -3 * n), e.lineTo(n, -3 * n), e.lineTo(n, -n), e.lineTo(3 * n, -n), e.lineTo(3 * n, n), e.lineTo(n, n), e.lineTo(n, 3 * n), e.lineTo(-n, 3 * n), e.lineTo(-n, n), e.lineTo(-3 * n, n), e.closePath();
  }
}, ET = ze(1 / 3), iH = ET * 2, LT = {
  draw(e, t) {
    const n = ze(t / iH), i = n * ET;
    e.moveTo(0, -n), e.lineTo(i, 0), e.lineTo(0, n), e.lineTo(-i, 0), e.closePath();
  }
}, RT = {
  draw(e, t) {
    const n = ze(t) * 0.62625;
    e.moveTo(0, -n), e.lineTo(n, 0), e.lineTo(0, n), e.lineTo(-n, 0), e.closePath();
  }
}, CT = {
  draw(e, t) {
    const n = ze(t - dw(t / 7, 2)) * 0.87559;
    e.moveTo(-n, 0), e.lineTo(n, 0), e.moveTo(0, n), e.lineTo(0, -n);
  }
}, kT = {
  draw(e, t) {
    const n = ze(t), i = -n / 2;
    e.rect(i, i, n, n);
  }
}, UT = {
  draw(e, t) {
    const n = ze(t) * 0.4431;
    e.moveTo(n, n), e.lineTo(n, -n), e.lineTo(-n, -n), e.lineTo(-n, n), e.closePath();
  }
}, rH = 0.8908130915292852, zT = Op(Fp / 10) / Op(7 * Fp / 10), sH = Op(d0 / 10) * zT, oH = -IT(d0 / 10) * zT, PT = {
  draw(e, t) {
    const n = ze(t * rH), i = sH * n, r = oH * n;
    e.moveTo(0, -n), e.lineTo(i, r);
    for (let s = 1; s < 5; ++s) {
      const o = d0 * s / 5, a = IT(o), c = Op(o);
      e.lineTo(c * n, -a * n), e.lineTo(a * i - c * r, c * i + a * r);
    }
    e.closePath();
  }
}, Em = ze(3), VT = {
  draw(e, t) {
    const n = -ze(t / (Em * 3));
    e.moveTo(0, n * 2), e.lineTo(-Em * n, -n), e.lineTo(Em * n, -n), e.closePath();
  }
}, aH = ze(3), jT = {
  draw(e, t) {
    const n = ze(t) * 0.6824, i = n / 2, r = n * aH / 2;
    e.moveTo(0, -n), e.lineTo(r, i), e.lineTo(-r, i), e.closePath();
  }
}, Wn = -0.5, Gn = ze(3) / 2, A1 = 1 / ze(12), cH = (A1 / 2 + 1) * 3, qT = {
  draw(e, t) {
    const n = ze(t / cH), i = n / 2, r = n * A1, s = i, o = n * A1 + n, a = -s, c = o;
    e.moveTo(i, r), e.lineTo(s, o), e.lineTo(a, c), e.lineTo(Wn * i - Gn * r, Gn * i + Wn * r), e.lineTo(Wn * s - Gn * o, Gn * s + Wn * o), e.lineTo(Wn * a - Gn * c, Gn * a + Wn * c), e.lineTo(Wn * i + Gn * r, Wn * r - Gn * i), e.lineTo(Wn * s + Gn * o, Wn * o - Gn * s), e.lineTo(Wn * a + Gn * c, Wn * c - Gn * a), e.closePath();
  }
}, YT = {
  draw(e, t) {
    const n = ze(t - dw(t / 6, 1.7)) * 0.6189;
    e.moveTo(-n, -n), e.lineTo(n, n), e.moveTo(-n, n), e.lineTo(n, -n);
  }
}, lH = [
  Pu,
  FT,
  LT,
  kT,
  PT,
  VT,
  qT
], uH = [
  Pu,
  CT,
  YT,
  jT,
  OT,
  UT,
  RT
];
function Xs() {
}
function Ep(e, t, n) {
  e._context.bezierCurveTo(
    (2 * e._x0 + e._x1) / 3,
    (2 * e._y0 + e._y1) / 3,
    (e._x0 + 2 * e._x1) / 3,
    (e._y0 + 2 * e._y1) / 3,
    (e._x0 + 4 * e._x1 + t) / 6,
    (e._y0 + 4 * e._y1 + n) / 6
  );
}
function p0(e) {
  this._context = e;
}
p0.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        Ep(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        Ep(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function fH(e) {
  return new p0(e);
}
function WT(e) {
  this._context = e;
}
WT.prototype = {
  areaStart: Xs,
  areaEnd: Xs,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2), this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._x2 = e, this._y2 = t;
        break;
      case 1:
        this._point = 2, this._x3 = e, this._y3 = t;
        break;
      case 2:
        this._point = 3, this._x4 = e, this._y4 = t, this._context.moveTo((this._x0 + 4 * this._x1 + e) / 6, (this._y0 + 4 * this._y1 + t) / 6);
        break;
      default:
        Ep(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function hH(e) {
  return new WT(e);
}
function GT(e) {
  this._context = e;
}
GT.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var n = (this._x0 + 4 * this._x1 + e) / 6, i = (this._y0 + 4 * this._y1 + t) / 6;
        this._line ? this._context.lineTo(n, i) : this._context.moveTo(n, i);
        break;
      case 3:
        this._point = 4;
      default:
        Ep(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function dH(e) {
  return new GT(e);
}
function XT(e, t) {
  this._basis = new p0(e), this._beta = t;
}
XT.prototype = {
  lineStart: function() {
    this._x = [], this._y = [], this._basis.lineStart();
  },
  lineEnd: function() {
    var e = this._x, t = this._y, n = e.length - 1;
    if (n > 0)
      for (var i = e[0], r = t[0], s = e[n] - i, o = t[n] - r, a = -1, c; ++a <= n; )
        c = a / n, this._basis.point(
          this._beta * e[a] + (1 - this._beta) * (i + c * s),
          this._beta * t[a] + (1 - this._beta) * (r + c * o)
        );
    this._x = this._y = null, this._basis.lineEnd();
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
const pH = function e(t) {
  function n(i) {
    return t === 1 ? new p0(i) : new XT(i, t);
  }
  return n.beta = function(i) {
    return e(+i);
  }, n;
}(0.85);
function Lp(e, t, n) {
  e._context.bezierCurveTo(
    e._x1 + e._k * (e._x2 - e._x0),
    e._y1 + e._k * (e._y2 - e._y0),
    e._x2 + e._k * (e._x1 - t),
    e._y2 + e._k * (e._y1 - n),
    e._x2,
    e._y2
  );
}
function yw(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
yw.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        Lp(this, this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2, this._x1 = e, this._y1 = t;
        break;
      case 2:
        this._point = 3;
      default:
        Lp(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const yH = function e(t) {
  function n(i) {
    return new yw(i, t);
  }
  return n.tension = function(i) {
    return e(+i);
  }, n;
}(0);
function mw(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
mw.prototype = {
  areaStart: Xs,
  areaEnd: Xs,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._x3 = e, this._y3 = t;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
        break;
      case 2:
        this._point = 3, this._x5 = e, this._y5 = t;
        break;
      default:
        Lp(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const mH = function e(t) {
  function n(i) {
    return new mw(i, t);
  }
  return n.tension = function(i) {
    return e(+i);
  }, n;
}(0);
function gw(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
gw.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        Lp(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const gH = function e(t) {
  function n(i) {
    return new gw(i, t);
  }
  return n.tension = function(i) {
    return e(+i);
  }, n;
}(0);
function bw(e, t, n) {
  var i = e._x1, r = e._y1, s = e._x2, o = e._y2;
  if (e._l01_a > CS) {
    var a = 2 * e._l01_2a + 3 * e._l01_a * e._l12_a + e._l12_2a, c = 3 * e._l01_a * (e._l01_a + e._l12_a);
    i = (i * a - e._x0 * e._l12_2a + e._x2 * e._l01_2a) / c, r = (r * a - e._y0 * e._l12_2a + e._y2 * e._l01_2a) / c;
  }
  if (e._l23_a > CS) {
    var l = 2 * e._l23_2a + 3 * e._l23_a * e._l12_a + e._l12_2a, u = 3 * e._l23_a * (e._l23_a + e._l12_a);
    s = (s * l + e._x1 * e._l23_2a - t * e._l12_2a) / u, o = (o * l + e._y1 * e._l23_2a - n * e._l12_2a) / u;
  }
  e._context.bezierCurveTo(i, r, s, o, e._x2, e._y2);
}
function HT(e, t) {
  this._context = e, this._alpha = t;
}
HT.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, i = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + i * i, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        bw(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const bH = function e(t) {
  function n(i) {
    return t ? new HT(i, t) : new yw(i, 0);
  }
  return n.alpha = function(i) {
    return e(+i);
  }, n;
}(0.5);
function JT(e, t) {
  this._context = e, this._alpha = t;
}
JT.prototype = {
  areaStart: Xs,
  areaEnd: Xs,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, i = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + i * i, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._x3 = e, this._y3 = t;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
        break;
      case 2:
        this._point = 3, this._x5 = e, this._y5 = t;
        break;
      default:
        bw(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const wH = function e(t) {
  function n(i) {
    return t ? new JT(i, t) : new mw(i, 0);
  }
  return n.alpha = function(i) {
    return e(+i);
  }, n;
}(0.5);
function KT(e, t) {
  this._context = e, this._alpha = t;
}
KT.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, i = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + i * i, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        bw(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const vH = function e(t) {
  function n(i) {
    return t ? new KT(i, t) : new gw(i, 0);
  }
  return n.alpha = function(i) {
    return e(+i);
  }, n;
}(0.5);
function ZT(e) {
  this._context = e;
}
ZT.prototype = {
  areaStart: Xs,
  areaEnd: Xs,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._point && this._context.closePath();
  },
  point: function(e, t) {
    e = +e, t = +t, this._point ? this._context.lineTo(e, t) : (this._point = 1, this._context.moveTo(e, t));
  }
};
function _H(e) {
  return new ZT(e);
}
function kS(e) {
  return e < 0 ? -1 : 1;
}
function US(e, t, n) {
  var i = e._x1 - e._x0, r = t - e._x1, s = (e._y1 - e._y0) / (i || r < 0 && -0), o = (n - e._y1) / (r || i < 0 && -0), a = (s * r + o * i) / (i + r);
  return (kS(s) + kS(o)) * Math.min(Math.abs(s), Math.abs(o), 0.5 * Math.abs(a)) || 0;
}
function zS(e, t) {
  var n = e._x1 - e._x0;
  return n ? (3 * (e._y1 - e._y0) / n - t) / 2 : t;
}
function Lm(e, t, n) {
  var i = e._x0, r = e._y0, s = e._x1, o = e._y1, a = (s - i) / 3;
  e._context.bezierCurveTo(i + a, r + a * t, s - a, o - a * n, s, o);
}
function Rp(e) {
  this._context = e;
}
Rp.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        Lm(this, this._t0, zS(this, this._t0));
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    var n = NaN;
    if (e = +e, t = +t, !(e === this._x1 && t === this._y1)) {
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, Lm(this, zS(this, n = US(this, e, t)), n);
          break;
        default:
          Lm(this, this._t0, n = US(this, e, t));
          break;
      }
      this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t, this._t0 = n;
    }
  }
};
function QT(e) {
  this._context = new tD(e);
}
(QT.prototype = Object.create(Rp.prototype)).point = function(e, t) {
  Rp.prototype.point.call(this, t, e);
};
function tD(e) {
  this._context = e;
}
tD.prototype = {
  moveTo: function(e, t) {
    this._context.moveTo(t, e);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(e, t) {
    this._context.lineTo(t, e);
  },
  bezierCurveTo: function(e, t, n, i, r, s) {
    this._context.bezierCurveTo(t, e, i, n, s, r);
  }
};
function SH(e) {
  return new Rp(e);
}
function xH(e) {
  return new QT(e);
}
function eD(e) {
  this._context = e;
}
eD.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [], this._y = [];
  },
  lineEnd: function() {
    var e = this._x, t = this._y, n = e.length;
    if (n)
      if (this._line ? this._context.lineTo(e[0], t[0]) : this._context.moveTo(e[0], t[0]), n === 2)
        this._context.lineTo(e[1], t[1]);
      else
        for (var i = PS(e), r = PS(t), s = 0, o = 1; o < n; ++s, ++o)
          this._context.bezierCurveTo(i[0][s], r[0][s], i[1][s], r[1][s], e[o], t[o]);
    (this._line || this._line !== 0 && n === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
function PS(e) {
  var t, n = e.length - 1, i, r = new Array(n), s = new Array(n), o = new Array(n);
  for (r[0] = 0, s[0] = 2, o[0] = e[0] + 2 * e[1], t = 1; t < n - 1; ++t)
    r[t] = 1, s[t] = 4, o[t] = 4 * e[t] + 2 * e[t + 1];
  for (r[n - 1] = 2, s[n - 1] = 7, o[n - 1] = 8 * e[n - 1] + e[n], t = 1; t < n; ++t)
    i = r[t] / s[t - 1], s[t] -= i, o[t] -= i * o[t - 1];
  for (r[n - 1] = o[n - 1] / s[n - 1], t = n - 2; t >= 0; --t)
    r[t] = (o[t] - r[t + 1]) / s[t];
  for (s[n - 1] = (e[n] + r[n - 1]) / 2, t = 0; t < n - 1; ++t)
    s[t] = 2 * e[t + 1] - r[t + 1];
  return [r, s];
}
function IH(e) {
  return new eD(e);
}
function y0(e, t) {
  this._context = e, this._t = t;
}
y0.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN, this._point = 0;
  },
  lineEnd: function() {
    0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0)
          this._context.lineTo(this._x, t), this._context.lineTo(e, t);
        else {
          var n = this._x * (1 - this._t) + e * this._t;
          this._context.lineTo(n, this._y), this._context.lineTo(n, t);
        }
        break;
      }
    }
    this._x = e, this._y = t;
  }
};
function AH(e) {
  return new y0(e, 0.5);
}
function MH(e) {
  return new y0(e, 0);
}
function $H(e) {
  return new y0(e, 1);
}
const vh = (e) => () => e;
function TH(e, {
  sourceEvent: t,
  target: n,
  transform: i,
  dispatch: r
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    target: { value: n, enumerable: !0, configurable: !0 },
    transform: { value: i, enumerable: !0, configurable: !0 },
    _: { value: r }
  });
}
function ir(e, t, n) {
  this.k = e, this.x = t, this.y = n;
}
ir.prototype = {
  constructor: ir,
  scale: function(e) {
    return e === 1 ? this : new ir(this.k * e, this.x, this.y);
  },
  translate: function(e, t) {
    return e === 0 & t === 0 ? this : new ir(this.k, this.x + this.k * e, this.y + this.k * t);
  },
  apply: function(e) {
    return [e[0] * this.k + this.x, e[1] * this.k + this.y];
  },
  applyX: function(e) {
    return e * this.k + this.x;
  },
  applyY: function(e) {
    return e * this.k + this.y;
  },
  invert: function(e) {
    return [(e[0] - this.x) / this.k, (e[1] - this.y) / this.k];
  },
  invertX: function(e) {
    return (e - this.x) / this.k;
  },
  invertY: function(e) {
    return (e - this.y) / this.k;
  },
  rescaleX: function(e) {
    return e.copy().domain(e.range().map(this.invertX, this).map(e.invert, e));
  },
  rescaleY: function(e) {
    return e.copy().domain(e.range().map(this.invertY, this).map(e.invert, e));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var nD = new ir(1, 0, 0);
ir.prototype;
function Rm(e) {
  e.stopImmediatePropagation();
}
function Ml(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
function DH(e) {
  return (!e.ctrlKey || e.type === "wheel") && !e.button;
}
function NH() {
  var e = this;
  return e instanceof SVGElement ? (e = e.ownerSVGElement || e, e.hasAttribute("viewBox") ? (e = e.viewBox.baseVal, [[e.x, e.y], [e.x + e.width, e.y + e.height]]) : [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]]) : [[0, 0], [e.clientWidth, e.clientHeight]];
}
function VS() {
  return this.__zoom || nD;
}
function BH(e) {
  return -e.deltaY * (e.deltaMode === 1 ? 0.05 : e.deltaMode ? 1 : 2e-3) * (e.ctrlKey ? 10 : 1);
}
function OH() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function FH(e, t, n) {
  var i = e.invertX(t[0][0]) - n[0][0], r = e.invertX(t[1][0]) - n[1][0], s = e.invertY(t[0][1]) - n[0][1], o = e.invertY(t[1][1]) - n[1][1];
  return e.translate(
    r > i ? (i + r) / 2 : Math.min(0, i) || Math.max(0, r),
    o > s ? (s + o) / 2 : Math.min(0, s) || Math.max(0, o)
  );
}
function EH() {
  var e = DH, t = NH, n = FH, i = BH, r = OH, s = [0, 1 / 0], o = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], a = 250, c = yj, l = Xy("start", "zoom", "end"), u, f, h, d = 500, p = 150, y = 0, m = 10;
  function g(x) {
    x.property("__zoom", VS).on("wheel.zoom", T, { passive: !1 }).on("mousedown.zoom", M).on("dblclick.zoom", N).filter(r).on("touchstart.zoom", A).on("touchmove.zoom", B).on("touchend.zoom touchcancel.zoom", R).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  g.transform = function(x, $, D, L) {
    var k = x.selection ? x.selection() : x;
    k.property("__zoom", VS), x !== k ? S(x, $, D, L) : k.interrupt().each(function() {
      _(this, arguments).event(L).start().zoom(null, typeof $ == "function" ? $.apply(this, arguments) : $).end();
    });
  }, g.scaleBy = function(x, $, D, L) {
    g.scaleTo(x, function() {
      var k = this.__zoom.k, U = typeof $ == "function" ? $.apply(this, arguments) : $;
      return k * U;
    }, D, L);
  }, g.scaleTo = function(x, $, D, L) {
    g.transform(x, function() {
      var k = t.apply(this, arguments), U = this.__zoom, C = D == null ? v(k) : typeof D == "function" ? D.apply(this, arguments) : D, z = U.invert(C), P = typeof $ == "function" ? $.apply(this, arguments) : $;
      return n(w(b(U, P), C, z), k, o);
    }, D, L);
  }, g.translateBy = function(x, $, D, L) {
    g.transform(x, function() {
      return n(this.__zoom.translate(
        typeof $ == "function" ? $.apply(this, arguments) : $,
        typeof D == "function" ? D.apply(this, arguments) : D
      ), t.apply(this, arguments), o);
    }, null, L);
  }, g.translateTo = function(x, $, D, L, k) {
    g.transform(x, function() {
      var U = t.apply(this, arguments), C = this.__zoom, z = L == null ? v(U) : typeof L == "function" ? L.apply(this, arguments) : L;
      return n(nD.translate(z[0], z[1]).scale(C.k).translate(
        typeof $ == "function" ? -$.apply(this, arguments) : -$,
        typeof D == "function" ? -D.apply(this, arguments) : -D
      ), U, o);
    }, L, k);
  };
  function b(x, $) {
    return $ = Math.max(s[0], Math.min(s[1], $)), $ === x.k ? x : new ir($, x.x, x.y);
  }
  function w(x, $, D) {
    var L = $[0] - D[0] * x.k, k = $[1] - D[1] * x.k;
    return L === x.x && k === x.y ? x : new ir(x.k, L, k);
  }
  function v(x) {
    return [(+x[0][0] + +x[1][0]) / 2, (+x[0][1] + +x[1][1]) / 2];
  }
  function S(x, $, D, L) {
    x.on("start.zoom", function() {
      _(this, arguments).event(L).start();
    }).on("interrupt.zoom end.zoom", function() {
      _(this, arguments).event(L).end();
    }).tween("zoom", function() {
      var k = this, U = arguments, C = _(k, U).event(L), z = t.apply(k, U), P = D == null ? v(z) : typeof D == "function" ? D.apply(k, U) : D, G = Math.max(z[1][0] - z[0][0], z[1][1] - z[0][1]), K = k.__zoom, et = typeof $ == "function" ? $.apply(k, U) : $, Z = c(K.invert(P).concat(G / K.k), et.invert(P).concat(G / et.k));
      return function(Y) {
        if (Y === 1)
          Y = et;
        else {
          var X = Z(Y), j = G / X[2];
          Y = new ir(j, P[0] - X[0] * j, P[1] - X[1] * j);
        }
        C.zoom(null, Y);
      };
    });
  }
  function _(x, $, D) {
    return !D && x.__zooming || new I(x, $);
  }
  function I(x, $) {
    this.that = x, this.args = $, this.active = 0, this.sourceEvent = null, this.extent = t.apply(x, $), this.taps = 0;
  }
  I.prototype = {
    event: function(x) {
      return x && (this.sourceEvent = x), this;
    },
    start: function() {
      return ++this.active === 1 && (this.that.__zooming = this, this.emit("start")), this;
    },
    zoom: function(x, $) {
      return this.mouse && x !== "mouse" && (this.mouse[1] = $.invert(this.mouse[0])), this.touch0 && x !== "touch" && (this.touch0[1] = $.invert(this.touch0[0])), this.touch1 && x !== "touch" && (this.touch1[1] = $.invert(this.touch1[0])), this.that.__zoom = $, this.emit("zoom"), this;
    },
    end: function() {
      return --this.active === 0 && (delete this.that.__zooming, this.emit("end")), this;
    },
    emit: function(x) {
      var $ = ce(this.that).datum();
      l.call(
        x,
        this.that,
        new TH(x, {
          sourceEvent: this.sourceEvent,
          target: g,
          type: x,
          transform: this.that.__zoom,
          dispatch: l
        }),
        $
      );
    }
  };
  function T(x, ...$) {
    if (!e.apply(this, arguments))
      return;
    var D = _(this, $).event(x), L = this.__zoom, k = Math.max(s[0], Math.min(s[1], L.k * Math.pow(2, i.apply(this, arguments)))), U = mi(x);
    if (D.wheel)
      (D.mouse[0][0] !== U[0] || D.mouse[0][1] !== U[1]) && (D.mouse[1] = L.invert(D.mouse[0] = U)), clearTimeout(D.wheel);
    else {
      if (L.k === k)
        return;
      D.mouse = [U, L.invert(U)], dc(this), D.start();
    }
    Ml(x), D.wheel = setTimeout(C, p), D.zoom("mouse", n(w(b(L, k), D.mouse[0], D.mouse[1]), D.extent, o));
    function C() {
      D.wheel = null, D.end();
    }
  }
  function M(x, ...$) {
    if (h || !e.apply(this, arguments))
      return;
    var D = x.currentTarget, L = _(this, $, !0).event(x), k = ce(x.view).on("mousemove.zoom", P, !0).on("mouseup.zoom", G, !0), U = mi(x, D), C = x.clientX, z = x.clientY;
    MM(x.view), Rm(x), L.mouse = [U, this.__zoom.invert(U)], dc(this), L.start();
    function P(K) {
      if (Ml(K), !L.moved) {
        var et = K.clientX - C, Z = K.clientY - z;
        L.moved = et * et + Z * Z > y;
      }
      L.event(K).zoom("mouse", n(w(L.that.__zoom, L.mouse[0] = mi(K, D), L.mouse[1]), L.extent, o));
    }
    function G(K) {
      k.on("mousemove.zoom mouseup.zoom", null), $M(K.view, L.moved), Ml(K), L.event(K).end();
    }
  }
  function N(x, ...$) {
    if (e.apply(this, arguments)) {
      var D = this.__zoom, L = mi(x.changedTouches ? x.changedTouches[0] : x, this), k = D.invert(L), U = D.k * (x.shiftKey ? 0.5 : 2), C = n(w(b(D, U), L, k), t.apply(this, $), o);
      Ml(x), a > 0 ? ce(this).transition().duration(a).call(S, C, L, x) : ce(this).call(g.transform, C, L, x);
    }
  }
  function A(x, ...$) {
    if (e.apply(this, arguments)) {
      var D = x.touches, L = D.length, k = _(this, $, x.changedTouches.length === L).event(x), U, C, z, P;
      for (Rm(x), C = 0; C < L; ++C)
        z = D[C], P = mi(z, this), P = [P, this.__zoom.invert(P), z.identifier], k.touch0 ? !k.touch1 && k.touch0[2] !== P[2] && (k.touch1 = P, k.taps = 0) : (k.touch0 = P, U = !0, k.taps = 1 + !!u);
      u && (u = clearTimeout(u)), U && (k.taps < 2 && (f = P[0], u = setTimeout(function() {
        u = null;
      }, d)), dc(this), k.start());
    }
  }
  function B(x, ...$) {
    if (this.__zooming) {
      var D = _(this, $).event(x), L = x.changedTouches, k = L.length, U, C, z, P;
      for (Ml(x), U = 0; U < k; ++U)
        C = L[U], z = mi(C, this), D.touch0 && D.touch0[2] === C.identifier ? D.touch0[0] = z : D.touch1 && D.touch1[2] === C.identifier && (D.touch1[0] = z);
      if (C = D.that.__zoom, D.touch1) {
        var G = D.touch0[0], K = D.touch0[1], et = D.touch1[0], Z = D.touch1[1], Y = (Y = et[0] - G[0]) * Y + (Y = et[1] - G[1]) * Y, X = (X = Z[0] - K[0]) * X + (X = Z[1] - K[1]) * X;
        C = b(C, Math.sqrt(Y / X)), z = [(G[0] + et[0]) / 2, (G[1] + et[1]) / 2], P = [(K[0] + Z[0]) / 2, (K[1] + Z[1]) / 2];
      } else if (D.touch0)
        z = D.touch0[0], P = D.touch0[1];
      else
        return;
      D.zoom("touch", n(w(C, z, P), D.extent, o));
    }
  }
  function R(x, ...$) {
    if (this.__zooming) {
      var D = _(this, $).event(x), L = x.changedTouches, k = L.length, U, C;
      for (Rm(x), h && clearTimeout(h), h = setTimeout(function() {
        h = null;
      }, d), U = 0; U < k; ++U)
        C = L[U], D.touch0 && D.touch0[2] === C.identifier ? delete D.touch0 : D.touch1 && D.touch1[2] === C.identifier && delete D.touch1;
      if (D.touch1 && !D.touch0 && (D.touch0 = D.touch1, delete D.touch1), D.touch0)
        D.touch0[1] = this.__zoom.invert(D.touch0[0]);
      else if (D.end(), D.taps === 2 && (C = mi(C, this), Math.hypot(f[0] - C[0], f[1] - C[1]) < m)) {
        var z = ce(this).on("dblclick.zoom");
        z && z.apply(this, arguments);
      }
    }
  }
  return g.wheelDelta = function(x) {
    return arguments.length ? (i = typeof x == "function" ? x : vh(+x), g) : i;
  }, g.filter = function(x) {
    return arguments.length ? (e = typeof x == "function" ? x : vh(!!x), g) : e;
  }, g.touchable = function(x) {
    return arguments.length ? (r = typeof x == "function" ? x : vh(!!x), g) : r;
  }, g.extent = function(x) {
    return arguments.length ? (t = typeof x == "function" ? x : vh([[+x[0][0], +x[0][1]], [+x[1][0], +x[1][1]]]), g) : t;
  }, g.scaleExtent = function(x) {
    return arguments.length ? (s[0] = +x[0], s[1] = +x[1], g) : [s[0], s[1]];
  }, g.translateExtent = function(x) {
    return arguments.length ? (o[0][0] = +x[0][0], o[1][0] = +x[1][0], o[0][1] = +x[0][1], o[1][1] = +x[1][1], g) : [[o[0][0], o[0][1]], [o[1][0], o[1][1]]];
  }, g.constrain = function(x) {
    return arguments.length ? (n = x, g) : n;
  }, g.duration = function(x) {
    return arguments.length ? (a = +x, g) : a;
  }, g.interpolate = function(x) {
    return arguments.length ? (c = x, g) : c;
  }, g.on = function() {
    var x = l.on.apply(l, arguments);
    return x === l ? g : x;
  }, g.clickDistance = function(x) {
    return arguments.length ? (y = (x = +x) * x, g) : Math.sqrt(y);
  }, g.tapDistance = function(x) {
    return arguments.length ? (m = +x, g) : m;
  }, g;
}
function dn(e) {
  return e != null && !Number.isNaN(e);
}
function ui(e, t) {
  return +dn(t) - +dn(e) || me(e, t);
}
function Cp(e, t) {
  return +dn(t) - +dn(e) || Ho(e, t);
}
function ww(e) {
  return e != null && `${e}` != "";
}
function kp(e) {
  return isFinite(e) ? e : NaN;
}
function Qr(e) {
  return e > 0 && isFinite(e) ? e : NaN;
}
function m0(e) {
  return e < 0 && isFinite(e) ? e : NaN;
}
function iD(e, t) {
  if (e instanceof Date || (e = /* @__PURE__ */ new Date(+e)), isNaN(e))
    return typeof t == "function" ? t(e) : t;
  const n = e.getUTCHours(), i = e.getUTCMinutes(), r = e.getUTCSeconds(), s = e.getUTCMilliseconds();
  return `${LH(e.getUTCFullYear())}-${Pr(e.getUTCMonth() + 1, 2)}-${Pr(e.getUTCDate(), 2)}${n || i || r || s ? `T${Pr(n, 2)}:${Pr(i, 2)}${r || s ? `:${Pr(r, 2)}${s ? `.${Pr(s, 3)}` : ""}` : ""}Z` : ""}`;
}
function LH(e) {
  return e < 0 ? `-${Pr(-e, 6)}` : e > 9999 ? `+${Pr(e, 6)}` : Pr(e, 4);
}
function Pr(e, t) {
  return `${e}`.padStart(t, "0");
}
const RH = /^(?:[-+]\d{2})?\d{4}(?:-\d{2}(?:-\d{2})?)?(?:T\d{2}:\d{2}(?::\d{2}(?:\.\d{3})?)?(?:Z|[-+]\d{2}:?\d{2})?)?$/;
function rD(e, t) {
  return RH.test(e += "") ? new Date(e) : typeof t == "function" ? t(e) : t;
}
function kc(e) {
  if (e == null)
    return;
  const t = e[0], n = e[e.length - 1];
  return Ho(t, n);
}
const tc = 1e3, Ls = tc * 60, Rs = Ls * 60, dr = Rs * 24, Wi = dr * 7, jo = dr * 30, xs = dr * 365, Cm = [
  ["millisecond", 1],
  ["2 milliseconds", 2],
  ["5 milliseconds", 5],
  ["10 milliseconds", 10],
  ["20 milliseconds", 20],
  ["50 milliseconds", 50],
  ["100 milliseconds", 100],
  ["200 milliseconds", 200],
  ["500 milliseconds", 500],
  ["second", tc],
  ["5 seconds", 5 * tc],
  ["15 seconds", 15 * tc],
  ["30 seconds", 30 * tc],
  ["minute", Ls],
  ["5 minutes", 5 * Ls],
  ["15 minutes", 15 * Ls],
  ["30 minutes", 30 * Ls],
  ["hour", Rs],
  ["3 hours", 3 * Rs],
  ["6 hours", 6 * Rs],
  ["12 hours", 12 * Rs],
  ["day", dr],
  ["2 days", 2 * dr],
  ["week", Wi],
  ["2 weeks", 2 * Wi],
  // https://github.com/d3/d3-time/issues/46
  ["month", jo],
  ["3 months", 3 * jo],
  ["6 months", 6 * jo],
  // https://github.com/d3/d3-time/issues/46
  ["year", xs],
  ["2 years", 2 * xs],
  ["5 years", 5 * xs],
  ["10 years", 10 * xs],
  ["20 years", 20 * xs],
  ["50 years", 50 * xs],
  ["100 years", 100 * xs]
  // TODO generalize to longer time scales
], vw = /* @__PURE__ */ new Map([
  ["second", tc],
  ["minute", Ls],
  ["hour", Rs],
  ["day", dr],
  ["monday", Wi],
  ["tuesday", Wi],
  ["wednesday", Wi],
  ["thursday", Wi],
  ["friday", Wi],
  ["saturday", Wi],
  ["sunday", Wi],
  ["week", Wi],
  ["month", jo],
  ["year", xs]
]), sD = /* @__PURE__ */ new Map([
  ["second", xi],
  ["minute", Af],
  ["hour", $f],
  ["day", aa],
  // https://github.com/d3/d3-time/issues/62
  ["monday", Uu],
  ["tuesday", Q$],
  ["wednesday", t6],
  ["thursday", na],
  ["friday", e6],
  ["saturday", n6],
  ["sunday", Rc],
  ["week", Rc],
  ["month", Df],
  ["year", Ni]
]), _w = /* @__PURE__ */ new Map([
  ["second", xi],
  ["minute", Mf],
  ["hour", Tf],
  ["day", l0],
  ["monday", zu],
  ["tuesday", i6],
  ["wednesday", r6],
  ["thursday", ia],
  ["friday", s6],
  ["saturday", o6],
  ["sunday", Cc],
  ["week", Cc],
  ["month", Nf],
  ["year", Bi]
]), Ff = Symbol("intervalDuration"), g0 = Symbol("intervalType");
for (const [e, t] of sD)
  t[Ff] = vw.get(e), t[g0] = "time";
for (const [e, t] of _w)
  t[Ff] = vw.get(e), t[g0] = "utc";
const Zl = [
  ["year", Bi, "utc"],
  ["month", Nf, "utc"],
  ["day", l0, "utc", 6 * jo],
  ["hour", Tf, "utc", 3 * dr],
  ["minute", Mf, "utc", 6 * Rs],
  ["second", xi, "utc", 30 * Ls]
], sd = [
  ["year", Ni, "time"],
  ["month", Df, "time"],
  ["day", aa, "time", 6 * jo],
  ["hour", $f, "time", 3 * dr],
  ["minute", Af, "time", 6 * Rs],
  ["second", xi, "time", 30 * Ls]
], CH = [
  Zl[0],
  sd[0],
  Zl[1],
  sd[1],
  Zl[2],
  sd[2],
  // Below day, local time typically has an hourly offset from UTC and hence the
  // two are aligned and indistinguishable; therefore, we only consider UTC, and
  // we dont consider these if the domain only has a single value.
  ...Zl.slice(3)
];
function Sw(e) {
  let t = `${e}`.toLowerCase();
  t.endsWith("s") && (t = t.slice(0, -1));
  let n = 1;
  const i = /^(?:(\d+)\s+)/.exec(t);
  switch (i && (t = t.slice(i[0].length), n = +i[1]), t) {
    case "quarter":
      t = "month", n *= 3;
      break;
    case "half":
      t = "month", n *= 6;
      break;
  }
  let r = _w.get(t);
  if (!r)
    throw new Error(`unknown interval: ${e}`);
  if (n > 1 && !r.every)
    throw new Error(`non-periodic interval: ${t}`);
  return [t, n];
}
function oD(e) {
  return aD(Sw(e), "time");
}
function xw(e) {
  return aD(Sw(e), "utc");
}
function aD([e, t], n) {
  let i = (n === "time" ? sD : _w).get(e);
  return t > 1 && (i = i.every(t), i[Ff] = vw.get(e) * t, i[g0] = n), i;
}
function jS(e, t) {
  if (!(t > 1))
    return;
  const n = e[Ff];
  if (!Cm.some(([, r]) => r === n) || n % dr === 0 && dr < n && n < jo)
    return;
  const [i] = Cm[qy(([, r]) => Math.log(r)).center(Cm, Math.log(n * t))];
  return (e[g0] === "time" ? oD : xw)(i);
}
function qS(e, t, n) {
  const i = t === "time" ? fw : Bf;
  if (n == null)
    return i(
      e === "year" ? "%Y" : e === "month" ? "%Y-%m" : e === "day" ? "%Y-%m-%d" : e === "hour" || e === "minute" ? "%Y-%m-%dT%H:%M" : e === "second" ? "%Y-%m-%dT%H:%M:%S" : "%Y-%m-%dT%H:%M:%S.%L"
    );
  const r = kH(n);
  switch (e) {
    case "millisecond":
      return Ia(i(".%L"), i(":%M:%S"), r);
    case "second":
      return Ia(i(":%S"), i("%-I:%M"), r);
    case "minute":
      return Ia(i("%-I:%M"), i("%p"), r);
    case "hour":
      return Ia(i("%-I %p"), i("%b %-d"), r);
    case "day":
      return Ia(i("%-d"), i("%b"), r);
    case "month":
      return Ia(i("%b"), i("%Y"), r);
    case "year":
      return i("%Y");
  }
  throw new Error("unable to format time ticks");
}
function kH(e) {
  return e === "left" || e === "right" ? (t, n) => `
${t}
${n}` : e === "top" ? (t, n) => `${n}
${t}` : (t, n) => `${t}
${n}`;
}
function UH(e) {
  return e === "time" ? sd : e === "utc" ? Zl : CH;
}
function zH(e, t, n) {
  const i = De(jz(t, (r, s) => Math.abs(s - r)));
  if (i < 1e3)
    return qS("millisecond", "utc", n);
  for (const [r, s, o, a] of UH(e)) {
    if (i > a || r === "hour" && !i)
      break;
    if (t.every((c) => s.floor(c) >= c))
      return qS(r, o, n);
  }
}
function Ia(e, t, n) {
  return (i, r, s) => {
    const o = e(i, r), a = t(i, r), c = r - kc(s);
    return r !== c && s[c] !== void 0 && a === t(s[c], c) ? o : n(o, a);
  };
}
const Uc = Object.getPrototypeOf(Uint8Array), PH = Object.prototype.toString, cD = Symbol("reindex");
function Pt(e, t, n) {
  const i = typeof t;
  return i === "string" ? YS(e, lD(t), n) : i === "function" ? YS(e, t, n) : i === "number" || t instanceof Date || i === "boolean" ? ye(e, qn(t), n) : typeof (t == null ? void 0 : t.transform) == "function" ? WS(t.transform(e), n) : VH(WS(t, n), e == null ? void 0 : e[cD]);
}
function VH(e, t) {
  return t ? v0(e, t) : e;
}
function YS(e, t, n) {
  return ye(e, (n == null ? void 0 : n.prototype) instanceof Uc ? jH(t) : t, n);
}
function WS(e, t) {
  return t === void 0 ? Nn(e) : e instanceof t ? e : t.prototype instanceof Uc && !(e instanceof Uc) ? t.from(e, Mw) : t.from(e);
}
function jH(e) {
  return (t, n) => Mw(e(t, n));
}
const pu = [null], lD = (e) => (t) => t[e], vn = { transform: hs }, Tt = { transform: (e) => e }, Iw = () => 1, qH = () => !0, tn = (e) => e == null ? e : `${e}`, qt = (e) => e == null ? e : +e, b0 = (e) => e ? e[0] : void 0, Vu = (e) => e ? e[1] : void 0, YH = (e) => e ? e[2] : void 0, qn = (e) => () => e;
function Aw(e) {
  const t = +`${e}`.slice(1) / 100;
  return (n, i) => Ws(n, t, i);
}
function An(e) {
  return e instanceof Uc ? e : ye(e, Mw, Float64Array);
}
function Mw(e) {
  return e == null ? NaN : Number(e);
}
function WH(e) {
  return ye(e, uD);
}
function uD(e) {
  return e instanceof Date && !isNaN(e) ? e : typeof e == "string" ? rD(e) : e == null || isNaN(e = +e) ? void 0 : new Date(e);
}
function mn(e, t) {
  return e === void 0 && (e = t), e === null ? [void 0, "none"] : Ef(e) ? [void 0, e] : [e, void 0];
}
function Be(e, t) {
  return e === void 0 && (e = t), e === null || typeof e == "number" ? [void 0, e] : [e, void 0];
}
function fD(e, t, n) {
  if (e != null)
    return Yn(e, t, n);
}
function Yn(e, t, n) {
  const i = `${e}`.toLowerCase();
  if (!n.includes(i))
    throw new Error(`invalid ${t}: ${e}`);
  return i;
}
function Nn(e) {
  return e == null || e instanceof Array || e instanceof Uc ? e : Array.from(e);
}
function ye(e, t, n = Array) {
  return e == null ? e : e instanceof n ? e.map(t) : n.from(e, t);
}
function ju(e, t = Array) {
  return e instanceof t ? e.slice() : t.from(e);
}
function hD({ x: e, x1: t, x2: n }) {
  return e !== void 0 || t !== void 0 || n !== void 0;
}
function dD({ y: e, y1: t, y2: n }) {
  return e !== void 0 || t !== void 0 || n !== void 0;
}
function w0(e) {
  return hD(e) || dD(e) || e.interval !== void 0;
}
function di(e) {
  return (e == null ? void 0 : e.toString) === PH;
}
function qo(e) {
  return di(e) && (e.type !== void 0 || e.domain !== void 0);
}
function Hi(e) {
  return di(e) && typeof e.transform != "function";
}
function Hs(e) {
  return Hi(e) && e.value === void 0 && e.channel === void 0;
}
function pD(e, t, n, i = Tt) {
  return t === void 0 && n === void 0 ? (t = 0, n = e === void 0 ? i : e) : t === void 0 ? t = e === void 0 ? 0 : e : n === void 0 && (n = e === void 0 ? 0 : e), [t, n];
}
function ki(e, t) {
  return e === void 0 && t === void 0 ? [b0, Vu] : [e, t];
}
function lo({ z: e, fill: t, stroke: n } = {}) {
  return e === void 0 && ([e] = mn(t)), e === void 0 && ([e] = mn(n)), e;
}
function hs(e) {
  const t = e.length, n = new Uint32Array(t);
  for (let i = 0; i < t; ++i)
    n[i] = i;
  return n;
}
function v0(e, t) {
  return ye(t, (n) => e[n], e.constructor);
}
function $w(e) {
  return e.length === 1 ? (t, n) => e(v0(n, t)) : e;
}
function Yo(e, t, n) {
  return e.subarray ? e.subarray(t, n) : e.slice(t, n);
}
function Lo(e) {
  return e !== null && typeof e == "object" ? e.valueOf() : e;
}
function yD(e, t) {
  if (t[e] !== void 0)
    return t[e];
  switch (e) {
    case "x1":
    case "x2":
      e = "x";
      break;
    case "y1":
    case "y2":
      e = "y";
      break;
  }
  return t[e];
}
function zn(e) {
  let t;
  return [
    {
      transform: () => t,
      label: wr(e)
    },
    (n) => t = n
  ];
}
function Sn(e) {
  return e == null ? [e] : zn(e);
}
function wr(e, t) {
  return typeof e == "string" ? e : e && e.label !== void 0 ? e.label : t;
}
function Up(e, t) {
  return {
    transform(n) {
      const i = e.transform(n), r = t.transform(n);
      return gn(i) || gn(r) ? ye(i, (s, o) => new Date((+i[o] + +r[o]) / 2)) : ye(i, (s, o) => (+i[o] + +r[o]) / 2, Float64Array);
    },
    label: e.label
  };
}
function zp(e, t) {
  const n = mD(t == null ? void 0 : t.interval, t == null ? void 0 : t.type);
  return n ? ye(e, n) : e;
}
function mD(e, t) {
  const n = _0(e, t);
  return n && ((i) => dn(i) ? n.floor(i) : i);
}
function _0(e, t) {
  if (e != null) {
    if (typeof e == "number") {
      0 < e && e < 1 && Number.isInteger(1 / e) && (e = -1 / e);
      const n = Math.abs(e);
      return e < 0 ? {
        floor: (i) => Math.floor(i * n) / n,
        offset: (i) => (i * n + 1) / n,
        // note: no optional step for simplicity
        range: (i, r) => kn(Math.ceil(i * n), r * n).map((s) => s / n)
      } : {
        floor: (i) => Math.floor(i / n) * n,
        offset: (i) => i + n,
        // note: no optional step for simplicity
        range: (i, r) => kn(Math.ceil(i / n), r / n).map((s) => s * n)
      };
    }
    if (typeof e == "string")
      return (t === "time" ? oD : xw)(e);
    if (typeof e.floor != "function")
      throw new Error("invalid interval; missing floor method");
    if (typeof e.offset != "function")
      throw new Error("invalid interval; missing offset method");
    return e;
  }
}
function ol(e, t) {
  if (e = _0(e, t), e && typeof e.range != "function")
    throw new Error("invalid interval: missing range method");
  return e;
}
function GH(e, t) {
  if (e = ol(e, t), e && typeof e.ceil != "function")
    throw new Error("invalid interval: missing ceil method");
  return e;
}
function XH(e) {
  return ec(e) && typeof (e == null ? void 0 : e.floor) == "function" && e.floor() instanceof Date;
}
function ec(e) {
  return typeof (e == null ? void 0 : e.range) == "function";
}
function al(e) {
  return e === void 0 || Hi(e) ? e : { value: e };
}
function HH(e) {
  return e == null ? null : {
    transform: (t) => Pt(t, e, Float64Array),
    label: wr(e)
  };
}
function JH(e) {
  if (!ds(e))
    return !1;
  for (const t of e)
    if (t != null)
      return typeof t == "object" && "0" in t && "1" in t;
}
function ds(e) {
  return e && typeof e[Symbol.iterator] == "function";
}
function gD(e) {
  for (const t of e)
    if (t != null)
      return typeof t != "object" || t instanceof Date;
}
function Ae(e) {
  for (const t of e) {
    if (t == null)
      continue;
    const n = typeof t;
    return n === "string" || n === "boolean";
  }
}
function gn(e) {
  for (const t of e)
    if (t != null)
      return t instanceof Date;
}
function KH(e) {
  for (const t of e)
    if (t != null)
      return typeof t == "string" && isNaN(t) && rD(t);
}
function ZH(e) {
  for (const t of e)
    if (t != null) {
      if (typeof t != "string")
        return !1;
      if (t.trim())
        return !isNaN(t);
    }
}
function nc(e) {
  for (const t of e)
    if (t != null)
      return typeof t == "number";
}
function km(e, t) {
  let n;
  for (const i of e)
    if (i != null) {
      if (!t(i))
        return !1;
      n = !0;
    }
  return n;
}
const QH = new Set("none,currentcolor,transparent,aliceblue,antiquewhite,aqua,aquamarine,azure,beige,bisque,black,blanchedalmond,blue,blueviolet,brown,burlywood,cadetblue,chartreuse,chocolate,coral,cornflowerblue,cornsilk,crimson,cyan,darkblue,darkcyan,darkgoldenrod,darkgray,darkgreen,darkgrey,darkkhaki,darkmagenta,darkolivegreen,darkorange,darkorchid,darkred,darksalmon,darkseagreen,darkslateblue,darkslategray,darkslategrey,darkturquoise,darkviolet,deeppink,deepskyblue,dimgray,dimgrey,dodgerblue,firebrick,floralwhite,forestgreen,fuchsia,gainsboro,ghostwhite,gold,goldenrod,gray,green,greenyellow,grey,honeydew,hotpink,indianred,indigo,ivory,khaki,lavender,lavenderblush,lawngreen,lemonchiffon,lightblue,lightcoral,lightcyan,lightgoldenrodyellow,lightgray,lightgreen,lightgrey,lightpink,lightsalmon,lightseagreen,lightskyblue,lightslategray,lightslategrey,lightsteelblue,lightyellow,lime,limegreen,linen,magenta,maroon,mediumaquamarine,mediumblue,mediumorchid,mediumpurple,mediumseagreen,mediumslateblue,mediumspringgreen,mediumturquoise,mediumvioletred,midnightblue,mintcream,mistyrose,moccasin,navajowhite,navy,oldlace,olive,olivedrab,orange,orangered,orchid,palegoldenrod,palegreen,paleturquoise,palevioletred,papayawhip,peachpuff,peru,pink,plum,powderblue,purple,rebeccapurple,red,rosybrown,royalblue,saddlebrown,salmon,sandybrown,seagreen,seashell,sienna,silver,skyblue,slateblue,slategray,slategrey,snow,springgreen,steelblue,tan,teal,thistle,tomato,turquoise,violet,wheat,white,whitesmoke,yellow".split(","));
function Ef(e) {
  return typeof e != "string" ? !1 : (e = e.toLowerCase().trim(), /^#[0-9a-f]{3,8}$/.test(e) || // hex rgb, rgba, rrggbb, rrggbbaa
  /^(?:url|var|rgb|rgba|hsl|hsla|hwb|lab|lch|oklab|oklch|color|color-mix)\(.*\)$/.test(e) || // <funciri>, CSS variable, color, etc.
  QH.has(e));
}
function tJ(e) {
  return typeof e == "number" && (0 <= e && e <= 1 || isNaN(e));
}
function we(e) {
  return e == null || zc(e);
}
function zc(e) {
  return /^\s*none\s*$/i.test(e);
}
function eJ(e) {
  return /^\s*round\s*$/i.test(e);
}
function M1(e, t) {
  return fD(e, t, [
    "middle",
    "top-left",
    "top",
    "top-right",
    "right",
    "bottom-right",
    "bottom",
    "bottom-left",
    "left"
  ]);
}
function Lf(e = "middle") {
  return M1(e, "frameAnchor");
}
function nJ(e = {}, ...t) {
  let n = e;
  for (const i of t)
    for (const r in i)
      if (n[r] === void 0) {
        const s = i[r];
        n === e ? n = { ...n, [r]: s } : n[r] = s;
      }
  return n;
}
function iJ(e) {
  console.warn("named iterables are deprecated; please use an object instead");
  const t = /* @__PURE__ */ new Set();
  return Object.fromEntries(
    Array.from(e, (n) => {
      const { name: i } = n;
      if (i == null)
        throw new Error("missing name");
      const r = `${i}`;
      if (r === "__proto__")
        throw new Error(`illegal name: ${r}`);
      if (t.has(r))
        throw new Error(`duplicate name: ${r}`);
      return t.add(r), [i, n];
    })
  );
}
function Tw(e) {
  return ds(e) ? iJ(e) : e;
}
function bD(e) {
  return e === !0 ? e = "frame" : e === !1 ? e = null : e != null && (e = Yn(e, "clip", ["frame", "sphere"])), e;
}
const rr = Symbol("position"), ps = Symbol("color"), Rf = Symbol("radius"), Cf = Symbol("length"), kf = Symbol("opacity"), S0 = Symbol("symbol"), wD = Symbol("projection"), xe = /* @__PURE__ */ new Map([
  ["x", rr],
  ["y", rr],
  ["fx", rr],
  ["fy", rr],
  ["r", Rf],
  ["color", ps],
  ["opacity", kf],
  ["symbol", S0],
  ["length", Cf],
  ["projection", wD]
]);
function rJ(e) {
  return e === rr || e === wD;
}
function sJ(e) {
  return e === rr || e === Rf || e === Cf || e === kf;
}
const vD = Math.sqrt(3), _D = 2 / vD, oJ = {
  draw(e, t) {
    const n = Math.sqrt(t / Math.PI), i = n * _D, r = i / 2;
    e.moveTo(0, i), e.lineTo(n, r), e.lineTo(n, -r), e.lineTo(0, -i), e.lineTo(-n, -r), e.lineTo(-n, r), e.closePath();
  }
}, Dw = /* @__PURE__ */ new Map([
  ["asterisk", OT],
  ["circle", Pu],
  ["cross", FT],
  ["diamond", LT],
  ["diamond2", RT],
  ["hexagon", oJ],
  ["plus", CT],
  ["square", kT],
  ["square2", UT],
  ["star", PT],
  ["times", YT],
  ["triangle", VT],
  ["triangle2", jT],
  ["wye", qT]
]);
function Nw(e) {
  return e && typeof e.draw == "function";
}
function aJ(e) {
  return Nw(e) ? !0 : typeof e != "string" ? !1 : Dw.has(e.toLowerCase());
}
function Bw(e) {
  if (e == null || Nw(e))
    return e;
  const t = Dw.get(`${e}`.toLowerCase());
  if (t)
    return t;
  throw new Error(`invalid symbol: ${e}`);
}
function cJ(e) {
  if (e == null || Nw(e))
    return [void 0, e];
  if (typeof e == "string") {
    const t = Dw.get(`${e}`.toLowerCase());
    if (t)
      return [void 0, t];
  }
  return [e, void 0];
}
function vr({ filter: e, sort: t, reverse: n, transform: i, initializer: r, ...s } = {}, o) {
  if (i === void 0 && (e != null && (i = Ow(e)), t != null && !Hs(t) && (i = Um(i, Ew(t))), n && (i = Um(i, Fw))), o != null && r != null)
    throw new Error("transforms cannot be applied after initializers");
  return {
    ...s,
    ...(t === null || Hs(t)) && { sort: t },
    transform: Um(i, o)
  };
}
function Bn({ filter: e, sort: t, reverse: n, initializer: i, ...r } = {}, s) {
  return i === void 0 && (e != null && (i = Ow(e)), t != null && !Hs(t) && (i = zm(i, Ew(t))), n && (i = zm(i, Fw))), {
    ...r,
    ...(t === null || Hs(t)) && { sort: t },
    initializer: zm(i, s)
  };
}
function Um(e, t) {
  return e == null ? t === null ? void 0 : t : t == null ? e === null ? void 0 : e : function(n, i, r) {
    return { data: n, facets: i } = e.call(this, n, i, r), t.call(this, Nn(n), i, r);
  };
}
function zm(e, t) {
  return e == null ? t === null ? void 0 : t : t == null ? e === null ? void 0 : e : function(n, i, r, ...s) {
    let o, a, c, l, u, f;
    return { data: a = n, facets: c = i, channels: o } = e.call(this, n, i, r, ...s), { data: u = a, facets: f = c, channels: l } = t.call(this, a, c, { ...r, ...o }, ...s), { data: u, facets: f, channels: { ...o, ...l } };
  };
}
function x0(e, t) {
  return (e.initializer != null ? Bn : vr)(e, t);
}
function lJ(e, t) {
  return x0(t, Ow(e));
}
function Ow(e) {
  return (t, n) => {
    const i = Pt(t, e);
    return { data: t, facets: n.map((r) => r.filter((s) => i[s])) };
  };
}
function uJ({ sort: e, ...t } = {}) {
  return {
    ...x0(t, Fw),
    sort: Hs(e) ? e : null
  };
}
function Fw(e, t) {
  return { data: e, facets: t.map((n) => n.slice().reverse()) };
}
function fJ({ seed: e, sort: t, ...n } = {}) {
  return {
    ...x0(n, xD(e == null ? Math.random : cw(e))),
    sort: Hs(t) ? t : null
  };
}
function SD(e, { sort: t, ...n } = {}) {
  return {
    ...(Hi(e) && e.channel !== void 0 ? Bn : x0)(n, Ew(e)),
    sort: Hs(t) ? t : null
  };
}
function Ew(e) {
  return (typeof e == "function" && e.length !== 1 ? hJ : xD)(e);
}
function hJ(e) {
  return (t, n) => {
    const i = (r, s) => e(t[r], t[s]);
    return { data: t, facets: n.map((r) => r.slice().sort(i)) };
  };
}
function xD(e) {
  let t, n;
  ({ channel: t, value: e, order: n } = { ...al(e) });
  const i = t == null ? void 0 : t.startsWith("-");
  if (i && (t = t.slice(1)), n === void 0 && (n = i ? Cp : ui), typeof n != "function")
    switch (`${n}`.toLowerCase()) {
      case "ascending":
        n = ui;
        break;
      case "descending":
        n = Cp;
        break;
      default:
        throw new Error(`invalid order: ${n}`);
    }
  return (r, s, o) => {
    let a;
    if (t === void 0)
      a = Pt(r, e);
    else {
      if (o === void 0)
        throw new Error("channel sort requires an initializer");
      if (a = o[t], !a)
        return {};
      a = a.value;
    }
    const c = (l, u) => n(a[l], a[u]);
    return { data: r, facets: s.map((l) => l.slice().sort(c)) };
  };
}
function Lw(e, t) {
  return I0(null, null, e, t);
}
function qu(e = { y: "count" }, t = {}) {
  const { x: n = Tt } = t;
  if (n == null)
    throw new Error("missing channel: x");
  return I0(n, null, e, t);
}
function Yu(e = { x: "count" }, t = {}) {
  const { y: n = Tt } = t;
  if (n == null)
    throw new Error("missing channel: y");
  return I0(null, n, e, t);
}
function Rw(e = { fill: "count" }, t = {}) {
  let { x: n, y: i } = t;
  if ([n, i] = ki(n, i), n == null)
    throw new Error("missing channel: x");
  if (i == null)
    throw new Error("missing channel: y");
  return I0(n, i, e, t);
}
function I0(e, t, {
  data: n = zw,
  filter: i,
  sort: r,
  reverse: s,
  ...o
  // output channel definitions
} = {}, a = {}) {
  o = AD(o, a), n = TD(n, Tt), r = r == null ? void 0 : MD("sort", r, a), i = i == null ? void 0 : $D("filter", i, a);
  const [c, l] = Sn(e), [u, f] = Sn(t), {
    z: h,
    fill: d,
    stroke: p,
    x1: y,
    x2: m,
    // consumed if x is an output
    y1: g,
    y2: b,
    // consumed if y is an output
    ...w
  } = a, [v, S] = Sn(h), [_] = mn(d), [I] = mn(p), [T, M] = Sn(_), [N, A] = Sn(I);
  return {
    ..."z" in a && { z: v || h },
    ..."fill" in a && { fill: T || d },
    ..."stroke" in a && { stroke: N || p },
    ...vr(w, (B, R, x) => {
      const $ = zp(Pt(B, e), x == null ? void 0 : x.x), D = zp(Pt(B, t), x == null ? void 0 : x.y), L = Pt(B, h), k = Pt(B, _), U = Pt(B, I), C = Uw(o, { z: L, fill: k, stroke: U }), z = [], P = [], G = $ && l([]), K = D && f([]), et = L && S([]), Z = k && M([]), Y = U && A([]);
      let X = 0;
      for (const j of o)
        j.initialize(B);
      r && r.initialize(B), i && i.initialize(B);
      for (const j of R) {
        const J = [];
        for (const tt of o)
          tt.scope("facet", j);
        r && r.scope("facet", j), i && i.scope("facet", j);
        for (const [tt, V] of pc(j, C))
          for (const [Ft, st] of pc(V, D))
            for (const [Vt, jt] of pc(st, $)) {
              const Q = { data: B };
              if ($ && (Q.x = Vt), D && (Q.y = Ft), C && (Q.z = tt), !(i && !i.reduce(jt, Q))) {
                J.push(X++), P.push(n.reduceIndex(jt, B, Q)), $ && G.push(Vt), D && K.push(Ft), L && et.push(C === L ? tt : L[jt[0]]), k && Z.push(C === k ? tt : k[jt[0]]), U && Y.push(C === U ? tt : U[jt[0]]);
                for (const Zt of o)
                  Zt.reduce(jt, Q);
                r && r.reduce(jt, Q);
              }
            }
        z.push(J);
      }
      return DD(z, r, s), { data: P, facets: z };
    }),
    ...!Cs(o, "x") && (c ? { x: c } : { x1: y, x2: m }),
    ...!Cs(o, "y") && (u ? { y: u } : { y1: g, y2: b }),
    ...Object.fromEntries(o.map(({ name: B, output: R }) => [B, R]))
  };
}
function Cs(e, ...t) {
  for (const { name: n } of e)
    if (t.includes(n))
      return !0;
  return !1;
}
function ID(e, t, n = Cw) {
  const i = Object.entries(e);
  return t.title != null && e.title === void 0 && i.push(["title", bJ]), t.href != null && e.href === void 0 && i.push(["href", Pw]), i.filter(([, r]) => r !== void 0).map(([r, s]) => s === null ? dJ(r) : n(r, s, t));
}
function Cw(e, t, n, i = kw) {
  let r;
  di(t) && "reduce" in t && (r = t.scale, t = t.reduce);
  const s = i(e, t, n), [o, a] = zn(s.label);
  let c;
  return {
    name: e,
    output: r === void 0 ? o : { value: o, scale: r },
    initialize(l) {
      s.initialize(l), c = a([]);
    },
    scope(l, u) {
      s.scope(l, u);
    },
    reduce(l, u) {
      c.push(s.reduce(l, u));
    }
  };
}
function dJ(e) {
  return { name: e, initialize() {
  }, scope() {
  }, reduce() {
  } };
}
function kw(e, t, n, i = A0) {
  const r = yD(e, n), s = i(t, r);
  let o, a;
  return {
    label: wr(s === Pp ? null : r, s.label),
    initialize(c) {
      o = r === void 0 ? c : Pt(c, r), s.scope === "data" && (a = s.reduceIndex(hs(c), o));
    },
    scope(c, l) {
      s.scope === c && (a = s.reduceIndex(l, o));
    },
    reduce(c, l) {
      return s.scope == null ? s.reduceIndex(c, o, l) : s.reduceIndex(c, o, a, l);
    }
  };
}
function pc(e, t) {
  return t ? fs(e, (n) => t[n]) : [[, e]];
}
function A0(e, t, n = pJ) {
  if (e == null)
    return n(e);
  if (typeof e.reduceIndex == "function")
    return e;
  if (typeof e.reduce == "function" && di(e))
    return mJ(e);
  if (typeof e == "function")
    return gJ(e);
  if (/^p\d{2}$/i.test(e))
    return Fr(Aw(e));
  switch (`${e}`.toLowerCase()) {
    case "first":
      return Pw;
    case "last":
      return wJ;
    case "identity":
      return zw;
    case "count":
      return Pp;
    case "distinct":
      return vJ;
    case "sum":
      return t == null ? Pp : _J;
    case "proportion":
      return XS(t, "data");
    case "proportion-facet":
      return XS(t, "facet");
    case "deviation":
      return Fr(gf);
    case "min":
      return Fr(Ye);
    case "min-index":
      return Fr(Uz);
    case "max":
      return Fr(De);
    case "max-index":
      return Fr(kz);
    case "mean":
      return GS(Gy);
    case "median":
      return GS(Bu);
    case "variance":
      return Fr(kb);
    case "mode":
      return Fr(dM);
  }
  return n(e);
}
function pJ(e) {
  throw new Error(`invalid reduce: ${e}`);
}
function AD(e, t) {
  return ID(e, t, MD);
}
function MD(e, t, n) {
  return Cw(e, t, n, $D);
}
function $D(e, t, n) {
  return kw(e, t, n, TD);
}
function TD(e, t) {
  return A0(e, t, yJ);
}
function yJ(e) {
  switch (`${e}`.toLowerCase()) {
    case "x":
      return SJ;
    case "y":
      return xJ;
    case "z":
      return ND;
  }
  throw new Error(`invalid group reduce: ${e}`);
}
function Uw(e, t) {
  for (const n in t) {
    const i = t[n];
    if (i !== void 0 && !e.some((r) => r.name === n))
      return i;
  }
}
function DD(e, t, n) {
  if (t) {
    const i = t.output.transform(), r = (s, o) => ui(i[s], i[o]);
    e.forEach((s) => s.sort(r));
  }
  n && e.forEach((i) => i.reverse());
}
function mJ(e) {
  return console.warn("deprecated reduce interface; implement reduceIndex instead."), { ...e, reduceIndex: e.reduce.bind(e) };
}
function gJ(e) {
  return {
    reduceIndex(t, n, i) {
      return e(v0(n, t), i);
    }
  };
}
function Fr(e) {
  return {
    reduceIndex(t, n) {
      return e(t, (i) => n[i]);
    }
  };
}
function GS(e) {
  return {
    reduceIndex(t, n) {
      const i = e(t, (r) => n[r]);
      return gn(n) ? new Date(i) : i;
    }
  };
}
const zw = {
  reduceIndex(e, t) {
    return v0(t, e);
  }
}, Pw = {
  reduceIndex(e, t) {
    return t[e[0]];
  }
}, bJ = {
  reduceIndex(e, t) {
    const i = Hd(
      uc(
        e,
        (s) => s.length,
        (s) => t[s]
      ),
      Vu
    ), r = i.slice(-5).reverse();
    if (r.length < i.length) {
      const s = i.slice(0, -4);
      r[4] = [` ${s.length.toLocaleString("en-US")} more`, fr(s, Vu)];
    }
    return r.map(([s, o]) => `${s} (${o.toLocaleString("en-US")})`).join(`
`);
  }
}, wJ = {
  reduceIndex(e, t) {
    return t[e[e.length - 1]];
  }
}, Pp = {
  label: "Frequency",
  reduceIndex(e) {
    return e.length;
  }
}, vJ = {
  label: "Distinct",
  reduceIndex(e, t) {
    const n = new el();
    for (const i of e)
      n.add(t[i]);
    return n.size;
  }
}, _J = Fr(fr);
function XS(e, t) {
  return e == null ? { scope: t, label: "Frequency", reduceIndex: (n, i, r = 1) => n.length / r } : { scope: t, reduceIndex: (n, i, r = 1) => fr(n, (s) => i[s]) / r };
}
const SJ = {
  reduceIndex(e, t, { x: n }) {
    return n;
  }
}, xJ = {
  reduceIndex(e, t, { y: n }) {
    return n;
  }
}, ND = {
  reduceIndex(e, t, { z: n }) {
    return n;
  }
};
function IJ(e) {
  if (typeof e != "function")
    throw new Error(`invalid test function: ${e}`);
  return {
    reduceIndex(t, n, { data: i }) {
      return n[t.find((r) => e(i[r], r, i))];
    }
  };
}
function Wu(e, { scale: t, type: n, value: i, filter: r, hint: s, label: o = wr(i) }, a) {
  return s === void 0 && typeof (i == null ? void 0 : i.transform) == "function" && (s = i.hint), OD(a, {
    scale: t,
    type: n,
    value: Pt(e, i),
    label: o,
    filter: r,
    hint: s
  });
}
function BD(e, t) {
  return Object.fromEntries(
    Object.entries(e).map(([n, i]) => [n, Wu(t, i, n)])
  );
}
function Vw(e, t) {
  const n = Object.fromEntries(
    Object.entries(e).map(([i, { scale: r, value: s }]) => {
      const o = r == null ? null : t[r];
      return [i, o == null ? s : ye(s, o)];
    })
  );
  return n.channels = e, n;
}
function OD(e, t) {
  const { scale: n, value: i } = t;
  if (n === !0 || n === "auto")
    switch (e) {
      case "fill":
      case "stroke":
      case "color":
        t.scale = n !== !0 && km(i, Ef) ? null : "color";
        break;
      case "fillOpacity":
      case "strokeOpacity":
      case "opacity":
        t.scale = n !== !0 && km(i, tJ) ? null : "opacity";
        break;
      case "symbol":
        n !== !0 && km(i, aJ) ? (t.scale = null, t.value = ye(i, Bw)) : t.scale = "symbol";
        break;
      default:
        t.scale = xe.has(e) ? e : null;
        break;
    }
  else if (n === !1)
    t.scale = null;
  else if (n != null && !xe.has(n))
    throw new Error(`unknown scale: ${n}`);
  return t;
}
function AJ(e, t, n, i, r) {
  const { order: s, reverse: o, reduce: a = !0, limit: c } = r;
  for (const l in r) {
    if (!xe.has(l))
      continue;
    let { value: u, order: f = s, reverse: h = o, reduce: d = a, limit: p = c } = al(r[l]);
    const y = u == null ? void 0 : u.startsWith("-");
    if (y && (u = u.slice(1)), f = f === void 0 ? y !== (u === "width" || u === "height") ? ED : FD : TJ(f), d == null || d === !1)
      continue;
    const m = l === "fx" || l === "fy" ? $J(t, i[l]) : MJ(n, l);
    if (!m)
      throw new Error(`missing channel for scale: ${l}`);
    const g = m.value, [b = 0, w = 1 / 0] = ds(p) ? p : p < 0 ? [p] : [0, p];
    if (u == null)
      m.domain = () => {
        let v = Array.from(new el(g));
        return h && (v = v.reverse()), (b !== 0 || w !== 1 / 0) && (v = v.slice(b, w)), v;
      };
    else {
      const v = u === "data" ? e : u === "height" ? HS(n, "y1", "y2") : u === "width" ? HS(n, "x1", "x2") : $1(n, u, u === "y" ? "y2" : u === "x" ? "x2" : void 0), S = A0(d === !0 ? "max" : d, v);
      m.domain = () => {
        let _ = Fz(
          hs(g),
          (I) => S.reduceIndex(I, v),
          (I) => g[I]
        );
        return f && _.sort(f), h && _.reverse(), (b !== 0 || w !== 1 / 0) && (_ = _.slice(b, w)), _.map(b0);
      };
    }
  }
}
function MJ(e, t) {
  for (const n in e) {
    const i = e[n];
    if (i.scale === t)
      return i;
  }
}
function $J(e, t) {
  const n = e.original;
  if (n === e)
    return t;
  const i = t.value, r = t.value = [];
  for (let s = 0; s < n.length; ++s) {
    const o = i[n[s][0]];
    for (const a of e[s])
      r[a] = o;
  }
  return t;
}
function HS(e, t, n) {
  const i = $1(e, t), r = $1(e, n);
  return ye(r, (s, o) => Math.abs(s - i[o]), Float64Array);
}
function $1(e, t, n) {
  let i = e[t];
  if (!i && n !== void 0 && (i = e[n]), i)
    return i.value;
  throw new Error(`missing channel: ${t}`);
}
function TJ(e) {
  if (e == null || typeof e == "function")
    return e;
  switch (`${e}`.toLowerCase()) {
    case "ascending":
      return FD;
    case "descending":
      return ED;
  }
  throw new Error(`invalid order: ${e}`);
}
function FD([e, t], [n, i]) {
  return ui(t, i) || ui(e, n);
}
function ED([e, t], [n, i]) {
  return Cp(t, i) || ui(e, n);
}
function T1(e, t) {
  let n = e[t];
  if (n) {
    for (; n.source; )
      n = n.source;
    return n.source === null ? null : n;
  }
}
function M0(e = {}) {
  const { document: t = typeof window < "u" ? window.document : void 0, clip: n } = e;
  return { document: t, clip: bD(n) };
}
function Gt(e, { document: t }) {
  return ce(Jy(e).call(t.documentElement));
}
let D1 = 0, N1;
function DJ() {
  const e = D1;
  return D1 = 0, N1 = void 0, e;
}
function ts(e) {
  e !== N1 && (N1 = e, console.warn(e), ++D1);
}
const LD = Math.PI, Mr = 2 * LD, JS = 0.618;
function NJ({
  projection: e,
  inset: t = 0,
  insetTop: n = t,
  insetRight: i = t,
  insetBottom: r = t,
  insetLeft: s = t
} = {}, o) {
  if (e == null)
    return;
  if (typeof e.stream == "function")
    return e;
  let a, c, l = "frame";
  if (di(e)) {
    let S;
    if ({
      type: e,
      domain: c,
      inset: S,
      insetTop: n = S !== void 0 ? S : n,
      insetRight: i = S !== void 0 ? S : i,
      insetBottom: r = S !== void 0 ? S : r,
      insetLeft: s = S !== void 0 ? S : s,
      clip: l = l,
      ...a
    } = e, e == null)
      return;
  }
  typeof e != "function" && ({ type: e } = RD(e));
  const { width: u, height: f, marginLeft: h, marginRight: d, marginTop: p, marginBottom: y } = o, m = u - h - d - s - i, g = f - p - y - n - r;
  if (e = e == null ? void 0 : e({ width: m, height: g, clip: l, ...a }), e == null)
    return;
  l = BJ(l, h, p, u - d, f - y);
  let b = h + s, w = p + n, v;
  if (c != null) {
    const [[S, _], [I, T]] = ao(e).bounds(c), M = Math.min(m / (I - S), g / (T - _));
    M > 0 ? (b -= (M * (S + I) - m) / 2, w -= (M * (_ + T) - g) / 2, v = Ip({
      point(N, A) {
        this.stream.point(N * M + b, A * M + w);
      }
    })) : ts("Warning: the projection could not be fit to the specified domain; using the default scale.");
  }
  return v ?? (v = b === 0 && w === 0 ? CD() : Ip({
    point(S, _) {
      this.stream.point(S + b, _ + w);
    }
  })), { stream: (S) => e.stream(v.stream(l(S))) };
}
function RD(e) {
  switch (`${e}`.toLowerCase()) {
    case "albers-usa":
      return pi(_W, 0.7463, 0.4673);
    case "albers":
      return _h($$, 0.7463, 0.4673);
    case "azimuthal-equal-area":
      return pi(SW, 4, 4);
    case "azimuthal-equidistant":
      return pi(xW, Mr, Mr);
    case "conic-conformal":
      return _h(MW, Mr, Mr);
    case "conic-equal-area":
      return _h(Ap, 6.1702, 2.9781);
    case "conic-equidistant":
      return _h(DW, 7.312, 3.6282);
    case "equal-earth":
      return pi(BW, 5.4133, 2.6347);
    case "equirectangular":
      return pi($W, Mr, LD);
    case "gnomonic":
      return pi(OW, 3.4641, 3.4641);
    case "identity":
      return { type: CD };
    case "reflect-y":
      return { type: OJ };
    case "mercator":
      return pi(IW, Mr, Mr);
    case "orthographic":
      return pi(FW, 2, 2);
    case "stereographic":
      return pi(EW, 2, 2);
    case "transverse-mercator":
      return pi(LW, Mr, Mr);
    default:
      throw new Error(`unknown projection type: ${e}`);
  }
}
function BJ(e, t, n, i, r) {
  if (e === !1 || e == null || typeof e == "number")
    return (s) => s;
  switch (e === !0 && (e = "frame"), `${e}`.toLowerCase()) {
    case "frame":
      return f$(t, n, i, r);
    default:
      throw new Error(`unknown projection clip type: ${e}`);
  }
}
function pi(e, t, n) {
  return {
    type: ({ width: i, height: r, rotate: s, precision: o = 0.15, clip: a }) => {
      var l, u, f;
      const c = e();
      return o != null && ((l = c.precision) == null || l.call(c, o)), s != null && ((u = c.rotate) == null || u.call(c, s)), typeof a == "number" && ((f = c.clipAngle) == null || f.call(c, a)), c.scale(Math.min(i / t, r / n)), c.translate([i / 2, r / 2]), c;
    },
    aspectRatio: n / t
  };
}
function _h(e, t, n) {
  const { type: i, aspectRatio: r } = pi(e, t, n);
  return {
    type: (s) => {
      const { parallels: o, domain: a, width: c, height: l } = s, u = i(s);
      return o != null && (u.parallels(o), a === void 0 && u.fitSize([c, l], { type: "Sphere" })), u;
    },
    aspectRatio: r
  };
}
const CD = qn({ stream: (e) => e }), OJ = qn(
  Ip({
    point(e, t) {
      this.stream.point(e, -t);
    }
  })
);
function kD(e, t, n, i) {
  const r = n[e], s = n[t], o = r.length, a = n[e] = new Float64Array(o).fill(NaN), c = n[t] = new Float64Array(o).fill(NaN);
  let l;
  const u = i.stream({
    point(f, h) {
      a[l] = f, c[l] = h;
    }
  });
  for (l = 0; l < o; ++l)
    u.point(r[l], s[l]);
}
function FJ({ projection: e } = {}) {
  return e == null ? !1 : typeof e.stream == "function" ? !0 : (di(e) && (e = e.type), e != null);
}
function EJ(e) {
  if (typeof (e == null ? void 0 : e.stream) == "function")
    return JS;
  if (di(e) && (e = e.type), e != null) {
    if (typeof e != "function") {
      const { aspectRatio: t } = RD(e);
      if (t)
        return t;
    }
    return JS;
  }
}
function $0(e, t, { projection: n }) {
  const { x: i, y: r } = e;
  let s = {};
  return i && (s.x = i), r && (s.y = r), s = Vw(s, t), n && (i == null ? void 0 : i.scale) === "x" && (r == null ? void 0 : r.scale) === "y" && kD("x", "y", s, n), i && (s.x = An(s.x)), r && (s.y = An(s.y)), s;
}
function LJ(e) {
  const t = [], n = [], i = { scale: "x", value: t }, r = { scale: "y", value: n }, s = {
    point(o, a) {
      t.push(o), n.push(a);
    },
    lineStart() {
    },
    lineEnd() {
    },
    polygonStart() {
    },
    polygonEnd() {
    },
    sphere() {
    }
  };
  for (const o of e.value)
    Bs(o, s);
  return [i, r];
}
const UD = /* @__PURE__ */ new Map([
  ["accent", VX],
  ["category10", PX],
  ["dark2", jX],
  ["observable10", qX],
  ["paired", YX],
  ["pastel1", WX],
  ["pastel2", GX],
  ["set1", XX],
  ["set2", HX],
  ["set3", JX],
  ["tableau10", KX]
]);
function RJ(e) {
  return e != null && UD.has(`${e}`.toLowerCase());
}
const KS = new Map([
  ...UD,
  // diverging
  ["brbg", $r(g6, b6)],
  ["prgn", $r(w6, v6)],
  ["piyg", $r(_6, S6)],
  ["puor", $r(x6, I6)],
  ["rdbu", $r(x1, Np)],
  ["rdgy", $r(A6, M6)],
  ["rdylbu", $r(I1, Bp)],
  ["rdylgn", $r($6, T6)],
  ["spectral", $r(D6, N6)],
  // reversed diverging (for temperature data)
  ["burd", ZS(x1, Np)],
  ["buylrd", ZS(I1, Bp)],
  // sequential (single-hue)
  ["blues", Ve(eT, nT)],
  ["greens", Ve(iT, rT)],
  ["greys", Ve(sT, oT)],
  ["oranges", Ve(fT, hT)],
  ["purples", Ve(aT, cT)],
  ["reds", Ve(lT, uT)],
  // sequential (multi-hue)
  ["turbo", Tr(wT)],
  ["viridis", Tr(vT)],
  ["magma", Tr(_T)],
  ["inferno", Tr(ST)],
  ["plasma", Tr(xT)],
  ["cividis", Tr(dT)],
  ["cubehelix", Tr(pT)],
  ["warm", Tr(yT)],
  ["cool", Tr(mT)],
  ["bugn", Ve(B6, O6)],
  ["bupu", Ve(F6, E6)],
  ["gnbu", Ve(L6, R6)],
  ["orrd", Ve(C6, k6)],
  ["pubu", Ve(P6, V6)],
  ["pubugn", Ve(U6, z6)],
  ["purd", Ve(j6, q6)],
  ["rdpu", Ve(Y6, W6)],
  ["ylgn", Ve(H6, J6)],
  ["ylgnbu", Ve(G6, X6)],
  ["ylorbr", Ve(K6, Z6)],
  ["ylorrd", Ve(Q6, tT)],
  // cyclical
  ["rainbow", QS(gT)],
  ["sinebow", QS(bT)]
]);
function Ve(e, t) {
  return ({ length: n }) => n === 1 ? [e[3][1]] : n === 2 ? [e[3][1], e[3][2]] : (n = Math.max(3, Math.floor(n)), n > 9 ? Ti(t, n) : e[n]);
}
function $r(e, t) {
  return ({ length: n }) => n === 2 ? [e[3][0], e[3][2]] : (n = Math.max(3, Math.floor(n)), n > 11 ? Ti(t, n) : e[n]);
}
function ZS(e, t) {
  return ({ length: n }) => n === 2 ? [e[3][2], e[3][0]] : (n = Math.max(3, Math.floor(n)), n > 11 ? Ti((i) => t(1 - i), n) : e[n].slice().reverse());
}
function Tr(e) {
  return ({ length: t }) => Ti(e, Math.max(2, Math.floor(t)));
}
function QS(e) {
  return ({ length: t }) => Ti(e, Math.floor(t) + 1).slice(0, -1);
}
function zD(e) {
  const t = `${e}`.toLowerCase();
  if (!KS.has(t))
    throw new Error(`unknown ordinal scheme: ${t}`);
  return KS.get(t);
}
function T0(e, t) {
  const n = zD(e), i = typeof n == "function" ? n({ length: t }) : n;
  return i.length !== t ? i.slice(0, t) : i;
}
function CJ(e, t = "greys") {
  const n = /* @__PURE__ */ new Set(), [i, r] = T0(t, 2);
  for (const s of e)
    if (s != null)
      if (s === !0)
        n.add(r);
      else if (s === !1)
        n.add(i);
      else
        return;
  return [...n];
}
const tx = /* @__PURE__ */ new Map([
  // diverging
  ["brbg", b6],
  ["prgn", v6],
  ["piyg", S6],
  ["puor", I6],
  ["rdbu", Np],
  ["rdgy", M6],
  ["rdylbu", Bp],
  ["rdylgn", T6],
  ["spectral", N6],
  // reversed diverging (for temperature data)
  ["burd", (e) => Np(1 - e)],
  ["buylrd", (e) => Bp(1 - e)],
  // sequential (single-hue)
  ["blues", nT],
  ["greens", rT],
  ["greys", oT],
  ["purples", cT],
  ["reds", uT],
  ["oranges", hT],
  // sequential (multi-hue)
  ["turbo", wT],
  ["viridis", vT],
  ["magma", _T],
  ["inferno", ST],
  ["plasma", xT],
  ["cividis", dT],
  ["cubehelix", pT],
  ["warm", yT],
  ["cool", mT],
  ["bugn", O6],
  ["bupu", E6],
  ["gnbu", R6],
  ["orrd", k6],
  ["pubugn", z6],
  ["pubu", V6],
  ["purd", q6],
  ["rdpu", W6],
  ["ylgnbu", X6],
  ["ylgn", J6],
  ["ylorbr", Z6],
  ["ylorrd", tT],
  // cyclical
  ["rainbow", gT],
  ["sinebow", bT]
]);
function jw(e) {
  const t = `${e}`.toLowerCase();
  if (!tx.has(t))
    throw new Error(`unknown quantitative scheme: ${t}`);
  return tx.get(t);
}
const kJ = /* @__PURE__ */ new Set([
  "brbg",
  "prgn",
  "piyg",
  "puor",
  "rdbu",
  "rdgy",
  "rdylbu",
  "rdylgn",
  "spectral",
  "burd",
  "buylrd"
]);
function UJ(e) {
  return e != null && kJ.has(`${e}`.toLowerCase());
}
const PD = (e) => (t) => e(1 - t), Pm = [0, 1], ex = /* @__PURE__ */ new Map([
  // numbers
  ["number", Qe],
  // color spaces
  ["rgb", Qo],
  ["hsl", gj],
  ["hcl", vj],
  ["lab", bj]
]);
function VD(e) {
  const t = `${e}`.toLowerCase();
  if (!ex.has(t))
    throw new Error(`unknown interpolator: ${t}`);
  return ex.get(t);
}
function Uf(e, t, n, {
  type: i,
  nice: r,
  clamp: s,
  zero: o,
  domain: a = qD(e, n),
  unknown: c,
  round: l,
  scheme: u,
  interval: f,
  range: h = xe.get(e) === Rf ? JJ(n, a) : xe.get(e) === Cf ? KJ(n, a) : xe.get(e) === kf ? Pm : void 0,
  interpolate: d = xe.get(e) === ps ? u == null && h !== void 0 ? Qo : jw(u !== void 0 ? u : i === "cyclical" ? "rainbow" : "turbo") : l ? Jb : Qe,
  reverse: p
}) {
  if (f = ol(f, i), (i === "cyclical" || i === "sequential") && (i = "linear"), typeof d != "function" && (d = VD(d)), p = !!p, h !== void 0) {
    const y = (a = Nn(a)).length, m = (h = Nn(h)).length;
    if (y !== m) {
      if (d.length === 1)
        throw new Error("invalid piecewise interpolator");
      d = Qy(d, h), h = void 0;
    }
  }
  if (d.length === 1 ? (p && (d = PD(d), p = !1), h === void 0 && (h = Float64Array.from(a, (y, m) => m / (a.length - 1)), h.length === 2 && (h = Pm)), t.interpolate((h === Pm ? qn : Yw)(d))) : t.interpolate(d), o) {
    const [y, m] = ke(a);
    (y > 0 || m < 0) && (a = ju(a), kc(a) !== Math.sign(y) ? a[a.length - 1] = 0 : a[0] = 0);
  }
  return p && (a = Kd(a)), t.domain(a).unknown(c), r && (t.nice(zJ(r, i)), a = t.domain()), h !== void 0 && t.range(h), s && t.clamp(s), { type: i, domain: a, range: h, scale: t, interpolate: d, interval: f };
}
function zJ(e, t) {
  return e === !0 ? void 0 : typeof e == "number" ? e : GH(e, t);
}
function PJ(e, t, n) {
  return Uf(e, a0(), t, n);
}
function VJ(e, t, n) {
  return jD(e, t, { ...n, exponent: 0.5 });
}
function jD(e, t, { exponent: n = 1, ...i }) {
  return Uf(e, J$().exponent(n), t, { ...i, type: "pow" });
}
function jJ(e, t, { base: n = 10, domain: i = ZJ(t), ...r }) {
  return Uf(e, W$().base(n), t, { ...r, domain: i });
}
function qJ(e, t, { constant: n = 1, ...i }) {
  return Uf(e, X$().constant(n), t, i);
}
function YJ(e, t, {
  range: n,
  quantiles: i = n === void 0 ? 5 : (n = [...n]).length,
  // deprecated; use n instead
  n: r = i,
  scheme: s = "rdylbu",
  domain: o = QJ(t),
  unknown: a,
  interpolate: c,
  reverse: l
}) {
  return n === void 0 && (n = c !== void 0 ? Ti(c, r) : xe.get(e) === ps ? T0(s, r) : void 0), o.length > 0 && (o = K$(o, n === void 0 ? { length: r } : n).quantiles()), qw(e, t, { domain: o, range: n, reverse: l, unknown: a });
}
function WJ(e, t, {
  range: n,
  n: i = n === void 0 ? 5 : (n = [...n]).length,
  scheme: r = "rdylbu",
  domain: s = qD(e, t),
  unknown: o,
  interpolate: a,
  reverse: c
}) {
  const [l, u] = ke(s);
  let f;
  return n === void 0 ? (f = Ys(l, u, i), f[0] <= l && f.splice(0, 1), f[f.length - 1] >= u && f.pop(), i = f.length + 1, n = a !== void 0 ? Ti(a, i) : xe.get(e) === ps ? T0(r, i) : void 0) : (f = Ti(Qe(l, u), i + 1).slice(1, -1), l instanceof Date && (f = f.map((h) => new Date(h)))), kc(Nn(s)) < 0 && f.reverse(), qw(e, t, { domain: f, range: n, reverse: c, unknown: o });
}
function qw(e, t, {
  domain: n = [0],
  // explicit thresholds in ascending order
  unknown: i,
  scheme: r = "rdylbu",
  interpolate: s,
  range: o = s !== void 0 ? Ti(s, n.length + 1) : xe.get(e) === ps ? T0(r, n.length + 1) : void 0,
  reverse: a
}) {
  n = Nn(n);
  const c = kc(n);
  if (!isNaN(c) && !GJ(n, c))
    throw new Error(`the ${e} scale has a non-monotonic domain`);
  return a && (o = Kd(o)), {
    type: "threshold",
    scale: Z$(c < 0 ? Kd(n) : n, o === void 0 ? [] : o).unknown(i),
    domain: n,
    range: o
  };
}
function GJ(e, t) {
  for (let n = 1, i = e.length, r = e[0]; n < i; ++n) {
    const s = Ho(r, r = e[n]);
    if (s !== 0 && s !== t)
      return !1;
  }
  return !0;
}
function XJ(e) {
  return { type: "identity", scale: sJ(xe.get(e)) ? j$() : (t) => t };
}
function Gu(e, t = kp) {
  return e.length ? [
    Ye(e, ({ value: n }) => n === void 0 ? n : Ye(n, t)),
    De(e, ({ value: n }) => n === void 0 ? n : De(n, t))
  ] : [0, 1];
}
function qD(e, t) {
  const n = xe.get(e);
  return (n === Rf || n === kf || n === Cf ? HJ : Gu)(t);
}
function HJ(e) {
  return [0, e.length ? De(e, ({ value: t }) => t === void 0 ? t : De(t, kp)) : 1];
}
function JJ(e, t) {
  const n = e.find(({ radius: o }) => o !== void 0);
  if (n !== void 0)
    return [0, n.radius];
  const i = Ws(e, 0.5, ({ value: o }) => o === void 0 ? NaN : Ws(o, 0.25, Qr)), r = t.map((o) => 3 * Math.sqrt(o / i)), s = 30 / De(r);
  return s < 1 ? r.map((o) => o * s) : r;
}
function KJ(e, t) {
  const n = Bu(e, ({ value: s }) => s === void 0 ? NaN : Bu(s, Math.abs)), i = t.map((s) => 12 * s / n), r = 60 / De(i);
  return r < 1 ? i.map((s) => s * r) : i;
}
function ZJ(e) {
  for (const { value: t } of e)
    if (t !== void 0)
      for (let n of t) {
        if (n > 0)
          return Gu(e, Qr);
        if (n < 0)
          return Gu(e, m0);
      }
  return [1, 10];
}
function QJ(e) {
  const t = [];
  for (const { value: n } of e)
    if (n !== void 0)
      for (const i of n)
        t.push(i);
  return t;
}
function Yw(e) {
  return (t, n) => (i) => e(t + i * (n - t));
}
function D0(e, t, n, i, {
  type: r,
  nice: s,
  clamp: o,
  domain: a = Gu(i),
  unknown: c,
  pivot: l = 0,
  scheme: u,
  range: f,
  symmetric: h = !0,
  interpolate: d = xe.get(e) === ps ? u == null && f !== void 0 ? Qo : jw(u !== void 0 ? u : "rdbu") : Qe,
  reverse: p
}) {
  l = +l, a = Nn(a);
  let [y, m] = a;
  if (a.length > 2 && ts(`Warning: the diverging ${e} scale domain contains extra elements.`), Ho(y, m) < 0 && ([y, m] = [m, y], p = !p), y = Math.min(y, l), m = Math.max(m, l), typeof d != "function" && (d = VD(d)), f !== void 0 && (d = d.length === 1 ? Yw(d)(...f) : Qy(d, f)), p && (d = PD(d)), h) {
    const g = n.apply(l), b = g - n.apply(y), w = n.apply(m) - g;
    b < w ? y = n.invert(g - w) : b > w && (m = n.invert(g + b));
  }
  return t.domain([y, l, m]).unknown(c).interpolator(d), o && t.clamp(o), s && t.nice(s), { type: r, domain: [y, m], pivot: l, interpolate: d, scale: t };
}
function tK(e, t, n) {
  return D0(e, d6(), rK, t, n);
}
function eK(e, t, n) {
  return YD(e, t, { ...n, exponent: 0.5 });
}
function YD(e, t, { exponent: n = 1, ...i }) {
  return D0(e, m6().exponent(n = +n), aK(n), t, {
    ...i,
    type: "diverging-pow"
  });
}
function nK(e, t, { base: n = 10, pivot: i = 1, domain: r = Gu(t, i < 0 ? m0 : Qr), ...s }) {
  return D0(e, p6().base(n = +n), sK, t, {
    domain: r,
    pivot: i,
    ...s
  });
}
function iK(e, t, { constant: n = 1, ...i }) {
  return D0(
    e,
    y6().constant(n = +n),
    cK(n),
    t,
    i
  );
}
const rK = {
  apply(e) {
    return e;
  },
  invert(e) {
    return e;
  }
}, sK = {
  apply: Math.log,
  invert: Math.exp
}, oK = {
  apply(e) {
    return Math.sign(e) * Math.sqrt(Math.abs(e));
  },
  invert(e) {
    return Math.sign(e) * (e * e);
  }
};
function aK(e) {
  return e === 0.5 ? oK : {
    apply(t) {
      return Math.sign(t) * Math.pow(Math.abs(t), e);
    },
    invert(t) {
      return Math.sign(t) * Math.pow(Math.abs(t), 1 / e);
    }
  };
}
function cK(e) {
  return {
    apply(t) {
      return Math.sign(t) * Math.log1p(Math.abs(t / e));
    },
    invert(t) {
      return Math.sign(t) * Math.expm1(Math.abs(t)) * e;
    }
  };
}
function WD(e, t, n, i) {
  return Uf(e, t, n, i);
}
function lK(e, t, n) {
  return WD(e, UX(), t, n);
}
function uK(e, t, n) {
  return WD(e, zX(), t, n);
}
const zf = Symbol("ordinal");
function GD(e, t, n, { type: i, interval: r, domain: s, range: o, reverse: a, hint: c }) {
  return r = ol(r, i), s === void 0 && (s = HD(n, r, e)), (i === "categorical" || i === zf) && (i = "ordinal"), a && (s = Kd(s)), s = t.domain(s).domain(), o !== void 0 && (typeof o == "function" && (o = o(s)), t.range(o)), { type: i, domain: s, range: o, scale: t, hint: c, interval: r };
}
function fK(e, t, { type: n, interval: i, domain: r, range: s, scheme: o, unknown: a, ...c }) {
  i = ol(i, n), r === void 0 && (r = HD(t, i, e));
  let l;
  if (xe.get(e) === S0)
    l = pK(t), s = s === void 0 ? yK(l) : ye(s, Bw);
  else if (xe.get(e) === ps && (s === void 0 && (n === "ordinal" || n === zf) && (s = CJ(r, o), s !== void 0 && (o = void 0)), o === void 0 && s === void 0 && (o = n === "ordinal" ? "turbo" : "observable10"), o !== void 0))
    if (s !== void 0) {
      const u = jw(o), f = s[0], h = s[1] - s[0];
      s = ({ length: d }) => Ti((p) => u(f + h * p), d);
    } else
      s = zD(o);
  if (a === v1)
    throw new Error(`implicit unknown on ${e} scale is not supported`);
  return GD(e, lw().unknown(a), t, { ...c, type: n, domain: r, range: s, hint: l });
}
function hK(e, t, { align: n = 0.5, padding: i = 0.5, ...r }) {
  return XD(vG().align(n).padding(i), t, r, e);
}
function dK(e, t, {
  align: n = 0.5,
  padding: i = 0.1,
  paddingInner: r = i,
  paddingOuter: s = e === "fx" || e === "fy" ? 0 : i,
  ...o
}) {
  return XD(
    s0().align(n).paddingInner(r).paddingOuter(s),
    t,
    o,
    e
  );
}
function XD(e, t, n, i) {
  let { round: r } = n;
  return r !== void 0 && e.round(r = !!r), e = GD(i, e, t, n), e.round = r, e;
}
function HD(e, t, n) {
  const i = new el();
  for (const { value: r, domain: s } of e) {
    if (s !== void 0)
      return s();
    if (r !== void 0)
      for (const o of r)
        i.add(o);
  }
  if (t !== void 0) {
    const [r, s] = ke(i).map(t.floor, t);
    return t.range(r, t.offset(s));
  }
  if (i.size > 1e4 && xe.get(n) === rr)
    throw new Error(`implicit ordinal domain of ${n} scale has more than 10,000 values`);
  return Hd(i, ui);
}
function nx(e, t) {
  let n;
  for (const { hint: i } of e) {
    const r = i == null ? void 0 : i[t];
    if (r !== void 0) {
      if (n === void 0)
        n = r;
      else if (n !== r)
        return;
    }
  }
  return n;
}
function pK(e) {
  return {
    fill: nx(e, "fill"),
    stroke: nx(e, "stroke")
  };
}
function yK(e) {
  return we(e.fill) ? uH : lH;
}
function B1(e, {
  label: t,
  inset: n = 0,
  insetTop: i = n,
  insetRight: r = n,
  insetBottom: s = n,
  insetLeft: o = n,
  round: a,
  nice: c,
  clamp: l,
  zero: u,
  align: f,
  padding: h,
  projection: d,
  facet: { label: p = t } = {},
  ...y
} = {}) {
  const m = {};
  for (const [g, b] of e) {
    const w = y[g], v = t8(g, b, {
      round: xe.get(g) === rr ? a : void 0,
      // only for position
      nice: c,
      clamp: l,
      zero: u,
      align: f,
      padding: h,
      projection: d,
      ...w
    });
    if (v) {
      let {
        label: S = g === "fx" || g === "fy" ? p : t,
        percent: _,
        transform: I,
        inset: T,
        insetTop: M = T !== void 0 ? T : g === "y" ? i : 0,
        // not fy
        insetRight: N = T !== void 0 ? T : g === "x" ? r : 0,
        // not fx
        insetBottom: A = T !== void 0 ? T : g === "y" ? s : 0,
        // not fy
        insetLeft: B = T !== void 0 ? T : g === "x" ? o : 0
        // not fx
      } = w || {};
      if (I == null)
        I = void 0;
      else if (typeof I != "function")
        throw new Error("invalid scale transform; not a function");
      v.percent = !!_, v.label = S === void 0 ? gK(b, v) : S, v.transform = I, g === "x" || g === "fx" ? (v.insetLeft = +B, v.insetRight = +N) : (g === "y" || g === "fy") && (v.insetTop = +M, v.insetBottom = +A), m[g] = v;
    }
  }
  return m;
}
function ix(e) {
  const t = {}, n = { scales: t };
  for (const [i, r] of Object.entries(e)) {
    const { scale: s, type: o, interval: a, label: c } = r;
    t[i] = n8(r), n[i] = s, s.type = o, a != null && (s.interval = a), c != null && (s.label = c);
  }
  return n;
}
function mK(e, t) {
  const { x: n, y: i, fx: r, fy: s } = e, o = r || s ? Ww(t) : t;
  r && rx(r, o), s && sx(s, o);
  const a = r || s ? KD(e, t) : t;
  n && rx(n, a), i && sx(i, a);
}
function gK(e = [], t) {
  let n;
  for (const { label: i } of e)
    if (i !== void 0) {
      if (n === void 0)
        n = i;
      else if (n !== i)
        return;
    }
  if (n !== void 0)
    return !ua(t) && t.percent && (n = `${n} (%)`), { inferred: !0, toString: () => n };
}
function JD(e) {
  return Math.sign(kc(e.domain())) * Math.sign(kc(e.range()));
}
function Ww(e) {
  const {
    marginTop: t,
    marginRight: n,
    marginBottom: i,
    marginLeft: r,
    width: s,
    height: o,
    facet: {
      marginTop: a,
      marginRight: c,
      marginBottom: l,
      marginLeft: u
    }
  } = e;
  return {
    marginTop: Math.max(t, a),
    marginRight: Math.max(n, c),
    marginBottom: Math.max(i, l),
    marginLeft: Math.max(r, u),
    width: s,
    height: o
  };
}
function KD({ fx: e, fy: t }, n) {
  const { marginTop: i, marginRight: r, marginBottom: s, marginLeft: o, width: a, height: c } = Ww(n);
  return {
    marginTop: i,
    marginRight: r,
    marginBottom: s,
    marginLeft: o,
    width: e ? e.scale.bandwidth() + o + r : a,
    height: t ? t.scale.bandwidth() + i + s : c,
    facet: { width: a, height: c }
  };
}
function rx(e, t) {
  if (e.range === void 0) {
    const { insetLeft: n, insetRight: i } = e, { width: r, marginLeft: s = 0, marginRight: o = 0 } = t, a = s + n, c = r - o - i;
    e.range = [a, Math.max(a, c)], ua(e) || (e.range = QD(e)), e.scale.range(e.range);
  }
  ZD(e);
}
function sx(e, t) {
  if (e.range === void 0) {
    const { insetTop: n, insetBottom: i } = e, { height: r, marginTop: s = 0, marginBottom: o = 0 } = t, a = s + n, c = r - o - i;
    e.range = [Math.max(a, c), a], ua(e) ? e.range.reverse() : e.range = QD(e), e.scale.range(e.range);
  }
  ZD(e);
}
function ZD(e) {
  e.round === void 0 && vK(e) && bK(e) <= 30 && e.scale.round(!0);
}
function bK({ scale: e }) {
  const t = e.domain().length, [n, i] = e.range(), r = e.paddingInner ? e.paddingInner() : 1, s = e.paddingOuter ? e.paddingOuter() : e.padding(), o = t - r, a = Math.abs(i - n) / Math.max(1, o + s * 2);
  return (a - Math.floor(a)) * o;
}
function QD(e) {
  const t = e.scale.domain().length + e8(e);
  if (!(t > 2))
    return e.range;
  const [n, i] = e.range;
  return Array.from({ length: t }, (r, s) => n + s / (t - 1) * (i - n));
}
function O1(e, t, n) {
  return t8(e, n === void 0 ? void 0 : [{ hint: n }], { ...t });
}
function t8(e, t = [], n = {}) {
  const i = wK(e, t, n);
  if (n.type === void 0 && n.domain === void 0 && n.range === void 0 && n.interval == null && e !== "fx" && e !== "fy" && ua({ type: i })) {
    const r = t.map(({ value: s }) => s).filter((s) => s !== void 0);
    r.some(gn) ? ts(
      `Warning: some data associated with the ${e} scale are dates. Dates are typically associated with a "utc" or "time" scale rather than a "${Aa(
        i
      )}" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can specify the interval of the ${e} scale (e.g., d3.utcDay), or you can suppress this warning by setting the type of the ${e} scale to "${Aa(
        i
      )}".`
    ) : r.some(KH) ? ts(
      `Warning: some data associated with the ${e} scale are strings that appear to be dates (e.g., YYYY-MM-DD). If these strings represent dates, you should parse them to Date objects. Dates are typically associated with a "utc" or "time" scale rather than a "${Aa(
        i
      )}" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can suppress this warning by setting the type of the ${e} scale to "${Aa(
        i
      )}".`
    ) : r.some(ZH) && ts(
      `Warning: some data associated with the ${e} scale are strings that appear to be numbers. If these strings represent numbers, you should parse or coerce them to numbers. Numbers are typically associated with a "linear" scale rather than a "${Aa(
        i
      )}" scale. If you want to treat this data as ordinal, you can specify the interval of the ${e} scale (e.g., 1 for integers), or you can suppress this warning by setting the type of the ${e} scale to "${Aa(
        i
      )}".`
    );
  }
  switch (n.type = i, i) {
    case "diverging":
    case "diverging-sqrt":
    case "diverging-pow":
    case "diverging-log":
    case "diverging-symlog":
    case "cyclical":
    case "sequential":
    case "linear":
    case "sqrt":
    case "threshold":
    case "quantile":
    case "pow":
    case "log":
    case "symlog":
      n = Sh(t, n, An);
      break;
    case "identity":
      switch (xe.get(e)) {
        case rr:
          n = Sh(t, n, An);
          break;
        case S0:
          n = Sh(t, n, _K);
          break;
      }
      break;
    case "utc":
    case "time":
      n = Sh(t, n, WH);
      break;
  }
  switch (i) {
    case "diverging":
      return tK(e, t, n);
    case "diverging-sqrt":
      return eK(e, t, n);
    case "diverging-pow":
      return YD(e, t, n);
    case "diverging-log":
      return nK(e, t, n);
    case "diverging-symlog":
      return iK(e, t, n);
    case "categorical":
    case "ordinal":
    case zf:
      return fK(e, t, n);
    case "cyclical":
    case "sequential":
    case "linear":
      return PJ(e, t, n);
    case "sqrt":
      return VJ(e, t, n);
    case "threshold":
      return qw(e, t, n);
    case "quantile":
      return YJ(e, t, n);
    case "quantize":
      return WJ(e, t, n);
    case "pow":
      return jD(e, t, n);
    case "log":
      return jJ(e, t, n);
    case "symlog":
      return qJ(e, t, n);
    case "utc":
      return uK(e, t, n);
    case "time":
      return lK(e, t, n);
    case "point":
      return hK(e, t, n);
    case "band":
      return dK(e, t, n);
    case "identity":
      return XJ(e);
    case void 0:
      return;
    default:
      throw new Error(`unknown scale type: ${i}`);
  }
}
function Aa(e) {
  return typeof e == "symbol" ? e.description : e;
}
function ox(e) {
  return typeof e == "string" ? `${e}`.toLowerCase() : e;
}
const ax = { toString: () => "projection" };
function wK(e, t, { type: n, domain: i, range: r, scheme: s, pivot: o, projection: a }) {
  if (n = ox(n), e === "fx" || e === "fy")
    return "band";
  (e === "x" || e === "y") && a != null && (n = ax);
  for (const l of t) {
    const u = ox(l.type);
    if (u !== void 0) {
      if (n === void 0)
        n = u;
      else if (n !== u)
        throw new Error(`scale incompatible with channel: ${n} !== ${u}`);
    }
  }
  if (n === ax)
    return;
  if (n !== void 0)
    return n;
  if (i === void 0 && !t.some(({ value: l }) => l !== void 0))
    return;
  const c = xe.get(e);
  if (c === Rf)
    return "sqrt";
  if (c === kf || c === Cf)
    return "linear";
  if (c === S0)
    return "ordinal";
  if ((i || r || []).length > 2)
    return Vm(c);
  if (i !== void 0) {
    if (Ae(i))
      return Vm(c);
    if (gn(i))
      return "utc";
  } else {
    const l = t.map(({ value: u }) => u).filter((u) => u !== void 0);
    if (l.some(Ae))
      return Vm(c);
    if (l.some(gn))
      return "utc";
  }
  if (c === ps) {
    if (o != null || UJ(s))
      return "diverging";
    if (RJ(s))
      return "categorical";
  }
  return "linear";
}
function Vm(e) {
  switch (e) {
    case rr:
      return "point";
    case ps:
      return zf;
    default:
      return "ordinal";
  }
}
function ua({ type: e }) {
  return e === "ordinal" || e === "point" || e === "band" || e === zf;
}
function e8({ type: e }) {
  return e === "threshold";
}
function vK({ type: e }) {
  return e === "point" || e === "band";
}
function ai(e) {
  if (e === void 0)
    return !0;
  const t = e.domain(), n = e(t[0]);
  for (let i = 1, r = t.length; i < r; ++i)
    if (e(t[i]) - n)
      return !1;
  return !0;
}
function Sh(e, { domain: t, ...n }, i) {
  var r;
  for (const s of e)
    s.value !== void 0 && (t === void 0 && (t = (r = s.value) == null ? void 0 : r.domain), s.value = i(s.value));
  return {
    domain: t === void 0 ? t : i(t),
    ...n
  };
}
function _K(e) {
  return ye(e, Bw);
}
function Xu(e = {}) {
  let t;
  for (const n in e)
    if (xe.has(n) && qo(e[n])) {
      if (t !== void 0)
        throw new Error("ambiguous scale definition; multiple scales found");
      t = n8(O1(n, e[n]));
    }
  if (t === void 0)
    throw new Error("invalid scale definition; no scale found");
  return t;
}
function SK(e) {
  return (t) => {
    if (!xe.has(t = `${t}`))
      throw new Error(`unknown scale: ${t}`);
    return e[t];
  };
}
function n8({ scale: e, type: t, domain: n, range: i, interpolate: r, interval: s, transform: o, percent: a, pivot: c }) {
  if (t === "identity")
    return { type: "identity", apply: (u) => u, invert: (u) => u };
  const l = e.unknown ? e.unknown() : void 0;
  return {
    type: t,
    domain: ju(n),
    // defensive copy
    ...i !== void 0 && { range: ju(i) },
    // defensive copy
    ...o !== void 0 && { transform: o },
    ...a && { percent: a },
    // only exposed if truthy
    ...l !== void 0 && { unknown: l },
    ...s !== void 0 && { interval: s },
    // quantitative
    ...r !== void 0 && { interpolate: r },
    ...e.clamp && { clamp: e.clamp() },
    // diverging (always asymmetric; we never want to apply the symmetric transform twice)
    ...c !== void 0 && { pivot: c, symmetric: !1 },
    // log, diverging-log
    ...e.base && { base: e.base() },
    // pow, diverging-pow
    ...e.exponent && { exponent: e.exponent() },
    // symlog, diverging-symlog
    ...e.constant && { constant: e.constant() },
    // band, point
    ...e.align && { align: e.align(), round: e.round() },
    ...e.padding && (e.paddingInner ? { paddingInner: e.paddingInner(), paddingOuter: e.paddingOuter() } : { padding: e.padding() }),
    ...e.bandwidth && { bandwidth: e.bandwidth(), step: e.step() },
    // utilities
    apply: (u) => e(u),
    ...e.invert && { invert: (u) => e.invert(u) }
  };
}
function Gw(e) {
  let t, n;
  return (...i) => (((n == null ? void 0 : n.length) !== i.length || n.some((r, s) => r !== i[s])) && (n = i, t = e(...i)), t);
}
const xK = Gw((e) => new Intl.NumberFormat(e)), IK = Gw((e, t) => new Intl.DateTimeFormat(e, { timeZone: "UTC", ...t && { month: t } })), AK = Gw((e, t) => new Intl.DateTimeFormat(e, { timeZone: "UTC", ...t && { weekday: t } }));
function MK(e = "en-US") {
  const t = xK(e);
  return (n) => n != null && !isNaN(n) ? t.format(n) : void 0;
}
function $K(e = "en-US", t = "short") {
  const n = IK(e, t);
  return (i) => i != null && !isNaN(i = +new Date(Date.UTC(2e3, +i))) ? n.format(i) : void 0;
}
function TK(e = "en-US", t = "short") {
  const n = AK(e, t);
  return (i) => i != null && !isNaN(i = +new Date(Date.UTC(2001, 0, +i))) ? n.format(i) : void 0;
}
function i8(e) {
  return iD(e, "Invalid Date");
}
function DK(e = "en-US") {
  const t = MK(e);
  return (n) => (n instanceof Date ? i8 : typeof n == "number" ? t : tn)(n);
}
const ra = DK(), He = (typeof window < "u" ? window.devicePixelRatio > 1 : typeof it > "u") ? 0 : 0.5;
let NK = 0;
function F1() {
  return `plot-clip-${++NK}`;
}
function r8(e, {
  title: t,
  href: n,
  ariaLabel: i,
  ariaDescription: r,
  ariaHidden: s,
  target: o,
  fill: a,
  fillOpacity: c,
  stroke: l,
  strokeWidth: u,
  strokeOpacity: f,
  strokeLinejoin: h,
  strokeLinecap: d,
  strokeMiterlimit: p,
  strokeDasharray: y,
  strokeDashoffset: m,
  opacity: g,
  mixBlendMode: b,
  imageFilter: w,
  paintOrder: v,
  pointerEvents: S,
  shapeRendering: _,
  channels: I
}, {
  ariaLabel: T,
  fill: M = "currentColor",
  fillOpacity: N,
  stroke: A = "none",
  strokeOpacity: B,
  strokeWidth: R,
  strokeLinecap: x,
  strokeLinejoin: $,
  strokeMiterlimit: D,
  paintOrder: L
}) {
  M === null && (a = null, c = null), A === null && (l = null, f = null), we(M) ? !we(A) && (!we(a) || I != null && I.fill) && (A = "none") : we(A) && (!we(l) || I != null && I.stroke) && (M = "none");
  const [k, U] = mn(a, M), [C, z] = Be(c, N), [P, G] = mn(l, A), [K, et] = Be(f, B), [Z, Y] = Be(g);
  zc(G) || (u === void 0 && (u = R), d === void 0 && (d = x), h === void 0 && (h = $), p === void 0 && !eJ(h) && (p = D), !zc(U) && v === void 0 && (v = L));
  const [X, j] = Be(u);
  return M !== null && (e.fill = Me(U, "currentColor"), e.fillOpacity = $l(z, 1)), A !== null && (e.stroke = Me(G, "none"), e.strokeWidth = $l(j, 1), e.strokeOpacity = $l(et, 1), e.strokeLinejoin = Me(h, "miter"), e.strokeLinecap = Me(d, "butt"), e.strokeMiterlimit = $l(p, 4), e.strokeDasharray = Me(y, "none"), e.strokeDashoffset = Me(m, "0")), e.target = tn(o), e.ariaLabel = tn(T), e.ariaDescription = tn(r), e.ariaHidden = tn(s), e.opacity = $l(Y, 1), e.mixBlendMode = Me(b, "normal"), e.imageFilter = Me(w, "none"), e.paintOrder = Me(v, "normal"), e.pointerEvents = Me(S, "auto"), e.shapeRendering = Me(_, "auto"), {
    title: { value: t, optional: !0, filter: null },
    href: { value: n, optional: !0, filter: null },
    ariaLabel: { value: i, optional: !0, filter: null },
    fill: { value: k, scale: "auto", optional: !0 },
    fillOpacity: { value: C, scale: "auto", optional: !0 },
    stroke: { value: P, scale: "auto", optional: !0 },
    strokeOpacity: { value: K, scale: "auto", optional: !0 },
    strokeWidth: { value: X, optional: !0 },
    opacity: { value: Z, scale: "auto", optional: !0 }
  };
}
function BK(e, t) {
  t && e.filter((n) => ww(t[n])).append("title").call(FK, t);
}
function OK(e, t) {
  t && e.filter(([n]) => ww(t[n])).append("title").call(EK, t);
}
function FK(e, t) {
  t && e.text((n) => ra(t[n]));
}
function EK(e, t) {
  t && e.text(([n]) => ra(t[n]));
}
function Pe(e, { target: t, tip: n }, {
  ariaLabel: i,
  title: r,
  fill: s,
  fillOpacity: o,
  stroke: a,
  strokeOpacity: c,
  strokeWidth: l,
  opacity: u,
  href: f
}) {
  i && mt(e, "aria-label", (h) => i[h]), s && mt(e, "fill", (h) => s[h]), o && mt(e, "fill-opacity", (h) => o[h]), a && mt(e, "stroke", (h) => a[h]), c && mt(e, "stroke-opacity", (h) => c[h]), l && mt(e, "stroke-width", (h) => l[h]), u && mt(e, "opacity", (h) => u[h]), f && o8(e, (h) => f[h], t), n || BK(e, r);
}
function Vp(e, { target: t, tip: n }, {
  ariaLabel: i,
  title: r,
  fill: s,
  fillOpacity: o,
  stroke: a,
  strokeOpacity: c,
  strokeWidth: l,
  opacity: u,
  href: f
}) {
  i && mt(e, "aria-label", ([h]) => i[h]), s && mt(e, "fill", ([h]) => s[h]), o && mt(e, "fill-opacity", ([h]) => o[h]), a && mt(e, "stroke", ([h]) => a[h]), c && mt(e, "stroke-opacity", ([h]) => c[h]), l && mt(e, "stroke-width", ([h]) => l[h]), u && mt(e, "opacity", ([h]) => u[h]), f && o8(e, ([h]) => f[h], t), n || OK(e, r);
}
function LK({
  ariaLabel: e,
  title: t,
  fill: n,
  fillOpacity: i,
  stroke: r,
  strokeOpacity: s,
  strokeWidth: o,
  opacity: a,
  href: c
}, { tip: l }) {
  return [e, l ? void 0 : t, n, i, r, s, o, a, c].filter((u) => u !== void 0);
}
function Xw(e, t, n) {
  const i = fs(e, (r) => t[r]);
  return n === void 0 && i.size > 1 + e.length >> 1 && ts(
    "Warning: the implicit z channel has high cardinality. This may occur when the fill or stroke channel is associated with quantitative data rather than ordinal or categorical data. You can suppress this warning by setting the z option explicitly; if this data represents a single series, set z to null."
  ), i.values();
}
function* s8(e, t, n, i) {
  const { z: r } = n, { z: s } = i, o = LK(i, n), a = [...t, ...o];
  for (const c of s ? Xw(e, s, r) : [e]) {
    let l, u;
    t:
      for (const f of c) {
        for (const h of a)
          if (!dn(h[f])) {
            u && u.push(-1);
            continue t;
          }
        if (l === void 0) {
          u && (yield u), l = o.map((h) => Lo(h[f])), u = [f];
          continue;
        }
        u.push(f);
        for (let h = 0; h < o.length; ++h)
          if (Lo(o[h][f]) !== l[h]) {
            yield u, l = o.map((p) => Lo(p[f])), u = [f];
            continue t;
          }
      }
    u && (yield u);
  }
}
function RK(e, t, n, i) {
  let r;
  const { clip: s = i.clip } = t;
  switch (s) {
    case "frame": {
      const { width: o, height: a, marginLeft: c, marginRight: l, marginTop: u, marginBottom: f } = n, h = F1();
      r = `url(#${h})`, e = Gt("svg:g", i).call(
        (d) => d.append("svg:clipPath").attr("id", h).append("rect").attr("x", c).attr("y", u).attr("width", o - l - c).attr("height", a - u - f)
      ).each(function() {
        this.appendChild(e.node()), e.node = () => this;
      });
      break;
    }
    case "sphere": {
      const { projection: o } = i;
      if (!o)
        throw new Error('the "sphere" clip option requires a projection');
      const a = F1();
      r = `url(#${a})`, e.append("clipPath").attr("id", a).append("path").attr("d", ao(o)({ type: "Sphere" }));
      break;
    }
  }
  mt(e, "aria-label", t.ariaLabel), mt(e, "aria-description", t.ariaDescription), mt(e, "aria-hidden", t.ariaHidden), mt(e, "clip-path", r);
}
function ve(e, t, n, i) {
  RK(e, t, n, i), mt(e, "fill", t.fill), mt(e, "fill-opacity", t.fillOpacity), mt(e, "stroke", t.stroke), mt(e, "stroke-width", t.strokeWidth), mt(e, "stroke-opacity", t.strokeOpacity), mt(e, "stroke-linejoin", t.strokeLinejoin), mt(e, "stroke-linecap", t.strokeLinecap), mt(e, "stroke-miterlimit", t.strokeMiterlimit), mt(e, "stroke-dasharray", t.strokeDasharray), mt(e, "stroke-dashoffset", t.strokeDashoffset), mt(e, "shape-rendering", t.shapeRendering), mt(e, "filter", t.imageFilter), mt(e, "paint-order", t.paintOrder);
  const { pointerEvents: r = i.pointerSticky === !1 ? "none" : void 0 } = t;
  mt(e, "pointer-events", r);
}
function be(e, t) {
  CK(e, "mix-blend-mode", t.mixBlendMode), mt(e, "opacity", t.opacity);
}
function o8(e, t, n) {
  e.each(function(i) {
    const r = t(i);
    if (r != null) {
      const s = this.ownerDocument.createElementNS(Ko.svg, "a");
      s.setAttribute("fill", "inherit"), s.setAttributeNS(Ko.xlink, "href", r), n != null && s.setAttribute("target", n), this.parentNode.insertBefore(s, this).appendChild(this);
    }
  });
}
function mt(e, t, n) {
  n != null && e.attr(t, n);
}
function CK(e, t, n) {
  n != null && e.style(t, n);
}
function ue(e, t, { x: n, y: i }, r = He, s = He) {
  r += t.dx, s += t.dy, n != null && n.bandwidth && (r += n.bandwidth() / 2), i != null && i.bandwidth && (s += i.bandwidth() / 2), (r || s) && e.attr("transform", `translate(${r},${s})`);
}
function Me(e, t) {
  if ((e = tn(e)) !== t)
    return e;
}
function $l(e, t) {
  if ((e = qt(e)) !== t)
    return e;
}
const kK = /^-?([_a-z]|[\240-\377]|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])([_a-z0-9-]|[\240-\377]|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])*$/i;
function Hw(e) {
  if (e === void 0)
    return "plot-d6a7b5";
  if (e = `${e}`, !kK.test(e))
    throw new Error(`invalid class name: ${e}`);
  return e;
}
function Jw(e, t) {
  if (typeof t == "string")
    e.property("style", t);
  else if (t != null)
    for (const n of e)
      Object.assign(n.style, t);
}
function _r({ frameAnchor: e }, { width: t, height: n, marginTop: i, marginRight: r, marginBottom: s, marginLeft: o }) {
  return [
    /left$/.test(e) ? o : /right$/.test(e) ? t - r : (o + t - r) / 2,
    /^top/.test(e) ? i : /^bottom/.test(e) ? n - s : (i + n - s) / 2
  ];
}
function UK(e, t, n = {}) {
  let i = 0.5 - He, r = 0.5 + He, s = 0.5 + He, o = 0.5 - He;
  for (const { marginTop: y, marginRight: m, marginBottom: g, marginLeft: b } of t)
    y > i && (i = y), m > r && (r = m), g > s && (s = g), b > o && (o = b);
  let {
    margin: a,
    marginTop: c = a !== void 0 ? a : i,
    marginRight: l = a !== void 0 ? a : r,
    marginBottom: u = a !== void 0 ? a : s,
    marginLeft: f = a !== void 0 ? a : o
  } = n;
  c = +c, l = +l, u = +u, f = +f;
  let {
    width: h = 640,
    height: d = zK(e, n, {
      width: h,
      marginTopDefault: i,
      marginRightDefault: r,
      marginBottomDefault: s,
      marginLeftDefault: o
    }) + Math.max(0, c - i + u - s)
  } = n;
  h = +h, d = +d;
  const p = {
    width: h,
    height: d,
    marginTop: c,
    marginRight: l,
    marginBottom: u,
    marginLeft: f
  };
  if (e.fx || e.fy) {
    let {
      margin: y,
      marginTop: m = y !== void 0 ? y : c,
      marginRight: g = y !== void 0 ? y : l,
      marginBottom: b = y !== void 0 ? y : u,
      marginLeft: w = y !== void 0 ? y : f
    } = n.facet ?? {};
    m = +m, g = +g, b = +b, w = +w, p.facet = {
      marginTop: m,
      marginRight: g,
      marginBottom: b,
      marginLeft: w
    };
  }
  return p;
}
function zK({ x: e, y: t, fy: n, fx: i }, { projection: r, aspectRatio: s }, { width: o, marginTopDefault: a, marginRightDefault: c, marginBottomDefault: l, marginLeftDefault: u }) {
  const f = n ? n.scale.domain().length : 1, h = EJ(r);
  if (h) {
    const p = i ? i.scale.domain().length : 1, y = (1.1 * f - 0.1) / (1.1 * p - 0.1) * h, m = Math.max(0.1, Math.min(10, y));
    return Math.round((o - u - c) * m + a + l);
  }
  const d = t ? ua(t) ? t.scale.domain().length : Math.max(7, 17 / f) : 1;
  if (s != null) {
    if (s = +s, !(isFinite(s) && s > 0))
      throw new Error(`invalid aspectRatio: ${s}`);
    const p = cx("y", t) / (cx("x", e) * s), y = i ? i.scale.bandwidth() : 1, m = n ? n.scale.bandwidth() : 1, g = y * (o - u - c) - e.insetLeft - e.insetRight;
    return (p * g + t.insetTop + t.insetBottom) / m + a + l;
  }
  return !!(t || n) * Math.max(1, Math.min(60, d * f)) * 20 + !!i * 30 + 60;
}
function cx(e, t) {
  if (!t)
    throw new Error(`aspectRatio requires ${e} scale`);
  const { type: n, domain: i } = t;
  let r;
  switch (n) {
    case "linear":
    case "utc":
    case "time":
      r = Number;
      break;
    case "pow": {
      const a = t.scale.exponent();
      r = (c) => Math.pow(c, a);
      break;
    }
    case "log":
      r = Math.log;
      break;
    case "point":
    case "band":
      return i.length;
    default:
      throw new Error(`unsupported ${e} scale for aspectRatio: ${n}`);
  }
  const [s, o] = ke(i);
  return Math.abs(r(o) - r(s));
}
function PK(e, t) {
  const { fx: n, fy: i } = B1(e, t), r = n == null ? void 0 : n.scale.domain(), s = i == null ? void 0 : i.scale.domain();
  return r && s ? Bz(r, s).map(([o, a], c) => ({ x: o, y: a, i: c })) : r ? r.map((o, a) => ({ x: o, i: a })) : s ? s.map((o, a) => ({ y: o, i: a })) : void 0;
}
function VK(e, { x: t, y: n }) {
  return t && (t = E1(t)), n && (n = E1(n)), e.filter(
    t && n ? (i) => t.has(i.x) && n.has(i.y) : t ? (i) => t.has(i.x) : (i) => n.has(i.y)
  ).sort(
    t && n ? (i, r) => t.get(i.x) - t.get(r.x) || n.get(i.y) - n.get(r.y) : t ? (i, r) => t.get(i.x) - t.get(r.x) : (i, r) => n.get(i.y) - n.get(r.y)
  );
}
function Kw(e, { fx: t, fy: n }) {
  const i = hs(e), r = t == null ? void 0 : t.value, s = n == null ? void 0 : n.value;
  return t && n ? uc(
    i,
    (o) => (o.fx = r[o[0]], o.fy = s[o[0]], o),
    (o) => r[o],
    (o) => s[o]
  ) : t ? uc(
    i,
    (o) => (o.fx = r[o[0]], o),
    (o) => r[o]
  ) : uc(
    i,
    (o) => (o.fy = s[o[0]], o),
    (o) => s[o]
  );
}
function jK(e, t, { marginTop: n, marginLeft: i }) {
  return e && t ? ({ x: r, y: s }) => `translate(${e(r) - i},${t(s) - n})` : e ? ({ x: r }) => `translate(${e(r) - i},0)` : ({ y: r }) => `translate(0,${t(r) - n})`;
}
function qK(e) {
  const t = [], n = new Uint32Array(fr(e, (i) => i.length));
  for (const i of e) {
    let r = 0;
    for (const s of e)
      i !== s && (n.set(s, r), r += s.length);
    t.push(n.slice(0, r));
  }
  return t;
}
const YK = /* @__PURE__ */ new Map([
  ["top", jm],
  ["right", Wm],
  ["bottom", qm],
  ["left", Ym],
  ["top-left", xh(jm, Ym)],
  ["top-right", xh(jm, Wm)],
  ["bottom-left", xh(qm, Ym)],
  ["bottom-right", xh(qm, Wm)],
  ["top-empty", XK],
  ["right-empty", KK],
  ["bottom-empty", HK],
  ["left-empty", JK],
  ["empty", ZK]
]);
function WK(e) {
  if (e == null)
    return null;
  const t = YK.get(`${e}`.toLowerCase());
  if (t)
    return t;
  throw new Error(`invalid facet anchor: ${e}`);
}
const lx = /* @__PURE__ */ new WeakMap();
function E1(e) {
  let t = lx.get(e);
  return t || lx.set(e, t = new Jo(ye(e, (n, i) => [n, i]))), t;
}
function uo(e, t) {
  return E1(e).get(t);
}
function GK(e, t, n) {
  return t = Lo(t), n = Lo(n), e.find((i) => Object.is(Lo(i.x), t) && Object.is(Lo(i.y), n));
}
function N0(e, t, n) {
  var i;
  return (i = GK(e, t, n)) == null ? void 0 : i.empty;
}
function jm(e, { y: t }, { y: n }) {
  return t ? uo(t, n) === 0 : !0;
}
function qm(e, { y: t }, { y: n }) {
  return t ? uo(t, n) === t.length - 1 : !0;
}
function Ym(e, { x: t }, { x: n }) {
  return t ? uo(t, n) === 0 : !0;
}
function Wm(e, { x: t }, { x: n }) {
  return t ? uo(t, n) === t.length - 1 : !0;
}
function XK(e, { y: t }, { x: n, y: i, empty: r }) {
  if (r)
    return !1;
  if (!t)
    return;
  const s = uo(t, i);
  if (s > 0)
    return N0(e, n, t[s - 1]);
}
function HK(e, { y: t }, { x: n, y: i, empty: r }) {
  if (r)
    return !1;
  if (!t)
    return;
  const s = uo(t, i);
  if (s < t.length - 1)
    return N0(e, n, t[s + 1]);
}
function JK(e, { x: t }, { x: n, y: i, empty: r }) {
  if (r)
    return !1;
  if (!t)
    return;
  const s = uo(t, n);
  if (s > 0)
    return N0(e, t[s - 1], i);
}
function KK(e, { x: t }, { x: n, y: i, empty: r }) {
  if (r)
    return !1;
  if (!t)
    return;
  const s = uo(t, n);
  if (s < t.length - 1)
    return N0(e, t[s + 1], i);
}
function ZK(e, t, { empty: n }) {
  return n;
}
function xh(e, t) {
  return function() {
    return e.apply(null, arguments) && t.apply(null, arguments);
  };
}
function Gm(e, { channels: { fx: t, fy: n }, groups: i }) {
  return t && n ? e.map(({ x: r, y: s }) => {
    var o;
    return ((o = i.get(r)) == null ? void 0 : o.get(s)) ?? [];
  }) : t ? e.map(({ x: r }) => i.get(r) ?? []) : e.map(({ y: r }) => i.get(r) ?? []);
}
let fe = class {
  constructor(t, n = {}, i = {}, r) {
    const {
      facet: s = "auto",
      facetAnchor: o,
      fx: a,
      fy: c,
      sort: l,
      dx: u = 0,
      dy: f = 0,
      margin: h = 0,
      marginTop: d = h,
      marginRight: p = h,
      marginBottom: y = h,
      marginLeft: m = h,
      clip: g = r == null ? void 0 : r.clip,
      channels: b,
      tip: w,
      render: v
    } = i;
    if (this.data = t, this.sort = Hs(l) ? l : null, this.initializer = Bn(i).initializer, this.transform = this.initializer ? i.transform : vr(i).transform, s === null || s === !1 ? this.facet = null : (this.facet = Yn(s === !0 ? "include" : s, "facet", ["auto", "include", "exclude", "super"]), this.fx = t === pu && typeof a == "string" ? [a] : a, this.fy = t === pu && typeof c == "string" ? [c] : c), this.facetAnchor = WK(o), n = Tw(n), b !== void 0 && (n = { ...QK(b), ...n }), r !== void 0 && (n = { ...r8(this, i, r), ...n }), this.channels = Object.fromEntries(
      Object.entries(n).map(([S, _]) => {
        if (Hi(_.value)) {
          const { value: I, label: T = _.label, scale: M = _.scale } = _.value;
          _ = { ..._, label: T, scale: M, value: I };
        }
        if (t === pu && typeof _.value == "string") {
          const { value: I } = _;
          _ = { ..._, value: [I] };
        }
        return [S, _];
      }).filter(([S, { value: _, optional: I }]) => {
        if (_ != null)
          return !0;
        if (I)
          return !1;
        throw new Error(`missing channel value: ${S}`);
      })
    ), this.dx = +u, this.dy = +f, this.marginTop = +d, this.marginRight = +p, this.marginBottom = +y, this.marginLeft = +m, this.clip = bD(g), this.tip = tZ(w), this.facet === "super") {
      if (a || c)
        throw new Error("super-faceting cannot use fx or fy");
      for (const S in this.channels) {
        const { scale: _ } = n[S];
        if (!(_ !== "x" && _ !== "y"))
          throw new Error("super-faceting cannot use x or y");
      }
    }
    v != null && (this.render = jp(v, this.render));
  }
  initialize(t, n, i) {
    let r = Nn(this.data);
    t === void 0 && r != null && (t = [hs(r)]);
    const s = t;
    this.transform != null && ({ facets: t, data: r } = this.transform(r, t, i), r = Nn(r)), t !== void 0 && (t.original = s);
    const o = BD(this.channels, r);
    return this.sort != null && AJ(r, t, o, n, this.sort), { data: r, facets: t, channels: o };
  }
  filter(t, n, i) {
    for (const r in n) {
      const { filter: s = dn } = n[r];
      if (s !== null) {
        const o = i[r];
        t = t.filter((a) => s(o[a]));
      }
    }
    return t;
  }
  // If there is a projection, and there are paired x and y channels associated
  // with the x and y scale respectively (and not already in screen coordinates
  // as with an initializer), then apply the projection, replacing the x and y
  // values. Note that the x and y scales themselves dont exist if there is a
  // projection, but whether the channels are associated with scales still
  // determines whether the projection should apply; think of the projection as
  // a combination xy-scale.
  project(t, n, i) {
    for (const r in t)
      if (t[r].scale === "x" && /^x|x$/.test(r)) {
        const s = r.replace(/^x|x$/, "y");
        s in t && t[s].scale === "y" && kD(r, s, n, i.projection);
      }
  }
  scale(t, n, i) {
    const r = Vw(t, n);
    return i.projection && this.project(t, r, i), r;
  }
};
function fi(...e) {
  return e.plot = fe.prototype.plot, e;
}
function jp(e, t) {
  if (e == null)
    return t === null ? void 0 : t;
  if (t == null)
    return e === null ? void 0 : e;
  if (typeof e != "function")
    throw new TypeError(`invalid render transform: ${e}`);
  if (typeof t != "function")
    throw new TypeError(`invalid render transform: ${t}`);
  return function(n, i, r, s, o, a) {
    return e.call(this, n, i, r, s, o, (c, l, u, f, h) => t.call(this, c, l, u, f, h, a));
  };
}
function QK(e) {
  return Object.fromEntries(
    Object.entries(Tw(e)).map(([t, n]) => (n = typeof n == "string" ? { value: n, label: t } : al(n), n.filter === void 0 && n.scale == null && (n = { ...n, filter: null }), [t, n]))
  );
}
function tZ(e) {
  return e === !0 ? "xy" : e === !1 || e == null ? null : typeof e == "string" ? Yn(e, "tip", ["x", "y", "xy"]) : e;
}
function fa(e, t) {
  return (e == null ? void 0 : e.tip) === !0 ? { ...e, tip: t } : di(e == null ? void 0 : e.tip) && e.tip.pointer === void 0 ? { ...e, tip: { ...e.tip, pointer: t } } : e;
}
const ux = /* @__PURE__ */ new WeakMap();
function Zw(e, t, { x: n, y: i, px: r, py: s, maxRadius: o = 40, channels: a, render: c, ...l } = {}) {
  return o = +o, r != null && (n ?? (n = null), a = { ...a, px: { value: r, scale: "x" } }), s != null && (i ?? (i = null), a = { ...a, py: { value: s, scale: "y" } }), {
    x: n,
    y: i,
    channels: a,
    ...l,
    // Unlike other composed transforms, the render transform must be the
    // outermost render function because it will re-render dynamically in
    // response to pointer events.
    render: jp(function(u, f, h, d, p, y) {
      p = { ...p, pointerSticky: !1 };
      const m = p.ownerSVGElement, { data: g } = p.getMarkState(this);
      let b = ux.get(m);
      b || ux.set(m, b = { sticky: !1, roots: [], renders: [] });
      let w = b.renders.push(G) - 1;
      const { x: v, y: S, fx: _, fy: I } = f;
      let T = _ ? _(u.fx) - d.marginLeft : 0, M = I ? I(u.fy) - d.marginTop : 0;
      v != null && v.bandwidth && (T += v.bandwidth() / 2), S != null && S.bandwidth && (M += S.bandwidth() / 2);
      const N = u.fi != null;
      let A;
      if (N) {
        let Y = b.facetStates;
        Y || (b.facetStates = Y = /* @__PURE__ */ new Map()), A = Y.get(this), A || Y.set(this, A = /* @__PURE__ */ new Map());
      }
      const [B, R] = _r(this, d), { px: x, py: $ } = h, D = x ? (Y) => x[Y] : a8(h, B), L = $ ? (Y) => $[Y] : c8(h, R);
      let k, U, C, z;
      function P(Y, X) {
        if (N)
          if (z && (z = cancelAnimationFrame(z)), Y == null)
            A.delete(u.fi);
          else {
            A.set(u.fi, X), z = requestAnimationFrame(() => {
              z = null;
              for (const [j, J] of A)
                if (J < X || J === X && j < u.fi) {
                  Y = null;
                  break;
                }
              G(Y);
            });
            return;
          }
        G(Y);
      }
      function G(Y) {
        if (k === Y && C === b.sticky)
          return;
        k = Y, C = p.pointerSticky = b.sticky;
        const X = k == null ? [] : [k];
        N && (X.fx = u.fx, X.fy = u.fy, X.fi = u.fi);
        const j = y(X, f, h, d, p);
        if (U) {
          if (N) {
            const J = U.parentNode, tt = U.getAttribute("transform"), V = j.getAttribute("transform");
            tt ? j.setAttribute("transform", tt) : j.removeAttribute("transform"), V ? J.setAttribute("transform", V) : J.removeAttribute("transform"), j.removeAttribute("aria-label"), j.removeAttribute("aria-description"), j.removeAttribute("aria-hidden");
          }
          U.replaceWith(j);
        }
        return b.roots[w] = U = j, k == null && (A == null ? void 0 : A.size) > 1 || p.dispatchValue(k == null ? null : g[k]), j;
      }
      function K(Y) {
        if (b.sticky || Y.pointerType === "mouse" && Y.buttons === 1)
          return;
        let [X, j] = mi(Y);
        X -= T, j -= M;
        const J = X < d.marginLeft || X > d.width - d.marginRight ? 1 : e, tt = j < d.marginTop || j > d.height - d.marginBottom ? 1 : t;
        let V = null, Ft = o * o;
        for (const st of u) {
          const Vt = J * (D(st) - X), jt = tt * (L(st) - j), Q = Vt * Vt + jt * jt;
          Q <= Ft && (V = st, Ft = Q);
        }
        if (V != null && (e !== 1 || t !== 1)) {
          const st = D(V) - X, Vt = L(V) - j;
          Ft = st * st + Vt * Vt;
        }
        P(V, Ft);
      }
      function et(Y) {
        Y.pointerType === "mouse" && k != null && (b.sticky && b.roots.some((X) => X == null ? void 0 : X.contains(Y.target)) || (b.sticky ? (b.sticky = !1, b.renders.forEach((X) => X(null))) : (b.sticky = !0, G(k)), Y.stopImmediatePropagation()));
      }
      function Z(Y) {
        Y.pointerType === "mouse" && (b.sticky || P(null));
      }
      return m.addEventListener("pointerenter", K), m.addEventListener("pointermove", K), m.addEventListener("pointerdown", et), m.addEventListener("pointerleave", Z), G(null);
    }, c)
  };
}
function Qw(e) {
  return Zw(1, 1, e);
}
function tv(e) {
  return Zw(1, 0.01, e);
}
function qp(e) {
  return Zw(0.01, 1, e);
}
function a8({ x1: e, x2: t, x: n = e }, i) {
  return e && t ? (r) => (e[r] + t[r]) / 2 : n ? (r) => n[r] : () => i;
}
function c8({ y1: e, y2: t, y: n = e }, i) {
  return e && t ? (r) => (e[r] + t[r]) / 2 : n ? (r) => n[r] : () => i;
}
function l8(e) {
  return ua(e) && e.interval === void 0 ? void 0 : "tabular-nums";
}
function eZ(e, t) {
  let {
    label: n = e.label,
    tickSize: i = 6,
    width: r = 240,
    height: s = 44 + i,
    marginTop: o = 18,
    marginRight: a = 0,
    marginBottom: c = 16 + i,
    marginLeft: l = 0,
    style: u,
    ticks: f = (r - l - a) / 64,
    tickFormat: h,
    fontVariant: d = l8(e),
    round: p = !0,
    opacity: y,
    className: m
  } = t;
  const g = M0(t);
  m = Hw(m), y = Be(y)[1], h === null && (h = () => null);
  const b = Gt("svg", g).attr("class", `${m}-ramp`).attr("font-family", "system-ui, sans-serif").attr("font-size", 10).attr("width", r).attr("height", s).attr("viewBox", `0 0 ${r} ${s}`).call(
    (B) => (
      // Warning: if you edit this, change defaultClassName.
      B.append("style").text(
        `:where(.${m}-ramp) {
  display: block;
  height: auto;
  height: intrinsic;
  max-width: 100%;
  overflow: visible;
}
:where(.${m}-ramp text) {
  white-space: pre;
}`
      )
    )
  ).call(Jw, u);
  let w = (B) => B.selectAll(".tick line").attr("y1", o + c - s), v;
  const S = p ? (B, R) => B.rangeRound(R) : (B, R) => B.range(R), { type: _, domain: I, range: T, interpolate: M, scale: N, pivot: A } = e;
  if (M) {
    const B = T === void 0 ? M : Qy(M.length === 1 ? Yw(M) : M, T);
    v = S(
      N.copy(),
      Ti(
        Qe(l, r - a),
        Math.min(I.length + (A !== void 0), T === void 0 ? 1 / 0 : T.length)
      )
    );
    const R = 256, x = g.document.createElement("canvas");
    x.width = R, x.height = 1;
    const $ = x.getContext("2d");
    for (let D = 0, L = R - 1; D < R; ++D)
      $.fillStyle = B(D / L), $.fillRect(D, 0, 1, 1);
    b.append("image").attr("opacity", y).attr("x", l).attr("y", o).attr("width", r - l - a).attr("height", s - o - c).attr("preserveAspectRatio", "none").attr("xlink:href", x.toDataURL());
  } else if (_ === "threshold") {
    const B = I, R = h === void 0 ? (x) => x : typeof h == "string" ? rl(h) : h;
    v = S(a0().domain([-1, T.length - 1]), [l, r - a]), b.append("g").attr("fill-opacity", y).selectAll().data(T).enter().append("rect").attr("x", (x, $) => v($ - 1)).attr("y", o).attr("width", (x, $) => v($) - v($ - 1)).attr("height", s - o - c).attr("fill", (x) => x), f = ye(B, (x, $) => $), h = (x) => R(B[x], x);
  } else
    v = S(s0().domain(I), [l, r - a]), b.append("g").attr("fill-opacity", y).selectAll().data(I).enter().append("rect").attr("x", v).attr("y", o).attr("width", Math.max(0, v.bandwidth() - 1)).attr("height", s - o - c).attr("fill", N), w = () => {
    };
  return b.append("g").attr("transform", `translate(0,${s - c})`).call(
    Qz(v).ticks(Array.isArray(f) ? null : f, typeof h == "string" ? h : void 0).tickFormat(typeof h == "function" ? h : void 0).tickSize(i).tickValues(Array.isArray(f) ? f : null)
  ).attr("font-size", null).attr("font-family", null).attr("font-variant", Me(d, "normal")).call(w).call((B) => B.select(".domain").remove()), n !== void 0 && b.append("text").attr("x", l).attr("y", o - 6).attr("fill", "currentColor").attr("font-weight", "bold").text(n), b.node();
}
const Yp = Math.PI / 180;
function cl(e, { marker: t, markerStart: n = t, markerMid: i = t, markerEnd: r = t } = {}) {
  e.markerStart = Xm(n), e.markerMid = Xm(i), e.markerEnd = Xm(r);
}
function Xm(e) {
  if (e == null || e === !1)
    return null;
  if (e === !0)
    return hx;
  if (typeof e == "function")
    return e;
  switch (`${e}`.toLowerCase()) {
    case "none":
      return null;
    case "arrow":
      return fx("auto");
    case "arrow-reverse":
      return fx("auto-start-reverse");
    case "dot":
      return nZ;
    case "circle":
    case "circle-fill":
      return hx;
    case "circle-stroke":
      return iZ;
    case "tick":
      return Hm("auto");
    case "tick-x":
      return Hm(90);
    case "tick-y":
      return Hm(0);
  }
  throw new Error(`invalid marker: ${e}`);
}
function fx(e) {
  return (t, n) => Gt("svg:marker", n).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("orient", e).attr("fill", "none").attr("stroke", t).attr("stroke-width", 1.5).attr("stroke-linecap", "round").attr("stroke-linejoin", "round").call((i) => i.append("path").attr("d", "M-1.5,-3l3,3l-3,3")).node();
}
function nZ(e, t) {
  return Gt("svg:marker", t).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", e).attr("stroke", "none").call((n) => n.append("circle").attr("r", 2.5)).node();
}
function hx(e, t) {
  return Gt("svg:marker", t).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", e).attr("stroke", "var(--plot-background)").attr("stroke-width", 1.5).call((n) => n.append("circle").attr("r", 3)).node();
}
function iZ(e, t) {
  return Gt("svg:marker", t).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", "var(--plot-background)").attr("stroke", e).attr("stroke-width", 1.5).call((n) => n.append("circle").attr("r", 3)).node();
}
function Hm(e) {
  return (t, n) => Gt("svg:marker", n).attr("viewBox", "-3 -3 6 6").attr("markerWidth", 6).attr("markerHeight", 6).attr("orient", e).attr("stroke", t).call((i) => i.append("path").attr("d", "M0,-3v6")).node();
}
let rZ = 0;
function Pf(e, t, { stroke: n }, i) {
  return u8(e, t, n && ((r) => n[r]), i);
}
function sZ(e, t, { stroke: n }, i) {
  return u8(e, t, n && (([r]) => n[r]), i);
}
function u8(e, { markerStart: t, markerMid: n, markerEnd: i, stroke: r }, s = () => r, o) {
  const a = /* @__PURE__ */ new Map();
  function c(l) {
    return function(u) {
      const f = s(u);
      let h = a.get(l);
      h || a.set(l, h = /* @__PURE__ */ new Map());
      let d = h.get(f);
      if (!d) {
        const p = this.parentNode.insertBefore(l(f, o), this), y = `plot-marker-${++rZ}`;
        p.setAttribute("id", y), h.set(f, d = `url(#${y})`);
      }
      return d;
    };
  }
  t && e.attr("marker-start", c(t)), n && e.attr("marker-mid", c(n)), i && e.attr("marker-end", c(i));
}
function Vf({ inset: e, insetLeft: t, insetRight: n, ...i } = {}) {
  return [t, n] = f8(e, t, n), { inset: e, insetLeft: t, insetRight: n, ...i };
}
function jf({ inset: e, insetTop: t, insetBottom: n, ...i } = {}) {
  return [t, n] = f8(e, t, n), { inset: e, insetTop: t, insetBottom: n, ...i };
}
function f8(e, t, n) {
  return e === void 0 && t === void 0 && n === void 0 ? He ? [1, 0] : [0.5, 0.5] : [t, n];
}
function h8(e, { interval: t }) {
  return e = { ...al(e) }, e.interval = _0(e.interval === void 0 ? t : e.interval), e;
}
function B0(e, t, n, i) {
  const { [e]: r, [`${e}1`]: s, [`${e}2`]: o } = n, { value: a, interval: c } = h8(r, n);
  if (a == null || c == null && !i)
    return n;
  const l = wr(r);
  if (c == null) {
    let d;
    const p = { transform: (y) => d || (d = Pt(y, a)), label: l };
    return {
      ...n,
      [e]: void 0,
      [`${e}1`]: s === void 0 ? p : s,
      [`${e}2`]: o === void 0 && !(s === o && i) ? p : o
    };
  }
  let u, f;
  function h(d) {
    return f !== void 0 && d === u ? f : f = ye(Pt(u = d, a), (p) => c.floor(p));
  }
  return t({
    ...n,
    [e]: void 0,
    [`${e}1`]: s === void 0 ? { transform: h, label: l } : s,
    [`${e}2`]: o === void 0 ? { transform: (d) => h(d).map((p) => c.offset(p)), label: l } : o
  });
}
function d8(e, t, n) {
  const { [e]: i } = n, { value: r, interval: s } = h8(i, n);
  return r == null || s == null ? n : t({
    ...n,
    [e]: {
      label: wr(i),
      transform: (o) => {
        const a = ye(Pt(o, r), (l) => s.floor(l)), c = a.map((l) => s.offset(l));
        return a.map(
          gn(a) ? (l, u) => l == null || isNaN(l = +l) || (u = c[u], u == null) || isNaN(u = +u) ? void 0 : new Date((l + u) / 2) : (l, u) => l == null || (u = c[u], u == null) ? NaN : (+l + +u) / 2
        );
      }
    }
  });
}
function p8(e = {}) {
  return B0("x", Vf, e, !0);
}
function y8(e = {}) {
  return B0("y", jf, e, !0);
}
function m8(e = {}) {
  return B0("x", Vf, e);
}
function g8(e = {}) {
  return B0("y", jf, e);
}
function b8(e = {}) {
  return d8("x", Vf, e);
}
function w8(e = {}) {
  return d8("y", jf, e);
}
const v8 = {
  ariaLabel: "rule",
  fill: null,
  stroke: "currentColor"
};
class _8 extends fe {
  constructor(t, n = {}) {
    const { x: i, y1: r, y2: s, inset: o = 0, insetTop: a = o, insetBottom: c = o } = n;
    super(
      t,
      {
        x: { value: i, scale: "x", optional: !0 },
        y1: { value: r, scale: "y", optional: !0 },
        y2: { value: s, scale: "y", optional: !0 }
      },
      fa(n, "x"),
      v8
    ), this.insetTop = qt(a), this.insetBottom = qt(c), cl(this, n);
  }
  render(t, n, i, r, s) {
    const { x: o, y: a } = n, { x: c, y1: l, y2: u } = i, { width: f, height: h, marginTop: d, marginRight: p, marginLeft: y, marginBottom: m } = r, { insetTop: g, insetBottom: b } = this;
    return Gt("svg:g", s).call(ve, this, r, s).call(ue, this, { x: c && o }, He, 0).call(
      (w) => w.selectAll().data(t).enter().append("line").call(be, this).attr("x1", c ? (v) => c[v] : (y + f - p) / 2).attr("x2", c ? (v) => c[v] : (y + f - p) / 2).attr("y1", l && !ai(a) ? (v) => l[v] + g : d + g).attr(
        "y2",
        u && !ai(a) ? a.bandwidth ? (v) => u[v] + a.bandwidth() - b : (v) => u[v] - b : h - m - b
      ).call(Pe, this, i).call(Pf, this, i, s)
    ).node();
  }
}
class S8 extends fe {
  constructor(t, n = {}) {
    const { x1: i, x2: r, y: s, inset: o = 0, insetRight: a = o, insetLeft: c = o } = n;
    super(
      t,
      {
        y: { value: s, scale: "y", optional: !0 },
        x1: { value: i, scale: "x", optional: !0 },
        x2: { value: r, scale: "x", optional: !0 }
      },
      fa(n, "y"),
      v8
    ), this.insetRight = qt(a), this.insetLeft = qt(c), cl(this, n);
  }
  render(t, n, i, r, s) {
    const { x: o, y: a } = n, { y: c, x1: l, x2: u } = i, { width: f, height: h, marginTop: d, marginRight: p, marginLeft: y, marginBottom: m } = r, { insetLeft: g, insetRight: b } = this;
    return Gt("svg:g", s).call(ve, this, r, s).call(ue, this, { y: c && a }, 0, He).call(
      (w) => w.selectAll().data(t).enter().append("line").call(be, this).attr("x1", l && !ai(o) ? (v) => l[v] + g : y + g).attr(
        "x2",
        u && !ai(o) ? o.bandwidth ? (v) => u[v] + o.bandwidth() - b : (v) => u[v] - b : f - p - b
      ).attr("y1", c ? (v) => c[v] : (d + h - m) / 2).attr("y2", c ? (v) => c[v] : (d + h - m) / 2).call(Pe, this, i).call(Pf, this, i, s)
    ).node();
  }
}
function Js(e, t) {
  let { x: n = Tt, y: i, y1: r, y2: s, ...o } = g8(t);
  return [r, s] = x8(i, r, s), new _8(e, { ...o, x: n, y1: r, y2: s });
}
function Ks(e, t) {
  let { y: n = Tt, x: i, x1: r, x2: s, ...o } = m8(t);
  return [r, s] = x8(i, r, s), new S8(e, { ...o, y: n, x1: r, x2: s });
}
function x8(e, t, n) {
  if (e == null) {
    if (t === void 0) {
      if (n !== void 0)
        return [0, n];
    } else if (n === void 0)
      return [0, t];
  } else {
    if (t === void 0)
      return n === void 0 ? [0, e] : [e, n];
    if (n === void 0)
      return [e, t];
  }
  return [t, n];
}
function O0(e, ...t) {
  let n = t.length;
  for (let i = 0, r = !0; i < n; ++i)
    typeof t[i] != "function" && (r && (e = e.slice(), r = !1), e.splice(i, 2, e[i] + t[i] + e[i + 1]), t.splice(i, 1), --i, --n);
  return (i) => {
    let r = e[0];
    for (let s = 0; s < n; ++s)
      r += t[s](i) + e[s + 1];
    return r;
  };
}
const oZ = {
  ariaLabel: "text",
  strokeLinejoin: "round",
  strokeWidth: 3,
  paintOrder: "stroke"
}, I8 = "";
class F0 extends fe {
  constructor(t, n = {}) {
    const {
      x: i,
      y: r,
      text: s = ds(t) && gD(t) ? Tt : vn,
      frameAnchor: o,
      textAnchor: a = /right$/i.test(o) ? "end" : /left$/i.test(o) ? "start" : "middle",
      lineAnchor: c = /^top/i.test(o) ? "top" : /^bottom/i.test(o) ? "bottom" : "middle",
      lineHeight: l = 1,
      lineWidth: u = 1 / 0,
      textOverflow: f,
      monospace: h,
      fontFamily: d = h ? "ui-monospace, monospace" : void 0,
      fontSize: p,
      fontStyle: y,
      fontVariant: m,
      fontWeight: g,
      rotate: b
    } = n, [w, v] = Be(b, 0), [S, _] = uZ(p);
    if (super(
      t,
      {
        x: { value: i, scale: "x", optional: !0 },
        y: { value: r, scale: "y", optional: !0 },
        fontSize: { value: S, optional: !0 },
        rotate: { value: HH(w), optional: !0 },
        text: { value: s, filter: ww, optional: !0 }
      },
      n,
      oZ
    ), this.rotate = v, this.textAnchor = Me(a, "middle"), this.lineAnchor = Yn(c, "lineAnchor", ["top", "middle", "bottom"]), this.lineHeight = +l, this.lineWidth = +u, this.textOverflow = A8(f), this.monospace = !!h, this.fontFamily = tn(d), this.fontSize = _, this.fontStyle = tn(y), this.fontVariant = tn(m), this.fontWeight = tn(g), this.frameAnchor = Lf(o), !(this.lineWidth >= 0))
      throw new Error(`invalid lineWidth: ${u}`);
    this.splitLines = D8(this), this.clipLine = N8(this);
  }
  render(t, n, i, r, s) {
    const { x: o, y: a } = n, { x: c, y: l, rotate: u, text: f, title: h, fontSize: d } = i, { rotate: p } = this, [y, m] = _r(this, r);
    return Gt("svg:g", s).call(ve, this, r, s).call(T8, this, f, r).call(ue, this, { x: c && o, y: l && a }).call(
      (g) => g.selectAll().data(t).enter().append("text").call(be, this).call(aZ, this, f, h).attr(
        "transform",
        O0`translate(${c ? (b) => c[b] : y},${l ? (b) => l[b] : m})${u ? (b) => ` rotate(${u[b]})` : p ? ` rotate(${p})` : ""}`
      ).call(mt, "font-size", d && ((b) => d[b])).call(Pe, this, i)
    ).node();
  }
}
function A8(e) {
  return e == null ? null : Yn(e, "textOverflow", [
    "clip",
    // shorthand for clip-end
    "ellipsis",
    //  ellipsis-end
    "clip-start",
    "clip-end",
    "ellipsis-start",
    "ellipsis-middle",
    "ellipsis-end"
  ]).replace(/^(clip|ellipsis)$/, "$1-end");
}
function aZ(e, t, n, i) {
  if (!n)
    return;
  const { lineAnchor: r, lineHeight: s, textOverflow: o, splitLines: a, clipLine: c } = t;
  e.each(function(l) {
    const u = a(ra(n[l]) ?? "").map(c), f = u.length, h = r === "top" ? 0.71 : r === "bottom" ? 1 - f : (164 - f * 100) / 200;
    if (f > 1) {
      let d = 0;
      for (let p = 0; p < f; ++p) {
        if (++d, !u[p])
          continue;
        const y = this.ownerDocument.createElementNS(Ko.svg, "tspan");
        y.setAttribute("x", 0), p === d - 1 ? y.setAttribute("y", `${(h + p) * s}em`) : y.setAttribute("dy", `${d * s}em`), y.textContent = u[p], this.appendChild(y), d = 0;
      }
    } else
      h && this.setAttribute("y", `${h * s}em`), this.textContent = u[0];
    if (o && !i && u[0] !== n[l]) {
      const d = this.ownerDocument.createElementNS(Ko.svg, "title");
      d.textContent = n[l], this.appendChild(d);
    }
  });
}
function Pc(e, { x: t, y: n, ...i } = {}) {
  return i.frameAnchor === void 0 && ([t, n] = ki(t, n)), new F0(e, { ...i, x: t, y: n });
}
function M8(e, { x: t = Tt, ...n } = {}) {
  return new F0(e, w8({ ...n, x: t }));
}
function $8(e, { y: t = Tt, ...n } = {}) {
  return new F0(e, b8({ ...n, y: t }));
}
function T8(e, t, n) {
  mt(e, "text-anchor", t.textAnchor), mt(e, "font-family", t.fontFamily), mt(e, "font-size", t.fontSize), mt(e, "font-style", t.fontStyle), mt(e, "font-variant", t.fontVariant === void 0 ? cZ(n) : t.fontVariant), mt(e, "font-weight", t.fontWeight);
}
function cZ(e) {
  return e && (nc(e) || gn(e)) ? "tabular-nums" : void 0;
}
const lZ = /* @__PURE__ */ new Set([
  // global keywords
  "inherit",
  "initial",
  "revert",
  "unset",
  // absolute keywords
  "xx-small",
  "x-small",
  "small",
  "medium",
  "large",
  "x-large",
  "xx-large",
  "xxx-large",
  // relative keywords
  "larger",
  "smaller"
]);
function uZ(e) {
  return e == null || typeof e == "number" ? [void 0, e] : typeof e != "string" ? [e, void 0] : (e = e.trim().toLowerCase(), lZ.has(e) || /^[+-]?\d*\.?\d+(e[+-]?\d+)?(\w*|%)$/.test(e) ? [void 0, e] : [e, void 0]);
}
function fZ(e, t, n) {
  const i = [];
  let r, s = 0;
  for (const [o, a, c] of hZ(e)) {
    if (r === void 0 && (r = o), s > r && n(e, r, a) > t && (i.push(e.slice(r, s) + (e[s - 1] === I8 ? "-" : "")), r = o), c) {
      i.push(e.slice(r, a)), r = void 0;
      continue;
    }
    s = a;
  }
  return i;
}
function* hZ(e) {
  let t = 0, n = 0;
  const i = e.length;
  for (; n < i; ) {
    let r = 1;
    switch (e[n]) {
      case I8:
      case "-":
        ++n, yield [t, n, !1], t = n;
        break;
      case " ":
        for (yield [t, n, !1]; e[++n] === " "; )
          ;
        t = n;
        break;
      case "\r":
        e[n + 1] === `
` && ++r;
      case `
`:
        yield [t, n, !0], n += r, t = n;
        break;
      default:
        ++n;
        break;
    }
  }
  yield [t, n, !0];
}
const dx = {
  a: 56,
  b: 63,
  c: 57,
  d: 63,
  e: 58,
  f: 37,
  g: 62,
  h: 60,
  i: 26,
  j: 26,
  k: 55,
  l: 26,
  m: 88,
  n: 60,
  o: 60,
  p: 62,
  q: 62,
  r: 39,
  s: 54,
  t: 38,
  u: 60,
  v: 55,
  w: 79,
  x: 54,
  y: 55,
  z: 55,
  A: 69,
  B: 67,
  C: 73,
  D: 74,
  E: 61,
  F: 58,
  G: 76,
  H: 75,
  I: 28,
  J: 55,
  K: 67,
  L: 58,
  M: 89,
  N: 75,
  O: 78,
  P: 65,
  Q: 78,
  R: 67,
  S: 65,
  T: 65,
  U: 75,
  V: 69,
  W: 98,
  X: 69,
  Y: 67,
  Z: 67,
  0: 64,
  1: 48,
  2: 62,
  3: 64,
  4: 66,
  5: 63,
  6: 65,
  7: 58,
  8: 65,
  9: 65,
  " ": 29,
  "!": 32,
  '"': 49,
  "'": 31,
  "(": 39,
  ")": 39,
  ",": 31,
  "-": 48,
  ".": 31,
  "/": 32,
  ":": 31,
  ";": 31,
  "?": 52,
  "": 31,
  "": 31,
  "": 47,
  "": 47,
  "": 82
};
function ev(e, t = 0, n = e.length) {
  let i = 0;
  for (let r = t; r < n; r = ll(e, r))
    i += dx[e[r]] ?? (O8(e, r) ? 120 : dx.e);
  return i;
}
function nv(e, t = 0, n = e.length) {
  let i = 0;
  for (let r = t; r < n; r = ll(e, r))
    i += O8(e, r) ? 126 : 63;
  return i;
}
function D8({ monospace: e, lineWidth: t, textOverflow: n }) {
  if (n != null || t == 1 / 0)
    return (s) => s.split(/\r\n?|\n/g);
  const i = e ? nv : ev, r = t * 100;
  return (s) => fZ(s, r, i);
}
function N8({ monospace: e, lineWidth: t, textOverflow: n }) {
  if (n == null || t == 1 / 0)
    return (s) => s;
  const i = e ? nv : ev, r = t * 100;
  switch (n) {
    case "clip-start":
      return (s) => yx(s, r, i, "");
    case "clip-end":
      return (s) => px(s, r, i, "");
    case "ellipsis-start":
      return (s) => yx(s, r, i, yc);
    case "ellipsis-middle":
      return (s) => dZ(s, r, i, yc);
    case "ellipsis-end":
      return (s) => px(s, r, i, yc);
  }
}
const yc = "";
function Vc(e, t, n, i) {
  const r = [];
  let s = 0;
  for (let o = 0, a = 0, c = e.length; o < c; o = a) {
    a = ll(e, o);
    const l = n(e, o, a);
    if (s + l > t) {
      for (s += i; s > t && o > 0; )
        a = o, o = r.pop(), s -= n(e, o, a);
      return [o, t - s];
    }
    s += l, r.push(o);
  }
  return [-1, 0];
}
function px(e, t, n, i) {
  e = e.trim();
  const r = n(i), [s] = Vc(e, t, n, r);
  return s < 0 ? e : e.slice(0, s).trimEnd() + i;
}
function dZ(e, t, n, i) {
  e = e.trim();
  const r = n(e);
  if (r <= t)
    return e;
  const s = n(i) / 2, [o, a] = Vc(e, t / 2, n, s), [c] = Vc(e, r - t / 2 - a + s, n, -s);
  return c < 0 ? i : e.slice(0, o).trimEnd() + i + e.slice(ll(e, c)).trimStart();
}
function yx(e, t, n, i) {
  e = e.trim();
  const r = n(e);
  if (r <= t)
    return e;
  const s = n(i), [o] = Vc(e, r - t + s, n, -s);
  return o < 0 ? i : i + e.slice(ll(e, o)).trimStart();
}
const L1 = /[\p{Combining_Mark}\p{Emoji_Modifier}]+/uy, mx = new RegExp("\\p{Extended_Pictographic}", "uy");
function ll(e, t) {
  return t += pZ(e, t) ? 2 : 1, mZ(e, t) && (t = L1.lastIndex), yZ(e, t) ? ll(e, t + 1) : t;
}
function B8(e, t) {
  return e.charCodeAt(t) < 128;
}
function pZ(e, t) {
  const n = e.charCodeAt(t);
  if (n >= 55296 && n < 56320) {
    const i = e.charCodeAt(t + 1);
    return i >= 56320 && i < 57344;
  }
  return !1;
}
function yZ(e, t) {
  return e.charCodeAt(t) === 8205;
}
function mZ(e, t) {
  return B8(e, t) ? !1 : (L1.lastIndex = t, L1.test(e));
}
function O8(e, t) {
  return B8(e, t) ? !1 : (mx.lastIndex = t, mx.test(e));
}
const F8 = {
  ariaLabel: "vector",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 1.5,
  strokeLinejoin: "round",
  strokeLinecap: "round"
}, E8 = 3.5, gZ = E8 * 5, L8 = {
  draw(e, t, n) {
    const i = t * n / gZ;
    e.moveTo(0, 0), e.lineTo(0, -t), e.moveTo(-i, i - t), e.lineTo(0, -t), e.lineTo(i, i - t);
  }
}, R8 = {
  draw(e, t, n) {
    e.moveTo(-n, 0), e.lineTo(0, -t), e.lineTo(n, 0);
  }
}, bZ = /* @__PURE__ */ new Map([
  ["arrow", L8],
  ["spike", R8]
]);
function wZ(e) {
  return e && typeof e.draw == "function";
}
function vZ(e) {
  if (wZ(e))
    return e;
  const t = bZ.get(`${e}`.toLowerCase());
  if (t)
    return t;
  throw new Error(`invalid shape: ${e}`);
}
let E0 = class extends fe {
  constructor(t, n = {}) {
    const { x: i, y: r, r: s = E8, length: o, rotate: a, shape: c = L8, anchor: l = "middle", frameAnchor: u } = n, [f, h] = Be(o, 12), [d, p] = Be(a, 0);
    super(
      t,
      {
        x: { value: i, scale: "x", optional: !0 },
        y: { value: r, scale: "y", optional: !0 },
        length: { value: f, scale: "length", optional: !0 },
        rotate: { value: d, optional: !0 }
      },
      n,
      F8
    ), this.r = +s, this.length = h, this.rotate = p, this.shape = vZ(c), this.anchor = Yn(l, "anchor", ["start", "middle", "end"]), this.frameAnchor = Lf(u);
  }
  render(t, n, i, r, s) {
    const { x: o, y: a } = n, { x: c, y: l, length: u, rotate: f } = i, { length: h, rotate: d, anchor: p, shape: y, r: m } = this, [g, b] = _r(this, r);
    return Gt("svg:g", s).call(ve, this, r, s).call(ue, this, { x: c && o, y: l && a }).call(
      (w) => w.selectAll().data(t).enter().append("path").call(be, this).attr(
        "transform",
        O0`translate(${c ? (v) => c[v] : g},${l ? (v) => l[v] : b})${f ? (v) => ` rotate(${f[v]})` : d ? ` rotate(${d})` : ""}${p === "start" ? "" : p === "end" ? u ? (v) => ` translate(0,${u[v]})` : ` translate(0,${h})` : u ? (v) => ` translate(0,${u[v] / 2})` : ` translate(0,${h / 2})`}`
      ).attr(
        "d",
        u ? (v) => {
          const S = Xr();
          return y.draw(S, u[v], m), S;
        } : (() => {
          const v = Xr();
          return y.draw(v, h, m), v;
        })()
      ).call(Pe, this, i)
    ).node();
  }
};
function C8(e, t = {}) {
  let { x: n, y: i, ...r } = t;
  return t.frameAnchor === void 0 && ([n, i] = ki(n, i)), new E0(e, { ...r, x: n, y: i });
}
function k8(e, t = {}) {
  const { x: n = Tt, ...i } = t;
  return new E0(e, { ...i, x: n });
}
function U8(e, t = {}) {
  const { y: n = Tt, ...i } = t;
  return new E0(e, { ...i, y: n });
}
function _Z(e, t = {}) {
  const {
    shape: n = R8,
    stroke: i = F8.stroke,
    strokeWidth: r = 1,
    fill: s = i,
    fillOpacity: o = 0.3,
    anchor: a = "start",
    ...c
  } = t;
  return C8(e, { ...c, shape: n, stroke: i, strokeWidth: r, fill: s, fillOpacity: o, anchor: a });
}
function fo(e, t) {
  return arguments.length < 2 && !ds(e) && (t = e, e = null), t === void 0 && (t = {}), [e, t];
}
function L0({ anchor: e } = {}, t) {
  return e === void 0 ? t[0] : Yn(e, "anchor", t);
}
function z8(e) {
  return L0(e, ["left", "right"]);
}
function P8(e) {
  return L0(e, ["right", "left"]);
}
function V8(e) {
  return L0(e, ["bottom", "top"]);
}
function j8(e) {
  return L0(e, ["top", "bottom"]);
}
function iv() {
  const [e, t] = fo(...arguments);
  return W8("y", z8(t), e, t);
}
function q8() {
  const [e, t] = fo(...arguments);
  return W8("fy", P8(t), e, t);
}
function rv() {
  const [e, t] = fo(...arguments);
  return G8("x", V8(t), e, t);
}
function Y8() {
  const [e, t] = fo(...arguments);
  return G8("fx", j8(t), e, t);
}
function W8(e, t, n, {
  color: i = "currentColor",
  opacity: r = 1,
  stroke: s = i,
  strokeOpacity: o = r,
  strokeWidth: a = 1,
  fill: c = i,
  fillOpacity: l = r,
  textAnchor: u,
  textStroke: f,
  textStrokeOpacity: h,
  textStrokeWidth: d,
  tickSize: p = e === "y" ? 6 : 0,
  tickPadding: y,
  tickRotate: m,
  x: g,
  margin: b,
  marginTop: w = b === void 0 ? 20 : b,
  marginRight: v = b === void 0 ? t === "right" ? 40 : 0 : b,
  marginBottom: S = b === void 0 ? 20 : b,
  marginLeft: _ = b === void 0 ? t === "left" ? 40 : 0 : b,
  label: I,
  labelAnchor: T,
  labelArrow: M,
  labelOffset: N,
  ...A
}) {
  return p = qt(p), y = qt(y), m = qt(m), T !== void 0 && (T = Yn(T, "labelAnchor", ["center", "top", "bottom"])), M = s4(M), fi(
    p && !we(s) ? SZ(e, t, n, {
      stroke: s,
      strokeOpacity: o,
      strokeWidth: a,
      tickSize: p,
      tickPadding: y,
      tickRotate: m,
      x: g,
      ...A
    }) : null,
    we(c) ? null : IZ(e, t, n, {
      fill: c,
      fillOpacity: l,
      stroke: f,
      strokeOpacity: h,
      strokeWidth: d,
      textAnchor: u,
      tickSize: p,
      tickPadding: y,
      tickRotate: m,
      x: g,
      marginTop: w,
      marginRight: v,
      marginBottom: S,
      marginLeft: _,
      ...A
    }),
    !we(c) && I !== null ? Pc(
      [],
      e4({ fill: c, fillOpacity: l, ...A }, function(B, R, x, $, D) {
        const L = $[e], { marginTop: k, marginRight: U, marginBottom: C, marginLeft: z } = e === "y" && D.inset || D, P = T ?? (L.bandwidth ? "center" : "top"), G = N ?? (t === "right" ? U : z) - 3;
        return P === "center" ? (this.textAnchor = void 0, this.lineAnchor = t === "right" ? "bottom" : "top", this.frameAnchor = t, this.rotate = -90) : (this.textAnchor = t === "right" ? "end" : "start", this.lineAnchor = P, this.frameAnchor = `${P}-${t}`, this.rotate = 0), this.dy = P === "top" ? 3 - k : P === "bottom" ? C - 3 : 0, this.dx = t === "right" ? G : -G, this.ariaLabel = `${e}-axis label`, {
          facets: [[0]],
          channels: { text: { value: [r4(e, L, { anchor: t, label: I, labelAnchor: P, labelArrow: M })] } }
        };
      })
    ) : null
  );
}
function G8(e, t, n, {
  color: i = "currentColor",
  opacity: r = 1,
  stroke: s = i,
  strokeOpacity: o = r,
  strokeWidth: a = 1,
  fill: c = i,
  fillOpacity: l = r,
  textAnchor: u,
  textStroke: f,
  textStrokeOpacity: h,
  textStrokeWidth: d,
  tickSize: p = e === "x" ? 6 : 0,
  tickPadding: y,
  tickRotate: m,
  y: g,
  margin: b,
  marginTop: w = b === void 0 ? t === "top" ? 30 : 0 : b,
  marginRight: v = b === void 0 ? 20 : b,
  marginBottom: S = b === void 0 ? t === "bottom" ? 30 : 0 : b,
  marginLeft: _ = b === void 0 ? 20 : b,
  label: I,
  labelAnchor: T,
  labelArrow: M,
  labelOffset: N,
  ...A
}) {
  return p = qt(p), y = qt(y), m = qt(m), T !== void 0 && (T = Yn(T, "labelAnchor", ["center", "left", "right"])), M = s4(M), fi(
    p && !we(s) ? xZ(e, t, n, {
      stroke: s,
      strokeOpacity: o,
      strokeWidth: a,
      tickSize: p,
      tickPadding: y,
      tickRotate: m,
      y: g,
      ...A
    }) : null,
    we(c) ? null : AZ(e, t, n, {
      fill: c,
      fillOpacity: l,
      stroke: f,
      strokeOpacity: h,
      strokeWidth: d,
      textAnchor: u,
      tickSize: p,
      tickPadding: y,
      tickRotate: m,
      y: g,
      marginTop: w,
      marginRight: v,
      marginBottom: S,
      marginLeft: _,
      ...A
    }),
    !we(c) && I !== null ? Pc(
      [],
      e4({ fill: c, fillOpacity: l, ...A }, function(B, R, x, $, D) {
        const L = $[e], { marginTop: k, marginRight: U, marginBottom: C, marginLeft: z } = e === "x" && D.inset || D, P = T ?? (L.bandwidth ? "center" : "right"), G = N ?? (t === "top" ? k : C) - 3;
        return P === "center" ? (this.frameAnchor = t, this.textAnchor = void 0) : (this.frameAnchor = `${t}-${P}`, this.textAnchor = P === "right" ? "end" : "start"), this.lineAnchor = t, this.dy = t === "top" ? -G : G, this.dx = P === "right" ? U - 3 : P === "left" ? 3 - z : 0, this.ariaLabel = `${e}-axis label`, {
          facets: [[0]],
          channels: { text: { value: [r4(e, L, { anchor: t, label: I, labelAnchor: P, labelArrow: M })] } }
        };
      })
    ) : null
  );
}
function SZ(e, t, n, {
  strokeWidth: i = 1,
  strokeLinecap: r = null,
  strokeLinejoin: s = null,
  facetAnchor: o = t + (e === "y" ? "-empty" : ""),
  frameAnchor: a = t,
  tickSize: c,
  inset: l = 0,
  insetLeft: u = l,
  insetRight: f = l,
  dx: h = 0,
  y: d = e === "y" ? void 0 : null,
  ...p
}) {
  return ul(
    U8,
    e,
    n,
    {
      ariaLabel: `${e}-axis tick`,
      ariaHidden: !0
    },
    {
      strokeWidth: i,
      strokeLinecap: r,
      strokeLinejoin: s,
      facetAnchor: o,
      frameAnchor: a,
      y: d,
      ...p,
      dx: t === "left" ? +h - He + +u : +h + He - f,
      anchor: "start",
      length: c,
      shape: t === "left" ? DZ : NZ
    }
  );
}
function xZ(e, t, n, {
  strokeWidth: i = 1,
  strokeLinecap: r = null,
  strokeLinejoin: s = null,
  facetAnchor: o = t + (e === "x" ? "-empty" : ""),
  frameAnchor: a = t,
  tickSize: c,
  inset: l = 0,
  insetTop: u = l,
  insetBottom: f = l,
  dy: h = 0,
  x: d = e === "x" ? void 0 : null,
  ...p
}) {
  return ul(
    k8,
    e,
    n,
    {
      ariaLabel: `${e}-axis tick`,
      ariaHidden: !0
    },
    {
      strokeWidth: i,
      strokeLinejoin: s,
      strokeLinecap: r,
      facetAnchor: o,
      frameAnchor: a,
      x: d,
      ...p,
      dy: t === "bottom" ? +h - He - f : +h + He + +u,
      anchor: "start",
      length: c,
      shape: t === "bottom" ? $Z : TZ
    }
  );
}
function IZ(e, t, n, {
  facetAnchor: i = t + (e === "y" ? "-empty" : ""),
  frameAnchor: r = t,
  tickSize: s,
  tickRotate: o = 0,
  tickPadding: a = Math.max(3, 9 - s) + (Math.abs(o) > 60 ? 4 * Math.cos(o * Yp) : 0),
  text: c,
  textAnchor: l = Math.abs(o) > 60 ? "middle" : t === "left" ? "end" : "start",
  lineAnchor: u = o > 60 ? "top" : o < -60 ? "bottom" : "middle",
  fontVariant: f,
  inset: h = 0,
  insetLeft: d = h,
  insetRight: p = h,
  dx: y = 0,
  y: m = e === "y" ? void 0 : null,
  ...g
}) {
  return ul(
    $8,
    e,
    n,
    { ariaLabel: `${e}-axis tick label` },
    {
      facetAnchor: i,
      frameAnchor: r,
      text: c,
      textAnchor: l,
      lineAnchor: u,
      fontVariant: f,
      rotate: o,
      y: m,
      ...g,
      dx: t === "left" ? +y - s - a + +d : +y + +s + +a - p
    },
    function(b, w, v, S, _) {
      f === void 0 && (this.fontVariant = i4(b)), c === void 0 && (_.text = n4(b, w, v, S, t));
    }
  );
}
function AZ(e, t, n, {
  facetAnchor: i = t + (e === "x" ? "-empty" : ""),
  frameAnchor: r = t,
  tickSize: s,
  tickRotate: o = 0,
  tickPadding: a = Math.max(3, 9 - s) + (Math.abs(o) >= 10 ? 4 * Math.cos(o * Yp) : 0),
  text: c,
  textAnchor: l = Math.abs(o) >= 10 ? o < 0 ^ t === "bottom" ? "start" : "end" : "middle",
  lineAnchor: u = Math.abs(o) >= 10 ? "middle" : t === "bottom" ? "top" : "bottom",
  fontVariant: f,
  inset: h = 0,
  insetTop: d = h,
  insetBottom: p = h,
  dy: y = 0,
  x: m = e === "x" ? void 0 : null,
  ...g
}) {
  return ul(
    M8,
    e,
    n,
    { ariaLabel: `${e}-axis tick label` },
    {
      facetAnchor: i,
      frameAnchor: r,
      text: c === void 0 ? null : c,
      textAnchor: l,
      lineAnchor: u,
      fontVariant: f,
      rotate: o,
      x: m,
      ...g,
      dy: t === "bottom" ? +y + +s + +a - p : +y - s - a + +d
    },
    function(b, w, v, S, _) {
      f === void 0 && (this.fontVariant = i4(b)), c === void 0 && (_.text = n4(b, w, v, S, t));
    }
  );
}
function X8() {
  const [e, t] = fo(...arguments);
  return Z8("y", z8(t), e, t);
}
function H8() {
  const [e, t] = fo(...arguments);
  return Z8("fy", P8(t), e, t);
}
function J8() {
  const [e, t] = fo(...arguments);
  return Q8("x", V8(t), e, t);
}
function K8() {
  const [e, t] = fo(...arguments);
  return Q8("fx", j8(t), e, t);
}
function Z8(e, t, n, {
  y: i = e === "y" ? void 0 : null,
  x: r = null,
  x1: s = t === "left" ? r : null,
  x2: o = t === "right" ? r : null,
  ...a
}) {
  return ul(Ks, e, n, { ariaLabel: `${e}-grid`, ariaHidden: !0 }, { y: i, x1: s, x2: o, ...t4(a) });
}
function Q8(e, t, n, {
  x: i = e === "x" ? void 0 : null,
  y: r = null,
  y1: s = t === "top" ? r : null,
  y2: o = t === "bottom" ? r : null,
  ...a
}) {
  return ul(Js, e, n, { ariaLabel: `${e}-grid`, ariaHidden: !0 }, { x: i, y1: s, y2: o, ...t4(a) });
}
function t4({
  color: e = "currentColor",
  opacity: t = 0.1,
  stroke: n = e,
  strokeOpacity: i = t,
  strokeWidth: r = 1,
  ...s
}) {
  return { stroke: n, strokeOpacity: i, strokeWidth: r, ...s };
}
function e4({
  fill: e,
  fillOpacity: t,
  fontFamily: n,
  fontSize: i,
  fontStyle: r,
  fontVariant: s,
  fontWeight: o,
  monospace: a,
  pointerEvents: c,
  shapeRendering: l,
  clip: u = !1
}, f) {
  return [, e] = mn(e), [, t] = Be(t), {
    facet: "super",
    x: null,
    y: null,
    fill: e,
    fillOpacity: t,
    fontFamily: n,
    fontSize: i,
    fontStyle: r,
    fontVariant: s,
    fontWeight: o,
    monospace: a,
    pointerEvents: c,
    shapeRendering: l,
    clip: u,
    initializer: f
  };
}
function ul(e, t, n, i, r, s) {
  let o;
  function a(u, f, h, d, p, y) {
    const m = u == null && (t === "fx" || t === "fy"), { [t]: g } = d;
    if (!g)
      throw new Error(`missing scale: ${t}`);
    const b = g.domain();
    let { interval: w, ticks: v, tickFormat: S, tickSpacing: _ = t === "x" ? 80 : 35 } = r;
    if (typeof v == "string" && o4(g) && (w = v, v = void 0), v === void 0 && (v = ol(w, g.type) ?? MZ(g, _)), u == null) {
      if (ds(v))
        u = Nn(v);
      else if (ec(v))
        u = Jm(v, ...ke(b));
      else if (g.interval) {
        let T = g.interval;
        if (g.ticks) {
          const [M, N] = ke(b), A = (N - M) / T[Ff];
          T = jS(T, A / v) ?? T, u = Jm(T, M, N);
        } else {
          u = b;
          const M = u.length;
          T = jS(T, M / v) ?? T, T !== g.interval && (u = Jm(T, ...ke(u)));
        }
        if (T === g.interval) {
          const M = Math.round(u.length / v);
          M > 1 && (u = u.filter((N, A) => A % M === 0));
        }
      } else
        g.ticks ? u = g.ticks(v) : u = b;
      if (!g.ticks && u.length && u !== b) {
        const T = new el(b);
        u = u.filter((M) => T.has(M)), u.length || ts(`Warning: the ${t}-axis ticks appear to not align with the scale domain, resulting in no ticks. Try different ticks?`);
      }
      t === "y" || t === "x" ? f = [hs(u)] : o[t] = { scale: t, value: Tt };
    }
    s == null || s.call(this, g, u, v, S, o);
    const I = Object.fromEntries(
      Object.entries(o).map(([T, M]) => [T, { ...M, value: Pt(u, M.value) }])
    );
    return m && (f = y.filterFacets(u, I)), { data: u, facets: f, channels: I };
  }
  const c = Bn(r).initializer, l = e(n, Bn({ ...r, initializer: a }, c));
  return n == null ? (o = l.channels, l.channels = {}) : o = {}, i !== void 0 && Object.assign(l, i), l.clip === void 0 && (l.clip = !1), l;
}
function MZ(e, t) {
  const [n, i] = ke(e.range());
  return (i - n) / t;
}
function n4(e, t, n, i, r) {
  return { value: sv(e, t, n, i, r) };
}
function sv(e, t, n, i, r) {
  return typeof i == "function" ? i : i === void 0 && t && gn(t) ? zH(e.type, t, r) ?? ra : e.tickFormat ? e.tickFormat(typeof n == "number" ? n : null, i) : i === void 0 ? ra : typeof i == "string" ? (gn(e.domain()) ? Bf : rl)(i) : qn(i);
}
function Jm(e, t, n) {
  return e.range(t, e.offset(e.floor(n)));
}
const $Z = {
  draw(e, t) {
    e.moveTo(0, 0), e.lineTo(0, t);
  }
}, TZ = {
  draw(e, t) {
    e.moveTo(0, 0), e.lineTo(0, -t);
  }
}, DZ = {
  draw(e, t) {
    e.moveTo(0, 0), e.lineTo(-t, 0);
  }
}, NZ = {
  draw(e, t) {
    e.moveTo(0, 0), e.lineTo(t, 0);
  }
};
function i4(e) {
  return e.bandwidth && !e.interval ? void 0 : "tabular-nums";
}
function r4(e, t, { anchor: n, label: i = t.label, labelAnchor: r, labelArrow: s } = {}) {
  if (!(i == null || i.inferred && o4(t) && /^(date|time|year)$/i.test(i))) {
    if (i = String(i), s === "auto" && (s = (!t.bandwidth || t.interval) && !/[]/.test(i)), !s)
      return i;
    if (s === !0) {
      const o = JD(t);
      o && (s = /x$/.test(e) || r === "center" ? /x$/.test(e) === o < 0 ? "left" : "right" : o < 0 ? "up" : "down");
    }
    switch (s) {
      case "left":
        return ` ${i}`;
      case "right":
        return `${i} `;
      case "up":
        return n === "right" ? `${i} ` : ` ${i}`;
      case "down":
        return n === "right" ? `${i} ` : ` ${i}`;
    }
    return i;
  }
}
function s4(e = "auto") {
  return we(e) ? !1 : typeof e == "boolean" ? e : Yn(e, "labelArrow", ["auto", "up", "right", "down", "left"]);
}
function o4(e) {
  return gn(e.domain());
}
function gx(e, t) {
  if (t == null)
    return t;
  const n = e(t);
  if (!n)
    throw new Error(`scale not found: ${t}`);
  return n;
}
function BZ(e, { opacity: t, ...n } = {}) {
  if (!ua(e) && !e8(e))
    throw new Error(`swatches legend requires ordinal or threshold color scale (not ${e.type})`);
  return a4(
    e,
    n,
    (i, r, s, o) => i.append("svg").attr("width", s).attr("height", o).attr("fill", r.scale).attr("fill-opacity", Be(t)[1]).append("rect").attr("width", "100%").attr("height", "100%")
  );
}
function OZ(e, {
  fill: t = ((l) => (l = e.hint) == null ? void 0 : l.fill)() !== void 0 ? e.hint.fill : "none",
  fillOpacity: n = 1,
  stroke: i = ((u) => (u = e.hint) == null ? void 0 : u.stroke)() !== void 0 ? e.hint.stroke : we(t) ? "currentColor" : "none",
  strokeOpacity: r = 1,
  strokeWidth: s = 1.5,
  r: o = 4.5,
  ...a
} = {}, c) {
  const [f, h] = mn(t), [d, p] = mn(i), y = gx(c, f), m = gx(c, d), g = o * o * Math.PI;
  return n = Be(n)[1], r = Be(r)[1], s = Be(s)[1], a4(
    e,
    a,
    (b, w, v, S) => b.append("svg").attr("viewBox", "-8 -8 16 16").attr("width", v).attr("height", S).attr("fill", f === "color" ? (_) => y.scale(_) : h).attr("fill-opacity", n).attr("stroke", d === "color" ? (_) => m.scale(_) : p).attr("stroke-opacity", r).attr("stroke-width", s).append("path").attr("d", (_) => {
      const I = Xr();
      return e.scale(_).draw(I, g), I;
    })
  );
}
function a4(e, t = {}, n) {
  let {
    columns: i,
    tickFormat: r,
    fontVariant: s = l8(e),
    // TODO label,
    swatchSize: o = 15,
    swatchWidth: a = o,
    swatchHeight: c = o,
    marginLeft: l = 0,
    className: u,
    style: f,
    width: h
  } = t;
  const d = M0(t);
  u = Hw(u), r = sv(e.scale, e.domain, void 0, r);
  const p = Gt("div", d).attr(
    "class",
    `${u}-swatches ${u}-swatches-${i != null ? "columns" : "wrap"}`
  );
  let y;
  return i != null ? (y = `:where(.${u}-swatches-columns .${u}-swatch) {
  display: flex;
  align-items: center;
  break-inside: avoid;
  padding-bottom: 1px;
}
:where(.${u}-swatches-columns .${u}-swatch::before) {
  flex-shrink: 0;
}
:where(.${u}-swatches-columns .${u}-swatch-label) {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}`, p.style("columns", i).selectAll().data(e.domain).enter().append("div").attr("class", `${u}-swatch`).call(n, e, a, c).call(
    (m) => m.append("div").attr("class", `${u}-swatch-label`).attr("title", r).text(r)
  )) : (y = `:where(.${u}-swatches-wrap) {
  display: flex;
  align-items: center;
  min-height: 33px;
  flex-wrap: wrap;
}
:where(.${u}-swatches-wrap .${u}-swatch) {
  display: inline-flex;
  align-items: center;
  margin-right: 1em;
}`, p.selectAll().data(e.domain).enter().append("span").attr("class", `${u}-swatch`).call(n, e, a, c).append(function() {
    return this.ownerDocument.createTextNode(r.apply(this, arguments));
  })), p.call(
    (m) => m.insert("style", "*").text(
      `:where(.${u}-swatches) {
  font-family: system-ui, sans-serif;
  font-size: 10px;
  margin-bottom: 0.5em;
}
:where(.${u}-swatch > svg) {
  margin-right: 0.5em;
  overflow: visible;
}
${y}`
    )
  ).style("margin-left", l ? `${+l}px` : null).style("width", h === void 0 ? null : `${+h}px`).style("font-variant", Me(s, "normal")).call(Jw, f).node();
}
const Wp = /* @__PURE__ */ new Map([
  ["symbol", OZ],
  ["color", c4],
  ["opacity", LZ]
]);
function FZ(e = {}) {
  for (const [t, n] of Wp) {
    const i = e[t];
    if (qo(i)) {
      const r = M0(e);
      let s;
      if (t === "symbol") {
        const { fill: o, stroke: a = o === void 0 && qo(e.color) ? "color" : void 0 } = e;
        s = { fill: o, stroke: a };
      }
      return n(
        O1(t, i, s),
        ov(r, i, e),
        (o) => qo(e[o]) ? O1(o, e[o]) : null
      );
    }
  }
  throw new Error("unknown legend type; no scale found");
}
function EZ(e, t, n = {}) {
  return (i, r) => {
    if (!Wp.has(i))
      throw new Error(`unknown legend type: ${i}`);
    if (i in e)
      return Wp.get(i)(e[i], ov(t, n[i], r), (s) => e[s]);
  };
}
function ov({ className: e, ...t }, { label: n, ticks: i, tickFormat: r } = {}, s) {
  return nJ(s, { className: e, ...t }, { label: n, ticks: i, tickFormat: r });
}
function c4(e, { legend: t = !0, ...n }) {
  if (t === !0 && (t = e.type === "ordinal" ? "swatches" : "ramp"), e.domain !== void 0)
    switch (`${t}`.toLowerCase()) {
      case "swatches":
        return BZ(e, n);
      case "ramp":
        return eZ(e, n);
      default:
        throw new Error(`unknown legend type: ${t}`);
    }
}
function LZ({ type: e, interpolate: t, ...n }, { legend: i = !0, color: r = Vn(0, 0, 0), ...s }) {
  if (!t)
    throw new Error(`${e} opacity scales are not supported`);
  if (i === !0 && (i = "ramp"), `${i}`.toLowerCase() !== "ramp")
    throw new Error(`${i} opacity legends are not supported`);
  return c4({ type: e, ...n, interpolate: RZ(r) }, { legend: i, ...s });
}
function RZ(e) {
  const { r: t, g: n, b: i } = Vn(e) || Vn(0, 0, 0);
  return (r) => `rgba(${t},${n},${i},${r})`;
}
function CZ(e, t, n) {
  const i = [];
  for (const [r, s] of Wp) {
    const o = n[r];
    if (o != null && o.legend && r in e) {
      const a = s(e[r], ov(t, e[r], o), (c) => e[c]);
      a != null && i.push(a);
    }
  }
  return i;
}
const kZ = {
  ariaLabel: "frame",
  fill: "none",
  stroke: "currentColor",
  clip: !1
}, UZ = {
  ariaLabel: "frame",
  fill: null,
  stroke: "currentColor",
  strokeLinecap: "square",
  clip: !1
};
class l4 extends fe {
  constructor(t = {}) {
    const {
      anchor: n = null,
      inset: i = 0,
      insetTop: r = i,
      insetRight: s = i,
      insetBottom: o = i,
      insetLeft: a = i,
      rx: c,
      ry: l
    } = t;
    super(pu, void 0, t, n == null ? kZ : UZ), this.anchor = fD(n, "anchor", ["top", "right", "bottom", "left"]), this.insetTop = qt(r), this.insetRight = qt(s), this.insetBottom = qt(o), this.insetLeft = qt(a), this.rx = qt(c), this.ry = qt(l);
  }
  render(t, n, i, r, s) {
    const { marginTop: o, marginRight: a, marginBottom: c, marginLeft: l, width: u, height: f } = r, { anchor: h, insetTop: d, insetRight: p, insetBottom: y, insetLeft: m, rx: g, ry: b } = this, w = l + m, v = u - a - p, S = o + d, _ = f - c - y;
    return Gt(h ? "svg:line" : "svg:rect", s).datum(0).call(ve, this, r, s).call(be, this).call(Pe, this, i).call(ue, this, {}).call(
      h === "left" ? (I) => I.attr("x1", w).attr("x2", w).attr("y1", S).attr("y2", _) : h === "right" ? (I) => I.attr("x1", v).attr("x2", v).attr("y1", S).attr("y2", _) : h === "top" ? (I) => I.attr("x1", w).attr("x2", v).attr("y1", S).attr("y2", S) : h === "bottom" ? (I) => I.attr("x1", w).attr("x2", v).attr("y1", _).attr("y2", _) : (I) => I.attr("x", w).attr("y", S).attr("width", v - w).attr("height", _ - S).attr("rx", g).attr("ry", b)
    ).node();
  }
}
function av(e) {
  return new l4(e);
}
const Km = {
  ariaLabel: "tip",
  fill: "var(--plot-background)",
  stroke: "currentColor"
}, zZ = /* @__PURE__ */ new Set(["geometry", "href", "src", "ariaLabel", "scales"]);
class u4 extends fe {
  constructor(t, n = {}) {
    n.tip && (n = { ...n, tip: !1 }), n.title === void 0 && ds(t) && gD(t) && (n = { ...n, title: Tt });
    const {
      x: i,
      y: r,
      x1: s,
      x2: o,
      y1: a,
      y2: c,
      anchor: l,
      preferredAnchor: u = "bottom",
      monospace: f,
      fontFamily: h = f ? "ui-monospace, monospace" : void 0,
      fontSize: d,
      fontStyle: p,
      fontVariant: y,
      fontWeight: m,
      lineHeight: g = 1,
      lineWidth: b = 20,
      frameAnchor: w,
      format: v,
      textAnchor: S = "start",
      textOverflow: _,
      textPadding: I = 8,
      title: T,
      pointerSize: M = 12,
      pathFilter: N = "drop-shadow(0 3px 4px rgba(0,0,0,0.2))"
    } = n;
    super(
      t,
      {
        x: { value: s != null && o != null ? null : i, scale: "x", optional: !0 },
        // ignore midpoint
        y: { value: a != null && c != null ? null : r, scale: "y", optional: !0 },
        // ignore midpoint
        x1: { value: s, scale: "x", optional: o == null },
        y1: { value: a, scale: "y", optional: c == null },
        x2: { value: o, scale: "x", optional: s == null },
        y2: { value: c, scale: "y", optional: a == null },
        title: { value: T, optional: !0 }
        // filter: defined
      },
      n,
      Km
    ), this.anchor = M1(l, "anchor"), this.preferredAnchor = M1(u, "preferredAnchor"), this.frameAnchor = Lf(w), this.textAnchor = Me(S, "middle"), this.textPadding = +I, this.pointerSize = +M, this.pathFilter = tn(N), this.lineHeight = +g, this.lineWidth = +b, this.textOverflow = A8(_), this.monospace = !!f, this.fontFamily = tn(h), this.fontSize = qt(d), this.fontStyle = tn(p), this.fontVariant = tn(y), this.fontWeight = tn(m);
    for (const A in Km)
      A in this.channels && (this[A] = Km[A]);
    this.splitLines = D8(this), this.clipLine = N8(this), this.format = { ...v };
  }
  render(t, n, i, r, s) {
    const o = this, { x: a, y: c, fx: l, fy: u } = n, { ownerSVGElement: f, document: h } = s, { anchor: d, monospace: p, lineHeight: y, lineWidth: m } = this, { textPadding: g, pointerSize: b, pathFilter: w } = this, { marginTop: v, marginLeft: S } = r, { x1: _, y1: I, x2: T, y2: M, x: N = _ ?? T, y: A = I ?? M } = i, B = l ? l(t.fx) - S : 0, R = u ? u(t.fy) - v : 0, [x, $] = _r(this, r), D = a8(i, x), L = c8(i, $), k = p ? nv : ev, U = k(yc);
    let C, z;
    "title" in i ? (C = i.channels, z = YZ) : (C = qZ.call(this, i, n), z = WZ);
    const P = Gt("svg:g", s).call(ve, this, r, s).call(T8, this).call(ue, this, { x: N && a, y: A && c }).call(
      (et) => et.selectAll().data(t).enter().append("g").attr("transform", (Z) => `translate(${Math.round(D(Z))},${Math.round(L(Z))})`).call(be, this).call((Z) => Z.append("path").attr("filter", w)).call(
        (Z) => Z.append("text").each(function(Y) {
          const X = ce(this);
          this.setAttribute("fill", "currentColor"), this.setAttribute("fill-opacity", 1), this.setAttribute("stroke", "none");
          const j = z.call(o, Y, t, C, n, i);
          if (typeof j == "string")
            for (const J of o.splitLines(j))
              G(X, { value: o.clipLine(J) });
          else {
            const J = /* @__PURE__ */ new Set();
            for (const tt of j) {
              const { label: V = "" } = tt;
              V && J.has(V) || (J.add(V), G(X, tt));
            }
          }
        })
      )
    );
    function G(et, { label: Z, value: Y, color: X, opacity: j }) {
      Z ?? (Z = ""), Y ?? (Y = "");
      const J = X != null || j != null;
      let tt, V = m * 100;
      const [Ft] = Vc(Z, V, k, U);
      if (Ft >= 0)
        Z = Z.slice(0, Ft).trimEnd() + yc, tt = Y.trim(), Y = "";
      else {
        (Z || !Y && !J) && (Y = " " + Y);
        const [Vt] = Vc(Y, V - k(Z), k, U);
        Vt >= 0 && (tt = Y.trim(), Y = Y.slice(0, Vt).trimEnd() + yc);
      }
      const st = et.append("tspan").attr("x", 0).attr("dy", `${y}em`).text("");
      Z && st.append("tspan").attr("font-weight", "bold").text(Z), Y && st.append(() => h.createTextNode(Y)), J && st.append("tspan").text(" ").attr("fill", X).attr("fill-opacity", j).style("user-select", "none"), tt && st.append("title").text(tt);
    }
    function K() {
      const { width: et, height: Z } = r.facet ?? r;
      P.selectChildren().each(function(Y) {
        let { x: X, width: j, height: J } = this.getBBox();
        j = Math.round(j), J = Math.round(J);
        let tt = d;
        if (tt === void 0) {
          const st = D(Y) + B, Vt = L(Y) + R, jt = st + j + b + g * 2 < et, Q = st - j - b - g * 2 > 0, Zt = Vt + J + b + g * 2 < Z, En = Vt - J - b - g * 2 > 0;
          tt = jt && Q ? Zt && En ? o.preferredAnchor : En ? "bottom" : "top" : Zt && En ? jt ? "left" : "right" : (jt || Q) && (Zt || En) ? `${En ? "bottom" : "top"}-${jt ? "left" : "right"}` : o.preferredAnchor;
        }
        const V = this.firstChild, Ft = this.lastChild;
        if (V.setAttribute("d", jZ(tt, b, g, j, J)), X)
          for (const st of Ft.childNodes)
            st.setAttribute("x", -X);
        Ft.setAttribute("y", `${+PZ(tt, Ft.childNodes.length, y).toFixed(6)}em`), Ft.setAttribute("transform", `translate(${VZ(tt, b, g, j, J)})`);
      }), P.attr("visibility", null);
    }
    return t.length && (P.attr("visibility", "hidden"), f.isConnected ? Promise.resolve().then(K) : typeof requestAnimationFrame < "u" && requestAnimationFrame(K)), P.node();
  }
}
function f4(e, { x: t, y: n, ...i } = {}) {
  return i.frameAnchor === void 0 && ([t, n] = ki(t, n)), new u4(e, { ...i, x: t, y: n });
}
function PZ(e, t, n) {
  return /^top(?:-|$)/.test(e) ? 0.94 - n : -0.29 - t * n;
}
function VZ(e, t, n, i, r) {
  switch (e) {
    case "middle":
      return [-i / 2, r / 2];
    case "top-left":
      return [n, t + n];
    case "top":
      return [-i / 2, t / 2 + n];
    case "top-right":
      return [-i - n, t + n];
    case "right":
      return [-t / 2 - i - n, r / 2];
    case "bottom-left":
      return [n, -t - n];
    case "bottom":
      return [-i / 2, -t / 2 - n];
    case "bottom-right":
      return [-i - n, -t - n];
    case "left":
      return [n + t / 2, r / 2];
  }
}
function jZ(e, t, n, i, r) {
  const s = i + n * 2, o = r + n * 2;
  switch (e) {
    case "middle":
      return `M${-s / 2},${-o / 2}h${s}v${o}h${-s}z`;
    case "top-left":
      return `M0,0l${t},${t}h${s - t}v${o}h${-s}z`;
    case "top":
      return `M0,0l${t / 2},${t / 2}h${(s - t) / 2}v${o}h${-s}v${-o}h${(s - t) / 2}z`;
    case "top-right":
      return `M0,0l${-t},${t}h${t - s}v${o}h${s}z`;
    case "right":
      return `M0,0l${-t / 2},${-t / 2}v${t / 2 - o / 2}h${-s}v${o}h${s}v${t / 2 - o / 2}z`;
    case "bottom-left":
      return `M0,0l${t},${-t}h${s - t}v${-o}h${-s}z`;
    case "bottom":
      return `M0,0l${t / 2},${-t / 2}h${(s - t) / 2}v${-o}h${-s}v${o}h${(s - t) / 2}z`;
    case "bottom-right":
      return `M0,0l${-t},${-t}h${t - s}v${-o}h${s}z`;
    case "left":
      return `M0,0l${t / 2},${-t / 2}v${t / 2 - o / 2}h${s}v${o}h${-s}v${t / 2 - o / 2}z`;
  }
}
function qZ({ channels: e }, t) {
  var r, s;
  const n = {};
  let i = this.format;
  i = bx(i, e, "x"), i = bx(i, e, "y"), this.format = i;
  for (const o in i) {
    const a = i[o];
    if (!(a === null || a === !1))
      if (o === "fx" || o === "fy")
        n[o] = !0;
      else {
        const c = T1(e, o);
        c && (n[o] = c);
      }
  }
  for (const o in e) {
    if (o in n || o in i || zZ.has(o))
      continue;
    const a = T1(e, o);
    a && (n[o] = a);
  }
  this.facet && (t.fx && !("fx" in i) && (n.fx = !0), t.fy && !("fy" in i) && (n.fy = !0));
  for (const o in n) {
    const a = this.format[o];
    if (typeof a == "string") {
      const c = ((r = n[o]) == null ? void 0 : r.value) ?? ((s = t[o]) == null ? void 0 : s.domain()) ?? [];
      this.format[o] = (gn(c) ? Bf : rl)(a);
    } else if (a === void 0 || a === !0) {
      const c = t[o];
      this.format[o] = c != null && c.bandwidth ? sv(c, c.domain()) : ra;
    }
  }
  return n;
}
function bx(e, t, n) {
  if (!(n in e))
    return e;
  const i = `${n}1`, r = `${n}2`;
  if ((i in e || !(i in t)) && (r in e || !(r in t)))
    return e;
  const s = Object.entries(e), o = e[n];
  return s.splice(s.findIndex(([a]) => a === n) + 1, 0, [i, o], [r, o]), Object.fromEntries(s);
}
function YZ(e, t, { title: n }) {
  return ra(n.value[e], e);
}
function* WZ(e, t, n, i, r) {
  for (const s in n) {
    if (s === "fx" || s === "fy") {
      yield {
        label: Gp(i, n, s),
        value: this.format[s](t[s], e)
      };
      continue;
    }
    if (s === "x1" && "x2" in n || s === "y1" && "y2" in n)
      continue;
    const o = n[s];
    if (s === "x2" && "x1" in n)
      yield {
        label: vx(i, n, "x"),
        value: wx(this.format.x2, n.x1, o, e)
      };
    else if (s === "y2" && "y1" in n)
      yield {
        label: vx(i, n, "y"),
        value: wx(this.format.y2, n.y1, o, e)
      };
    else {
      const a = o.value[e], c = o.scale;
      if (!dn(a) && c == null)
        continue;
      yield {
        label: Gp(i, n, s),
        value: this.format[s](a, e),
        color: c === "color" ? r[s][e] : null,
        opacity: c === "opacity" ? r[s][e] : null
      };
    }
  }
}
function wx(e, t, n, i) {
  var r;
  return (r = n.hint) != null && r.length ? `${e(n.value[i] - t.value[i], i)}` : `${e(t.value[i], i)}${e(n.value[i], i)}`;
}
function vx(e, t, n) {
  const i = Gp(e, t, `${n}1`, n), r = Gp(e, t, `${n}2`, n);
  return i === r ? i : `${i}${r}`;
}
function Gp(e, t, n, i = n) {
  const r = t[n], s = e[(r == null ? void 0 : r.scale) ?? n];
  return String((s == null ? void 0 : s.label) ?? (r == null ? void 0 : r.label) ?? i);
}
function cv(e = {}) {
  var U;
  const { facet: t, style: n, title: i, subtitle: r, caption: s, ariaLabel: o, ariaDescription: a } = e, c = Hw(e.className), l = e.marks === void 0 ? [] : Sx(e.marks);
  l.push(...tQ(l));
  const u = ZZ(t, e), f = /* @__PURE__ */ new Map();
  for (const C of l) {
    const z = xx(C, u, e);
    z && f.set(C, z);
  }
  const h = /* @__PURE__ */ new Map();
  u && Tl(h, [u], e), Tl(h, f, e);
  const d = Sx(eQ(l, h, e));
  for (const C of d) {
    const z = xx(C, u, e);
    z && f.set(C, z);
  }
  l.unshift(...d);
  let p = PK(h, e);
  if (p !== void 0) {
    const C = u ? Gm(p, u) : void 0;
    for (const P of l) {
      if (P.facet === null || P.facet === "super")
        continue;
      const G = f.get(P);
      G !== void 0 && (G.facetsIndex = P.fx != null || P.fy != null ? Gm(p, G) : C);
    }
    const z = /* @__PURE__ */ new Set();
    for (const { facetsIndex: P } of f.values())
      P == null || P.forEach((G, K) => {
        (G == null ? void 0 : G.length) > 0 && z.add(K);
      });
    p.forEach(
      0 < z.size && z.size < p.length ? (P, G) => P.empty = !z.has(G) : (P) => P.empty = !1
    );
    for (const P of l)
      if (P.facet === "exclude") {
        const G = f.get(P);
        G !== void 0 && (G.facetsIndex = qK(G.facetsIndex));
      }
  }
  for (const C of xe.keys())
    qo(e[C]) && C !== "fx" && C !== "fy" && h.set(C, []);
  const y = /* @__PURE__ */ new Map();
  for (const C of l) {
    if (y.has(C))
      throw new Error("duplicate mark; each mark must be unique");
    const { facetsIndex: z, channels: P } = f.get(C) ?? {}, { data: G, facets: K, channels: et } = C.initialize(z, P, e);
    lv(et, e), y.set(C, { data: G, facets: K, channels: et });
  }
  const m = B1(Tl(h, y, e), e), g = UK(m, l, e);
  mK(m, g);
  const b = ix(m), { fx: w, fy: v } = b, S = w || v ? KD(m, g) : g, _ = w || v ? cQ(b, g) : g, I = M0(e), T = I.document, M = Jy("svg").call(T.documentElement);
  let N = M;
  I.ownerSVGElement = M, I.className = c, I.projection = NJ(e, S), I.filterFacets = (C, z) => Gm(p, { channels: z, groups: Kw(C, z) }), I.getMarkState = (C) => {
    const z = y.get(C), P = f.get(C);
    return { ...z, channels: { ...z.channels, ...P == null ? void 0 : P.channels } };
  }, I.dispatchValue = (C) => {
    N.value !== C && (N.value = C, N.dispatchEvent(new Event("input", { bubbles: !0 })));
  };
  const A = /* @__PURE__ */ new Set();
  for (const [C, z] of y)
    if (C.initializer != null) {
      const P = C.facet === "super" ? _ : S, G = C.initializer(z.data, z.facets, z.channels, b, P, I);
      if (G.data !== void 0 && (z.data = G.data), G.facets !== void 0 && (z.facets = G.facets), G.channels !== void 0) {
        const { fx: K, fy: et, ...Z } = G.channels;
        KZ(Z), Object.assign(z.channels, Z);
        for (const Y of Object.values(Z)) {
          const { scale: X } = Y;
          X != null && !rJ(xe.get(X)) && (h4(Y, e), A.add(X));
        }
        (K != null || et != null) && f.set(C, !0);
      }
    }
  if (A.size) {
    const C = /* @__PURE__ */ new Map();
    Tl(C, y, e, (K) => A.has(K)), Tl(h, y, e, (K) => A.has(K));
    const z = aQ(B1(C, e), m), { scales: P, ...G } = ix(z);
    Object.assign(m, z), Object.assign(b, G), Object.assign(b.scales, P);
  }
  let B, R;
  p !== void 0 && (B = { x: w == null ? void 0 : w.domain(), y: v == null ? void 0 : v.domain() }, p = VK(p, B), R = jK(w, v, g));
  for (const [C, z] of y)
    z.values = C.scale(z.channels, b, I);
  const { width: x, height: $ } = g;
  ce(M).attr("class", c).attr("fill", "currentColor").attr("font-family", "system-ui, sans-serif").attr("font-size", 10).attr("text-anchor", "middle").attr("width", x).attr("height", $).attr("viewBox", `0 0 ${x} ${$}`).attr("aria-label", o).attr("aria-description", a).call(
    (C) => (
      // Warning: if you edit this, change defaultClassName.
      C.append("style").text(
        `:where(.${c}) {
  --plot-background: white;
  display: block;
  height: auto;
  height: intrinsic;
  max-width: 100%;
}
:where(.${c} text),
:where(.${c} tspan) {
  white-space: pre;
}`
      )
    )
  ).call(Jw, n);
  for (const C of l) {
    const { channels: z, values: P, facets: G } = y.get(C);
    if (p === void 0 || C.facet === "super") {
      let K = null;
      if (G && (K = G[0], K = C.filter(K, z, P), K.length === 0))
        continue;
      const et = C.render(K, b, P, _, I);
      if (et == null)
        continue;
      M.appendChild(et);
    } else {
      let K;
      for (const et of p) {
        if (!(((U = C.facetAnchor) == null ? void 0 : U.call(C, p, B, et)) ?? !et.empty))
          continue;
        let Z = null;
        if (G) {
          const X = f.has(C);
          if (Z = G[X ? et.i : 0], Z = C.filter(Z, z, P), Z.length === 0)
            continue;
          !X && Z === G[0] && (Z = Yo(Z)), Z.fx = et.x, Z.fy = et.y, Z.fi = et.i;
        }
        const Y = C.render(Z, b, P, S, I);
        if (Y != null) {
          (K ?? (K = ce(M).append("g"))).append(() => Y).datum(et);
          for (const X of ["aria-label", "aria-description", "aria-hidden", "transform"])
            Y.hasAttribute(X) && (K.attr(X, Y.getAttribute(X)), Y.removeAttribute(X));
        }
      }
      K == null || K.selectChildren().attr("transform", R);
    }
  }
  const D = CZ(m, I, e), { figure: L = i != null || r != null || s != null || D.length > 0 } = e;
  L && (N = T.createElement("figure"), N.className = `${c}-figure`, N.style.maxWidth = "initial", i != null && N.append(_x(T, i, "h2")), r != null && N.append(_x(T, r, "h3")), N.append(...D, M), s != null && N.append(GZ(T, s))), N.scale = SK(b.scales), N.legend = EZ(m, I, e);
  const k = DJ();
  return k > 0 && ce(M).append("text").attr("x", x).attr("y", 20).attr("dy", "-1em").attr("text-anchor", "end").attr("font-family", "initial").text("").append("title").text(`${k.toLocaleString("en-US")} warning${k === 1 ? "" : "s"}. Please check the console.`), N;
}
function _x(e, t, n) {
  if (t.ownerDocument)
    return t;
  const i = e.createElement(n);
  return i.append(t), i;
}
function GZ(e, t) {
  const n = e.createElement("figcaption");
  return n.append(t), n;
}
function XZ({ marks: e = [], ...t } = {}) {
  return cv({ ...t, marks: [...e, this] });
}
fe.prototype.plot = XZ;
function Sx(e) {
  return e.flat(1 / 0).filter((t) => t != null).map(HZ);
}
function HZ(e) {
  return typeof e.render == "function" ? e : new JZ(e);
}
class JZ extends fe {
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("invalid mark; missing render function");
    super(), this.render = t;
  }
  render() {
  }
}
function lv(e, t) {
  for (const n in e)
    h4(e[n], t);
  return e;
}
function h4(e, t) {
  const { scale: n, transform: i = !0 } = e;
  if (n == null || !i)
    return;
  const {
    type: r,
    percent: s,
    interval: o,
    transform: a = s ? (c) => c * 100 : mD(o, r)
  } = t[n] ?? {};
  a != null && (e.value = ye(e.value, a), e.transform = !1);
}
function KZ(e) {
  for (const t in e)
    OD(t, e[t]);
}
function Tl(e, t, n, i = qH) {
  var r, s;
  for (const { channels: o } of t.values())
    for (const a in o) {
      const c = o[a], { scale: l } = c;
      if (l != null && i(l))
        if (l === "projection") {
          if (!FJ(n)) {
            const u = ((r = n.x) == null ? void 0 : r.domain) === void 0, f = ((s = n.y) == null ? void 0 : s.domain) === void 0;
            if (u || f) {
              const [h, d] = LJ(c);
              u && Zm(e, "x", h), f && Zm(e, "y", d);
            }
          }
        } else
          Zm(e, l, c);
    }
  return e;
}
function Zm(e, t, n) {
  const i = e.get(t);
  i !== void 0 ? i.push(n) : e.set(t, [n]);
}
function ZZ(e, t) {
  if (e == null)
    return;
  const { x: n, y: i } = e;
  if (n == null && i == null)
    return;
  const r = Nn(e.data);
  if (r == null)
    throw new Error("missing facet data");
  const s = {};
  n != null && (s.fx = Wu(r, { value: n, scale: "fx" })), i != null && (s.fy = Wu(r, { value: i, scale: "fy" })), lv(s, t);
  const o = Kw(r, s);
  return { channels: s, groups: o, data: e.data };
}
function xx(e, t, n) {
  var c;
  if (e.facet === null || e.facet === "super")
    return;
  const { fx: i, fy: r } = e;
  if (i != null || r != null) {
    const l = Nn(e.data ?? i ?? r);
    if (l === void 0)
      throw new Error(`missing facet data in ${e.ariaLabel}`);
    if (l === null)
      return;
    const u = {};
    return i != null && (u.fx = Wu(l, { value: i, scale: "fx" })), r != null && (u.fy = Wu(l, { value: r, scale: "fy" })), lv(u, n), { channels: u, groups: Kw(l, u) };
  }
  if (t === void 0)
    return;
  const { channels: s, groups: o, data: a } = t;
  if (e.facet !== "auto" || e.data === a)
    return { channels: s, groups: o };
  a.length > 0 && (o.size > 1 || o.size === 1 && s.fx && s.fy && [...o][0][1].size > 1) && ((c = Nn(e.data)) == null ? void 0 : c.length) === a.length && ts(
    `Warning: the ${e.ariaLabel} mark appears to use faceted data, but isnt faceted. The mark data has the same length as the facet data and the mark facet option is "auto", but the mark data and facet data are distinct. If this mark should be faceted, set the mark facet option to true; otherwise, suppress this warning by setting the mark facet option to false.`
  );
}
function QZ(e, t = {}) {
  return Bn({ ...t, x: null, y: null }, (n, i, r, s, o, a) => a.getMarkState(e));
}
function tQ(e) {
  const t = [];
  for (const n of e) {
    let i = n.tip;
    if (i) {
      i === !0 ? i = {} : typeof i == "string" && (i = { pointer: i });
      let { pointer: r, preferredAnchor: s } = i;
      r = /^x$/i.test(r) ? tv : /^y$/i.test(r) ? qp : Qw, i = r(QZ(n, i)), i.title = null, s === void 0 && (i.preferredAnchor = r === qp ? "left" : "bottom");
      const o = f4(n.data, i);
      o.facet = n.facet, o.facetAnchor = n.facetAnchor, t.push(o);
    }
  }
  return t;
}
function eQ(e, t, n) {
  let {
    projection: i,
    x: r = {},
    y: s = {},
    fx: o = {},
    fy: a = {},
    axis: c,
    grid: l,
    facet: u = {},
    facet: { axis: f = c, grid: h } = u,
    x: { axis: d = c, grid: p = d === null ? null : l } = r,
    y: { axis: y = c, grid: m = y === null ? null : l } = s,
    fx: { axis: g = f, grid: b = g === null ? null : h } = o,
    fy: { axis: w = f, grid: v = w === null ? null : h } = a
  } = n;
  (i || !qo(r) && !Ix("x", e)) && (d = p = null), (i || !qo(s) && !Ix("y", e)) && (y = m = null), t.has("fx") || (g = b = null), t.has("fy") || (w = v = null), d === void 0 && (d = !Mh(e, "x")), y === void 0 && (y = !Mh(e, "y")), g === void 0 && (g = !Mh(e, "fx")), w === void 0 && (w = !Mh(e, "fy")), d === !0 && (d = "bottom"), y === !0 && (y = "left"), g === !0 && (g = d === "top" || d === null ? "bottom" : "top"), w === !0 && (w = y === "right" || y === null ? "left" : "right");
  const S = [];
  return Ah(S, v, H8, a), Ih(S, w, q8, "right", "left", u, a), Ah(S, b, K8, o), Ih(S, g, Y8, "top", "bottom", u, o), Ah(S, m, X8, s), Ih(S, y, iv, "left", "right", n, s), Ah(S, p, J8, r), Ih(S, d, rv, "bottom", "top", n, r), S;
}
function Ih(e, t, n, i, r, s, o) {
  if (!t)
    return;
  const a = nQ(t);
  o = iQ(a ? i : t, s, o);
  const { line: c } = o;
  (n === iv || n === rv) && c && !zc(c) && e.push(av(rQ(o))), e.push(n(o)), a && e.push(n({ ...o, anchor: r, label: null }));
}
function Ah(e, t, n, i) {
  !t || zc(t) || e.push(n(sQ(t, i)));
}
function nQ(e) {
  return /^\s*both\s*$/i.test(e);
}
function iQ(e, t, {
  line: n = t.line,
  ticks: i,
  tickSize: r,
  tickSpacing: s,
  tickPadding: o,
  tickFormat: a,
  tickRotate: c,
  fontVariant: l,
  ariaLabel: u,
  ariaDescription: f,
  label: h = t.label,
  labelAnchor: d,
  labelArrow: p = t.labelArrow,
  labelOffset: y
}) {
  return {
    anchor: e,
    line: n,
    ticks: i,
    tickSize: r,
    tickSpacing: s,
    tickPadding: o,
    tickFormat: a,
    tickRotate: c,
    fontVariant: l,
    ariaLabel: u,
    ariaDescription: f,
    label: h,
    labelAnchor: d,
    labelArrow: p,
    labelOffset: y
  };
}
function rQ(e) {
  const { anchor: t, line: n } = e;
  return { anchor: t, facetAnchor: t + "-empty", stroke: n === !0 ? void 0 : n };
}
function sQ(e, {
  stroke: t = Ef(e) ? e : void 0,
  ticks: n = oQ(e) ? e : void 0,
  tickSpacing: i,
  ariaLabel: r,
  ariaDescription: s
}) {
  return {
    stroke: t,
    ticks: n,
    tickSpacing: i,
    ariaLabel: r,
    ariaDescription: s
  };
}
function oQ(e) {
  switch (typeof e) {
    case "number":
      return !0;
    case "string":
      return !Ef(e);
  }
  return ds(e) || typeof (e == null ? void 0 : e.range) == "function";
}
function Mh(e, t) {
  const n = `${t}-axis `;
  return e.some((i) => {
    var r;
    return (r = i.ariaLabel) == null ? void 0 : r.startsWith(n);
  });
}
function Ix(e, t) {
  for (const n of t)
    for (const i in n.channels) {
      const { scale: r } = n.channels[i];
      if (r === e || r === "projection")
        return !0;
    }
  return !1;
}
function aQ(e, t) {
  for (const n in e) {
    const i = e[n], r = t[n];
    i.label === void 0 && r && (i.label = r.label);
  }
  return e;
}
function cQ({ fx: e, fy: t }, n) {
  const { marginTop: i, marginRight: r, marginBottom: s, marginLeft: o, width: a, height: c } = Ww(n), l = e && Ax(e), u = t && Ax(t);
  return {
    marginTop: t ? u[0] : i,
    marginRight: e ? a - l[1] : r,
    marginBottom: t ? c - u[1] : s,
    marginLeft: e ? l[0] : o,
    // Some marks, namely the x- and y-axis labels, want to know what the
    // desired (rather than actual) margins are for positioning.
    inset: {
      marginTop: n.marginTop,
      marginRight: n.marginRight,
      marginBottom: n.marginBottom,
      marginLeft: n.marginLeft
    },
    width: a,
    height: c
  };
}
function Ax(e) {
  const t = e.domain();
  let n = e(t[0]), i = e(t[t.length - 1]);
  return i < n && ([n, i] = [i, n]), [n, i + e.bandwidth()];
}
const lQ = /* @__PURE__ */ new Map([
  ["basis", fH],
  ["basis-closed", hH],
  ["basis-open", dH],
  ["bundle", pH],
  ["bump-x", tH],
  ["bump-y", eH],
  ["cardinal", yH],
  ["cardinal-closed", mH],
  ["cardinal-open", gH],
  ["catmull-rom", bH],
  ["catmull-rom-closed", wH],
  ["catmull-rom-open", vH],
  ["linear", Of],
  ["linear-closed", _H],
  ["monotone-x", SH],
  ["monotone-y", xH],
  ["natural", IH],
  ["step", AH],
  ["step-after", $H],
  ["step-before", MH]
]);
function uv(e = Of, t) {
  if (typeof e == "function")
    return e;
  const n = lQ.get(`${e}`.toLowerCase());
  if (!n)
    throw new Error(`unknown curve: ${e}`);
  if (t !== void 0) {
    if ("beta" in n)
      return n.beta(t);
    if ("tension" in n)
      return n.tension(t);
    if ("alpha" in n)
      return n.alpha(t);
  }
  return n;
}
function d4(e = jc, t) {
  return typeof e != "function" && `${e}`.toLowerCase() === "auto" ? jc : uv(e, t);
}
function jc(e) {
  return Of(e);
}
function Os(e = { y: "count" }, t = {}) {
  [e, t] = pv(e, t);
  const { x: n, y: i } = t;
  return dv(Xp(n, t, Tt), null, null, i, e, Vf(t));
}
function Fs(e = { x: "count" }, t = {}) {
  [e, t] = pv(e, t);
  const { x: n, y: i } = t;
  return dv(null, Xp(i, t, Tt), n, null, e, jf(t));
}
function Bo(e = { fill: "count" }, t = {}) {
  [e, t] = pv(e, t);
  const { x: n, y: i } = uQ(t);
  return dv(n, i, null, null, e, Vf(jf(t)));
}
function p4(e, t, n = {}) {
  if ((n == null ? void 0 : n.interval) == null)
    return n;
  const { reduce: i = Pw } = n, r = { filter: null };
  return n[t] != null && (r[t] = i), n[`${t}1`] != null && (r[`${t}1`] = i), n[`${t}2`] != null && (r[`${t}2`] = i), e(r, n);
}
function fv(e = {}) {
  return p4(Os, "y", fa(e, "x"));
}
function hv(e = {}) {
  return p4(Fs, "x", fa(e, "y"));
}
function dv(e, t, n, i, {
  data: r = zw,
  // TODO avoid materializing when unused?
  filter: s = Pp,
  // return only non-empty bins by default
  sort: o,
  reverse: a,
  ...c
  // output channel definitions
} = {}, l = {}) {
  e = Mx(e), t = Mx(t), c = fQ(c, l), r = b4(r, Tt), o = o == null ? void 0 : m4("sort", o, l), s = s == null ? void 0 : g4("filter", s, l), n != null && Cs(c, "x", "x1", "x2") && (n = null), i != null && Cs(c, "y", "y1", "y2") && (i = null);
  const [u, f] = Sn(e), [h, d] = Sn(e), [p, y] = Sn(t), [m, g] = Sn(t), [b, w] = n != null ? [n, "x"] : i != null ? [i, "y"] : [], [v, S] = Sn(b), {
    x: _,
    y: I,
    z: T,
    fill: M,
    stroke: N,
    x1: A,
    x2: B,
    // consumed if x is an output
    y1: R,
    y2: x,
    // consumed if y is an output
    domain: $,
    cumulative: D,
    thresholds: L,
    interval: k,
    ...U
  } = l, [C, z] = Sn(T), [P] = mn(M), [G] = mn(N), [K, et] = Sn(P), [Z, Y] = Sn(G);
  return {
    ..."z" in l && { z: C || T },
    ..."fill" in l && { fill: K || M },
    ..."stroke" in l && { stroke: Z || N },
    ...vr(U, (X, j, J) => {
      const tt = zp(Pt(X, b), J == null ? void 0 : J[w]), V = Pt(X, T), Ft = Pt(X, P), st = Pt(X, G), Vt = Uw(c, { z: V, fill: Ft, stroke: st }), jt = [], Q = [], Zt = tt && S([]), En = V && z([]), zi = Ft && et([]), xC = st && Y([]), x_ = e && f([]), IC = e && d([]), I_ = t && y([]), AC = t && g([]), MC = pQ(e, t, X);
      let $C = 0;
      for (const pa of c)
        pa.initialize(X);
      o && o.initialize(X), s && s.initialize(X);
      for (const pa of j) {
        const A_ = [];
        for (const ya of c)
          ya.scope("facet", pa);
        o && o.scope("facet", pa), s && s.scope("facet", pa);
        for (const [ya, TC] of pc(pa, Vt))
          for (const [DC, Qf] of pc(TC, tt))
            for (const [Pi, Sr] of MC(Qf))
              if (Vt && (Sr.z = ya), !(s && !s.reduce(Pi, Sr))) {
                A_.push($C++), Q.push(r.reduceIndex(Pi, X, Sr)), tt && Zt.push(DC), V && En.push(Vt === V ? ya : V[(Pi.length > 0 ? Pi : Qf)[0]]), Ft && zi.push(Vt === Ft ? ya : Ft[(Pi.length > 0 ? Pi : Qf)[0]]), st && xC.push(Vt === st ? ya : st[(Pi.length > 0 ? Pi : Qf)[0]]), x_ && (x_.push(Sr.x1), IC.push(Sr.x2)), I_ && (I_.push(Sr.y1), AC.push(Sr.y2));
                for (const NC of c)
                  NC.reduce(Pi, Sr);
                o && o.reduce(Pi, Sr);
              }
        jt.push(A_);
      }
      return DD(jt, o, a), { data: Q, facets: jt };
    }),
    ...!Cs(c, "x") && (u ? { x1: u, x2: h, x: Up(u, h) } : { x: _, x1: A, x2: B }),
    ...!Cs(c, "y") && (p ? { y1: p, y2: m, y: Up(p, m) } : { y: I, y1: R, y2: x }),
    ...v && { [w]: v },
    ...Object.fromEntries(c.map(({ name: X, output: j }) => [X, j]))
  };
}
function pv({ cumulative: e, domain: t, thresholds: n, interval: i, ...r }, s) {
  return [r, { cumulative: e, domain: t, thresholds: n, interval: i, ...s }];
}
function Xp(e, { cumulative: t, domain: n, thresholds: i, interval: r }, s) {
  return e = { ...al(e) }, e.domain === void 0 && (e.domain = n), e.cumulative === void 0 && (e.cumulative = t), e.thresholds === void 0 && (e.thresholds = i), e.interval === void 0 && (e.interval = r), e.value === void 0 && (e.value = s), e.thresholds = y4(e.thresholds, e.interval), e;
}
function uQ(e) {
  let { x: t, y: n } = e;
  return t = Xp(t, e), n = Xp(n, e), [t.value, n.value] = ki(t.value, n.value), { x: t, y: n };
}
function Mx(e) {
  if (e == null)
    return;
  const { value: t, cumulative: n, domain: i = ke, thresholds: r } = e, s = (o) => {
    let a = Pt(o, t), c;
    if (gn(a) || dQ(r)) {
      a = ye(a, uD, Float64Array);
      let [u, f] = typeof i == "function" ? i(a) : i, h = typeof r == "function" && !ec(r) ? r(a, u, f) : r;
      typeof h == "number" && (h = c6(u, f, h)), ec(h) && (i === ke && (u = h.floor(u), f = h.offset(h.floor(f))), h = h.range(u, h.offset(f))), c = h;
    } else {
      a = An(a);
      let [u, f] = typeof i == "function" ? i(a) : i, h = typeof r == "function" && !ec(r) ? r(a, u, f) : r;
      if (typeof h == "number")
        if (i === ke) {
          let d = Nu(u, f, h);
          if (isFinite(d))
            if (d > 0) {
              let p = Math.round(u / d), y = Math.round(f / d);
              p * d <= u || --p, y * d > f || ++y;
              let m = y - p + 1;
              h = new Float64Array(m);
              for (let g = 0; g < m; ++g)
                h[g] = (p + g) * d;
            } else if (d < 0) {
              d = -d;
              let p = Math.round(u * d), y = Math.round(f * d);
              p / d <= u || --p, y / d > f || ++y;
              let m = y - p + 1;
              h = new Float64Array(m);
              for (let g = 0; g < m; ++g)
                h[g] = (p + g) / d;
            } else
              h = [u];
          else
            h = [u];
        } else
          h = Ys(u, f, h);
      else
        ec(h) && (i === ke && (u = h.floor(u), f = h.offset(h.floor(f))), h = h.range(u, h.offset(f)));
      c = h;
    }
    const l = [];
    if (c.length === 1)
      l.push([c[0], c[0]]);
    else
      for (let u = 1; u < c.length; ++u)
        l.push([c[u - 1], c[u]]);
    return l.bin = (n < 0 ? mQ : n > 0 ? yQ : yv)(l, c, a), l;
  };
  return s.label = wr(t), s;
}
function y4(e, t, n = $x) {
  if (e === void 0)
    return t === void 0 ? n : ol(t);
  if (typeof e == "string") {
    switch (e.toLowerCase()) {
      case "freedman-diaconis":
        return Pz;
      case "scott":
        return fM;
      case "sturges":
        return Vb;
      case "auto":
        return $x;
    }
    return xw(e);
  }
  return e;
}
function fQ(e, t) {
  return ID(e, t, m4);
}
function m4(e, t, n) {
  return Cw(e, t, n, g4);
}
function g4(e, t, n) {
  return kw(e, t, n, b4);
}
function b4(e, t) {
  return A0(e, t, hQ);
}
function hQ(e) {
  switch (`${e}`.toLowerCase()) {
    case "x":
      return gQ;
    case "x1":
      return wQ;
    case "x2":
      return vQ;
    case "y":
      return bQ;
    case "y1":
      return _Q;
    case "y2":
      return SQ;
    case "z":
      return ND;
  }
  throw new Error(`invalid bin reduce: ${e}`);
}
function $x(e, t, n) {
  return Math.min(200, fM(e, t, n));
}
function dQ(e) {
  return XH(e) || ds(e) && gn(e);
}
function pQ(e, t, n) {
  const i = e == null ? void 0 : e(n), r = t == null ? void 0 : t(n);
  return i && r ? function* (s) {
    const o = i.bin(s);
    for (const [a, [c, l]] of i.entries()) {
      const u = r.bin(o[a]);
      for (const [f, [h, d]] of r.entries())
        yield [u[f], { data: n, x1: c, y1: h, x2: l, y2: d }];
    }
  } : i ? function* (s) {
    const o = i.bin(s);
    for (const [a, [c, l]] of i.entries())
      yield [o[a], { data: n, x1: c, x2: l }];
  } : function* (s) {
    const o = r.bin(s);
    for (const [a, [c, l]] of r.entries())
      yield [o[a], { data: n, y1: c, y2: l }];
  };
}
function yv(e, t, n) {
  return t = An(t), (i) => {
    var s;
    const r = e.map(() => []);
    for (const o of i)
      (s = r[Yy(t, n[o]) - 1]) == null || s.push(o);
    return r;
  };
}
function yQ(e, t, n) {
  const i = yv(e, t, n);
  return (r) => {
    const s = i(r);
    for (let o = 1, a = s.length; o < a; ++o) {
      const c = s[o - 1], l = s[o];
      for (const u of c)
        l.push(u);
    }
    return s;
  };
}
function mQ(e, t, n) {
  const i = yv(e, t, n);
  return (r) => {
    const s = i(r);
    for (let o = s.length - 2; o >= 0; --o) {
      const a = s[o + 1], c = s[o];
      for (const l of a)
        c.push(l);
    }
    return s;
  };
}
function w4(e, t) {
  const n = (+e + +t) / 2;
  return e instanceof Date ? new Date(n) : n;
}
const gQ = {
  reduceIndex(e, t, { x1: n, x2: i }) {
    return w4(n, i);
  }
}, bQ = {
  reduceIndex(e, t, { y1: n, y2: i }) {
    return w4(n, i);
  }
}, wQ = {
  reduceIndex(e, t, { x1: n }) {
    return n;
  }
}, vQ = {
  reduceIndex(e, t, { x2: n }) {
    return n;
  }
}, _Q = {
  reduceIndex(e, t, { y1: n }) {
    return n;
  }
}, SQ = {
  reduceIndex(e, t, { y2: n }) {
    return n;
  }
};
function mv(e = {}) {
  return hD(e) ? e : { ...e, x: Tt };
}
function gv(e = {}) {
  return dD(e) ? e : { ...e, y: Tt };
}
function xQ(e, t) {
  if (t.length === 1)
    return { data: e, facets: t };
  const n = e.length, i = new Uint8Array(n);
  let r = 0;
  for (const a of t)
    for (const c of a)
      i[c] && ++r, i[c] = 1;
  if (r === 0)
    return { data: e, facets: t };
  e = ju(e);
  const s = e[cD] = new Uint32Array(n + r);
  t = t.map((a) => ju(a, Uint32Array));
  let o = n;
  i.fill(0);
  for (const a of t)
    for (let c = 0, l = a.length; c < l; ++c) {
      const u = a[c];
      i[u] ? (a[c] = o, e[o] = e[u], s[o] = u, ++o) : s[u] = u, i[u] = 1;
    }
  return { data: e, facets: t };
}
function v4(e = {}, t = {}) {
  arguments.length === 1 && ([e, t] = fl(e));
  const { y1: n, y: i = n, x: r, ...s } = t, [o, a, c, l] = hl(i, r, "y", "x", e, s);
  return { ...o, y1: n, y: a, x1: c, x2: l, x: Up(c, l) };
}
function IQ(e = {}, t = {}) {
  arguments.length === 1 && ([e, t] = fl(e));
  const { y1: n, y: i = n, x: r } = t, [s, o, a] = hl(i, r, "y", "x", e, t);
  return { ...s, y1: n, y: o, x: a };
}
function AQ(e = {}, t = {}) {
  arguments.length === 1 && ([e, t] = fl(e));
  const { y1: n, y: i = n, x: r } = t, [s, o, , a] = hl(i, r, "y", "x", e, t);
  return { ...s, y1: n, y: o, x: a };
}
function _4(e = {}, t = {}) {
  arguments.length === 1 && ([e, t] = fl(e));
  const { x1: n, x: i = n, y: r, ...s } = t, [o, a, c, l] = hl(i, r, "x", "y", e, s);
  return { ...o, x1: n, x: a, y1: c, y2: l, y: Up(c, l) };
}
function MQ(e = {}, t = {}) {
  arguments.length === 1 && ([e, t] = fl(e));
  const { x1: n, x: i = n, y: r } = t, [s, o, a] = hl(i, r, "x", "y", e, t);
  return { ...s, x1: n, x: o, y: a };
}
function $Q(e = {}, t = {}) {
  arguments.length === 1 && ([e, t] = fl(e));
  const { x1: n, x: i = n, y: r } = t, [s, o, , a] = hl(i, r, "x", "y", e, t);
  return { ...s, x1: n, x: o, y: a };
}
function bv({ x: e, x1: t, x2: n, ...i } = {}) {
  return i = fa(i, "y"), t === void 0 && n === void 0 ? v4({ x: e, ...i }) : ([t, n] = pD(e, t, n), { ...i, x1: t, x2: n });
}
function wv({ y: e, y1: t, y2: n, ...i } = {}) {
  return i = fa(i, "x"), t === void 0 && n === void 0 ? _4({ y: e, ...i }) : ([t, n] = pD(e, t, n), { ...i, y1: t, y2: n });
}
function fl(e) {
  const { offset: t, order: n, reverse: i, ...r } = e;
  return [{ offset: t, order: n, reverse: i }, r];
}
const TQ = { length: !0 };
function hl(e, t = Iw, n, i, { offset: r, order: s, reverse: o }, a) {
  if (t === null)
    throw new Error(`stack requires ${i}`);
  const c = lo(a), [l, u] = Sn(e), [f, h] = zn(t), [d, p] = zn(t);
  return f.hint = d.hint = TQ, r = DQ(r), s = OQ(s, r, i), [
    vr(a, (y, m, g) => {
      ({ data: y, facets: m } = xQ(y, m));
      const b = e == null ? void 0 : u(zp(Pt(y, e), g == null ? void 0 : g[n])), w = Pt(y, t, Float64Array), v = Pt(y, c), S = s && s(y, b, w, v), _ = y.length, I = h(new Float64Array(_)), T = p(new Float64Array(_)), M = [];
      for (const N of m) {
        const A = b ? Array.from(fs(N, (B) => b[B]).values()) : [N];
        if (S)
          for (const B of A)
            B.sort(S);
        for (const B of A) {
          let R = 0, x = 0;
          o && B.reverse();
          for (const $ of B) {
            const D = w[$];
            D < 0 ? R = T[$] = (I[$] = R) + D : D > 0 ? x = T[$] = (I[$] = x) + D : T[$] = I[$] = x;
          }
        }
        M.push(A);
      }
      return r && r(M, I, T, v), { data: y, facets: m };
    }),
    l,
    f,
    d
  ];
}
function DQ(e) {
  if (e != null) {
    if (typeof e == "function")
      return e;
    switch (`${e}`.toLowerCase()) {
      case "expand":
      case "normalize":
        return NQ;
      case "center":
      case "silhouette":
        return BQ;
      case "wiggle":
        return x4;
    }
    throw new Error(`unknown offset: ${e}`);
  }
}
function S4(e, t) {
  let n = 0, i = 0;
  for (const r of e) {
    const s = t[r];
    s < n && (n = s), s > i && (i = s);
  }
  return [n, i];
}
function NQ(e, t, n) {
  for (const i of e)
    for (const r of i) {
      const [s, o] = S4(r, n);
      for (const a of r) {
        const c = 1 / (o - s || 1);
        t[a] = c * (t[a] - s), n[a] = c * (n[a] - s);
      }
    }
}
function BQ(e, t, n) {
  for (const i of e) {
    for (const r of i) {
      const [s, o] = S4(r, n);
      for (const a of r) {
        const c = (o + s) / 2;
        t[a] -= c, n[a] -= c;
      }
    }
    I4(i, t, n);
  }
  A4(e, t, n);
}
function x4(e, t, n, i) {
  for (const r of e) {
    const s = new Jo();
    let o = 0;
    for (const a of r) {
      let c = -1;
      const l = a.map((d) => Math.abs(n[d] - t[d])), u = a.map((d) => {
        c = i ? i[d] : ++c;
        const p = n[d] - t[d], y = s.has(c) ? p - s.get(c) : 0;
        return s.set(c, p), y;
      }), f = [0, ...Oz(u)];
      for (const d of a)
        t[d] += o, n[d] += o;
      const h = fr(l);
      h && (o -= fr(l, (d, p) => (u[p] / 2 + f[p]) * d) / h);
    }
    I4(r, t, n);
  }
  A4(e, t, n);
}
function I4(e, t, n) {
  const i = Ye(e, (r) => Ye(r, (s) => t[s]));
  for (const r of e)
    for (const s of r)
      t[s] -= i, n[s] -= i;
}
function A4(e, t, n) {
  const i = e.length;
  if (i === 1)
    return;
  const r = e.map((a) => a.flat()), s = r.map((a) => (Ye(a, (c) => t[c]) + De(a, (c) => n[c])) / 2), o = Ye(s);
  for (let a = 0; a < i; a++) {
    const c = o - s[a];
    for (const l of r[a])
      t[l] += c, n[l] += c;
  }
}
function OQ(e, t, n) {
  if (e === void 0 && t === x4)
    return Tx(ui);
  if (e != null) {
    if (typeof e == "string") {
      const i = e.startsWith("-"), r = i ? Cp : ui;
      switch ((i ? e.slice(1) : e).toLowerCase()) {
        case "value":
        case n:
          return FQ(r);
        case "z":
          return EQ(r);
        case "sum":
          return LQ(r);
        case "appearance":
          return RQ(r);
        case "inside-out":
          return Tx(r);
      }
      return Dx(lD(e));
    }
    if (typeof e == "function")
      return (e.length === 1 ? Dx : CQ)(e);
    if (Array.isArray(e))
      return kQ(e);
    throw new Error(`invalid order: ${e}`);
  }
}
function FQ(e) {
  return (t, n, i) => (r, s) => e(i[r], i[s]);
}
function EQ(e) {
  return (t, n, i, r) => (s, o) => e(r[s], r[o]);
}
function LQ(e) {
  return R0(
    e,
    (t, n, i, r) => Pb(
      hs(t),
      (s) => fr(s, (o) => i[o]),
      (s) => r[s]
    )
  );
}
function RQ(e) {
  return R0(
    e,
    (t, n, i, r) => Pb(
      hs(t),
      (s) => n[jb(s, (o) => i[o])],
      (s) => r[s]
    )
  );
}
function Tx(e) {
  return R0(e, (t, n, i, r) => {
    const s = hs(t), o = Pb(
      s,
      (f) => n[jb(f, (h) => i[h])],
      (f) => r[f]
    ), a = uc(
      s,
      (f) => fr(f, (h) => i[h]),
      (f) => r[f]
    ), c = [], l = [];
    let u = 0;
    for (const f of o)
      u < 0 ? (u += a.get(f), c.push(f)) : (u -= a.get(f), l.push(f));
    return l.reverse().concat(c);
  });
}
function Dx(e) {
  return (t) => {
    const n = Pt(t, e);
    return (i, r) => ui(n[i], n[r]);
  };
}
function CQ(e) {
  return (t) => (n, i) => e(t[n], t[i]);
}
function kQ(e) {
  return R0(ui, () => e);
}
function R0(e, t) {
  return (n, i, r, s) => {
    if (!s)
      throw new Error("missing channel: z");
    const o = new Jo(t(n, i, r, s).map((a, c) => [a, c]));
    return (a, c) => e(o.get(s[a]), o.get(s[c]));
  };
}
const UQ = {
  ariaLabel: "area",
  strokeWidth: 1,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeMiterlimit: 1
};
class C0 extends fe {
  constructor(t, n = {}) {
    const { x1: i, y1: r, x2: s, y2: o, z: a, curve: c, tension: l } = n;
    super(
      t,
      {
        x1: { value: i, scale: "x" },
        y1: { value: r, scale: "y" },
        x2: { value: s, scale: "x", optional: !0 },
        y2: { value: o, scale: "y", optional: !0 },
        z: { value: lo(n), optional: !0 }
      },
      n,
      UQ
    ), this.z = a, this.curve = uv(c, l);
  }
  filter(t) {
    return t;
  }
  render(t, n, i, r, s) {
    const { x1: o, y1: a, x2: c = o, y2: l = a } = i;
    return Gt("svg:g", s).call(ve, this, r, s).call(ue, this, n, 0, 0).call(
      (u) => u.selectAll().data(s8(t, [o, a, c, l], this, i)).enter().append("path").call(be, this).call(Vp, this, i).attr(
        "d",
        pw().curve(this.curve).defined((f) => f >= 0).x0((f) => o[f]).y0((f) => a[f]).x1((f) => c[f]).y1((f) => l[f])
      )
    ).node();
  }
}
function R1(e, t) {
  return t === void 0 ? qc(e, { x: b0, y: Vu }) : new C0(e, t);
}
function Hu(e, t) {
  const { y: n = vn, ...i } = hv(t);
  return new C0(e, bv(mv({ ...i, y1: n, y2: void 0 })));
}
function qc(e, t) {
  const { x: n = vn, ...i } = fv(t);
  return new C0(e, wv(gv({ ...i, x1: n, x2: void 0 })));
}
const zQ = {
  ariaLabel: "link",
  fill: "none",
  stroke: "currentColor",
  strokeMiterlimit: 1
};
class M4 extends fe {
  constructor(t, n = {}) {
    const { x1: i, y1: r, x2: s, y2: o, curve: a, tension: c } = n;
    super(
      t,
      {
        x1: { value: i, scale: "x" },
        y1: { value: r, scale: "y" },
        x2: { value: s, scale: "x", optional: !0 },
        y2: { value: o, scale: "y", optional: !0 }
      },
      n,
      zQ
    ), this.curve = d4(a, c), cl(this, n);
  }
  project(t, n, i) {
    this.curve !== jc && super.project(t, n, i);
  }
  render(t, n, i, r, s) {
    const { x1: o, y1: a, x2: c = o, y2: l = a } = i, { curve: u } = this;
    return Gt("svg:g", s).call(ve, this, r, s).call(ue, this, n).call(
      (f) => f.selectAll().data(t).enter().append("path").call(be, this).attr(
        "d",
        u === jc && s.projection ? PQ(s.projection, o, a, c, l) : (h) => {
          const d = Xr(), p = u(d);
          return p.lineStart(), p.point(o[h], a[h]), p.point(c[h], l[h]), p.lineEnd(), d;
        }
      ).call(Pe, this, i).call(Pf, this, i, s)
    ).node();
  }
}
function PQ(e, t, n, i, r) {
  const s = ao(e);
  return t = An(t), n = An(n), i = An(i), r = An(r), (o) => s({
    type: "LineString",
    coordinates: [
      [t[o], n[o]],
      [i[o], r[o]]
    ]
  });
}
function $4(e, { x: t, x1: n, x2: i, y: r, y1: s, y2: o, ...a } = {}) {
  return [n, i] = Hp(t, n, i), [s, o] = Hp(r, s, o), new M4(e, { ...a, x1: n, x2: i, y1: s, y2: o });
}
function Hp(e, t, n) {
  if (e === void 0) {
    if (t === void 0) {
      if (n !== void 0)
        return [n];
    } else if (n === void 0)
      return [t];
  } else {
    if (t === void 0)
      return n === void 0 ? [e] : [e, n];
    if (n === void 0)
      return [e, t];
  }
  return [t, n];
}
const VQ = {
  ariaLabel: "arrow",
  fill: "none",
  stroke: "currentColor",
  strokeLinecap: "round",
  strokeMiterlimit: 1,
  strokeWidth: 1.5
};
class T4 extends fe {
  constructor(t, n = {}) {
    const {
      x1: i,
      y1: r,
      x2: s,
      y2: o,
      bend: a = 0,
      headAngle: c = 60,
      headLength: l = 8,
      // Disable the arrow with headLength = 0; or, use Plot.link.
      inset: u = 0,
      insetStart: f = u,
      insetEnd: h = u,
      sweep: d
    } = n;
    super(
      t,
      {
        x1: { value: i, scale: "x" },
        y1: { value: r, scale: "y" },
        x2: { value: s, scale: "x", optional: !0 },
        y2: { value: o, scale: "y", optional: !0 }
      },
      n,
      VQ
    ), this.bend = a === !0 ? 22.5 : Math.max(-90, Math.min(90, a)), this.headAngle = +c, this.headLength = +l, this.insetStart = +f, this.insetEnd = +h, this.sweep = jQ(d);
  }
  render(t, n, i, r, s) {
    const { x1: o, y1: a, x2: c = o, y2: l = a, SW: u } = i, { strokeWidth: f, bend: h, headAngle: d, headLength: p, insetStart: y, insetEnd: m } = this, g = u ? (v) => u[v] : qn(f === void 0 ? 1 : f), b = d * Yp / 2, w = p / 1.5;
    return Gt("svg:g", s).call(ve, this, r, s).call(ue, this, n).call(
      (v) => v.selectAll().data(t).enter().append("path").call(be, this).attr("d", (S) => {
        let _ = o[S], I = a[S], T = c[S], M = l[S];
        const N = Math.hypot(T - _, M - I);
        if (N <= y + m)
          return null;
        let A = Math.atan2(M - I, T - _);
        const B = Math.min(w * g(S), N / 3), R = this.sweep(_, I, T, M) * h * Yp, x = Math.hypot(N / Math.tan(R), N) / 2;
        if (y || m)
          if (x < 1e5) {
            const K = Math.sign(R), [et, Z] = qQ([_, I], [T, M], x, K);
            if (y && ([_, I] = Nx([et, Z, x], [_, I, y], -K * Math.sign(y))), m) {
              const [Y, X] = Nx([et, Z, x], [T, M, m], K * Math.sign(m));
              A += Math.atan2(X - Z, Y - et) - Math.atan2(M - Z, T - et), T = Y, M = X;
            }
          } else {
            const K = T - _, et = M - I, Z = Math.hypot(K, et);
            y && (_ += K / Z * y, I += et / Z * y), m && (T -= K / Z * m, M -= et / Z * m);
          }
        const $ = A + R, D = $ + b, L = $ - b, k = T - B * Math.cos(D), U = M - B * Math.sin(D), C = T - B * Math.cos(L), z = M - B * Math.sin(L), P = x < 1e5 ? `A${x},${x} 0,0,${R > 0 ? 1 : 0} ` : "L", G = B ? `M${k},${U}L${T},${M}L${C},${z}` : "";
        return `M${_},${I}${P}${T},${M}${G}`;
      }).call(Pe, this, i)
    ).node();
  }
}
function jQ(e = 1) {
  if (typeof e == "number")
    return qn(Math.sign(e));
  if (typeof e == "function")
    return (t, n, i, r) => Math.sign(e(t, n, i, r));
  switch (Yn(e, "sweep", ["+x", "-x", "+y", "-y"])) {
    case "+x":
      return (t, n, i) => me(t, i);
    case "-x":
      return (t, n, i) => Ho(t, i);
    case "+y":
      return (t, n, i, r) => me(n, r);
    case "-y":
      return (t, n, i, r) => Ho(n, r);
  }
}
function qQ([e, t], [n, i], r, s) {
  const o = n - e, a = i - t, c = Math.hypot(o, a), l = s * Math.sqrt(r * r - c * c / 4) / c;
  return [(e + n) / 2 - a * l, (t + i) / 2 + o * l];
}
function Nx([e, t, n], [i, r, s], o) {
  const a = i - e, c = r - t, l = Math.hypot(a, c), u = (a * a + c * c - s * s + n * n) / (2 * l), f = o * Math.sqrt(n * n - u * u);
  return [e + (a * u + c * f) / l, t + (c * u - a * f) / l];
}
function YQ(e, { x: t, x1: n, x2: i, y: r, y1: s, y2: o, ...a } = {}) {
  return [n, i] = Hp(t, n, i), [s, o] = Hp(r, s, o), new T4(e, { ...a, x1: n, x2: i, y1: s, y2: o });
}
class vv extends fe {
  constructor(t, n, i = {}, r) {
    super(t, n, i, r);
    const { inset: s = 0, insetTop: o = s, insetRight: a = s, insetBottom: c = s, insetLeft: l = s, rx: u, ry: f } = i;
    this.insetTop = qt(o), this.insetRight = qt(a), this.insetBottom = qt(c), this.insetLeft = qt(l), this.rx = Me(u, "auto"), this.ry = Me(f, "auto");
  }
  render(t, n, i, r, s) {
    const { rx: o, ry: a } = this;
    return Gt("svg:g", s).call(ve, this, r, s).call(this._transform, this, n).call(
      (c) => c.selectAll().data(t).enter().append("rect").call(be, this).attr("x", this._x(n, i, r)).attr("width", this._width(n, i, r)).attr("y", this._y(n, i, r)).attr("height", this._height(n, i, r)).call(mt, "rx", o).call(mt, "ry", a).call(Pe, this, i)
    ).node();
  }
  _x(t, { x: n }, { marginLeft: i }) {
    const { insetLeft: r } = this;
    return n ? (s) => n[s] + r : i + r;
  }
  _y(t, { y: n }, { marginTop: i }) {
    const { insetTop: r } = this;
    return n ? (s) => n[s] + r : i + r;
  }
  _width({ x: t }, { x: n }, { marginRight: i, marginLeft: r, width: s }) {
    const { insetLeft: o, insetRight: a } = this, c = n && t ? t.bandwidth() : s - i - r;
    return Math.max(0, c - o - a);
  }
  _height({ y: t }, { y: n }, { marginTop: i, marginBottom: r, height: s }) {
    const { insetTop: o, insetBottom: a } = this, c = n && t ? t.bandwidth() : s - i - r;
    return Math.max(0, c - o - a);
  }
}
const D4 = {
  ariaLabel: "bar"
};
class N4 extends vv {
  constructor(t, n = {}) {
    const { x1: i, x2: r, y: s } = n;
    super(
      t,
      {
        x1: { value: i, scale: "x" },
        x2: { value: r, scale: "x" },
        y: { value: s, scale: "y", type: "band", optional: !0 }
      },
      n,
      D4
    );
  }
  _transform(t, n, { x: i }) {
    t.call(ue, n, { x: i }, 0, 0);
  }
  _x({ x: t }, { x1: n, x2: i }, { marginLeft: r }) {
    const { insetLeft: s } = this;
    return ai(t) ? r + s : (o) => Math.min(n[o], i[o]) + s;
  }
  _width({ x: t }, { x1: n, x2: i }, { marginRight: r, marginLeft: s, width: o }) {
    const { insetLeft: a, insetRight: c } = this;
    return ai(t) ? o - r - s - a - c : (l) => Math.max(0, Math.abs(i[l] - n[l]) - a - c);
  }
}
class B4 extends vv {
  constructor(t, n = {}) {
    const { x: i, y1: r, y2: s } = n;
    super(
      t,
      {
        y1: { value: r, scale: "y" },
        y2: { value: s, scale: "y" },
        x: { value: i, scale: "x", type: "band", optional: !0 }
      },
      n,
      D4
    );
  }
  _transform(t, n, { y: i }) {
    t.call(ue, n, { y: i }, 0, 0);
  }
  _y({ y: t }, { y1: n, y2: i }, { marginTop: r }) {
    const { insetTop: s } = this;
    return ai(t) ? r + s : (o) => Math.min(n[o], i[o]) + s;
  }
  _height({ y: t }, { y1: n, y2: i }, { marginTop: r, marginBottom: s, height: o }) {
    const { insetTop: a, insetBottom: c } = this;
    return ai(t) ? o - r - s - a - c : (l) => Math.max(0, Math.abs(i[l] - n[l]) - a - c);
  }
}
function Ro(e, t = {}) {
  return w0(t) || (t = { ...t, y: vn, x2: Tt }), new N4(e, bv(m8(mv(t))));
}
function Co(e, t = {}) {
  return w0(t) || (t = { ...t, x: vn, y2: Tt }), new B4(e, wv(g8(gv(t))));
}
const WQ = {
  ariaLabel: "cell"
};
class k0 extends vv {
  constructor(t, { x: n, y: i, ...r } = {}) {
    super(
      t,
      {
        x: { value: n, scale: "x", type: "band", optional: !0 },
        y: { value: i, scale: "y", type: "band", optional: !0 }
      },
      r,
      WQ
    );
  }
  _transform(t, n) {
    t.call(ue, n, {}, 0, 0);
  }
}
function ic(e, { x: t, y: n, ...i } = {}) {
  return [t, n] = ki(t, n), new k0(e, { ...i, x: t, y: n });
}
function GQ(e, { x: t = vn, fill: n, stroke: i, ...r } = {}) {
  return n === void 0 && mn(i)[0] === void 0 && (n = Tt), new k0(e, { ...r, x: t, fill: n, stroke: i });
}
function XQ(e, { y: t = vn, fill: n, stroke: i, ...r } = {}) {
  return n === void 0 && mn(i)[0] === void 0 && (n = Tt), new k0(e, { ...r, y: t, fill: n, stroke: i });
}
const HQ = {
  ariaLabel: "dot",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 1.5
};
function _v(e) {
  return e.sort === void 0 && e.reverse === void 0 ? SD({ channel: "-r" }, e) : e;
}
class U0 extends fe {
  constructor(t, n = {}) {
    const { x: i, y: r, r: s, rotate: o, symbol: a = Pu, frameAnchor: c } = n, [l, u] = Be(o, 0), [f, h] = cJ(a), [d, p] = Be(s, f == null ? 3 : 4.5);
    super(
      t,
      {
        x: { value: i, scale: "x", optional: !0 },
        y: { value: r, scale: "y", optional: !0 },
        r: { value: d, scale: "r", filter: Qr, optional: !0 },
        rotate: { value: l, optional: !0 },
        symbol: { value: f, scale: "auto", optional: !0 }
      },
      _v(n),
      HQ
    ), this.r = p, this.rotate = u, this.symbol = h, this.frameAnchor = Lf(c);
    const { channels: y } = this, { symbol: m } = y;
    if (m) {
      const { fill: g, stroke: b } = y;
      m.hint = {
        fill: g ? g.value === m.value ? "color" : "currentColor" : this.fill ?? "currentColor",
        stroke: b ? b.value === m.value ? "color" : "currentColor" : this.stroke ?? "none"
      };
    }
  }
  render(t, n, i, r, s) {
    const { x: o, y: a } = n, { x: c, y: l, r: u, rotate: f, symbol: h } = i, { r: d, rotate: p, symbol: y } = this, [m, g] = _r(this, r), b = y === Pu, w = u ? void 0 : d * d * Math.PI;
    return m0(d) && (t = []), Gt("svg:g", s).call(ve, this, r, s).call(ue, this, { x: c && o, y: l && a }).call(
      (v) => v.selectAll().data(t).enter().append(b ? "circle" : "path").call(be, this).call(
        b ? (S) => {
          S.attr("cx", c ? (_) => c[_] : m).attr("cy", l ? (_) => l[_] : g).attr("r", u ? (_) => u[_] : d);
        } : (S) => {
          S.attr(
            "transform",
            O0`translate(${c ? (_) => c[_] : m},${l ? (_) => l[_] : g})${f ? (_) => ` rotate(${f[_]})` : p ? ` rotate(${p})` : ""}`
          ).attr(
            "d",
            u && h ? (_) => {
              const I = Xr();
              return h[_].draw(I, u[_] * u[_] * Math.PI), I;
            } : u ? (_) => {
              const I = Xr();
              return y.draw(I, u[_] * u[_] * Math.PI), I;
            } : h ? (_) => {
              const I = Xr();
              return h[_].draw(I, w), I;
            } : (() => {
              const _ = Xr();
              return y.draw(_, w), _;
            })()
          );
        }
      ).call(Pe, this, i)
    ).node();
  }
}
function ho(e, { x: t, y: n, ...i } = {}) {
  return i.frameAnchor === void 0 && ([t, n] = ki(t, n)), new U0(e, { ...i, x: t, y: n });
}
function JQ(e, { x: t = Tt, ...n } = {}) {
  return new U0(e, w8({ ...n, x: t }));
}
function KQ(e, { y: t = Tt, ...n } = {}) {
  return new U0(e, b8({ ...n, y: t }));
}
function ZQ(e, t) {
  return ho(e, { ...t, symbol: "circle" });
}
function QQ(e, t) {
  return ho(e, { ...t, symbol: "hexagon" });
}
const ttt = {
  ariaLabel: "line",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 1.5,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeMiterlimit: 1
};
class z0 extends fe {
  constructor(t, n = {}) {
    const { x: i, y: r, z: s, curve: o, tension: a } = n;
    super(
      t,
      {
        x: { value: i, scale: "x" },
        y: { value: r, scale: "y" },
        z: { value: lo(n), optional: !0 }
      },
      n,
      ttt
    ), this.z = s, this.curve = d4(o, a), cl(this, n);
  }
  filter(t) {
    return t;
  }
  project(t, n, i) {
    this.curve !== jc && super.project(t, n, i);
  }
  render(t, n, i, r, s) {
    const { x: o, y: a } = i, { curve: c } = this;
    return Gt("svg:g", s).call(ve, this, r, s).call(ue, this, n).call(
      (l) => l.selectAll().data(s8(t, [o, a], this, i)).enter().append("path").call(be, this).call(Vp, this, i).call(sZ, this, i, s).attr(
        "d",
        c === jc && s.projection ? ett(s.projection, o, a) : NT().curve(c).defined((u) => u >= 0).x((u) => o[u]).y((u) => a[u])
      )
    ).node();
  }
}
function ett(e, t, n) {
  const i = ao(e);
  return t = An(t), n = An(n), (r) => {
    let s = [];
    const o = [s];
    for (const a of r)
      a === -1 ? (s = [], o.push(s)) : s.push([t[a], n[a]]);
    return i({ type: "MultiLineString", coordinates: o });
  };
}
function P0(e, { x: t, y: n, ...i } = {}) {
  return [t, n] = ki(t, n), new z0(e, { ...i, x: t, y: n });
}
function Ju(e, { x: t = Tt, y: n = vn, ...i } = {}) {
  return new z0(e, hv({ ...i, x: t, y: n }));
}
function Ku(e, { x: t = vn, y: n = Tt, ...i } = {}) {
  return new z0(e, fv({ ...i, x: t, y: n }));
}
const ntt = {
  ariaLabel: "rect"
};
class V0 extends fe {
  constructor(t, n = {}) {
    const {
      x1: i,
      y1: r,
      x2: s,
      y2: o,
      inset: a = 0,
      insetTop: c = a,
      insetRight: l = a,
      insetBottom: u = a,
      insetLeft: f = a,
      rx: h,
      ry: d
    } = n;
    super(
      t,
      {
        x1: { value: i, scale: "x", type: i != null && s == null ? "band" : void 0, optional: !0 },
        y1: { value: r, scale: "y", type: r != null && o == null ? "band" : void 0, optional: !0 },
        x2: { value: s, scale: "x", optional: !0 },
        y2: { value: o, scale: "y", optional: !0 }
      },
      n,
      ntt
    ), this.insetTop = qt(c), this.insetRight = qt(l), this.insetBottom = qt(u), this.insetLeft = qt(f), this.rx = Me(h, "auto"), this.ry = Me(d, "auto");
  }
  render(t, n, i, r, s) {
    const { x: o, y: a } = n, { x1: c, y1: l, x2: u, y2: f } = i, { marginTop: h, marginRight: d, marginBottom: p, marginLeft: y, width: m, height: g } = r, { projection: b } = s, { insetTop: w, insetRight: v, insetBottom: S, insetLeft: _, rx: I, ry: T } = this, M = (o != null && o.bandwidth ? o.bandwidth() : 0) - _ - v, N = (a != null && a.bandwidth ? a.bandwidth() : 0) - w - S;
    return Gt("svg:g", s).call(ve, this, r, s).call(ue, this, {}, 0, 0).call(
      (A) => A.selectAll().data(t).enter().append("rect").call(be, this).attr(
        "x",
        c && (b || !ai(o)) ? u ? (B) => Math.min(c[B], u[B]) + _ : (B) => c[B] + _ : y + _
      ).attr(
        "y",
        l && (b || !ai(a)) ? f ? (B) => Math.min(l[B], f[B]) + w : (B) => l[B] + w : h + w
      ).attr(
        "width",
        c && (b || !ai(o)) ? u ? (B) => Math.max(0, Math.abs(u[B] - c[B]) + M) : M : m - d - y - v - _
      ).attr(
        "height",
        l && (b || !ai(a)) ? f ? (B) => Math.max(0, Math.abs(l[B] - f[B]) + N) : N : g - h - p - w - S
      ).call(mt, "rx", I).call(mt, "ry", T).call(Pe, this, i)
    ).node();
  }
}
function Sv(e, t) {
  return new V0(e, p8(y8(t)));
}
function Jp(e, t = {}) {
  return w0(t) || (t = { ...t, y: vn, x2: Tt, interval: 1 }), new V0(e, bv(y8(mv(t))));
}
function Kp(e, t = {}) {
  return w0(t) || (t = { ...t, x: vn, y2: Tt, interval: 1 }), new V0(e, wv(p8(gv(t))));
}
function O4(e, t) {
  t = rtt(t);
  const { x: n, y: i, color: r, size: s } = t, o = $h(e, n), a = $h(e, i), c = $h(e, r), l = $h(e, s);
  let {
    fx: u,
    fy: f,
    x: { value: h, reduce: d, zero: p, ...y },
    y: { value: m, reduce: g, zero: b, ...w },
    color: { value: v, color: S, reduce: _ },
    size: { value: I, reduce: T },
    // TODO constant radius?
    mark: M
  } = t;
  if (d === void 0 && (d = g == null && h == null && I == null && m != null ? "count" : null), g === void 0 && (g = d == null && m == null && I == null && h != null ? "count" : null), T === void 0 && I == null && _ == null && d == null && g == null && (h == null || Ae(o)) && (m == null || Ae(a)) && (T = "count"), p === void 0 && (p = Th(d) ? !0 : void 0), b === void 0 && (b = Th(g) ? !0 : void 0), h == null && m == null)
    throw new Error("must specify x or y");
  if (d != null && m == null)
    throw new Error("reducing x requires y");
  if (g != null && h == null)
    throw new Error("reducing y requires x");
  M === void 0 && (M = I != null || T != null ? "dot" : Th(d) || Th(g) || _ != null ? "bar" : h != null && m != null ? Ae(o) || Ae(a) || d == null && g == null && !Dl(o) && !Dl(a) ? "dot" : "line" : h != null || m != null ? "rule" : null);
  let N, A, B;
  switch (M) {
    case "dot":
      B = ho, A = "stroke";
      break;
    case "line":
      B = o && a || d != null || g != null ? b || g != null || o && Dl(o) ? Ku : p || d != null || a && Dl(a) ? Ju : P0 : o ? Ju : Ku, A = "stroke", Ox(c) && (N = null);
      break;
    case "area":
      B = !(b || g != null) && (p || d != null || a && Dl(a)) ? Hu : qc, A = "fill", Ox(c) && (N = null);
      break;
    case "rule":
      B = o ? Js : Ks, A = "stroke";
      break;
    case "bar":
      B = d != null ? Ae(a) ? Bx(d) && o && Ae(o) ? ic : Ro : Jp : g != null ? Ae(o) ? Bx(g) && a && Ae(a) ? ic : Co : Kp : _ != null || T != null ? o && Ae(o) && a && Ae(a) ? ic : o && Ae(o) ? Co : a && Ae(a) ? Ro : Sv : o && nc(o) && !(a && nc(a)) ? Ro : a && nc(a) && !(o && nc(o)) ? Co : ic, A = "fill";
      break;
    default:
      throw new Error(`invalid mark: ${M}`);
  }
  let R = {
    fx: u,
    fy: f,
    x: o ?? void 0,
    // treat null x as undefined for implicit stack
    y: a ?? void 0,
    // treat null y as undefined for implicit stack
    [A]: c ?? S,
    z: N,
    r: l ?? void 0,
    // treat null size as undefined for default constant radius
    tip: !0
  }, x, $ = { [A]: _ ?? void 0, r: T ?? void 0 };
  if (d != null && g != null)
    throw new Error("cannot reduce both x and y");
  return g != null ? ($.y = g, x = Ae(o) ? qu : Os) : d != null ? ($.x = d, x = Ae(a) ? Yu : Fs) : (_ != null || T != null) && (o && a ? x = Ae(o) && Ae(a) ? Rw : Ae(o) ? Fs : Ae(a) ? Os : Bo : o ? x = Ae(o) ? qu : Os : a && (x = Ae(a) ? Yu : Fs)), (x === Bo || x === Os) && (R.x = { value: o, ...y }), (x === Bo || x === Fs) && (R.y = { value: a, ...w }), p === void 0 && (p = o && !(x === Bo || x === Os) && (B === Ro || B === Hu || B === Jp || B === Ks)), b === void 0 && (b = a && !(x === Bo || x === Fs) && (B === Co || B === qc || B === Kp || B === Js)), {
    fx: u ?? null,
    fy: f ?? null,
    x: {
      value: h ?? null,
      reduce: d ?? null,
      zero: !!p,
      ...y
    },
    y: {
      value: m ?? null,
      reduce: g ?? null,
      zero: !!b,
      ...w
    },
    color: {
      value: v ?? null,
      reduce: _ ?? null,
      ...S !== void 0 && { color: S }
    },
    size: {
      value: I ?? null,
      reduce: T ?? null
    },
    mark: M,
    markImpl: Fx[B],
    markOptions: R,
    transformImpl: Fx[x],
    transformOptions: $,
    colorMode: A
  };
}
function itt(e, t) {
  const n = O4(e, t), {
    fx: i,
    fy: r,
    x: { zero: s },
    y: { zero: o },
    markOptions: a,
    transformOptions: c,
    colorMode: l
  } = n, u = C1[n.markImpl], f = C1[n.transformImpl], h = i != null || r != null ? av({ strokeOpacity: 0.1 }) : null, d = [s ? Js([0]) : null, o ? Ks([0]) : null], p = u(e, f ? f(c, a) : a);
  return l === "stroke" ? fi(h, d, p) : fi(h, p, d);
}
function Dl(e) {
  let t, n;
  for (const i of e) {
    if (i == null)
      continue;
    if (t === void 0) {
      t = i;
      continue;
    }
    const r = Math.sign(me(t, i));
    if (r) {
      if (n !== void 0 && r !== n)
        return !1;
      t = i, n = r;
    }
  }
  return !0;
}
function rtt({ x: e, y: t, color: n, size: i, fx: r, fy: s, mark: o } = {}) {
  return Hi(e) || (e = Ma(e)), Hi(t) || (t = Ma(t)), Hi(n) || (n = Ef(n) ? { color: n } : Ma(n)), Hi(i) || (i = Ma(i)), Hi(r) && ({ value: r } = Ma(r)), Hi(s) && ({ value: s } = Ma(s)), o != null && (o = `${o}`.toLowerCase()), { x: e, y: t, color: n, size: i, fx: r, fy: s, mark: o };
}
function $h(e, t) {
  const n = Pt(e, t.value);
  return n && (n.label = wr(t.value)), n;
}
function Ma(e) {
  return stt(e) ? { reduce: e } : { value: e };
}
function Th(e) {
  return /^(?:distinct|count|sum|proportion)$/i.test(e);
}
function Bx(e) {
  return /^(?:first|last|mode)$/i.test(e);
}
function stt(e) {
  if (e == null)
    return !1;
  if (typeof e.reduceIndex == "function" || typeof e.reduce == "function" && di(e) || /^p\d{2}$/i.test(e))
    return !0;
  switch (`${e}`.toLowerCase()) {
    case "first":
    case "last":
    case "count":
    case "distinct":
    case "sum":
    case "proportion":
    case "proportion-facet":
    case "deviation":
    case "min":
    case "min-index":
    case "max":
    case "max-index":
    case "mean":
    case "median":
    case "variance":
    case "mode":
      return !0;
  }
  return !1;
}
function Ox(e) {
  return e ? new el(e).size > e.length >> 1 : !1;
}
const C1 = {
  dot: ho,
  line: P0,
  lineX: Ju,
  lineY: Ku,
  areaX: Hu,
  areaY: qc,
  ruleX: Js,
  ruleY: Ks,
  barX: Ro,
  barY: Co,
  rect: Sv,
  rectX: Jp,
  rectY: Kp,
  cell: ic,
  bin: Bo,
  binX: Os,
  binY: Fs,
  group: Rw,
  groupX: qu,
  groupY: Yu
}, Fx = Object.fromEntries(Object.entries(C1).map(([e, t]) => [t, e]));
function xv(e, t = {}) {
  let { x: n, x1: i, x2: r } = t;
  n === void 0 && i === void 0 && r === void 0 && (t = { ...t, x: n = Tt });
  const s = {};
  return n != null && (s.x = e), i != null && (s.x1 = e), r != null && (s.x2 = e), pr(s, t);
}
function Iv(e, t = {}) {
  let { y: n, y1: i, y2: r } = t;
  n === void 0 && i === void 0 && r === void 0 && (t = { ...t, y: n = Tt });
  const s = {};
  return n != null && (s.y = e), i != null && (s.y1 = e), r != null && (s.y2 = e), pr(s, t);
}
function pr(e = {}, t = {}) {
  const n = lo(t), i = Object.entries(e).map(([r, s]) => {
    const o = yD(r, t);
    if (o == null)
      throw new Error(`missing channel: ${r}`);
    const [a, c] = zn(o);
    return { key: r, input: o, output: a, setOutput: c, map: ott(s) };
  });
  return {
    ...vr(t, (r, s) => {
      const o = Pt(r, n), a = i.map(({ input: l }) => Pt(r, l)), c = i.map(({ setOutput: l }) => l(new Array(r.length)));
      for (const l of s)
        for (const u of o ? fs(l, (f) => o[f]).values() : [l])
          i.forEach(({ map: f }, h) => f.mapIndex(u, a[h], c[h]));
      return { data: r, facets: s };
    }),
    ...Object.fromEntries(i.map(({ key: r, output: s }) => [r, s]))
  };
}
function ott(e) {
  if (e == null)
    throw new Error("missing map");
  if (typeof e.mapIndex == "function")
    return e;
  if (typeof e.map == "function" && di(e))
    return att(e);
  if (typeof e == "function")
    return Qm($w(e));
  switch (`${e}`.toLowerCase()) {
    case "cumsum":
      return ltt;
    case "rank":
      return Qm((t, n) => pM(t, (i) => n[i]));
    case "quantile":
      return Qm((t, n) => ctt(t, (i) => n[i]));
  }
  throw new Error(`invalid map: ${e}`);
}
function att(e) {
  return console.warn("deprecated map interface; implement mapIndex instead."), { mapIndex: e.map.bind(e) };
}
function ctt(e, t) {
  const n = Wy(e, t) - 1;
  return pM(e, t).map((i) => i / n);
}
function Qm(e) {
  return {
    mapIndex(t, n, i) {
      const r = e(t, n);
      if (r.length !== t.length)
        throw new Error("map function returned a mismatched length");
      for (let s = 0, o = t.length; s < o; ++s)
        i[t[s]] = r[s];
    }
  };
}
const ltt = {
  mapIndex(e, t, n) {
    let i = 0;
    for (const r of e)
      n[r] = i += t[r];
  }
};
function utt(e = {}, t) {
  return arguments.length === 1 && (t = e), xv(j0(e), t);
}
function ftt(e = {}, t) {
  return arguments.length === 1 && (t = e), Iv(j0(e), t);
}
function j0(e = {}) {
  typeof e == "number" && (e = { k: e });
  let { k: t, reduce: n, shift: i, anchor: r, strict: s } = e;
  if (r === void 0 && i !== void 0 && (r = dtt(i), ts(`Warning: the shift option is deprecated; please use anchor "${r}" instead.`)), !((t = Math.floor(t)) > 0))
    throw new Error(`invalid k: ${t}`);
  return ptt(n)(t, htt(r, t), s);
}
function htt(e = "middle", t) {
  switch (`${e}`.toLowerCase()) {
    case "middle":
      return t - 1 >> 1;
    case "start":
      return 0;
    case "end":
      return t - 1;
  }
  throw new Error(`invalid anchor: ${e}`);
}
function dtt(e) {
  switch (`${e}`.toLowerCase()) {
    case "centered":
      return "middle";
    case "leading":
      return "start";
    case "trailing":
      return "end";
  }
  throw new Error(`invalid shift: ${e}`);
}
function ptt(e = "mean") {
  if (typeof e == "string") {
    if (/^p\d{2}$/i.test(e))
      return Dh(Aw(e));
    switch (e.toLowerCase()) {
      case "deviation":
        return Dh(gf);
      case "max":
        return Nh((t, n) => De(t, (i) => n[i]));
      case "mean":
        return ytt;
      case "median":
        return Dh(Bu);
      case "min":
        return Nh((t, n) => Ye(t, (i) => n[i]));
      case "mode":
        return Nh((t, n) => dM(t, (i) => n[i]));
      case "sum":
        return F4;
      case "variance":
        return Dh(kb);
      case "difference":
        return btt;
      case "ratio":
        return wtt;
      case "first":
        return vtt;
      case "last":
        return _tt;
    }
  }
  if (typeof e != "function")
    throw new Error(`invalid reduce: ${e}`);
  return Nh($w(e));
}
function Dh(e) {
  return (t, n, i) => i ? {
    mapIndex(r, s, o) {
      const a = (l) => s[l] == null ? NaN : +s[l];
      let c = 0;
      for (let l = 0; l < t - 1; ++l)
        isNaN(a(l)) && ++c;
      for (let l = 0, u = r.length - t + 1; l < u; ++l)
        isNaN(a(l + t - 1)) && ++c, o[r[l + n]] = c === 0 ? e(Yo(r, l, l + t), a) : NaN, isNaN(a(l)) && --c;
    }
  } : {
    mapIndex(r, s, o) {
      const a = (c) => s[c] == null ? NaN : +s[c];
      for (let c = -n; c < 0; ++c)
        o[r[c + n]] = e(Yo(r, 0, c + t), a);
      for (let c = 0, l = r.length - n; c < l; ++c)
        o[r[c + n]] = e(Yo(r, c, c + t), a);
    }
  };
}
function Nh(e) {
  return (t, n, i) => i ? {
    mapIndex(r, s, o) {
      let a = 0;
      for (let c = 0; c < t - 1; ++c)
        a += dn(s[r[c]]);
      for (let c = 0, l = r.length - t + 1; c < l; ++c)
        a += dn(s[r[c + t - 1]]), a === t && (o[r[c + n]] = e(Yo(r, c, c + t), s)), a -= dn(s[r[c]]);
    }
  } : {
    mapIndex(r, s, o) {
      for (let a = -n; a < 0; ++a)
        o[r[a + n]] = e(Yo(r, 0, a + t), s);
      for (let a = 0, c = r.length - n; a < c; ++a)
        o[r[a + n]] = e(Yo(r, a, a + t), s);
    }
  };
}
function F4(e, t, n) {
  return n ? {
    mapIndex(i, r, s) {
      let o = 0, a = 0;
      for (let c = 0; c < e - 1; ++c) {
        const l = r[i[c]];
        l === null || isNaN(l) ? ++o : a += +l;
      }
      for (let c = 0, l = i.length - e + 1; c < l; ++c) {
        const u = r[i[c]], f = r[i[c + e - 1]];
        f === null || isNaN(f) ? ++o : a += +f, s[i[c + t]] = o === 0 ? a : NaN, u === null || isNaN(u) ? --o : a -= +u;
      }
    }
  } : {
    mapIndex(i, r, s) {
      let o = 0;
      const a = i.length;
      for (let c = 0, l = Math.min(a, e - t - 1); c < l; ++c)
        o += +r[i[c]] || 0;
      for (let c = -t, l = a - t; c < l; ++c)
        o += +r[i[c + e - 1]] || 0, s[i[c + t]] = o, o -= +r[i[c]] || 0;
    }
  };
}
function ytt(e, t, n) {
  if (n) {
    const i = F4(e, t, n);
    return {
      mapIndex(r, s, o) {
        i.mapIndex(r, s, o);
        for (let a = 0, c = r.length - e + 1; a < c; ++a)
          o[r[a + t]] /= e;
      }
    };
  } else
    return {
      mapIndex(i, r, s) {
        let o = 0, a = 0;
        const c = i.length;
        for (let l = 0, u = Math.min(c, e - t - 1); l < u; ++l) {
          let f = r[i[l]];
          f !== null && !isNaN(f = +f) && (o += f, ++a);
        }
        for (let l = -t, u = c - t; l < u; ++l) {
          let f = r[i[l + e - 1]], h = r[i[l]];
          f !== null && !isNaN(f = +f) && (o += f, ++a), s[i[l + t]] = o / a, h !== null && !isNaN(h = +h) && (o -= h, --a);
        }
      }
    };
}
function mtt(e, t, n, i) {
  for (let r = n + i; n < r; ++n) {
    const s = e[t[n]];
    if (dn(s))
      return s;
  }
}
function gtt(e, t, n, i) {
  for (let r = n + i - 1; r >= n; --r) {
    const s = e[t[r]];
    if (dn(s))
      return s;
  }
}
function E4(e, t, n, i) {
  for (let r = n + i; n < r; ++n) {
    let s = e[t[n]];
    if (s !== null && !isNaN(s = +s))
      return s;
  }
}
function L4(e, t, n, i) {
  for (let r = n + i - 1; r >= n; --r) {
    let s = e[t[r]];
    if (s !== null && !isNaN(s = +s))
      return s;
  }
}
function btt(e, t, n) {
  return n ? {
    mapIndex(i, r, s) {
      for (let o = 0, a = i.length - e; o < a; ++o) {
        const c = r[i[o]], l = r[i[o + e - 1]];
        s[i[o + t]] = c === null || l === null ? NaN : l - c;
      }
    }
  } : {
    mapIndex(i, r, s) {
      for (let o = -t, a = i.length - e + t + 1; o < a; ++o)
        s[i[o + t]] = L4(r, i, o, e) - E4(r, i, o, e);
    }
  };
}
function wtt(e, t, n) {
  return n ? {
    mapIndex(i, r, s) {
      for (let o = 0, a = i.length - e; o < a; ++o) {
        const c = r[i[o]], l = r[i[o + e - 1]];
        s[i[o + t]] = c === null || l === null ? NaN : l / c;
      }
    }
  } : {
    mapIndex(i, r, s) {
      for (let o = -t, a = i.length - e + t + 1; o < a; ++o)
        s[i[o + t]] = L4(r, i, o, e) / E4(r, i, o, e);
    }
  };
}
function vtt(e, t, n) {
  return n ? {
    mapIndex(i, r, s) {
      for (let o = 0, a = i.length - e; o < a; ++o)
        s[i[o + t]] = r[i[o]];
    }
  } : {
    mapIndex(i, r, s) {
      for (let o = -t, a = i.length - e + t + 1; o < a; ++o)
        s[i[o + t]] = mtt(r, i, o, e);
    }
  };
}
function _tt(e, t, n) {
  return n ? {
    mapIndex(i, r, s) {
      for (let o = 0, a = i.length - e; o < a; ++o)
        s[i[o + t]] = r[i[o + e - 1]];
    }
  } : {
    mapIndex(i, r, s) {
      for (let o = -t, a = i.length - e + t + 1; o < a; ++o)
        s[i[o + t]] = gtt(r, i, o, e);
    }
  };
}
const es = {
  n: 20,
  k: 2,
  color: "currentColor",
  opacity: 0.2,
  strict: !0,
  anchor: "end"
};
function Stt(e, {
  x: t = Tt,
  y: n,
  k: i = es.k,
  color: r = es.color,
  opacity: s = es.opacity,
  fill: o = r,
  fillOpacity: a = s,
  stroke: c = r,
  strokeOpacity: l,
  strokeWidth: u,
  ...f
} = {}) {
  return fi(
    we(o) ? null : Hu(
      e,
      pr(
        { x1: Wo({ k: -i, ...f }), x2: Wo({ k: i, ...f }) },
        { x1: t, x2: t, y: n, fill: o, fillOpacity: a, ...f }
      )
    ),
    we(c) ? null : Ju(e, pr({ x: Wo(f) }, { x: t, y: n, stroke: c, strokeOpacity: l, strokeWidth: u, ...f }))
  );
}
function xtt(e, {
  x: t,
  y: n = Tt,
  k: i = es.k,
  color: r = es.color,
  opacity: s = es.opacity,
  fill: o = r,
  fillOpacity: a = s,
  stroke: c = r,
  strokeOpacity: l,
  strokeWidth: u,
  ...f
} = {}) {
  return fi(
    we(o) ? null : qc(
      e,
      pr(
        { y1: Wo({ k: -i, ...f }), y2: Wo({ k: i, ...f }) },
        { x: t, y1: n, y2: n, fill: o, fillOpacity: a, ...f }
      )
    ),
    we(c) ? null : Ku(e, pr({ y: Wo(f) }, { x: t, y: n, stroke: c, strokeOpacity: l, strokeWidth: u, ...f }))
  );
}
function Wo({ n: e = es.n, k: t = 0, strict: n = es.strict, anchor: i = es.anchor } = {}) {
  return j0({ k: e, reduce: (r) => Gy(r) + t * (gf(r) || 0), strict: n, anchor: i });
}
const Itt = {
  ariaLabel: "tick",
  fill: null,
  stroke: "currentColor"
};
class R4 extends fe {
  constructor(t, n, i) {
    super(t, n, i, Itt), cl(this, i);
  }
  render(t, n, i, r, s) {
    return Gt("svg:g", s).call(ve, this, r, s).call(this._transform, this, n).call(
      (o) => o.selectAll().data(t).enter().append("line").call(be, this).attr("x1", this._x1(n, i, r)).attr("x2", this._x2(n, i, r)).attr("y1", this._y1(n, i, r)).attr("y2", this._y2(n, i, r)).call(Pe, this, i).call(Pf, this, i, s)
    ).node();
  }
}
class C4 extends R4 {
  constructor(t, n = {}) {
    const { x: i, y: r, inset: s = 0, insetTop: o = s, insetBottom: a = s } = n;
    super(
      t,
      {
        x: { value: i, scale: "x" },
        y: { value: r, scale: "y", type: "band", optional: !0 }
      },
      n
    ), this.insetTop = qt(o), this.insetBottom = qt(a);
  }
  _transform(t, n, { x: i }) {
    t.call(ue, n, { x: i }, He, 0);
  }
  _x1(t, { x: n }) {
    return (i) => n[i];
  }
  _x2(t, { x: n }) {
    return (i) => n[i];
  }
  _y1({ y: t }, { y: n }, { marginTop: i }) {
    const { insetTop: r } = this;
    return n && t ? (s) => n[s] + r : i + r;
  }
  _y2({ y: t }, { y: n }, { height: i, marginBottom: r }) {
    const { insetBottom: s } = this;
    return n && t ? (o) => n[o] + t.bandwidth() - s : i - r - s;
  }
}
class k4 extends R4 {
  constructor(t, n = {}) {
    const { x: i, y: r, inset: s = 0, insetRight: o = s, insetLeft: a = s } = n;
    super(
      t,
      {
        y: { value: r, scale: "y" },
        x: { value: i, scale: "x", type: "band", optional: !0 }
      },
      n
    ), this.insetRight = qt(o), this.insetLeft = qt(a);
  }
  _transform(t, n, { y: i }) {
    t.call(ue, n, { y: i }, 0, He);
  }
  _x1({ x: t }, { x: n }, { marginLeft: i }) {
    const { insetLeft: r } = this;
    return n && t ? (s) => n[s] + r : i + r;
  }
  _x2({ x: t }, { x: n }, { width: i, marginRight: r }) {
    const { insetRight: s } = this;
    return n && t ? (o) => n[o] + t.bandwidth() - s : i - r - s;
  }
  _y1(t, { y: n }) {
    return (i) => n[i];
  }
  _y2(t, { y: n }) {
    return (i) => n[i];
  }
}
function U4(e, { x: t = Tt, ...n } = {}) {
  return new C4(e, { ...n, x: t });
}
function z4(e, { y: t = Tt, ...n } = {}) {
  return new k4(e, { ...n, y: t });
}
function Att(e, {
  x: t = Tt,
  y: n = null,
  fill: i = "#ccc",
  fillOpacity: r,
  stroke: s = "currentColor",
  strokeOpacity: o,
  strokeWidth: a = 2,
  sort: c,
  ...l
} = {}) {
  const u = n != null ? Yu : Lw;
  return fi(
    Ks(e, u({ x1: Av, x2: Mv }, { x: t, y: n, stroke: s, strokeOpacity: o, ...l })),
    Ro(e, u({ x1: "p25", x2: "p75" }, { x: t, y: n, fill: i, fillOpacity: r, ...l })),
    U4(e, u({ x: "p50" }, { x: t, y: n, stroke: s, strokeOpacity: o, strokeWidth: a, sort: c, ...l })),
    ho(e, pr({ x: P4 }, { x: t, y: n, z: n, stroke: s, strokeOpacity: o, ...l }))
  );
}
function Mtt(e, {
  y: t = Tt,
  x: n = null,
  fill: i = "#ccc",
  fillOpacity: r,
  stroke: s = "currentColor",
  strokeOpacity: o,
  strokeWidth: a = 2,
  sort: c,
  ...l
} = {}) {
  const u = n != null ? qu : Lw;
  return fi(
    Js(e, u({ y1: Av, y2: Mv }, { x: n, y: t, stroke: s, strokeOpacity: o, ...l })),
    Co(e, u({ y1: "p25", y2: "p75" }, { x: n, y: t, fill: i, fillOpacity: r, ...l })),
    z4(e, u({ y: "p50" }, { x: n, y: t, stroke: s, strokeOpacity: o, strokeWidth: a, sort: c, ...l })),
    ho(e, pr({ y: P4 }, { x: n, y: t, z: n, stroke: s, strokeOpacity: o, ...l }))
  );
}
function P4(e) {
  const t = Av(e), n = Mv(e);
  return e.map((i) => i < t || i > n ? i : NaN);
}
function Av(e) {
  const t = V4(e) * 2.5 - j4(e) * 1.5;
  return Ye(e, (n) => n >= t ? n : NaN);
}
function Mv(e) {
  const t = j4(e) * 2.5 - V4(e) * 1.5;
  return De(e, (n) => n <= t ? n : NaN);
}
function V4(e) {
  return Ws(e, 0.25);
}
function j4(e) {
  return Ws(e, 0.75);
}
const $tt = {
  ariaLabel: "raster",
  stroke: null,
  pixelSize: 1
};
function $a(e, t) {
  const n = +e;
  if (isNaN(n))
    throw new Error(`invalid ${t}: ${e}`);
  return n;
}
function Ex(e, t) {
  const n = Math.floor(e);
  if (isNaN(n))
    throw new Error(`invalid ${t}: ${e}`);
  return n;
}
class q4 extends fe {
  constructor(t, n, i = {}, r) {
    let {
      width: s,
      height: o,
      x: a,
      y: c,
      x1: l = a == null ? 0 : void 0,
      y1: u = c == null ? 0 : void 0,
      x2: f = a == null ? s : void 0,
      y2: h = c == null ? o : void 0,
      pixelSize: d = r.pixelSize,
      blur: p = 0,
      interpolate: y
    } = i;
    if (s != null && (s = Ex(s, "width")), o != null && (o = Ex(o, "height")), l != null && (l = $a(l, "x1")), u != null && (u = $a(u, "y1")), f != null && (f = $a(f, "x2")), h != null && (h = $a(h, "y2")), a == null && (l == null || f == null))
      throw new Error("missing x");
    if (c == null && (u == null || h == null))
      throw new Error("missing y");
    t != null && s != null && o != null && (a === void 0 && l != null && f != null && (a = Rtt(l, f, s)), c === void 0 && u != null && h != null && (c = Ctt(u, h, s, o))), super(
      t,
      {
        x: { value: a, scale: "x", optional: !0 },
        y: { value: c, scale: "y", optional: !0 },
        x1: { value: l == null ? null : [l], scale: "x", optional: !0, filter: null },
        y1: { value: u == null ? null : [u], scale: "y", optional: !0, filter: null },
        x2: { value: f == null ? null : [f], scale: "x", optional: !0, filter: null },
        y2: { value: h == null ? null : [h], scale: "y", optional: !0, filter: null },
        ...n
      },
      i,
      r
    ), this.width = s, this.height = o, this.pixelSize = $a(d, "pixelSize"), this.blur = $a(p, "blur"), this.interpolate = a == null || c == null ? null : Dtt(y);
  }
}
class Y4 extends q4 {
  constructor(t, n = {}) {
    const { imageRendering: i } = n;
    if (t == null) {
      const { fill: r, fillOpacity: s } = n;
      Be(s)[0] !== void 0 && (n = k1("fillOpacity", n)), mn(r)[0] !== void 0 && (n = k1("fill", n));
    }
    super(t, void 0, n, $tt), this.imageRendering = Me(i, "auto");
  }
  // Ignore the color scale, so the fill channel is returned unscaled.
  scale(t, { color: n, ...i }, r) {
    return super.scale(t, i, r);
  }
  render(t, n, i, r, s) {
    var $;
    const o = n[($ = i.channels.fill) == null ? void 0 : $.scale] ?? ((D) => D), { x: a, y: c } = i, { document: l } = s, [u, f, h, d] = G4(i, r, s), p = h - u, y = d - f, { pixelSize: m, width: g = Math.round(Math.abs(p) / m), height: b = Math.round(Math.abs(y) / m) } = this, w = g * b;
    let { fill: v, fillOpacity: S } = i, _ = 0;
    if (this.interpolate) {
      const D = g / p, L = b / y, k = ye(a, (C) => (C - u) * D, Float64Array), U = ye(c, (C) => (C - f) * L, Float64Array);
      v && (v = this.interpolate(t, g, b, k, U, v)), S && (S = this.interpolate(t, g, b, k, U, S));
    } else
      this.data == null && t && (_ = t.fi * w);
    const I = l.createElement("canvas");
    I.width = g, I.height = b;
    const T = I.getContext("2d"), M = T.createImageData(g, b), N = M.data;
    let { r: A, g: B, b: R } = Vn(this.fill) ?? { r: 0, g: 0, b: 0 }, x = (this.fillOpacity ?? 1) * 255;
    for (let D = 0; D < w; ++D) {
      const L = D << 2;
      if (v) {
        const k = o(v[D + _]);
        if (k == null) {
          N[L + 3] = 0;
          continue;
        }
        ({ r: A, g: B, b: R } = Vn(k));
      }
      S && (x = S[D + _] * 255), N[L + 0] = A, N[L + 1] = B, N[L + 2] = R, N[L + 3] = x;
    }
    return this.blur > 0 && Iz(M, this.blur), T.putImageData(M, 0, 0), Gt("svg:g", s).call(ve, this, r, s).call(ue, this, n).call(
      (D) => D.append("image").attr("transform", `translate(${u},${f}) scale(${Math.sign(h - u)},${Math.sign(d - f)})`).attr("width", Math.abs(p)).attr("height", Math.abs(y)).attr("preserveAspectRatio", "none").call(mt, "image-rendering", this.imageRendering).call(be, this).attr("xlink:href", I.toDataURL())
    ).node();
  }
}
function W4(e, t, n) {
  arguments.length < 3 && (n = t, t = null);
  let { x: i, y: r, [e]: s, ...o } = n;
  return i === void 0 && r === void 0 && JH(t) && (i = b0, r = Vu, s === void 0 && (s = YH)), [t, { ...o, x: i, y: r, [e]: s }];
}
function Ttt() {
  const [e, t] = W4("fill", ...arguments);
  return new Y4(
    e,
    e == null || t.fill !== void 0 || t.fillOpacity !== void 0 ? t : { ...t, fill: Tt }
  );
}
function G4({ x1: e, y1: t, x2: n, y2: i }, r, { projection: s }) {
  const { width: o, height: a, marginTop: c, marginRight: l, marginBottom: u, marginLeft: f } = r;
  return [
    e && s == null ? e[0] : f,
    t && s == null ? t[0] : c,
    n && s == null ? n[0] : o - l,
    i && s == null ? i[0] : a - u
  ];
}
function X4({ x1: e, y1: t, x2: n, y2: i }, r, s, o) {
  const a = {};
  return e && (a.x1 = e), t && (a.y1 = t), n && (a.x2 = n), i && (a.y2 = i), G4(Vw(a, r), s, o);
}
function k1(e, t = {}) {
  const { [e]: n } = t;
  if (typeof n != "function")
    throw new Error(`invalid ${e}: not a function`);
  return Bn({ ...t, [e]: void 0 }, function(i, r, s, o, a, c) {
    const { x: l, y: u } = o;
    if (!l)
      throw new Error("missing scale: x");
    if (!u)
      throw new Error("missing scale: y");
    const [f, h, d, p] = X4(s, o, a, c), y = d - f, m = p - h, { pixelSize: g } = this, { width: b = Math.round(Math.abs(y) / g), height: w = Math.round(Math.abs(m) / g) } = t, v = new Array(b * w * (r ? r.length : 1)), S = y / b, _ = m / w;
    let I = 0;
    for (const T of r ?? [void 0])
      for (let M = 0.5; M < w; ++M)
        for (let N = 0.5; N < b; ++N, ++I)
          v[I] = n(l.invert(f + N * S), u.invert(h + M * _), T);
    return { data: v, facets: r, channels: { [e]: { value: v, scale: "auto" } } };
  });
}
function Dtt(e) {
  if (typeof e == "function")
    return e;
  if (e == null)
    return U1;
  switch (`${e}`.toLowerCase()) {
    case "none":
      return U1;
    case "nearest":
      return Tv;
    case "barycentric":
      return $v();
    case "random-walk":
      return Dv();
  }
  throw new Error(`invalid interpolate: ${e}`);
}
function U1(e, t, n, i, r, s) {
  const o = new Array(t * n);
  for (const a of e)
    i[a] < 0 || i[a] >= t || r[a] < 0 || r[a] >= n || (o[Math.floor(r[a]) * t + Math.floor(i[a])] = s[a]);
  return o;
}
function $v({ random: e = cw(42) } = {}) {
  return (t, n, i, r, s, o) => {
    const { points: a, triangles: c, hull: l } = oo.from(
      t,
      (d) => r[d],
      (d) => s[d]
    ), u = new o.constructor(n * i).fill(NaN), f = new Uint8Array(n * i), h = Ltt(o, e);
    for (let d = 0; d < c.length; d += 3) {
      const p = c[d], y = c[d + 1], m = c[d + 2], g = a[2 * p], b = a[2 * y], w = a[2 * m], v = a[2 * p + 1], S = a[2 * y + 1], _ = a[2 * m + 1], I = Math.min(g, b, w), T = Math.max(g, b, w), M = Math.min(v, S, _), N = Math.max(v, S, _), A = (S - _) * (g - w) + (v - _) * (w - b);
      if (!A)
        continue;
      const B = o[t[p]], R = o[t[y]], x = o[t[m]];
      for (let $ = Math.floor(I); $ < T; ++$)
        for (let D = Math.floor(M); D < N; ++D) {
          if ($ < 0 || $ >= n || D < 0 || D >= i)
            continue;
          const L = $ + 0.5, k = D + 0.5, U = ((S - _) * (L - w) + (k - _) * (w - b)) / A;
          if (U < 0)
            continue;
          const C = ((_ - v) * (L - w) + (k - _) * (g - w)) / A;
          if (C < 0)
            continue;
          const z = 1 - U - C;
          if (z < 0)
            continue;
          const P = $ + n * D;
          u[P] = h(B, U, R, C, x, z, $, D), f[P] = 1;
        }
    }
    return Ntt(u, f, r, s, o, n, i, l, t, h), u;
  };
}
function Ntt(e, t, n, i, r, s, o, a, c, l) {
  n = Float64Array.from(a, (d) => n[c[d]]), i = Float64Array.from(a, (d) => i[c[d]]), r = Array.from(a, (d) => r[c[d]]);
  const u = n.length, f = Array.from({ length: u }, (d, p) => Ott(p, n, i));
  let h = 0;
  for (let d = 0; d < o; ++d) {
    const p = d + 0.5;
    for (let y = 0; y < s; ++y) {
      const m = y + s * d;
      if (!t[m]) {
        const g = y + 0.5;
        for (let b = 0; b < u; ++b) {
          const w = (u + h + (b % 2 ? (b + 1) / 2 : -b / 2)) % u;
          if (f[w](g, p)) {
            const v = Btt(n.at(w - 1), i.at(w - 1), n[w], i[w], g, p);
            e[m] = l(r.at(w - 1), v, r[w], 1 - v, r[w], 0, y, d), h = w;
            break;
          }
        }
      }
    }
  }
}
function Btt(e, t, n, i, r, s) {
  const o = n - e, a = i - t, c = o * (n - r) + a * (i - s), l = o * (r - e) + a * (s - t);
  return c > 0 && l > 0 ? c / (c + l) : +(c > l);
}
function Nl(e, t, n, i) {
  return e * i - n * t;
}
function Ott(e, t, n) {
  const i = t.length, r = t.at(e - 2), s = n.at(e - 2), o = t.at(e - 1), a = n.at(e - 1), c = t[e], l = n[e], u = t.at(e + 1 - i), f = n.at(e + 1 - i), h = o - c, d = a - l, p = r - o, y = s - a, m = c - u, g = l - f, b = Math.hypot(h, d), w = Math.hypot(p, y), v = Math.hypot(m, g);
  return (S, _) => {
    const I = S - o, T = _ - a, M = S - c, N = _ - l;
    return Nl(I, T, M, N) > -1e-6 && Nl(I, T, h, d) * w - Nl(I, T, p, y) * b > -1e-6 && Nl(M, N, m, g) * b - Nl(M, N, h, d) * v <= 0;
  };
}
function Tv(e, t, n, i, r, s) {
  const o = new s.constructor(t * n), a = oo.from(
    e,
    (u) => i[u],
    (u) => r[u]
  );
  let c, l;
  for (let u = 0.5, f = 0; u < n; ++u) {
    l = c;
    for (let h = 0.5; h < t; ++h, ++f)
      l = a.find(h, u, l), h === 0.5 && (c = l), o[f] = s[e[l]];
  }
  return o;
}
function Dv({ random: e = cw(42), minDistance: t = 0.5, maxSteps: n = 2 } = {}) {
  return (i, r, s, o, a, c) => {
    const l = new c.constructor(r * s), u = oo.from(
      i,
      (p) => o[p],
      (p) => a[p]
    );
    let f, h, d;
    for (let p = 0.5, y = 0; p < s; ++p) {
      h = f;
      for (let m = 0.5; m < r; ++m, ++y) {
        let g = m, b = p;
        d = h = u.find(g, b, h), m === 0.5 && (f = h);
        let w, v = 0;
        for (; (w = Math.hypot(o[i[d]] - g, a[i[d]] - b)) > t && v < n; ) {
          const S = e(m, p, v) * 2 * Math.PI;
          g += Math.cos(S) * w, b += Math.sin(S) * w, d = u.find(g, b, d), ++v;
        }
        l[y] = c[i[d]];
      }
    }
    return l;
  };
}
function Ftt(e, t, n, i, r, s) {
  return t * e + i * n + s * r;
}
function Ett(e) {
  return (t, n, i, r, s, o, a, c) => {
    const l = e(a, c);
    return l < n ? t : l < n + r ? i : s;
  };
}
function Ltt(e, t) {
  return nc(e) || gn(e) ? Ftt : Ett(t);
}
function Rtt(e, t, n) {
  return {
    transform(i) {
      const r = i.length, s = new Float64Array(r), o = (t - e) / n, a = e + o / 2;
      for (let c = 0; c < r; ++c)
        s[c] = c % n * o + a;
      return s;
    }
  };
}
function Ctt(e, t, n, i) {
  return {
    transform(r) {
      const s = r.length, o = new Float64Array(s), a = (t - e) / i, c = e + a / 2;
      for (let l = 0; l < s; ++l)
        o[l] = Math.floor(l / n) % i * a + c;
      return o;
    }
  };
}
const Lx = {
  ariaLabel: "contour",
  fill: "none",
  stroke: "currentColor",
  strokeMiterlimit: 1,
  pixelSize: 2
};
class H4 extends q4 {
  constructor(t, { smooth: n = !0, value: i, ...r } = {}) {
    const s = r8({}, r, Lx);
    if (i === void 0) {
      for (const a in s)
        if (s[a].value != null) {
          if (i !== void 0)
            throw new Error("ambiguous contour value");
          i = r[a], r[a] = "value";
        }
    }
    if (i != null) {
      const a = { transform: (c) => c.map((l) => l.value), label: wr(i) };
      for (const c in s)
        r[c] === "value" && (r[c] = a);
    }
    if (t == null) {
      if (i == null)
        throw new Error("missing contour value");
      r = k1("value", { value: i, ...r }), i = null;
    } else {
      let { interpolate: a } = r;
      i === void 0 && (i = Tt), a === void 0 && (r.interpolate = "nearest");
    }
    super(t, { value: { value: i, optional: !0 } }, ktt(r), Lx);
    const o = { geometry: { value: Tt } };
    for (const a in this.channels) {
      const c = this.channels[a], { scale: l } = c;
      l === "x" || l === "y" || a === "value" || (o[a] = c, delete this.channels[a]);
    }
    this.contourChannels = o, this.smooth = !!n;
  }
  filter(t, { x: n, y: i, value: r, ...s }, o) {
    return super.filter(t, s, o);
  }
  render(t, n, i, r, s) {
    const { geometry: o } = i, a = ao();
    return Gt("svg:g", s).call(ve, this, r, s).call(ue, this, n).call((c) => {
      c.selectAll().data(t).enter().append("path").call(be, this).attr("d", (l) => a(o[l])).call(Pe, this, i);
    }).node();
  }
}
function ktt({ thresholds: e, interval: t, ...n }) {
  return e = y4(e, t, Vb), Bn(n, function(i, r, s, o, a, c) {
    const [l, u, f, h] = X4(s, o, a, c), d = f - l, p = h - u, { pixelSize: y, width: m = Math.round(Math.abs(d) / y), height: g = Math.round(Math.abs(p) / y) } = this, b = m / d, w = g / p, v = s.value.value, S = [];
    if (this.interpolate) {
      const { x: N, y: A } = $0(s, o, c), B = ye(N, (D) => (D - l) * b, Float64Array), R = ye(A, (D) => (D - u) * w, Float64Array), x = [s.x, s.y, s.value], $ = [B, R, v];
      for (const D of r) {
        const L = this.filter(D, x, $);
        S.push(this.interpolate(L, m, g, B, R, v));
      }
    } else if (r) {
      const N = m * g, A = r.length;
      for (let B = 0; B < A; ++B)
        S.push(v.slice(B * N, B * N + N));
    } else
      S.push(v);
    if (this.blur > 0)
      for (const N of S)
        iM({ data: N, width: m, height: g }, this.blur);
    const _ = Utt(e, v, ...Ptt(S));
    if (_ === null)
      throw new Error(`unsupported thresholds: ${e}`);
    const { contour: I } = rp().size([m, g]).smooth(this.smooth), T = [], M = [];
    for (const N of S)
      M.push(kn(T.length, T.push(...ye(_, (A) => I(N, A)))));
    for (const { coordinates: N } of T)
      for (const A of N)
        for (const B of A)
          for (const R of B)
            R[0] = R[0] / b + l, R[1] = R[1] / w + u;
    return {
      data: T,
      facets: M,
      channels: BD(this.contourChannels, T)
    };
  });
}
function Utt(e, t, n, i) {
  if (typeof (e == null ? void 0 : e.range) == "function")
    return e.range(e.floor(n), i);
  if (typeof e == "function" && (e = e(t, n, i)), typeof e != "number")
    return Nn(e);
  const r = Ys(...lM(n, i, e), e);
  for (; r[r.length - 1] >= i; )
    r.pop();
  for (; r[1] < n; )
    r.shift();
  return r;
}
function ztt() {
  return new H4(...W4("value", ...arguments));
}
function Ptt(e) {
  return [Ye(e, (t) => Ye(t, Rx)), De(e, (t) => De(t, Rx))];
}
function Rx(e) {
  return isFinite(e) ? e : NaN;
}
function Vtt(e, t) {
  return Nv(Qw, e, t);
}
function jtt(e, t = {}) {
  return Nv(tv, e, t);
}
function qtt(e, t = {}) {
  return Nv(qp, e, t);
}
function Nv(e, t, n = {}) {
  const { x: i, y: r, maxRadius: s } = n, o = e({ px: i, py: r, maxRadius: s }), a = [];
  i != null && a.push(Js(t, Cx("x", { ...o, inset: -6 }, n))), r != null && a.push(Ks(t, Cx("y", { ...o, inset: -6 }, n))), i != null && a.push(Pc(t, kx("x", { ...o, dy: 9, frameAnchor: "bottom", lineAnchor: "top" }, n))), r != null && a.push(Pc(t, kx("y", { ...o, dx: -9, frameAnchor: "left", textAnchor: "end" }, n)));
  for (const c of a)
    c.ariaLabel = `crosshair ${c.ariaLabel}`;
  return fi(...a);
}
function J4(e, { channels: t, ...n }, { facet: i, facetAnchor: r, fx: s, fy: o, [e]: a, channels: c, transform: l, initializer: u }) {
  return {
    ...n,
    facet: i,
    facetAnchor: r,
    fx: s,
    fy: o,
    [e]: a,
    channels: { ...t, ...c },
    transform: l,
    initializer: Ytt(e, u)
  };
}
function Ytt(e, t) {
  return t == null ? t : function(n, i, { x: r, y: s, px: o, py: a, ...c }, ...l) {
    const { channels: { x: u, y: f, ...h } = {}, ...d } = t.call(this, n, i, { ...c, x: o, y: a }, ...l);
    return {
      channels: {
        ...h,
        ...u && { px: u, ...e === "x" && { x: u } },
        ...f && { py: f, ...e === "y" && { y: f } }
      },
      ...d
    };
  };
}
function Cx(e, t, n) {
  const {
    color: i = "currentColor",
    opacity: r = 0.2,
    ruleStroke: s = i,
    ruleStrokeOpacity: o = r,
    ruleStrokeWidth: a
  } = n;
  return {
    ...J4(e, t, n),
    stroke: s,
    strokeOpacity: o,
    strokeWidth: a
  };
}
function kx(e, t, n) {
  const {
    color: i = "currentColor",
    textFill: r = i,
    textFillOpacity: s,
    textStroke: o = "var(--plot-background)",
    textStrokeOpacity: a,
    textStrokeWidth: c = 5
  } = n;
  return {
    ...J4(e, t, Wtt(e, n)),
    fill: r,
    fillOpacity: s,
    stroke: o,
    strokeOpacity: a,
    strokeWidth: c
  };
}
function Wtt(e, t) {
  return Bn(t, (n, i, r) => {
    var s;
    return { channels: { text: { value: (s = T1(r, e)) == null ? void 0 : s.value } } };
  });
}
const Gtt = {
  ariaLabel: "delaunay link",
  fill: "none",
  stroke: "currentColor",
  strokeMiterlimit: 1
}, Xtt = {
  ariaLabel: "delaunay mesh",
  fill: null,
  stroke: "currentColor",
  strokeOpacity: 0.2
}, Htt = {
  ariaLabel: "hull",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 1.5,
  strokeMiterlimit: 1
}, Jtt = {
  ariaLabel: "voronoi",
  fill: "none",
  stroke: "currentColor",
  strokeMiterlimit: 1
}, Ktt = {
  ariaLabel: "voronoi mesh",
  fill: null,
  stroke: "currentColor",
  strokeOpacity: 0.2
};
class Ztt extends fe {
  constructor(t, n = {}) {
    const { x: i, y: r, z: s, curve: o, tension: a } = n;
    super(
      t,
      {
        x: { value: i, scale: "x", optional: !0 },
        y: { value: r, scale: "y", optional: !0 },
        z: { value: s, optional: !0 }
      },
      n,
      Gtt
    ), this.curve = uv(o, a), cl(this, n);
  }
  render(t, n, i, r, s) {
    const { x: o, y: a } = n, { x: c, y: l, z: u } = i, { curve: f } = this, [h, d] = _r(this, r), p = c ? (b) => c[b] : qn(h), y = l ? (b) => l[b] : qn(d), m = this;
    function g(b) {
      let w = -1;
      const v = [], S = {};
      for (const x in i)
        S[x] = [];
      const _ = [], I = [], T = [], M = [];
      function N(x, $) {
        x = b[x], $ = b[$], v.push(++w), _[w] = p(x), T[w] = y(x), I[w] = p($), M[w] = y($);
        for (const D in i)
          S[D].push(i[D][$]);
      }
      const { halfedges: A, hull: B, triangles: R } = oo.from(b, p, y);
      for (let x = 0; x < A.length; ++x) {
        const $ = A[x];
        $ > x && N(R[x], R[$]);
      }
      for (let x = 0; x < B.length; ++x)
        N(B[x], B[(x + 1) % B.length]);
      ce(this).selectAll().data(v).enter().append("path").call(be, m).attr("d", (x) => {
        const $ = Xr(), D = f($);
        return D.lineStart(), D.point(_[x], T[x]), D.point(I[x], M[x]), D.lineEnd(), $;
      }).call(Pe, m, S).call(Pf, m, S, s);
    }
    return Gt("svg:g", s).call(ve, this, r, s).call(ue, this, { x: c && o, y: l && a }).call(
      u ? (b) => b.selectAll().data(fs(t, (w) => u[w]).values()).enter().append("g").each(g) : (b) => b.datum(t).each(g)
    ).node();
  }
}
class Bv extends fe {
  constructor(t, n = {}, i, r = ({ z: s }) => s) {
    const { x: s, y: o } = n;
    super(
      t,
      {
        x: { value: s, scale: "x", optional: !0 },
        y: { value: o, scale: "y", optional: !0 },
        z: { value: r(n), optional: !0 }
      },
      n,
      i
    );
  }
  render(t, n, i, r, s) {
    const { x: o, y: a } = n, { x: c, y: l, z: u } = i, [f, h] = _r(this, r), d = c ? (g) => c[g] : qn(f), p = l ? (g) => l[g] : qn(h), y = this;
    function m(g) {
      const b = oo.from(g, d, p);
      ce(this).append("path").datum(g[0]).call(be, y).attr("d", y._render(b, r)).call(Pe, y, i);
    }
    return Gt("svg:g", s).call(ve, this, r, s).call(ue, this, { x: c && o, y: l && a }).call(
      u ? (g) => g.selectAll().data(fs(t, (b) => u[b]).values()).enter().append("g").each(m) : (g) => g.datum(t).each(m)
    ).node();
  }
}
class Qtt extends Bv {
  constructor(t, n = {}) {
    super(t, n, Xtt), this.fill = "none";
  }
  _render(t) {
    return t.render();
  }
}
class tet extends Bv {
  constructor(t, n = {}) {
    super(t, n, Htt, lo);
  }
  _render(t) {
    return t.renderHull();
  }
}
class eet extends fe {
  constructor(t, n = {}) {
    const { x: i, y: r, z: s } = n;
    super(
      t,
      {
        x: { value: i, scale: "x", optional: !0 },
        y: { value: r, scale: "y", optional: !0 },
        z: { value: s, optional: !0 }
      },
      n,
      Jtt
    );
  }
  render(t, n, i, r, s) {
    const { x: o, y: a } = n, { x: c, y: l, z: u } = i, [f, h] = _r(this, r), d = c ? (g) => c[g] : qn(f), p = l ? (g) => l[g] : qn(h), y = this;
    function m(g) {
      const b = oo.from(g, d, p), w = K4(b, r);
      ce(this).selectAll().data(g).enter().append("path").call(be, y).attr("d", (v, S) => w.renderCell(S)).call(Pe, y, i);
    }
    return Gt("svg:g", s).call(ve, this, r, s).call(ue, this, { x: c && o, y: l && a }).call(
      u ? (g) => g.selectAll().data(fs(t, (b) => u[b]).values()).enter().append("g").each(m) : (g) => g.datum(t).each(m)
    ).node();
  }
}
class net extends Bv {
  constructor(t, n) {
    super(t, n, Ktt), this.fill = "none";
  }
  _render(t, n) {
    return K4(t, n).render();
  }
}
function K4(e, t) {
  const { width: n, height: i, marginTop: r, marginRight: s, marginBottom: o, marginLeft: a } = t;
  return e.voronoi([a, r, n - s, i - o]);
}
function qf(e, t, { x: n, y: i, ...r } = {}) {
  return [n, i] = ki(n, i), new e(t, { ...r, x: n, y: i });
}
function iet(e, t) {
  return qf(Ztt, e, t);
}
function ret(e, t) {
  return qf(Qtt, e, t);
}
function set(e, t) {
  return qf(tet, e, t);
}
function oet(e, t) {
  return qf(eet, e, t);
}
function aet(e, t) {
  return qf(net, e, t);
}
const cet = {
  ariaLabel: "density",
  fill: "none",
  stroke: "currentColor",
  strokeMiterlimit: 1
};
class Z4 extends fe {
  constructor(t, { x: n, y: i, z: r, weight: s, fill: o, stroke: a, ...c } = {}) {
    const l = Ux(o) && (o = "currentColor", !0), u = Ux(a) && (a = "currentColor", !0);
    super(
      t,
      {
        x: { value: n, scale: "x", optional: !0 },
        y: { value: i, scale: "y", optional: !0 },
        z: { value: lo({ z: r, fill: o, stroke: a }), optional: !0 },
        weight: { value: s, optional: !0 }
      },
      het({ ...c, fill: o, stroke: a }, l, u),
      cet
    ), l && (this.fill = void 0), u && (this.stroke = void 0), this.z = r;
  }
  filter(t) {
    return t;
  }
  render(t, n, i, r, s) {
    const { contours: o } = i, a = ao();
    return Gt("svg:g", s).call(ve, this, r, s).call(ue, this, {}).call(
      (c) => c.selectAll().data(t).enter().append("path").call(be, this).call(Pe, this, i).attr("d", (l) => a(o[l]))
    ).node();
  }
}
function uet(e, { x: t, y: n, ...i } = {}) {
  return [t, n] = ki(t, n), new Z4(e, { ...i, x: t, y: n });
}
const fet = /* @__PURE__ */ new Set(["x", "y", "z", "weight"]);
function het(e, t, n) {
  let { bandwidth: r, thresholds: s } = e;
  return r = r === void 0 ? 20 : +r, s = s === void 0 ? 20 : typeof (s == null ? void 0 : s[Symbol.iterator]) == "function" ? An(s) : +s, Bn(e, function(o, a, c, l, u, f) {
    var R;
    const h = c.weight ? An(c.weight.value) : null, d = (R = c.z) == null ? void 0 : R.value, { z: p } = this, [y, m] = _r(this, u), { width: g, height: b } = u, { x: w, y: v } = $0(c, l, f), S = Object.fromEntries(
      Object.entries(c).filter(([x]) => !fet.has(x)).map(([x, $]) => [x, { ...$, value: [] }])
    ), _ = t && [], I = n && [], T = sY().x(w ? (x) => w[x] : y).y(v ? (x) => v[x] : m).weight(h ? (x) => h[x] : 1).size([g, b]).bandwidth(r), M = [];
    for (const x of a) {
      const $ = [];
      M.push($);
      for (const D of d ? Xw(x, d, p) : [x]) {
        const L = T.contours(D);
        $.push([D, L]);
      }
    }
    let N = s;
    if (!(N instanceof Uc)) {
      let x = 0;
      for (const $ of M)
        for (const [, D] of $) {
          const L = D.max;
          L > x && (x = L);
        }
      N = Float64Array.from({ length: s - 1 }, ($, D) => x * 100 * (D + 1) / s);
    }
    const A = [], B = [];
    for (const x of M) {
      const $ = [];
      A.push($);
      for (const [D, L] of x)
        for (const k of N) {
          $.push(B.length), B.push(L(k / 100)), _ && _.push(k), I && I.push(k);
          for (const U in S)
            S[U].value.push(c[U].value[D[0]]);
        }
    }
    return _ && _.push(0), I && I.push(0), {
      data: o,
      facets: A,
      channels: {
        ...S,
        ..._ && { fill: { value: _, scale: "color" } },
        ...I && { stroke: { value: I, scale: "color" } },
        contours: { value: B }
      }
    };
  });
}
function Ux(e) {
  return /^density$/i.test(e);
}
function det(e, {
  x1: t,
  x2: n,
  y1: i,
  y2: r,
  x: s = t === void 0 && n === void 0 ? vn : void 0,
  y: o = i === void 0 && r === void 0 ? Tt : void 0,
  fill: a,
  // ignored
  positiveFill: c = "#3ca951",
  negativeFill: l = "#4269d0",
  fillOpacity: u = 1,
  positiveFillOpacity: f = u,
  negativeFillOpacity: h = u,
  stroke: d,
  strokeOpacity: p,
  z: y = mn(d)[0],
  clip: m,
  // optional additional clip for area
  tip: g,
  render: b,
  ...w
} = {}) {
  return [t, n] = zx(s, t, n), [i, r] = zx(o, i, r), t === n && i === r && (i = Is(0)), { tip: g } = fa({ tip: g }, "x"), fi(
    we(c) ? null : Object.assign(
      R1(e, {
        x1: t,
        x2: n,
        y1: i,
        y2: r,
        z: y,
        fill: c,
        fillOpacity: f,
        render: jp(b, Px(!0)),
        clip: m,
        ...w
      }),
      { ariaLabel: "positive difference" }
    ),
    we(l) ? null : Object.assign(
      R1(e, {
        x1: t,
        x2: n,
        y1: i,
        y2: r,
        z: y,
        fill: l,
        fillOpacity: h,
        render: jp(b, Px(!1)),
        clip: m,
        ...w
      }),
      { ariaLabel: "negative difference" }
    ),
    P0(e, {
      x: n,
      y: r,
      z: y,
      stroke: d,
      strokeOpacity: p,
      tip: g,
      clip: !0,
      ...w
    })
  );
}
function zx(e, t, n) {
  return t === void 0 && n === void 0 ? t = n = Is(e) : t === void 0 ? (n = Is(n), t = e === void 0 ? n : Is(e)) : n === void 0 ? (t = Is(t), n = e === void 0 ? t : Is(e)) : (t = Is(t), n = Is(n)), [t, n];
}
function Is(e) {
  let t;
  const { value: n, label: i = wr(n) } = al(e);
  return { transform: (r) => t || (t = Pt(r, n)), label: i };
}
function Px(e) {
  return (t, n, i, r, s, o) => {
    const { x1: a, x2: c } = i, { height: l } = r, u = new Float32Array(a.length), f = new Float32Array(c.length);
    (e === JD(n.y) < 0 ? u : f).fill(l);
    const h = o(t, n, { ...i, x2: a, y2: f }, r, s), d = o(t, n, { ...i, x1: c, y1: u }, r, s), p = h.querySelector("g") ?? h, y = d.querySelector("g") ?? d;
    for (let m = 0; p.firstChild; m += 2) {
      const g = F1(), b = Gt("svg:clipPath", s).attr("id", g).node();
      b.appendChild(p.firstChild), y.childNodes[m].setAttribute("clip-path", `url(#${g})`), y.insertBefore(b, y.childNodes[m]);
    }
    return d;
  };
}
const pet = {
  ariaLabel: "geo",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 1,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeMiterlimit: 1
};
class Q4 extends fe {
  constructor(t, n = {}) {
    const [i, r] = Be(n.r, 3);
    super(
      t,
      {
        geometry: { value: n.geometry, scale: "projection" },
        r: { value: i, scale: "r", filter: Qr, optional: !0 }
      },
      _v(n),
      pet
    ), this.r = r;
  }
  render(t, n, i, r, s) {
    const { geometry: o, r: a } = i, c = ao(s.projection ?? yet(n)), { r: l } = this;
    return m0(l) ? t = [] : l !== void 0 && c.pointRadius(l), Gt("svg:g", s).call(ve, this, r, s).call(ue, this, n).call((u) => {
      u.selectAll().data(t).enter().append("path").call(be, this).attr("d", a ? (f) => c.pointRadius(a[f])(o[f]) : (f) => c(o[f])).call(Pe, this, i);
    }).node();
  }
}
function yet({ x: e, y: t }) {
  if (e || t)
    return e ?? (e = (n) => n), t ?? (t = (n) => n), Ip({
      point(n, i) {
        this.stream.point(e(n), t(i));
      }
    });
}
function Ov(e, { geometry: t = Tt, ...n } = {}) {
  switch (e == null ? void 0 : e.type) {
    case "FeatureCollection":
      e = e.features;
      break;
    case "GeometryCollection":
      e = e.geometries;
      break;
    case "Feature":
    case "LineString":
    case "MultiLineString":
    case "MultiPoint":
    case "MultiPolygon":
    case "Point":
    case "Polygon":
    case "Sphere":
      e = [e];
      break;
  }
  return new Q4(e, { geometry: t, ...n });
}
function met({ strokeWidth: e = 1.5, ...t } = {}) {
  return Ov({ type: "Sphere" }, { strokeWidth: e, ...t });
}
function get({ strokeOpacity: e = 0.1, ...t } = {}) {
  return Ov(tW(), { strokeOpacity: e, ...t });
}
const yu = 0.5, mu = 0;
function bet(e = { fill: "count" }, { binWidth: t, ...n } = {}) {
  const { z: i } = n;
  return t = t === void 0 ? 20 : qt(t), e = AD(e, n), Cs(e, "fill") && (n.channels = { ...n.channels, fill: { value: [] } }), n.symbol === void 0 && (n.symbol = "hexagon"), n.r === void 0 && !Cs(e, "r") && (n.r = t / 2), Bn(n, (r, s, o, a, c, l) => {
    let { x: u, y: f, z: h, fill: d, stroke: p, symbol: y } = o;
    if (u === void 0)
      throw new Error("missing channel: x");
    if (f === void 0)
      throw new Error("missing channel: y");
    ({ x: u, y: f } = $0(o, a, l)), h = h ? h.value : Pt(r, i), d = d == null ? void 0 : d.value, p = p == null ? void 0 : p.value, y = y == null ? void 0 : y.value;
    const m = Uw(e, { z: h, fill: d, stroke: p, symbol: y }), g = h && [], b = d && [], w = p && [], v = y && [], S = [], _ = [], I = [];
    let T = -1;
    for (const B of e)
      B.initialize(r);
    for (const B of s) {
      const R = [];
      for (const x of e)
        x.scope("facet", B);
      for (const [x, $] of pc(B, m))
        for (const { index: D, extent: L } of wet(r, $, u, f, t)) {
          R.push(++T), _.push(L.x), I.push(L.y), h && g.push(m === h ? x : h[D[0]]), d && b.push(m === d ? x : d[D[0]]), p && w.push(m === p ? x : p[D[0]]), y && v.push(m === y ? x : y[D[0]]);
          for (const k of e)
            k.reduce(D, L);
        }
      S.push(R);
    }
    const M = o.x.scale, N = o.y.scale, A = {
      x: { value: _, source: a[M] ? { value: ye(_, a[M].invert), scale: M } : null },
      y: { value: I, source: a[N] ? { value: ye(I, a[N].invert), scale: N } : null },
      ...h && { z: { value: g } },
      ...d && { fill: { value: b, scale: "auto" } },
      ...p && { stroke: { value: w, scale: "auto" } },
      ...y && { symbol: { value: v, scale: "auto" } },
      ...Object.fromEntries(
        e.map(({ name: B, output: R }) => [
          B,
          {
            scale: "auto",
            label: R.label,
            radius: B === "r" ? t / 2 : void 0,
            value: R.transform()
          }
        ])
      )
    };
    return { data: r, facets: S, channels: A };
  });
}
function wet(e, t, n, i, r) {
  const s = r * (1.5 / vD), o = /* @__PURE__ */ new Map();
  for (const a of t) {
    let c = n[a], l = i[a];
    if (isNaN(c) || isNaN(l))
      continue;
    let u = Math.round(l = (l - mu) / s), f = Math.round(c = (c - yu) / r - (u & 1) / 2), h = l - u;
    if (Math.abs(h) * 3 > 1) {
      let y = c - f, m = f + (c < f ? -1 : 1) / 2, g = u + (l < u ? -1 : 1), b = c - m, w = l - g;
      y * y + h * h > b * b + w * w && (f = m + (u & 1 ? 1 : -1) / 2, u = g);
    }
    const d = `${f},${u}`;
    let p = o.get(d);
    p === void 0 && (p = { index: [], extent: { data: e, x: (f + (u & 1) / 2) * r + yu, y: u * s + mu } }, o.set(d, p)), p.index.push(a);
  }
  return o.values();
}
const vet = {
  ariaLabel: "hexgrid",
  fill: "none",
  stroke: "currentColor",
  strokeOpacity: 0.1
};
function _et(e) {
  return new tN(e);
}
class tN extends fe {
  constructor({ binWidth: t = 20, clip: n = !0, ...i } = {}) {
    super(pu, void 0, { clip: n, ...i }, vet), this.binWidth = qt(t);
  }
  render(t, n, i, r, s) {
    const { binWidth: o } = this, { marginTop: a, marginRight: c, marginBottom: l, marginLeft: u, width: f, height: h } = r, d = u - yu, p = f - c - yu, y = a - mu, m = h - l - mu, g = o / 2, b = g * _D, w = b / 2, v = g * 2, S = b * 1.5, _ = Math.floor(d / v), I = Math.ceil(p / v), T = Math.floor((y + w) / S), M = Math.ceil((m - w) / S) + 1, N = `m0,${vs(-b)}l${vs(g)},${vs(w)}v${vs(b)}l${vs(-g)},${vs(w)}`;
    let A = N;
    for (let B = T; B < M; ++B)
      for (let R = _; R < I; ++R)
        A += `M${vs(R * v + (B & 1) * g)},${vs(B * S)}${N}`;
    return Gt("svg:g", s).datum(0).call(ve, this, r, s).call(ue, this, {}, He + yu, He + mu).call((B) => B.append("path").call(be, this).call(Pe, this, i).attr("d", A)).node();
  }
}
function vs(e) {
  return Math.round(e * 1e3) / 1e3;
}
const xet = {
  ariaLabel: "image",
  fill: null,
  stroke: null
};
function Iet(e) {
  return /^\.*\//.test(e);
}
function Aet(e) {
  return /^(blob|data|file|http|https):/i.test(e);
}
function Met(e) {
  return typeof e == "string" && (Iet(e) || Aet(e)) ? [void 0, e] : [e, void 0];
}
class eN extends fe {
  constructor(t, n = {}) {
    let { x: i, y: r, r: s, width: o, height: a, rotate: c, src: l, preserveAspectRatio: u, crossOrigin: f, frameAnchor: h, imageRendering: d } = n;
    s == null && (s = void 0), s === void 0 && o === void 0 && a === void 0 ? o = a = 16 : o === void 0 && a !== void 0 ? o = a : a === void 0 && o !== void 0 && (a = o);
    const [p, y] = Met(l), [m, g] = Be(s), [b, w] = Be(o, g !== void 0 ? g * 2 : void 0), [v, S] = Be(a, g !== void 0 ? g * 2 : void 0), [_, I] = Be(c, 0);
    super(
      t,
      {
        x: { value: i, scale: "x", optional: !0 },
        y: { value: r, scale: "y", optional: !0 },
        r: { value: m, scale: "r", filter: Qr, optional: !0 },
        width: { value: b, filter: Qr, optional: !0 },
        height: { value: v, filter: Qr, optional: !0 },
        rotate: { value: _, optional: !0 },
        src: { value: p, optional: !0 }
      },
      _v(n),
      xet
    ), this.src = y, this.width = w, this.rotate = I, this.height = S, this.r = g, this.preserveAspectRatio = Me(u, "xMidYMid"), this.crossOrigin = tn(f), this.frameAnchor = Lf(h), this.imageRendering = Me(d, "auto");
  }
  render(t, n, i, r, s) {
    const { x: o, y: a } = n, { x: c, y: l, width: u, height: f, r: h, rotate: d, src: p } = i, { r: y, width: m, height: g, rotate: b } = this, [w, v] = _r(this, r);
    return Gt("svg:g", s).call(ve, this, r, s).call(ue, this, { x: c && o, y: l && a }).call(
      (S) => S.selectAll().data(t).enter().append("image").call(be, this).attr("x", Vx(c, u, h, w, m, y)).attr("y", Vx(l, f, h, v, g, y)).attr("width", u ? (_) => u[_] : m !== void 0 ? m : h ? (_) => h[_] * 2 : y * 2).attr("height", f ? (_) => f[_] : g !== void 0 ? g : h ? (_) => h[_] * 2 : y * 2).attr("transform", d ? (_) => `rotate(${d[_]})` : b ? `rotate(${b})` : null).attr("transform-origin", d || b ? O0`${c ? (_) => c[_] : w}px ${l ? (_) => l[_] : v}px` : null).call(mt, "href", p ? (_) => p[_] : this.src).call(mt, "preserveAspectRatio", this.preserveAspectRatio).call(mt, "crossorigin", this.crossOrigin).call(mt, "image-rendering", this.imageRendering).call(mt, "clip-path", h ? (_) => `circle(${h[_]}px)` : y !== void 0 ? `circle(${y}px)` : null).call(Pe, this, i)
    ).node();
  }
}
function Vx(e, t, n, i, r, s) {
  return t && e ? (o) => e[o] - t[o] / 2 : t ? (o) => i - t[o] / 2 : e && r !== void 0 ? (o) => e[o] - r / 2 : r !== void 0 ? i - r / 2 : n && e ? (o) => e[o] - n[o] : n ? (o) => i - n[o] : e ? (o) => e[o] - s : i - s;
}
function $et(e, { x: t, y: n, ...i } = {}) {
  return i.frameAnchor === void 0 && ([t, n] = ki(t, n)), new eN(e, { ...i, x: t, y: n });
}
function Tet(e, t, n) {
  var i = 1e-8, r = t - 1, s = n - 1, o = 0, a, c, l, u, f, h, d, p, y, m, g;
  if (e <= 0)
    return 0;
  if (e >= 1)
    return 1;
  for (t >= 1 && n >= 1 ? (l = e < 0.5 ? e : 1 - e, u = Math.sqrt(-2 * Math.log(l)), d = (2.30753 + u * 0.27061) / (1 + u * (0.99229 + u * 0.04481)) - u, e < 0.5 && (d = -d), p = (d * d - 3) / 6, y = 2 / (1 / (2 * t - 1) + 1 / (2 * n - 1)), m = d * Math.sqrt(p + y) / y - (1 / (2 * n - 1) - 1 / (2 * t - 1)) * (p + 5 / 6 - 2 / (3 * y)), d = t / (t + n * Math.exp(2 * m))) : (a = Math.log(t / (t + n)), c = Math.log(n / (t + n)), u = Math.exp(t * a) / t, f = Math.exp(n * c) / n, m = u + f, e < u / m ? d = Math.pow(t * m * e, 1 / t) : d = 1 - Math.pow(n * m * (1 - e), 1 / n)), g = -mc(t) - mc(n) + mc(t + n); o < 10; o++) {
    if (d === 0 || d === 1)
      return d;
    if (h = Det(d, t, n) - e, u = Math.exp(r * Math.log(d) + s * Math.log(1 - d) + g), f = h / u, d -= u = f / (1 - 0.5 * Math.min(1, f * (r / d - s / (1 - d)))), d <= 0 && (d = 0.5 * (d + u)), d >= 1 && (d = 0.5 * (d + u + 1)), Math.abs(u) < i * d && o > 0)
      break;
  }
  return d;
}
function Det(e, t, n) {
  var i = e === 0 || e === 1 ? 0 : Math.exp(mc(t + n) - mc(t) - mc(n) + t * Math.log(e) + n * Math.log(1 - e));
  return e < 0 || e > 1 ? !1 : e < (t + 1) / (t + n + 2) ? i * jx(e, t, n) / t : 1 - i * jx(1 - e, n, t) / n;
}
function jx(e, t, n) {
  var i = 1e-30, r = 1, s = t + n, o = t + 1, a = t - 1, c = 1, l = 1 - s * e / o, u, f, h, d;
  for (Math.abs(l) < i && (l = i), l = 1 / l, d = l; r <= 100 && (u = 2 * r, f = r * (n - r) * e / ((a + u) * (t + u)), l = 1 + f * l, Math.abs(l) < i && (l = i), c = 1 + f / c, Math.abs(c) < i && (c = i), l = 1 / l, d *= l * c, f = -(t + r) * (s + r) * e / ((t + u) * (o + u)), l = 1 + f * l, Math.abs(l) < i && (l = i), c = 1 + f / c, Math.abs(c) < i && (c = i), l = 1 / l, h = l * c, d *= h, !(Math.abs(h - 1) < 3e-7)); r++)
    ;
  return d;
}
function mc(e) {
  var t = 0, n = [
    76.18009172947146,
    -86.5053203294167,
    24.01409824083091,
    -1.231739572450155,
    0.001208650973866179,
    -5395239384953e-18
  ], i = 1.000000000190015, r, s, o;
  for (o = (s = r = e) + 5.5, o -= (r + 0.5) * Math.log(o); t < 6; t++)
    i += n[t] / ++s;
  return Math.log(2.506628274631 * i / r) - o;
}
function Net(e, t) {
  var n = Tet(2 * Math.min(e, 1 - e), 0.5 * t, 0.5);
  return n = Math.sqrt(t * (1 - n) / n), e > 0.5 ? n : -n;
}
const Bet = {
  ariaLabel: "linear-regression",
  fill: "currentColor",
  fillOpacity: 0.1,
  stroke: "currentColor",
  strokeWidth: 1.5,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeMiterlimit: 1
};
class nN extends fe {
  constructor(t, n = {}) {
    const { x: i, y: r, z: s, ci: o = 0.95, precision: a = 4 } = n;
    if (super(
      t,
      {
        x: { value: i, scale: "x" },
        y: { value: r, scale: "y" },
        z: { value: lo(n), optional: !0 }
      },
      n,
      Bet
    ), this.z = s, this.ci = +o, this.precision = +a, !(0 <= this.ci && this.ci < 1))
      throw new Error(`invalid ci; not in [0, 1): ${o}`);
    if (!(this.precision > 0))
      throw new Error(`invalid precision: ${a}`);
  }
  render(t, n, i, r, s) {
    const { x: o, y: a, z: c } = i, { ci: l } = this;
    return Gt("svg:g", s).call(ve, this, r, s).call(ue, this, n).call(
      (u) => u.selectAll().data(c ? Xw(t, c, this.z) : [t]).enter().call(
        (f) => f.append("path").attr("fill", "none").call(be, this).call(Vp, this, { ...i, fill: null, fillOpacity: null }).attr("d", (h) => this._renderLine(h, o, a)).call(
          l && !zc(this.fill) ? (h) => h.select(Oet).attr("stroke", "none").call(be, this).call(Vp, this, {
            ...i,
            stroke: null,
            strokeOpacity: null,
            strokeWidth: null
          }).attr("d", (d) => this._renderBand(d, o, a)) : () => {
          }
        )
      )
    ).node();
  }
}
function Oet() {
  return this.parentNode.insertBefore(this.ownerDocument.createElementNS(Ko.svg, "path"), this);
}
class Fet extends nN {
  constructor(t, n) {
    super(t, n);
  }
  _renderBand(t, n, i) {
    const { ci: r, precision: s } = this, [o, a] = ke(t, (u) => i[u]), c = Zp(t, i, n), l = iN(t, i, n, (1 - r) / 2, c);
    return pw().y((u) => u).x0((u) => l(u, -1)).x1((u) => l(u, 1))(kn(o, a - s / 2, s).concat(a));
  }
  _renderLine(t, n, i) {
    const [r, s] = ke(t, (a) => i[a]), o = Zp(t, i, n);
    return `M${o(r)},${r}L${o(s)},${s}`;
  }
}
class Eet extends nN {
  constructor(t, n) {
    super(t, n);
  }
  _renderBand(t, n, i) {
    const { ci: r, precision: s } = this, [o, a] = ke(t, (u) => n[u]), c = Zp(t, n, i), l = iN(t, n, i, (1 - r) / 2, c);
    return pw().x((u) => u).y0((u) => l(u, -1)).y1((u) => l(u, 1))(kn(o, a - s / 2, s).concat(a));
  }
  _renderLine(t, n, i) {
    const [r, s] = ke(t, (a) => n[a]), o = Zp(t, n, i);
    return `M${r},${o(r)}L${s},${o(s)}`;
  }
}
function Let(e, { y: t = vn, x: n = Tt, stroke: i, fill: r = we(i) ? "currentColor" : i, ...s } = {}) {
  return new Fet(e, hv({ ...s, x: n, y: t, fill: r, stroke: i }));
}
function Ret(e, { x: t = vn, y: n = Tt, stroke: i, fill: r = we(i) ? "currentColor" : i, ...s } = {}) {
  return new Eet(e, fv({ ...s, x: t, y: n, fill: r, stroke: i }));
}
function Zp(e, t, n) {
  let i = 0, r = 0, s = 0, o = 0;
  for (const u of e) {
    const f = t[u], h = n[u];
    i += f, r += h, s += f * h, o += f * f;
  }
  const a = e.length, c = (a * s - i * r) / (a * o - i * i), l = (r - c * i) / a;
  return (u) => c * u + l;
}
function iN(e, t, n, i, r) {
  const s = fr(e, (u) => t[u]) / e.length;
  let o = 0, a = 0;
  for (const u of e)
    o += (t[u] - s) ** 2, a += (n[u] - r(t[u])) ** 2;
  const c = Math.sqrt(a / (e.length - 2)), l = Net(i, e.length - 2);
  return (u, f) => {
    const h = r(u), d = c * Math.sqrt(1 / e.length + (u - s) ** 2 / o);
    return h + f * l * d;
  };
}
function z1({
  path: e = Tt,
  // the delimited path
  delimiter: t,
  // how the path is separated
  frameAnchor: n,
  treeLayout: i = Tp,
  treeSort: r,
  treeSeparation: s,
  treeAnchor: o,
  treeFilter: a,
  ...c
} = {}) {
  o = Fv(o), r = sN(r), a != null && (a = V1(a)), n === void 0 && (n = o.frameAnchor);
  const l = oN(t), u = dN(c, V1), [f, h] = zn(), [d, p] = zn();
  return {
    x: f,
    y: d,
    frameAnchor: n,
    ...vr(c, (y, m) => {
      const g = l(Pt(y, e)), b = h([]), w = p([]);
      let v = -1;
      const S = [], _ = [], I = z$().path((M) => g[M]), T = i();
      T.nodeSize && T.nodeSize([1, 1]), T.separation && s !== void 0 && T.separation(s ?? Iw);
      for (const M of u)
        M[Qp] = M[fN]([]);
      for (const M of m) {
        const N = [], A = I(M.filter((B) => g[B] != null)).each((B) => B.data = y[B.data]);
        r != null && A.sort(r), T(A);
        for (const B of A.descendants())
          if (!(a != null && !a(B))) {
            N.push(++v), S[v] = B.data, o.position(B, v, b, w);
            for (const R of u)
              R[Qp][v] = R[hN](B);
          }
        _.push(N);
      }
      return { data: S, facets: _ };
    }),
    ...Object.fromEntries(u)
  };
}
function rN({
  path: e = Tt,
  // the delimited path
  delimiter: t,
  // how the path is separated
  curve: n = "bump-x",
  stroke: i = "#555",
  strokeWidth: r = 1.5,
  strokeOpacity: s = 0.5,
  treeLayout: o = Tp,
  treeSort: a,
  treeSeparation: c,
  treeAnchor: l,
  treeFilter: u,
  ...f
} = {}) {
  l = Fv(l), a = sN(a), u != null && (u = Yx(u)), f = { curve: n, stroke: i, strokeWidth: r, strokeOpacity: s, ...f };
  const h = oN(t), d = dN(f, Yx), [p, y] = zn(), [m, g] = zn(), [b, w] = zn(), [v, S] = zn();
  return {
    x1: p,
    x2: m,
    y1: b,
    y2: v,
    ...vr(f, (_, I) => {
      const T = h(Pt(_, e)), M = y([]), N = g([]), A = w([]), B = S([]);
      let R = -1;
      const x = [], $ = [], D = z$().path((k) => T[k]), L = o();
      L.nodeSize && L.nodeSize([1, 1]), L.separation && c !== void 0 && L.separation(c ?? Iw);
      for (const k of d)
        k[Qp] = k[fN]([]);
      for (const k of I) {
        const U = [], C = D(k.filter((z) => T[z] != null)).each((z) => z.data = _[z.data]);
        a != null && C.sort(a), L(C);
        for (const { source: z, target: P } of C.links())
          if (!(u != null && !u(P, z))) {
            U.push(++R), x[R] = P.data, l.position(z, R, M, A), l.position(P, R, N, B);
            for (const G of d)
              G[Qp][R] = G[hN](P, z);
          }
        $.push(U);
      }
      return { data: x, facets: $ };
    }),
    ...Object.fromEntries(d)
  };
}
function Fv(e = "left") {
  switch (`${e}`.trim().toLowerCase()) {
    case "left":
      return Cet;
    case "right":
      return ket;
  }
  throw new Error(`invalid tree anchor: ${e}`);
}
const Cet = {
  frameAnchor: "left",
  dx: 6,
  position({ x: e, y: t }, n, i, r) {
    i[n] = t, r[n] = -e;
  }
}, ket = {
  frameAnchor: "right",
  dx: -6,
  position({ x: e, y: t }, n, i, r) {
    i[n] = -t, r[n] = -e;
  }
};
function sN(e) {
  return e == null || typeof e == "function" ? e : `${e}`.trim().toLowerCase().startsWith("node:") ? qx(V1(e)) : qx(Uet(e));
}
function qx(e) {
  return (t, n) => ui(e(t), e(n));
}
function Uet(e) {
  return (t) => {
    var n;
    return (n = t.data) == null ? void 0 : n[e];
  };
}
function oN(e = "/") {
  if (e = `${e}`, e === "/")
    return (n) => n;
  if (e.length !== 1)
    throw new Error("delimiter must be exactly one character");
  const t = e.charCodeAt(0);
  return (n) => n.map((i) => zet(i, t));
}
const P1 = 92, aN = 47;
function zet(e, t) {
  if (t === P1)
    throw new Error("delimiter cannot be backslash");
  let n = !1;
  for (let i = 0, r = e.length; i < r; ++i) {
    switch (e.charCodeAt(i)) {
      case P1:
        if (!n) {
          n = !0;
          continue;
        }
        break;
      case t:
        n ? (e = e.slice(0, i - 1) + e.slice(i), --i, --r) : e = e.slice(0, i) + "/" + e.slice(i + 1);
        break;
      case aN:
        n ? (e = e.slice(0, i) + "\\\\" + e.slice(i), i += 2, r += 2) : (e = e.slice(0, i) + "\\" + e.slice(i), ++i, ++r);
        break;
    }
    n = !1;
  }
  return e;
}
function Pet(e) {
  let t = !1;
  for (let n = 0, i = e.length; n < i; ++n) {
    switch (e.charCodeAt(n)) {
      case P1:
        if (!t) {
          t = !0;
          continue;
        }
      case aN:
        t && (e = e.slice(0, n - 1) + e.slice(n), --n, --i);
        break;
    }
    t = !1;
  }
  return e;
}
function cN(e) {
  return di(e) && typeof e.node == "function";
}
function Vet(e) {
  return di(e) && typeof e.link == "function";
}
function V1(e) {
  if (cN(e))
    return e.node;
  if (e = `${e}`.trim().toLowerCase(), !!e.startsWith("node:")) {
    switch (e) {
      case "node:name":
        return q1;
      case "node:path":
        return j1;
      case "node:internal":
        return lN;
      case "node:external":
        return uN;
      case "node:depth":
        return Y1;
      case "node:height":
        return W1;
    }
    throw new Error(`invalid node value: ${e}`);
  }
}
function Yx(e) {
  if (cN(e))
    return e.node;
  if (Vet(e))
    return e.link;
  if (e = `${e}`.trim().toLowerCase(), !(!e.startsWith("node:") && !e.startsWith("parent:"))) {
    switch (e) {
      case "parent:name":
        return Bh(q1);
      case "parent:path":
        return Bh(j1);
      case "parent:depth":
        return Bh(Y1);
      case "parent:height":
        return Bh(W1);
      case "node:name":
        return q1;
      case "node:path":
        return j1;
      case "node:internal":
        return lN;
      case "node:external":
        return uN;
      case "node:depth":
        return Y1;
      case "node:height":
        return W1;
    }
    throw new Error(`invalid link value: ${e}`);
  }
}
function j1(e) {
  return e.id;
}
function q1(e) {
  return jet(e.id);
}
function Y1(e) {
  return e.depth;
}
function W1(e) {
  return e.height;
}
function lN(e) {
  return !!e.children;
}
function uN(e) {
  return !e.children;
}
function Bh(e) {
  return (t, n) => n == null ? void 0 : e(n);
}
function jet(e) {
  let t = e.length;
  for (; --t > 0 && !qet(e, t); )
    ;
  return Pet(e.slice(t + 1));
}
function qet(e, t) {
  if (e[t] === "/") {
    let n = 0;
    for (; t > 0 && e[--t] === "\\"; )
      ++n;
    if (!(n & 1))
      return !0;
  }
  return !1;
}
const fN = 2, hN = 3, Qp = 4;
function dN(e, t) {
  const n = [];
  for (const i in e) {
    const r = e[i], s = t(r);
    s !== void 0 && n.push([i, ...zn(r), s]);
  }
  return n;
}
function pN(e, {
  fill: t,
  stroke: n,
  strokeWidth: i,
  strokeOpacity: r,
  strokeLinejoin: s,
  strokeLinecap: o,
  strokeMiterlimit: a,
  strokeDasharray: c,
  strokeDashoffset: l,
  marker: u,
  markerStart: f = u,
  markerEnd: h = u,
  dot: d = we(f) && we(h),
  text: p = "node:name",
  textStroke: y = "var(--plot-background)",
  title: m = "node:path",
  dx: g,
  dy: b,
  textAnchor: w,
  treeLayout: v = Tp,
  textLayout: S = v === Tp || v === C$ ? "mirrored" : "normal",
  tip: _,
  ...I
} = {}) {
  if (g === void 0 && (g = Fv(I.treeAnchor).dx), w !== void 0)
    throw new Error("textAnchor is not a configurable tree option");
  S = Yn(S, "textLayout", ["mirrored", "normal"]);
  function T(M) {
    return Pc(
      e,
      z1({
        treeLayout: v,
        text: p,
        fill: t === void 0 ? "currentColor" : t,
        stroke: y,
        dx: g,
        dy: b,
        title: m,
        ...M,
        ...I
      })
    );
  }
  return fi(
    $4(
      e,
      rN({
        treeLayout: v,
        markerStart: f,
        markerEnd: h,
        stroke: n !== void 0 ? n : t === void 0 ? "node:internal" : t,
        strokeWidth: i,
        strokeOpacity: r,
        strokeLinejoin: s,
        strokeLinecap: o,
        strokeMiterlimit: a,
        strokeDasharray: c,
        strokeDashoffset: l,
        ...I
      })
    ),
    d ? ho(e, z1({ treeLayout: v, fill: t === void 0 ? "node:internal" : t, title: m, tip: _, ...I })) : null,
    p != null ? S === "mirrored" ? [
      T({ textAnchor: "start", treeFilter: "node:external" }),
      T({ textAnchor: "end", treeFilter: "node:internal", dx: -g })
    ] : T() : null
  );
}
function Yet(e, t) {
  return pN(e, { ...t, treeLayout: C$ });
}
function Wet({ geometry: e = Tt, ...t } = {}) {
  return Bn({ ...t, x: null, y: null }, (n, i, r, s, o, { projection: a }) => {
    const c = Pt(n, e), l = c.length, u = new Float64Array(l), f = new Float64Array(l), h = ao(a);
    for (let d = 0; d < l; ++d)
      [u[d], f[d]] = h.centroid(c[d]);
    return {
      data: n,
      facets: i,
      channels: {
        x: { value: u, scale: a == null ? "x" : null, source: null },
        y: { value: f, scale: a == null ? "y" : null, source: null }
      }
    };
  });
}
function Get({ geometry: e = Tt, ...t } = {}) {
  let n;
  return {
    ...t,
    x: { transform: (i) => Float64Array.from(n = Pt(Pt(i, e), VY), ([r]) => r) },
    y: { transform: () => Float64Array.from(n, ([, i]) => i) }
  };
}
function Xet(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function Het(e, t, n, i, r) {
  for (var s = r + 1; i <= r; ) {
    var o = i + r >>> 1, a = e[o], c = n !== void 0 ? n(a, t) : a - t;
    c >= 0 ? (s = o, r = o - 1) : i = o + 1;
  }
  return s;
}
function Jet(e, t, n, i, r) {
  for (var s = r + 1; i <= r; ) {
    var o = i + r >>> 1, a = e[o], c = n !== void 0 ? n(a, t) : a - t;
    c > 0 ? (s = o, r = o - 1) : i = o + 1;
  }
  return s;
}
function Ket(e, t, n, i, r) {
  for (var s = i - 1; i <= r; ) {
    var o = i + r >>> 1, a = e[o], c = n !== void 0 ? n(a, t) : a - t;
    c < 0 ? (s = o, i = o + 1) : r = o - 1;
  }
  return s;
}
function Zet(e, t, n, i, r) {
  for (var s = i - 1; i <= r; ) {
    var o = i + r >>> 1, a = e[o], c = n !== void 0 ? n(a, t) : a - t;
    c <= 0 ? (s = o, i = o + 1) : r = o - 1;
  }
  return s;
}
function Qet(e, t, n, i, r) {
  for (; i <= r; ) {
    var s = i + r >>> 1, o = e[s], a = n !== void 0 ? n(o, t) : o - t;
    if (a === 0)
      return s;
    a <= 0 ? i = s + 1 : r = s - 1;
  }
  return -1;
}
function Bl(e, t, n, i, r, s) {
  return typeof n == "function" ? s(e, t, n, i === void 0 ? 0 : i | 0, r === void 0 ? e.length - 1 : r | 0) : s(e, t, void 0, n === void 0 ? 0 : n | 0, i === void 0 ? e.length - 1 : i | 0);
}
var tnt = {
  ge: function(e, t, n, i, r) {
    return Bl(e, t, n, i, r, Het);
  },
  gt: function(e, t, n, i, r) {
    return Bl(e, t, n, i, r, Jet);
  },
  lt: function(e, t, n, i, r) {
    return Bl(e, t, n, i, r, Ket);
  },
  le: function(e, t, n, i, r) {
    return Bl(e, t, n, i, r, Zet);
  },
  eq: function(e, t, n, i, r) {
    return Bl(e, t, n, i, r, Qet);
  }
}, ty = tnt, rc = 0, No = 1, od = 2, ent = int;
function Ev(e, t, n, i, r) {
  this.mid = e, this.left = t, this.right = n, this.leftPoints = i, this.rightPoints = r, this.count = (t ? t.count : 0) + (n ? n.count : 0) + i.length;
}
var Yf = Ev.prototype;
function tg(e, t) {
  e.mid = t.mid, e.left = t.left, e.right = t.right, e.leftPoints = t.leftPoints, e.rightPoints = t.rightPoints, e.count = t.count;
}
function yN(e, t) {
  var n = Yc(t);
  e.mid = n.mid, e.left = n.left, e.right = n.right, e.leftPoints = n.leftPoints, e.rightPoints = n.rightPoints, e.count = n.count;
}
function Wx(e, t) {
  var n = e.intervals([]);
  n.push(t), yN(e, n);
}
function Gx(e, t) {
  var n = e.intervals([]), i = n.indexOf(t);
  return i < 0 ? rc : (n.splice(i, 1), yN(e, n), No);
}
Yf.intervals = function(e) {
  return e.push.apply(e, this.leftPoints), this.left && this.left.intervals(e), this.right && this.right.intervals(e), e;
};
Yf.insert = function(e) {
  var t = this.count - this.leftPoints.length;
  if (this.count += 1, e[1] < this.mid)
    this.left ? 4 * (this.left.count + 1) > 3 * (t + 1) ? Wx(this, e) : this.left.insert(e) : this.left = Yc([e]);
  else if (e[0] > this.mid)
    this.right ? 4 * (this.right.count + 1) > 3 * (t + 1) ? Wx(this, e) : this.right.insert(e) : this.right = Yc([e]);
  else {
    var n = ty.ge(this.leftPoints, e, Lv), i = ty.ge(this.rightPoints, e, Rv);
    this.leftPoints.splice(n, 0, e), this.rightPoints.splice(i, 0, e);
  }
};
Yf.remove = function(e) {
  var t = this.count - this.leftPoints;
  if (e[1] < this.mid) {
    if (!this.left)
      return rc;
    var n = this.right ? this.right.count : 0;
    if (4 * n > 3 * (t - 1))
      return Gx(this, e);
    var i = this.left.remove(e);
    return i === od ? (this.left = null, this.count -= 1, No) : (i === No && (this.count -= 1), i);
  } else if (e[0] > this.mid) {
    if (!this.right)
      return rc;
    var r = this.left ? this.left.count : 0;
    if (4 * r > 3 * (t - 1))
      return Gx(this, e);
    var i = this.right.remove(e);
    return i === od ? (this.right = null, this.count -= 1, No) : (i === No && (this.count -= 1), i);
  } else {
    if (this.count === 1)
      return this.leftPoints[0] === e ? od : rc;
    if (this.leftPoints.length === 1 && this.leftPoints[0] === e) {
      if (this.left && this.right) {
        for (var s = this, o = this.left; o.right; )
          s = o, o = o.right;
        if (s === this)
          o.right = this.right;
        else {
          var a = this.left, i = this.right;
          s.count -= o.count, s.right = o.left, o.left = a, o.right = i;
        }
        tg(this, o), this.count = (this.left ? this.left.count : 0) + (this.right ? this.right.count : 0) + this.leftPoints.length;
      } else
        this.left ? tg(this, this.left) : tg(this, this.right);
      return No;
    }
    for (var a = ty.ge(this.leftPoints, e, Lv); a < this.leftPoints.length && this.leftPoints[a][0] === e[0]; ++a)
      if (this.leftPoints[a] === e) {
        this.count -= 1, this.leftPoints.splice(a, 1);
        for (var i = ty.ge(this.rightPoints, e, Rv); i < this.rightPoints.length && this.rightPoints[i][1] === e[1]; ++i)
          if (this.rightPoints[i] === e)
            return this.rightPoints.splice(i, 1), No;
      }
    return rc;
  }
};
function mN(e, t, n) {
  for (var i = 0; i < e.length && e[i][0] <= t; ++i) {
    var r = n(e[i]);
    if (r)
      return r;
  }
}
function gN(e, t, n) {
  for (var i = e.length - 1; i >= 0 && e[i][1] >= t; --i) {
    var r = n(e[i]);
    if (r)
      return r;
  }
}
function bN(e, t) {
  for (var n = 0; n < e.length; ++n) {
    var i = t(e[n]);
    if (i)
      return i;
  }
}
Yf.queryPoint = function(e, t) {
  if (e < this.mid) {
    if (this.left) {
      var n = this.left.queryPoint(e, t);
      if (n)
        return n;
    }
    return mN(this.leftPoints, e, t);
  } else if (e > this.mid) {
    if (this.right) {
      var n = this.right.queryPoint(e, t);
      if (n)
        return n;
    }
    return gN(this.rightPoints, e, t);
  } else
    return bN(this.leftPoints, t);
};
Yf.queryInterval = function(e, t, n) {
  if (e < this.mid && this.left) {
    var i = this.left.queryInterval(e, t, n);
    if (i)
      return i;
  }
  if (t > this.mid && this.right) {
    var i = this.right.queryInterval(e, t, n);
    if (i)
      return i;
  }
  return t < this.mid ? mN(this.leftPoints, t, n) : e > this.mid ? gN(this.rightPoints, e, n) : bN(this.leftPoints, n);
};
function nnt(e, t) {
  return e - t;
}
function Lv(e, t) {
  var n = e[0] - t[0];
  return n || e[1] - t[1];
}
function Rv(e, t) {
  var n = e[1] - t[1];
  return n || e[0] - t[0];
}
function Yc(e) {
  if (e.length === 0)
    return null;
  for (var t = [], n = 0; n < e.length; ++n)
    t.push(e[n][0], e[n][1]);
  t.sort(nnt);
  for (var i = t[t.length >> 1], r = [], s = [], o = [], n = 0; n < e.length; ++n) {
    var a = e[n];
    a[1] < i ? r.push(a) : i < a[0] ? s.push(a) : o.push(a);
  }
  var c = o, l = o.slice();
  return c.sort(Lv), l.sort(Rv), new Ev(
    i,
    Yc(r),
    Yc(s),
    c,
    l
  );
}
function G1(e) {
  this.root = e;
}
var dl = G1.prototype;
dl.insert = function(e) {
  this.root ? this.root.insert(e) : this.root = new Ev(e[0], null, null, [e], [e]);
};
dl.remove = function(e) {
  if (this.root) {
    var t = this.root.remove(e);
    return t === od && (this.root = null), t !== rc;
  }
  return !1;
};
dl.queryPoint = function(e, t) {
  if (this.root)
    return this.root.queryPoint(e, t);
};
dl.queryInterval = function(e, t, n) {
  if (e <= t && this.root)
    return this.root.queryInterval(e, t, n);
};
Object.defineProperty(dl, "count", {
  get: function() {
    return this.root ? this.root.count : 0;
  }
});
Object.defineProperty(dl, "intervals", {
  get: function() {
    return this.root ? this.root.intervals([]) : [];
  }
});
function int(e) {
  return !e || e.length === 0 ? new G1(null) : new G1(Yc(e));
}
const rnt = /* @__PURE__ */ Xet(ent), snt = ({ marginLeft: e }) => [1, e], ont = ({ width: e, marginRight: t }) => [-1, e - t], ant = ({ width: e, marginLeft: t, marginRight: n }) => [0, (t + e - n) / 2], cnt = ({ marginTop: e }) => [1, e], lnt = ({ height: e, marginBottom: t }) => [-1, e - t], unt = ({ height: e, marginTop: t, marginBottom: n }) => [0, (t + e - n) / 2];
function wN(e) {
  return typeof e == "string" ? { anchor: e } : e;
}
function fnt(e = {}, t = {}) {
  arguments.length === 1 && ([e, t] = vN(e));
  let { anchor: n = "left", padding: i = 1, r = t.r } = wN(e);
  switch (`${n}`.toLowerCase()) {
    case "left":
      n = snt;
      break;
    case "right":
      n = ont;
      break;
    case "middle":
      n = ant;
      break;
    default:
      throw new Error(`unknown dodge anchor: ${n}`);
  }
  return _N("x", "y", n, qt(i), r, t);
}
function hnt(e = {}, t = {}) {
  arguments.length === 1 && ([e, t] = vN(e));
  let { anchor: n = "bottom", padding: i = 1, r = t.r } = wN(e);
  switch (`${n}`.toLowerCase()) {
    case "top":
      n = cnt;
      break;
    case "bottom":
      n = lnt;
      break;
    case "middle":
      n = unt;
      break;
    default:
      throw new Error(`unknown dodge anchor: ${n}`);
  }
  return _N("y", "x", n, qt(i), r, t);
}
function vN(e) {
  const { anchor: t, padding: n, ...i } = e, { r } = i;
  return [{ anchor: t, padding: n, r }, i];
}
function _N(e, t, n, i, r, s) {
  if (r != null && typeof r != "number") {
    let { channels: o, sort: a, reverse: c } = s;
    o = Tw(o), (o == null ? void 0 : o.r) === void 0 && (s = { ...s, channels: { ...o, r: { value: r, scale: "r" } } }), a === void 0 && c === void 0 && (s.sort = { channel: "-r" });
  }
  return Bn(s, function(o, a, c, l, u, f) {
    let { [t]: h, r: d } = c;
    if (!c[t])
      throw new Error(`missing channel: ${t}`);
    ({ [t]: h } = $0(c, l, f));
    const p = d ? void 0 : r !== void 0 ? qt(r) : this.r !== void 0 ? this.r : 3;
    d && (d = Pt(d.value, l[d.scale] || Tt, Float64Array));
    let [y, m] = n(u);
    const g = y ? pnt : dnt, b = new Float64Array(h.length), w = d ? (v) => d[v] : () => p;
    for (let v of a) {
      const S = rnt();
      v = v.filter(d ? (I) => kp(h[I]) && Qr(d[I]) : (I) => kp(h[I]));
      const _ = new Float64Array(2 * v.length + 2);
      for (const I of v) {
        const T = w(I), M = y ? T + i : 0, N = h[I] - T, A = h[I] + T;
        let B = 2;
        S.queryInterval(N - i, A + i, ([, , x]) => {
          const $ = b[x] - M, D = h[I] - h[x], L = i + (d ? d[I] + d[x] : 2 * p), k = Math.sqrt(L * L - D * D);
          _[B++] = $ - k, _[B++] = $ + k;
        });
        let R = _.slice(0, B);
        y && (R = R.filter((x) => x >= 0));
        t:
          for (const x of R.sort(g)) {
            for (let $ = 0; $ < B; $ += 2)
              if (_[$] + 1e-6 < x && x < _[$ + 1] - 1e-6)
                continue t;
            b[I] = x + M;
            break;
          }
        S.insert([N, A, I]);
      }
    }
    y || (y = 1);
    for (const v of a)
      for (const S of v)
        b[S] = b[S] * y + m;
    return {
      data: o,
      facets: a,
      channels: {
        [e]: { value: b, source: null },
        // dont show in tooltip
        [t]: { value: h, source: c[t] },
        ...d && { r: { value: d, source: c.r } }
      }
    };
  });
}
function dnt(e, t) {
  return Math.abs(e) - Math.abs(t);
}
function pnt(e, t) {
  return e - t;
}
function ynt(e, t) {
  return arguments.length === 1 && ({ basis: e, ...t } = e), xv(Cv(e), t);
}
function mnt(e, t) {
  return arguments.length === 1 && ({ basis: e, ...t } = e), Iv(Cv(e), t);
}
function Cv(e) {
  if (e === void 0)
    return Xx;
  if (typeof e == "function")
    return q0($w(e));
  if (/^p\d{2}$/i.test(e))
    return pl(Aw(e));
  switch (`${e}`.toLowerCase()) {
    case "deviation":
      return wnt;
    case "first":
      return Xx;
    case "last":
      return bnt;
    case "max":
      return vnt;
    case "mean":
      return _nt;
    case "median":
      return Snt;
    case "min":
      return xnt;
    case "sum":
      return Int;
    case "extent":
      return gnt;
  }
  throw new Error(`invalid basis: ${e}`);
}
function q0(e) {
  return {
    mapIndex(t, n, i) {
      const r = +e(t, n);
      for (const s of t)
        i[s] = n[s] === null ? NaN : n[s] / r;
    }
  };
}
function pl(e) {
  return q0((t, n) => e(t, (i) => n[i]));
}
const gnt = {
  mapIndex(e, t, n) {
    const [i, r] = ke(e, (o) => t[o]), s = r - i;
    for (const o of e)
      n[o] = t[o] === null ? NaN : (t[o] - i) / s;
  }
}, Xx = q0((e, t) => {
  for (let n = 0; n < e.length; ++n) {
    const i = t[e[n]];
    if (dn(i))
      return i;
  }
}), bnt = q0((e, t) => {
  for (let n = e.length - 1; n >= 0; --n) {
    const i = t[e[n]];
    if (dn(i))
      return i;
  }
}), wnt = {
  mapIndex(e, t, n) {
    const i = Gy(e, (s) => t[s]), r = gf(e, (s) => t[s]);
    for (const s of e)
      n[s] = t[s] === null ? NaN : r ? (t[s] - i) / r : 0;
  }
}, vnt = pl(De), _nt = pl(Gy), Snt = pl(Bu), xnt = pl(Ye), Int = pl(fr);
function Ant(e, t) {
  return Mnt("x", e, t);
}
function Mnt(e, t, n = {}) {
  let i, r = 1;
  if (typeof t == "number")
    r = t, i = (l, u) => +l + u;
  else {
    if (typeof t == "string") {
      const l = t.startsWith("-") ? -1 : 1;
      [t, r] = Sw(t.replace(/^[+-]/, "")), r *= l;
    }
    t = _0(t), i = (l, u) => t.offset(l, u);
  }
  const s = `${e}1`, o = `${e}2`, a = pr(
    {
      [s]: (l) => l.map((u) => i(u, r)),
      [o]: (l) => l
    },
    n
  ), c = a[o].transform;
  return a[o].transform = () => {
    const l = c(), [u, f] = ke(l);
    return l.domain = r < 0 ? [u, i(f, r)] : [i(u, r), f], l;
  }, a;
}
function $nt(e, t = {}) {
  if (typeof e == "string")
    switch (e.toLowerCase()) {
      case "first":
        return SN(t);
      case "last":
        return xN(t);
    }
  if (typeof e == "function")
    return Zs(null, e, t);
  let n, i;
  for (n in e) {
    if (i !== void 0)
      throw new Error("ambiguous selector; multiple inputs");
    i = Tnt(e[n]);
  }
  if (i === void 0)
    throw new Error(`invalid selector: ${e}`);
  return Zs(n, i, t);
}
function Tnt(e) {
  if (typeof e == "function")
    return e;
  switch (`${e}`.toLowerCase()) {
    case "min":
      return kv;
    case "max":
      return Uv;
  }
  throw new Error(`unknown selector: ${e}`);
}
function SN(e) {
  return Zs(null, Fnt, e);
}
function xN(e) {
  return Zs(null, Ent, e);
}
function Dnt(e) {
  return Zs("x", kv, e);
}
function Nnt(e) {
  return Zs("y", kv, e);
}
function Bnt(e) {
  return Zs("x", Uv, e);
}
function Ont(e) {
  return Zs("y", Uv, e);
}
function* Fnt(e) {
  yield e[0];
}
function* Ent(e) {
  yield e[e.length - 1];
}
function* kv(e, t) {
  yield Yz(e, (n) => t[n]);
}
function* Uv(e, t) {
  yield jb(e, (n) => t[n]);
}
function Zs(e, t, n) {
  if (e != null) {
    if (n[e] == null)
      throw new Error(`missing channel: ${e}`);
    e = n[e];
  }
  const i = lo(n);
  return vr(n, (r, s) => {
    const o = Pt(r, i), a = Pt(r, e), c = [];
    for (const l of s) {
      const u = [];
      for (const f of o ? fs(l, (h) => o[h]).values() : [l])
        for (const h of t(f, a))
          u.push(h);
      c.push(u);
    }
    return { data: r, facets: c };
  });
}
const eg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Area: C0,
  Arrow: T4,
  BarX: N4,
  BarY: B4,
  Cell: k0,
  Contour: H4,
  Density: Z4,
  Dot: U0,
  Frame: l4,
  Geo: Q4,
  Hexgrid: tN,
  Image: eN,
  Line: z0,
  Link: M4,
  Mark: fe,
  Raster: Y4,
  Rect: V0,
  RuleX: _8,
  RuleY: S8,
  Text: F0,
  TickX: C4,
  TickY: k4,
  Tip: u4,
  Vector: E0,
  area: R1,
  areaX: Hu,
  areaY: qc,
  arrow: YQ,
  auto: itt,
  autoSpec: O4,
  axisFx: Y8,
  axisFy: q8,
  axisX: rv,
  axisY: iv,
  barX: Ro,
  barY: Co,
  bin: Bo,
  binX: Os,
  binY: Fs,
  bollinger: Wo,
  bollingerX: Stt,
  bollingerY: xtt,
  boxX: Att,
  boxY: Mtt,
  cell: ic,
  cellX: GQ,
  cellY: XQ,
  centroid: Wet,
  circle: ZQ,
  cluster: Yet,
  column: zn,
  contour: ztt,
  crosshair: Vtt,
  crosshairX: jtt,
  crosshairY: qtt,
  delaunayLink: iet,
  delaunayMesh: ret,
  density: uet,
  differenceY: det,
  dodgeX: fnt,
  dodgeY: hnt,
  dot: ho,
  dotX: JQ,
  dotY: KQ,
  filter: lJ,
  find: IJ,
  formatIsoDate: i8,
  formatMonth: $K,
  formatWeekday: TK,
  frame: av,
  geo: Ov,
  geoCentroid: Get,
  graticule: get,
  gridFx: K8,
  gridFy: H8,
  gridX: J8,
  gridY: X8,
  group: Rw,
  groupX: qu,
  groupY: Yu,
  groupZ: Lw,
  hexagon: QQ,
  hexbin: bet,
  hexgrid: _et,
  hull: set,
  identity: Tt,
  image: $et,
  indexOf: vn,
  initializer: Bn,
  interpolateNearest: Tv,
  interpolateNone: U1,
  interpolatorBarycentric: $v,
  interpolatorRandomWalk: Dv,
  legend: FZ,
  line: P0,
  lineX: Ju,
  lineY: Ku,
  linearRegressionX: Let,
  linearRegressionY: Ret,
  link: $4,
  map: pr,
  mapX: xv,
  mapY: Iv,
  marks: fi,
  normalize: Cv,
  normalizeX: ynt,
  normalizeY: mnt,
  plot: cv,
  pointer: Qw,
  pointerX: tv,
  pointerY: qp,
  raster: Ttt,
  rect: Sv,
  rectX: Jp,
  rectY: Kp,
  reverse: uJ,
  ruleX: Js,
  ruleY: Ks,
  scale: Xu,
  select: $nt,
  selectFirst: SN,
  selectLast: xN,
  selectMaxX: Bnt,
  selectMaxY: Ont,
  selectMinX: Dnt,
  selectMinY: Nnt,
  shiftX: Ant,
  shuffle: fJ,
  sort: SD,
  sphere: met,
  spike: _Z,
  stackX: v4,
  stackX1: IQ,
  stackX2: AQ,
  stackY: _4,
  stackY1: MQ,
  stackY2: $Q,
  text: Pc,
  textX: M8,
  textY: $8,
  tickX: U4,
  tickY: z4,
  tip: f4,
  transform: vr,
  tree: pN,
  treeLink: rN,
  treeNode: z1,
  valueof: Pt,
  vector: C8,
  vectorX: k8,
  vectorY: U8,
  voronoi: oet,
  voronoiMesh: aet,
  window: j0,
  windowX: utt,
  windowY: ftt
}, Symbol.toStringTag, { value: "Module" })), Lnt = /* @__PURE__ */ new Map([
  ["style", "style"],
  ["width", "width"],
  ["height", "height"],
  ["margin", "margin"],
  ["marginLeft", "marginLeft"],
  ["marginRight", "marginRight"],
  ["marginTop", "marginTop"],
  ["marginBottom", "marginBottom"],
  ["align", "align"],
  ["aspectRatio", "aspectRatio"],
  ["axis", "axis"],
  ["inset", "inset"],
  ["grid", "grid"],
  ["label", "label"],
  ["padding", "padding"],
  ["xScale", "x.type"],
  ["xDomain", "x.domain"],
  ["xRange", "x.range"],
  ["xNice", "x.nice"],
  ["xInset", "x.inset"],
  ["xInsetLeft", "x.insetLeft"],
  ["xInsetRight", "x.insetRight"],
  ["xClamp", "x.clamp"],
  ["xRound", "x.round"],
  ["xAlign", "x.align"],
  ["xPadding", "x.padding"],
  ["xPaddingInner", "x.paddingInner"],
  ["xPaddingOuter", "x.paddingOuter"],
  ["xAxis", "x.axis"],
  ["xTicks", "x.ticks"],
  ["xTickSize", "x.tickSize"],
  ["xTickSpacing", "x.tickSpacing"],
  ["xTickPadding", "x.tickPadding"],
  ["xTickFormat", "x.tickFormat"],
  ["xTickRotate", "x.tickRotate"],
  ["xGrid", "x.grid"],
  ["xLine", "x.line"],
  ["xLabel", "x.label"],
  ["xLabelAnchor", "x.labelAnchor"],
  ["xLabelOffset", "x.labelOffset"],
  ["xFontVariant", "x.fontVariant"],
  ["xAriaLabel", "x.ariaLabel"],
  ["xAriaDescription", "x.ariaDescription"],
  ["xReverse", "x.reverse"],
  ["xZero", "x.zero"],
  ["xBase", "x.base"],
  ["xExponent", "x.exponent"],
  ["xConstant", "x.constant"],
  ["yScale", "y.type"],
  ["yDomain", "y.domain"],
  ["yRange", "y.range"],
  ["yNice", "y.nice"],
  ["yInset", "y.inset"],
  ["yInsetTop", "y.insetTop"],
  ["yInsetBottom", "y.insetBottom"],
  ["yClamp", "y.clamp"],
  ["yRound", "y.round"],
  ["yAlign", "y.align"],
  ["yPadding", "y.padding"],
  ["yPaddingInner", "y.paddingInner"],
  ["yPaddingOuter", "y.paddingOuter"],
  ["yAxis", "y.axis"],
  ["yTicks", "y.ticks"],
  ["yTickSize", "y.tickSize"],
  ["yTickSpacing", "y.tickSpacing"],
  ["yTickPadding", "y.tickPadding"],
  ["yTickFormat", "y.tickFormat"],
  ["yTickRotate", "y.tickRotate"],
  ["yGrid", "y.grid"],
  ["yLine", "y.line"],
  ["yLabel", "y.label"],
  ["yLabelAnchor", "y.labelAnchor"],
  ["yLabelOffset", "y.labelOffset"],
  ["yFontVariant", "y.fontVariant"],
  ["yAriaLabel", "y.ariaLabel"],
  ["yAriaDescription", "y.ariaDescription"],
  ["yReverse", "y.reverse"],
  ["yZero", "y.zero"],
  ["yBase", "y.base"],
  ["yExponent", "y.exponent"],
  ["yConstant", "y.constant"],
  ["facetMargin", "facet.margin"],
  ["facetMarginTop", "facet.marginTop"],
  ["facetMarginBottom", "facet.marginBottom"],
  ["facetMarginLeft", "facet.marginLeft"],
  ["facetMarginRight", "facet.marginRight"],
  ["facetGrid", "facet.grid"],
  ["facetLabel", "facet.label"],
  ["fxDomain", "fx.domain"],
  ["fxRange", "fx.range"],
  ["fxNice", "fx.nice"],
  ["fxInset", "fx.inset"],
  ["fxInsetLeft", "fx.insetLeft"],
  ["fxInsetRight", "fx.insetRight"],
  ["fxRound", "fx.round"],
  ["fxAlign", "fx.align"],
  ["fxPadding", "fx.padding"],
  ["fxPaddingInner", "fx.paddingInner"],
  ["fxPaddingOuter", "fx.paddingOuter"],
  ["fxAxis", "fx.axis"],
  ["fxTicks", "fx.ticks"],
  ["fxTickSize", "fx.tickSize"],
  ["fxTickSpacing", "fx.tickSpacing"],
  ["fxTickPadding", "fx.tickPadding"],
  ["fxTickFormat", "fx.tickFormat"],
  ["fxTickRotate", "fx.tickRotate"],
  ["fxGrid", "fx.grid"],
  ["fxLine", "fx.line"],
  ["fxLabel", "fx.label"],
  ["fxLabelAnchor", "fx.labelAnchor"],
  ["fxLabelOffset", "fx.labelOffset"],
  ["fxFontVariant", "fx.fontVariant"],
  ["fxAriaLabel", "fx.ariaLabel"],
  ["fxAriaDescription", "fx.ariaDescription"],
  ["fxReverse", "fx.reverse"],
  ["fyDomain", "fy.domain"],
  ["fyRange", "fy.range"],
  ["fyNice", "fy.mice"],
  ["fyInset", "fy,inset"],
  ["fyInsetTop", "fy.insetTop"],
  ["fyInsetBottom", "fy.insetBottom"],
  ["fyRound", "fy.round"],
  ["fyAlign", "fy.align"],
  ["fyPadding", "fy.padding"],
  ["fyPaddingInner", "fy.paddingInner"],
  ["fyPaddingOuter", "fy.paddingOuter"],
  ["fyAxis", "fy.axis"],
  ["fyTicks", "fy.ticks"],
  ["fyTickSize", "fy.tickSize"],
  ["fyTickSpacing", "fy.tickSpacing"],
  ["fyTickPadding", "fy.tickPadding"],
  ["fyTickFormat", "fy.tickFormat"],
  ["fyTickRotate", "fy.tickRotate"],
  ["fyGrid", "fy.grid"],
  ["fyLine", "fy.line"],
  ["fyLabel", "fy.label"],
  ["fyLabelAnchor", "fy.labelAnchor"],
  ["fyLabelOffset", "fy.labelOffset"],
  ["fyFontVariant", "fy.fontVariant"],
  ["fyAriaLabel", "fy.ariaLabel"],
  ["fyAriaDescription", "fy.ariaDescription"],
  ["fyReverse", "fy.reverse"],
  ["colorScale", "color.type"],
  ["colorDomain", "color.domain"],
  ["colorRange", "color.range"],
  ["colorClamp", "color.clamp"],
  ["colorN", "color.n"],
  ["colorNice", "color.nice"],
  ["colorScheme", "color.scheme"],
  ["colorInterpolate", "color.interpolate"],
  ["colorPivot", "color.pivot"],
  ["colorSymmetric", "color.symmetric"],
  ["colorLabel", "color.label"],
  ["colorReverse", "color.reverse"],
  ["colorZero", "color.zero"],
  ["colorTickFormat", "color.tickFormat"],
  ["colorBase", "color.base"],
  ["colorExponent", "color.exponent"],
  ["colorConstant", "color.constant"],
  ["opacityScale", "opacity.type"],
  ["opacityDomain", "opacity.domain"],
  ["opacityRange", "opacity.range"],
  ["opacityClamp", "opacity.clamp"],
  ["opacityNice", "opacity.nice"],
  ["opacityLabel", "opacity.label"],
  ["opacityReverse", "opacity.reverse"],
  ["opacityZero", "opacity.zero"],
  ["opacityTickFormat", "opacity.tickFormat"],
  ["opacityBase", "opacity.base"],
  ["opacityExponent", "opacity.exponent"],
  ["opacityConstant", "opacity.constant"],
  ["symbolScale", "symbol.type"],
  ["symbolDomain", "symbol.domain"],
  ["symbolRange", "symbol.range"],
  ["rScale", "r.type"],
  ["rDomain", "r.domain"],
  ["rRange", "r.range"],
  ["rClamp", "r.clamp"],
  ["rNice", "r.nice"],
  ["rZero", "r.zero"],
  ["rBase", "r.base"],
  ["rExponent", "r.exponent"],
  ["rConstant", "r.constant"],
  ["lengthScale", "length.type"],
  ["lengthDomain", "length.domain"],
  ["lengthRange", "length.range"],
  ["lengthClamp", "length.clamp"],
  ["lengthNice", "length.nice"],
  ["lengthZero", "length.zero"],
  ["lengthBase", "length.base"],
  ["lengthExponent", "length.exponent"],
  ["lengthConstant", "length.constant"],
  ["projectionType", "projection.type"],
  ["projectionParallels", "projection.parallels"],
  ["projectionPrecision", "projection.precision"],
  ["projectionRotate", "projection.rotate"],
  ["projectionDomain", "projection.domain"],
  ["projectionInset", "projection.inset"],
  ["projectionInsetLeft", "projection.insetLeft"],
  ["projectionInsetRight", "projection.insetRight"],
  ["projectionInsetTop", "projection.insetTop"],
  ["projectionInsetBottom", "projection.insetBottom"],
  ["projectionClip", "projection.clip"]
]);
function Rnt(e, t, n) {
  for (let i = 0; i < t.length; ++i) {
    const r = t[i];
    i === t.length - 1 ? e[r] = n : e = e[r] || (e[r] = {});
  }
}
function Cnt(e, t, n) {
  for (const i in e) {
    const r = Lnt.get(i);
    if (r == null)
      throw new Error(`Unrecognized plot attribute: ${i}`);
    const s = e[i];
    typeof s == "symbol" ? n.push(i) : s !== void 0 && Rnt(t, r.split("."), s);
  }
}
const knt = /* @__PURE__ */ new Set([
  "frame",
  "hexgrid",
  "sphere",
  "graticule"
]);
async function Unt(e) {
  const t = { marks: [] }, n = [], { attributes: i, marks: r } = e;
  Cnt(i, t, n);
  const s = [];
  for (const a of r)
    for (const { type: c, data: l, options: u } of a.plotSpecs()) {
      if (knt.has(c))
        t.marks.push(eg[c](u));
      else if (Z3(l)) {
        const f = Object.fromEntries(
          Object.entries(u).map(([h, d]) => {
            let p = d;
            if (typeof d == "string")
              p = l.getChild(d) ?? d;
            else if (typeof d == "object") {
              const y = l.getChild(d.value);
              p = y ? { value: y } : d;
            }
            return [h, p];
          })
        );
        t.marks.push(eg[c]({ length: l.numRows }, f));
      } else
        t.marks.push(eg[c](l, u));
      s.push(a.index);
    }
  Pnt(t, e);
  const o = cv(t);
  Vnt(o, s), znt(e, o, i, n);
  for (const a of e.interactors)
    await a.init(o);
  return o;
}
function znt(e, t, n, i) {
  i.forEach((r) => {
    const s = n[r];
    if (s === mf) {
      if (!r.endsWith("Domain"))
        throw new Error(`Unsupported fixed attribute: ${r}`);
      const o = r.slice(0, -6), a = t.scale(o);
      a != null && a.domain && e.setAttribute(r, n[`${o}Reverse`] ? a.domain.slice().reverse() : a.domain);
    } else
      throw new Error(`Unrecognized symbol: ${s}`);
  });
}
function Pnt(e, t) {
  const { marks: n } = t;
  Oh("x", e, n), Oh("y", e, n), Oh("fx", e, n), Oh("fy", e, n);
}
function Oh(e, t, n) {
  const i = t[e] || {};
  if (i.axis === null || i.label !== void 0)
    return;
  const r = n.map((l) => {
    var u;
    return (u = l.channelField(e)) == null ? void 0 : u.field;
  });
  if (r.every((l) => l == null))
    return;
  let s, o, a;
  for (let l = 0; l < r.length; ++l) {
    const { column: u, label: f } = r[l] || {};
    u === void 0 && f === void 0 || (s === void 0 && o === void 0 ? (s = u, o = f, a = jnt(n[l].data, e) || "number") : o !== f ? o = void 0 : s !== u && (s = void 0));
  }
  let c = o || s;
  if (c !== void 0) {
    if ((a === "number" || a === "date") && (e === "x" || e === "y")) {
      i.percent && (c = `${c} (%)`);
      const l = (e === "x" ? 1 : -1) * (i.reverse ? -1 : 1);
      e === "x" || i.labelAnchor === "center" ? c = e === "x" == l < 0 ? ` ${c}` : `${c} ` : c = `${l < 0 ? " " : " "}${c}`;
    }
    t[e] = { ...i, label: c };
  }
}
function Vnt(e, t) {
  const n = e.querySelectorAll('g[aria-label="facet"]');
  if (n.length)
    for (const i of n)
      Hx(i, t);
  else
    Hx(e, t);
}
function Hx(e, t) {
  let n = -1;
  for (const i of e.children) {
    const r = i.getAttribute("aria-label") || "";
    i.nodeName === "style" || r.includes("-axis") || r.includes("-grid") || i.setAttribute("data-index", t[++n]);
  }
}
function jnt(e, t) {
  const { columns: n } = e, i = n[t] ?? n[t + "1"] ?? n[t + "2"];
  if (i) {
    for (const r of i)
      if (r != null)
        return r instanceof Date ? "date" : typeof r;
  }
}
const qnt = {
  width: 640,
  marginLeft: 40,
  marginRight: 20,
  marginTop: 20,
  marginBottom: 30
};
class Ynt {
  constructor(t) {
    this.attributes = { ...qnt }, this.listeners = null, this.interactors = [], this.legends = [], this.marks = [], this.markset = null, this.element = t || document.createElement("div"), this.element.setAttribute("class", "plot"), this.element.style.display = "flex", this.element.value = this, this.params = /* @__PURE__ */ new Map(), this.synch = vz();
  }
  margins() {
    return {
      left: this.getAttribute("marginLeft"),
      top: this.getAttribute("marginTop"),
      bottom: this.getAttribute("marginBottom"),
      right: this.getAttribute("marginRight")
    };
  }
  innerWidth() {
    const { left: t, right: n } = this.margins();
    return this.getAttribute("width") - t - n;
  }
  innerHeight(t = 400) {
    const { top: n, bottom: i } = this.margins();
    let r = this.getAttribute("height");
    return r == null && t != null && (r = t, this.setAttribute("height", r, { silent: !0 })), r - n - i;
  }
  pending(t) {
    this.synch.pending(t);
  }
  update(t) {
    return this.synch.ready(t) && !this.pendingRender && (this.pendingRender = !0, requestAnimationFrame(() => this.render())), this.synch.promise;
  }
  async render() {
    this.pendingRender = !1;
    const t = await Unt(this), n = this.legends.flatMap(({ legend: i, include: r }) => {
      const s = i.init(t);
      return r ? s : [];
    });
    this.element.replaceChildren(t, ...n), this.synch.resolve();
  }
  /**
   * @param {string} name The attribute to return.
   * @returns {*} The value of the attribute.
   */
  getAttribute(t) {
    return this.attributes[t];
  }
  /**
   * @param {string} name The name of the attribute to set.
   * @param {*} value The value to set.
   * @param {{silent: boolean}} [options] Options for setting the attribute.
   * @returns {boolean} whether the value changed.
   */
  setAttribute(t, n, i) {
    var r, s;
    return tM(this.attributes[t], n) ? (n === void 0 ? delete this.attributes[t] : this.attributes[t] = n, i != null && i.silent || (s = (r = this.listeners) == null ? void 0 : r.get(t)) == null || s.forEach((o) => o(t, n)), !0) : !1;
  }
  /**
   * @param {string} name The attribute name.
   * @param {*} callback The function to call when the attribute changes.
   * @returns {this}
   */
  addAttributeListener(t, n) {
    const i = this.listeners || (this.listeners = /* @__PURE__ */ new Map());
    return i.has(t) || i.set(t, /* @__PURE__ */ new Set()), i.get(t).add(n), this;
  }
  /**
   * @param {string} name The attribute name.
   * @param {*} callback The function to call when the attribute changes.
   * @returns {void}
   */
  removeAttributeListener(t, n) {
    var i, r;
    return (r = (i = this.listeners) == null ? void 0 : i.get(t)) == null ? void 0 : r.delete(n);
  }
  addParams(t, n) {
    const { params: i } = this;
    for (const r of n)
      i.has(r) ? i.get(r).push(t) : (i.set(r, [t]), r.addEventListener("value", () => Promise.allSettled(
        i.get(r).map((s) => s.requestQuery())
      )));
  }
  addMark(t) {
    return t.setPlot(this, this.marks.length), this.marks.push(t), this.markset = null, this;
  }
  get markSet() {
    return this.markset || (this.markset = new Set(this.marks));
  }
  addInteractor(t) {
    return this.interactors.push(t), this;
  }
  addLegend(t, n = !0) {
    t.setPlot(this), this.legends.push({ legend: t, include: n });
  }
}
function IN(e) {
  return typeof e != "string" ? !1 : (e = e.toLowerCase().trim(), e === "none" || e === "currentcolor" || e.startsWith("url(") && e.endsWith(")") || // <funciri>, e.g. pattern or gradient
  e.startsWith("var(") && e.endsWith(")") || // CSS variable
  Gs(e) !== null);
}
const Wnt = /* @__PURE__ */ new Set([
  "order",
  "sort",
  "label",
  "anchor",
  "curve",
  "tension",
  "marker",
  "markerStart",
  "markerMid",
  "markerEnd",
  "textAnchor",
  "lineAnchor",
  "lineHeight",
  "textOverflow",
  "monospace",
  "fontFamily",
  "fontSize",
  "fontStyle",
  "fontVariant",
  "fontWeight",
  "frameAnchor",
  "strokeLinejoin",
  "strokeLinecap",
  "strokeMiterlimit",
  "strokeDasharray",
  "strokeDashoffset",
  "mixBlendMode",
  "shapeRendering",
  "imageRendering",
  "preserveAspectRatio",
  "interpolate",
  "crossOrigin",
  "paintOrder",
  "pointerEvents",
  "target"
]);
function Gnt(e) {
  return Wnt.has(e);
}
const Xnt = /* @__PURE__ */ new Set([
  "asterisk",
  "circle",
  "cross",
  "diamond",
  "diamond2",
  "hexagon",
  "plus",
  "square",
  "square2",
  "star",
  "times",
  "triangle",
  "triangle2",
  "wye"
]);
function Hnt(e) {
  return Xnt.has(`${e}`.toLowerCase());
}
function Zu(e) {
  return Z3(e) ? Jnt(e) : Knt(e);
}
function Jnt(e) {
  const { numRows: t, numCols: n, schema: { fields: i } } = e, r = {};
  for (let s = 0; s < n; ++s) {
    const o = i[s].name;
    r[o] ? console.warn(`Redundant column name "${o}". Skipping...`) : r[o] = rz(e.getChildAt(s));
  }
  return { numRows: t, columns: r };
}
function Knt(e) {
  const t = e.length;
  if (typeof e[0] == "object") {
    const n = t ? Object.keys(e[0]) : [], i = {};
    return n.length > 0 && n.forEach((r) => {
      i[r] = e.map((s) => s[r]);
    }), { numRows: t, columns: i };
  } else
    return { numRows: t, values: e };
}
const AN = (e) => e === "stroke" || e === "fill", Znt = (e) => /opacity$/i.test(e), Qnt = (e) => e === "symbol", tit = (e, t) => e !== "sort" && e !== "tip" && t != null && !Array.isArray(t), ng = (e, t) => ({
  channel: e,
  field: t,
  as: t instanceof js ? t.column : e
}), ig = (e, t) => ({ channel: e, value: t }), X1 = (e) => Array.isArray(e);
class ha extends af {
  constructor(t, n, i, r = {}) {
    var l;
    super((l = n == null ? void 0 : n.options) == null ? void 0 : l.filterBy), this.type = t, this.reqs = r, this.source = n, X1(this.source) && (this.data = Zu(this.source));
    const s = this.channels = [], o = this.detail = /* @__PURE__ */ new Set(), a = this.params = /* @__PURE__ */ new Set(), c = (u, f) => {
      const h = typeof f;
      if (u === "channels")
        for (const d in f)
          o.add(d), c(d, f[d]);
      else if (h === "function" && f[eM]) {
        const d = f(this, u);
        for (const p in d)
          c(p, d[p]);
      } else if (h === "string")
        Gnt(u) || AN(u) && IN(f) || Qnt(u) && Hnt(f) ? s.push(ig(u, f)) : s.push(ng(u, zy(f)));
      else if (Mc(f))
        if (Array.isArray(f.columns))
          s.push(ng(u, f)), a.add(f);
        else {
          const d = ig(u, f.value);
          s.push(d), f.addEventListener("value", (p) => (d.value = p, this.update()));
        }
      else
        h === "object" && tit(u, f) ? s.push(ng(u, f)) : f !== void 0 && s.push(ig(u, f));
    };
    for (const u in i)
      c(u, i[u]);
  }
  /**
   * @param {import('../plot.js').Plot} plot The plot.
   * @param {number} index 
   */
  setPlot(t, n) {
    var i;
    this.plot = t, this.index = n, t.addParams(this, this.params), (i = this.source) != null && i.table && this.queryPending();
  }
  hasOwnData() {
    return this.source == null || X1(this.source);
  }
  hasFieldInfo() {
    return !!this._fieldInfo;
  }
  channel(t) {
    return this.channels.find((n) => n.channel === t);
  }
  channelField(t, { exact: n = !1 } = {}) {
    const i = n ? this.channel(t) : this.channels.find((r) => r.channel.startsWith(t));
    return i != null && i.field ? i : null;
  }
  fields() {
    var s, o, a;
    if (this.hasOwnData())
      return null;
    const { source: { table: t }, channels: n, reqs: i } = this, r = /* @__PURE__ */ new Map();
    for (const { channel: c, field: l } of n) {
      if (!l)
        continue;
      const u = ((s = l.stats) == null ? void 0 : s.stats) || [], f = ((o = l.stats) == null ? void 0 : o.column) ?? l, h = r.get(f) ?? r.set(f, /* @__PURE__ */ new Set()).get(f);
      u.forEach((d) => h.add(d)), (a = i[c]) == null || a.forEach((d) => h.add(d));
    }
    return Array.from(r, ([c, l]) => ({ table: t, column: c, stats: l }));
  }
  fieldInfo(t) {
    var i;
    const n = Object.fromEntries(t.map((r) => [r.column, r]));
    for (const r of this.channels) {
      const { field: s } = r;
      s && Object.assign(r, n[((i = s.stats) == null ? void 0 : i.column) ?? s]);
    }
    return this._fieldInfo = !0, this;
  }
  /**
   * Return a query specifying the data needed by this Mark client.
   * @param {*} [filter] The filtering criteria to apply in the query.
   * @returns {*} The client query
   */
  query(t = []) {
    if (this.hasOwnData())
      return null;
    const { channels: n, source: { table: i } } = this;
    return MN(n, i).where(t);
  }
  queryPending() {
    return this.plot.pending(this), this;
  }
  /**
   * Provide query result data to the mark.
   */
  queryResult(t) {
    return this.data = Zu(t), this;
  }
  update() {
    return this.plot.update(this);
  }
  /**
   * Generate an array of Plot mark specifications.
   * @returns {object[]}
   */
  plotSpecs() {
    const { type: t, detail: n, channels: i } = this, { numRows: r, values: s, columns: o } = this.data || {}, a = {}, c = {};
    for (const f of i) {
      const h = n.has(f.channel) ? c : a;
      h[f.channel] = Kn(f, o);
    }
    n.size && (a.channels = c);
    const l = s ?? (this.data ? { length: r } : null);
    return [{ type: t, data: l, options: a }];
  }
}
function Kn(e, t) {
  const n = (t == null ? void 0 : t[e.as]) ?? e.as;
  return Object.hasOwn(e, "value") ? e.value : AN(e.channel) ? { value: n, scale: "color" } : Znt(e.channel) ? { value: n, scale: "opacity" } : n;
}
function MN(e, t, n = []) {
  const i = Lt.from({ source: t }), r = /* @__PURE__ */ new Set();
  let s = !1;
  for (const o of e) {
    const { channel: a, field: c, as: l } = o;
    if (!n.includes(a)) {
      if (a === "orderby")
        i.orderby(o.value);
      else if (c) {
        if (c.aggregate)
          s = !0;
        else {
          if (r.has(l))
            continue;
          r.add(l);
        }
        i.select({ [l]: c });
      }
    }
  }
  return s && i.groupby(Array.from(r)), i;
}
function ey(e, t) {
  const { plot: n } = e;
  let i = n.getAttribute(`${t}Scale`);
  if (!i) {
    const { type: s } = e.channelField(t);
    i = s === "date" ? "time" : "linear";
  }
  const r = { type: i };
  switch (i) {
    case "log":
      r.base = n.getAttribute(`${t}Base`) ?? 10;
      break;
    case "pow":
      r.exponent = n.getAttribute(`${t}Exponent`) ?? 1;
      break;
    case "symlog":
      r.constant = n.getAttribute(`${t}Constant`) ?? 1;
      break;
  }
  return X3(r);
}
function Qs(e, t, n, i, r = 1, s) {
  const { field: o } = e.channelField(t);
  s = s ?? o;
  const { type: a, apply: c, sqlApply: l } = ey(e, t), u = !!e.plot.getAttribute(`${t}Reverse`), [f, h] = i.map((b) => c(b)), d = l(s), p = a === "time" || a === "utc" ? d : s, y = h === f ? 0 : (n - r) / (h - f), m = y !== 1 ? ` * ${y}::DOUBLE` : "";
  return [u ? q`(${h} - ${d}::DOUBLE)${m}` : q`(${d}::DOUBLE - ${f})${m}`, p];
}
const $N = { x: ["min", "max"] }, TN = { y: ["min", "max"] }, DN = { ...$N, ...TN };
function NN(e, t, n, i, r) {
  const { plot: s } = e, o = s.getAttribute(i), a = s.getAttribute(r);
  if (Array.isArray(o) && !o[$i])
    return o;
  {
    const { column: c, min: l, max: u } = e.channelField(n), f = BN(t, c) || (a ? a0().domain([l, u]).nice().domain() : [l, u]);
    return o !== mf && (f[$i] = !0), s.setAttribute(i, f, { silent: !0 }), f;
  }
}
function Wf(e, t) {
  return NN(e, t, "x", "xDomain", "xNice");
}
function Gf(e, t) {
  return NN(e, t, "y", "yDomain", "yNice");
}
function BN(e, t) {
  if (!e)
    return;
  let n, i;
  const r = (s, o) => {
    if (s === "BETWEEN" && `${o.field}` === t) {
      const { range: a } = o;
      a && (n == null || a[0] < n) && (n = a[0]), a && (i == null || a[1] > i) && (i = a[1]);
    }
  };
  return Array.isArray(e) ? e.forEach((s) => {
    var o;
    return (o = s.visit) == null ? void 0 : o.call(s, r);
  }) : e.visit && e.visit(r), n != null && i != null && n !== i ? [n, i] : void 0;
}
class eit extends ha {
  constructor(t, n, i) {
    const r = t.endsWith("X") ? "y" : t.endsWith("Y") ? "x" : null, s = r ? { [r]: ["min", "max"] } : void 0;
    super(t, n, i, s), this.dim = r;
  }
  /**
   * Return a query specifying the data needed by this Mark client.
   * @param {*} [filter] The filtering criteria to apply in the query.
   * @returns {*} The client query
   */
  query(t = []) {
    var y;
    const { plot: n, dim: i, source: r } = this, { optimize: s = !0 } = r.options || {}, o = super.query(t);
    if (!i)
      return o;
    const a = i === "x" ? "y" : "x", c = (y = this.channelField(a, { exact: !0 })) == null ? void 0 : y.as, { field: l, as: u, type: f, min: h, max: d } = this.channelField(i);
    if (s && (f === "date" || f === "number") && c) {
      const m = i === "x" ? n.innerWidth() : n.innerHeight(), [g, b] = BN(t, l) || [h, d], [w] = Qs(this, i, m, [g, b], 1, u), v = o.select().map((S) => S.as).filter((S) => S !== u && S !== c);
      return nit(o, w, u, c, v);
    } else
      return o.orderby(l);
  }
}
function nit(e, t, n, i, r = []) {
  const s = q`FLOOR(${t})::INTEGER`, o = (a) => Lt.from(e).select(a).groupby(s, r);
  return Lt.union(
    o([{ [n]: Tc(n), [i]: Ng(i, n) }, ...r]),
    o([{ [n]: $c(n), [i]: Bg(i, n) }, ...r]),
    o([{ [n]: Ng(n, i), [i]: Tc(i) }, ...r]),
    o([{ [n]: Bg(n, i), [i]: $c(i) }, ...r])
  ).orderby(r, n);
}
function ON(e, t = []) {
  return new t.constructor(e);
}
function iit(e, t, n) {
  const i = ON(e, n), r = n.length;
  for (let s = 0; s < r; ++s)
    i[t[s]] = n[s];
  return i;
}
function rit(e, t, n, i, r, s, o) {
  const a = n.length, c = e * t, l = r.map((d) => i[d]), u = {}, f = [], h = new Int32Array(a);
  if (s != null && s.length) {
    const d = s.map((y) => i[y]), p = {};
    for (let y = 0; y < a; ++y) {
      const m = d.map((g) => g[y]);
      h[y] = p[m] ?? (p[m] = f.push(m) - 1);
    }
    for (let y = 0; y < s.length; ++y)
      u[s[y]] = f.map((m) => m[y]);
  } else
    f.push([]);
  if (o) {
    const d = n.map((m) => m % e), p = n.map((m) => Math.floor(m / e)), y = f.map(() => []);
    for (let m = 0; m < a; ++m)
      y[h[m]].push(m);
    r.forEach((m, g) => {
      const b = l[g];
      u[m] = f.map((w, v) => o(y[v], e, t, d, p, b));
    });
  } else
    r.forEach((d, p) => {
      const y = l[p], m = u[d] = f.map(() => ON(c, y));
      for (let g = 0; g < a; ++g)
        m[h[g]][n[g]] = y[g];
    });
  return { numRows: f.length, columns: u };
}
function zv(e) {
  let t = 1 / 0, n = -1 / 0;
  return e.forEach((i) => {
    const r = i.length;
    for (let s = 0; s < r; ++s) {
      const o = i[s];
      o < t && (t = o), o > n && (n = o);
    }
  }), Number.isFinite(t) && Number.isFinite(n) ? [t, n] : [0, 1];
}
function sit(e) {
  const t = new el();
  return e.forEach((n) => {
    const i = n.length;
    for (let r = 0; r < i; ++r)
      t.add(n[r]);
  }), Array.from(t).sort(me);
}
function Rn(e, t) {
  return Us(e) ? (e.addEventListener("value", t), e.value) : e;
}
function H1(e, t = !1) {
  const n = new Float64Array(5), i = new Float64Array(4);
  oit(n, i, e);
  const r = Float64Array.of(
    0,
    i[1] - n[1] * i[0],
    i[2] - n[2] * i[0],
    i[3] - n[3] * i[0],
    -n[4] * i[0]
  ), s = 1 + n[1] + n[2] + n[3] + n[4], o = (i[0] + i[1] + i[2] + i[3]) / s, a = (r[1] + r[2] + r[3] + r[4]) / s;
  return {
    sigma: e,
    negative: t,
    a: n,
    b_causal: i,
    b_anticausal: r,
    sum_causal: o,
    sum_anticausal: a
  };
}
function oit(e, t, n) {
  const r = Float64Array.of(
    0.84,
    1.8675,
    0.84,
    -1.8675,
    -0.34015,
    -0.1299,
    -0.34015,
    0.1299
  ), s = Math.exp(-1.783 / n), o = Math.exp(-1.723 / n), a = 0.6318 / n, c = 1.997 / n, l = Float64Array.of(
    -s * Math.cos(a),
    s * Math.sin(a),
    -s * Math.cos(-a),
    s * Math.sin(-a),
    -o * Math.cos(c),
    o * Math.sin(c),
    -o * Math.cos(-c),
    o * Math.sin(-c)
  ), u = n * 2.5066282746310007, f = Float64Array.of(r[0], r[1], 0, 0, 0, 0, 0, 0), h = Float64Array.of(1, 0, l[0], l[1], 0, 0, 0, 0, 0, 0);
  let d, p;
  for (p = 2; p < 8; p += 2) {
    for (f[p] = l[p] * f[p - 2] - l[p + 1] * f[p - 1], f[p + 1] = l[p] * f[p - 1] + l[p + 1] * f[p - 2], d = p - 2; d > 0; d -= 2)
      f[d] += l[p] * f[d - 2] - l[p + 1] * f[d - 1], f[d + 1] += l[p] * f[d - 1] + l[p + 1] * f[d - 2];
    for (d = 0; d <= p; d += 2)
      f[d] += r[p] * h[d] - r[p + 1] * h[d + 1], f[d + 1] += r[p] * h[d + 1] + r[p + 1] * h[d];
    for (h[p + 2] = l[p] * h[p] - l[p + 1] * h[p + 1], h[p + 3] = l[p] * h[p + 1] + l[p + 1] * h[p], d = p; d > 0; d -= 2)
      h[d] += l[p] * h[d - 2] - l[p + 1] * h[d - 1], h[d + 1] += l[p] * h[d - 1] + l[p + 1] * h[d - 2];
  }
  for (p = 0; p < 4; ++p)
    d = p << 1, t[p] = f[d] / u, e[p + 1] = h[d + 2];
}
function ait(e, t, n, [i, r]) {
  const s = new Float64Array(Math.max(i, r)), o = new Float64Array(Math.max(i, r)), a = new Float64Array(5), c = new Float64Array(n.length);
  for (let l = 0, u = 0; l < r; ++l, u += i) {
    const f = c.subarray(u);
    J1(e, n.subarray(u), i, 1, s, o, a, f);
  }
  for (let l = 0; l < i; ++l) {
    const u = c.subarray(l);
    J1(t, u, r, i, s, o, a, u);
  }
  return c;
}
function J1(e, t, n, i = 1, r = new Float64Array(n), s = new Float64Array(n), o = new Float64Array(5), a = r, c = cit) {
  const l = i * 2, u = i * 3, f = i * 4, h = i * n;
  let d, p;
  for (c(
    r,
    t,
    n,
    i,
    e.b_causal,
    3,
    e.a,
    4,
    e.sum_causal,
    o,
    e.sigma
  ), p = 4, d = f; p < n; ++p, d += i)
    r[p] = e.b_causal[0] * t[d] + e.b_causal[1] * t[d - i] + e.b_causal[2] * t[d - l] + e.b_causal[3] * t[d - u] - e.a[1] * r[p - 1] - e.a[2] * r[p - 2] - e.a[3] * r[p - 3] - e.a[4] * r[p - 4];
  for (c(
    s,
    t,
    n,
    -i,
    e.b_anticausal,
    4,
    e.a,
    4,
    e.sum_anticausal,
    o,
    e.sigma
  ), p = 4, d = h - i * 5; p < n; ++p, d -= i)
    s[p] = e.b_anticausal[1] * t[d + i] + e.b_anticausal[2] * t[d + l] + e.b_anticausal[3] * t[d + u] + e.b_anticausal[4] * t[d + f] - e.a[1] * s[p - 1] - e.a[2] * s[p - 2] - e.a[3] * s[p - 3] - e.a[4] * s[p - 4];
  if (e.negative)
    for (p = 0, d = 0; p < n; ++p, d += i)
      a[d] = r[p] + s[n - p - 1];
  else
    for (p = 0, d = 0; p < n; ++p, d += i)
      a[d] = Math.max(0, r[p] + s[n - p - 1]);
  return a;
}
function cit(e, t, n, i, r, s, o, a, c, l, u, f = 0.5) {
  const h = Math.abs(i) * n, d = i < 0 ? h + i : 0;
  let p, y, m;
  for (y = 0; y <= a; ++y)
    for (l[y] = y <= s ? r[y] : 0, m = 1; m <= a && m <= y; ++m)
      l[y] -= o[m] * l[y - m];
  for (m = 0; m < a; ++m)
    for (e[m] = 0, y = 1; y <= m; ++y)
      p = d + i * y, p >= 0 && p < h && (e[m] += l[m - y] * t[p]);
  const g = t[d], b = Math.ceil(u * 10);
  for (y = 0; y < b; ++y) {
    for (m = 0; m < a; ++m)
      e[m] += l[m] * g;
    if (c -= Math.abs(l[0]), c <= f)
      break;
    for (l[a] = y + a <= s ? r[y + a] : 0, m = 1; m <= a; ++m)
      l[a] -= o[m] * l[a - m];
    for (m = 0; m < a; ++m)
      l[m] = l[m + 1];
  }
}
const Es = "density";
class Y0 extends ha {
  constructor(t, n, i) {
    const {
      bandwidth: r = 0,
      interpolate: s = "none",
      pixelSize: o = 1,
      pad: a = 1,
      width: c,
      height: l,
      ...u
    } = i, f = lit(u);
    super(t, n, u, DN), this.densityMap = f, this.bandwidth = Rn(r, (h) => (this.bandwidth = h, this.grids ? this.convolve().update() : null)), this.interpolate = Rn(s, (h) => (this.interpolate = h, this.requestUpdate())), this.pixelSize = Rn(o, (h) => (this.pixelSize = h, this.requestUpdate())), this.pad = Rn(a, (h) => (this.pad = h, this.requestUpdate())), this.width = Rn(c, (h) => (this.width = h, this.requestUpdate())), this.height = Rn(l, (h) => (this.height = h, this.requestUpdate()));
  }
  /**
   * @param {import('../plot.js').Plot} plot The plot.
   * @param {number} index 
   */
  setPlot(t, n) {
    const i = () => {
      this.hasFieldInfo() && this.requestUpdate();
    };
    t.addAttributeListener("xDomain", i), t.addAttributeListener("yDomain", i), super.setPlot(t, n);
  }
  get filterIndexable() {
    const t = this.plot.getAttribute("xDomain"), n = this.plot.getAttribute("yDomain");
    return t && n && !t[$i] && !n[$i];
  }
  query(t = []) {
    const { interpolate: n, pad: i, channels: r, densityMap: s, source: o } = this, [a, c] = this.extentX = Wf(this, t), [l, u] = this.extentY = Gf(this, t), [f, h] = this.bins = this.binDimensions(), [d, p] = Qs(this, "x", f, [a, c], i), [y, m] = Qs(this, "y", h, [l, u], i), g = i ? [Tn(p, [+a, +c]), Tn(m, [+l, +u])] : [Tu(+a, p), $u(p, +c), Tu(+l, m), $u(m, +u)], b = Lt.from(o.table).where(t.concat(g)), w = this.groupby = [], v = {};
    for (const _ of r)
      if (Object.hasOwn(_, "field")) {
        const { as: I, channel: T, field: M } = _;
        M.aggregate ? (v[T] = M, s[T] = !0) : T === "weight" ? v[Es] = oa(M) : T !== "x" && T !== "y" && (b.select({ [I]: M }), w.push(I));
      }
    const S = this.aggr = Object.keys(v);
    if (v.density && S.length > 1)
      throw new Error("Weight option can not be used with custom aggregates.");
    if (S.length || (S.push(Es), v.density = Uo()), n === "linear") {
      if (S.length > 1)
        throw new Error("Linear binning not applicable to multiple aggregates.");
      if (!v.density)
        throw new Error("Linear binning not applicable to custom aggregates.");
      return hit(b, d, y, v[Es], f, w);
    } else
      return fit(b, d, y, v, f, w);
  }
  /**
   * @returns {[number, number]} The bin dimensions.
   */
  binDimensions() {
    const { plot: t, pixelSize: n, width: i, height: r } = this;
    return [
      i ?? Math.round(t.innerWidth() / n),
      r ?? Math.round(t.innerHeight() / n)
    ];
  }
  queryResult(t) {
    const [n, i] = this.bins, r = uit(this.interpolate), { columns: s } = Zu(t);
    return this.grids0 = rit(n, i, s.index, s, this.aggr, this.groupby, r), this.convolve();
  }
  convolve() {
    const { aggr: t, bandwidth: n, bins: i, grids0: r, plot: s } = this;
    if (this.grids = r, n > 0) {
      const o = t.length === 1 ? t[0] : t.includes(Es) ? Es : null;
      if (!o)
        return console.warn("No compatible grid found for smoothing."), this;
      const a = r.columns[o], c = s.innerWidth(), l = s.innerHeight(), [u, f] = i, h = a.some((y) => y.some((m) => m < 0)), d = H1(n * (u - 1) / c, h), p = H1(n * (f - 1) / l, h);
      this.grids = {
        numRows: r.numRows,
        columns: {
          ...r.columns,
          // @ts-ignore
          [o]: a.map((y) => ait(d, p, y, i))
        }
      };
    }
    return this;
  }
}
function lit(e) {
  const t = {};
  for (const n in e)
    e[n] === "density" && (delete e[n], t[n] = !0);
  return t;
}
function uit(e = "none") {
  if (typeof e == "function")
    return e;
  switch (e.toLowerCase()) {
    case "none":
    case "linear":
      return;
    case "nearest":
      return Tv;
    case "barycentric":
      return $v();
    case "random-walk":
      return Dv();
  }
  throw new Error(`invalid interpolate: ${e}`);
}
function fit(e, t, n, i, r, s) {
  return e.select({
    index: q`FLOOR(${t})::INTEGER + FLOOR(${n})::INTEGER * ${r}`,
    ...i
  }).groupby("index", s);
}
function hit(e, t, n, i, r, s) {
  const o = i != null && i.column ? `* ${i.column}` : "", a = (h, d) => e.clone().select({ xp: t, yp: n, i: h, w: d }), c = a(
    q`FLOOR(xp)::INTEGER + FLOOR(yp)::INTEGER * ${r}`,
    q`(FLOOR(xp)::INTEGER + 1 - xp) * (FLOOR(yp)::INTEGER + 1 - yp)${o}`
  ), l = a(
    q`FLOOR(xp)::INTEGER + (FLOOR(yp)::INTEGER + 1) * ${r}`,
    q`(FLOOR(xp)::INTEGER + 1 - xp) * (yp - FLOOR(yp)::INTEGER)${o}`
  ), u = a(
    q`FLOOR(xp)::INTEGER + 1 + FLOOR(yp)::INTEGER * ${r}`,
    q`(xp - FLOOR(xp)::INTEGER) * (FLOOR(yp)::INTEGER + 1 - yp)${o}`
  ), f = a(
    q`FLOOR(xp)::INTEGER + 1 + (FLOOR(yp)::INTEGER + 1) * ${r}`,
    q`(xp - FLOOR(xp)::INTEGER) * (yp - FLOOR(yp)::INTEGER)${o}`
  );
  return Lt.from(Lt.unionAll(c, l, u, f)).select({ index: "i", density: oa("w") }, s).groupby("index", s).having(Lb("density", 0));
}
class dit extends Y0 {
  constructor(t, n) {
    const { thresholds: i = 10, ...r } = n;
    super("geo", t, {
      bandwidth: 20,
      interpolate: "linear",
      pixelSize: 2,
      ...r
    }), this.thresholds = Rn(i, (s) => (this.thresholds = s, this.grids ? this.contours().update() : null));
  }
  convolve() {
    return super.convolve().contours();
  }
  contours() {
    const { bins: t, densityMap: n, grids: i, thresholds: r, plot: s } = this, { numRows: o, columns: a } = i;
    let c = r, l;
    if (Array.isArray(c))
      l = c;
    else {
      const [, A] = zv(a.density);
      l = Array.from({ length: c - 1 }, (B, R) => A * (R + 1) / c);
    }
    (n.fill || n.stroke) && this.plot.getAttribute("colorScale") !== "log" && this.plot.setAttribute("colorZero", !0);
    const [u, f] = t, [h, d] = s.getAttribute("xDomain"), [p, y] = s.getAttribute("yDomain"), m = (d - h) / u, g = (y - p) / f, b = +h, w = +p, v = (A) => b + A * m, S = (A) => w + A * g, _ = rp().size(t), I = this.contourData = Array(o * l.length), { density: T, ...M } = a, N = Object.entries(M);
    for (let A = 0, B = 0; A < o; ++A) {
      const R = T[A], x = N.reduce(($, [D, L]) => ($[D] = L[A], $), {});
      for (let $ = 0; $ < l.length; ++$, ++B)
        I[B] = Object.assign(
          pit(_.contour(R, l[$]), v, S),
          x
        );
    }
    return this;
  }
  plotSpecs() {
    const { type: t, channels: n, densityMap: i, contourData: r } = this, s = {};
    for (const o of n) {
      const { channel: a } = o;
      a !== "x" && a !== "y" && (s[a] = Kn(o));
    }
    for (const o in i)
      i[o] && (s[o] = Kn({ channel: o, as: "value" }));
    return [{ type: t, data: r, options: s }];
  }
}
function pit(e, t, n) {
  function i(o) {
    o.forEach(r);
  }
  function r(o) {
    o.forEach(s);
  }
  function s(o) {
    o[0] = t(o[0]), o[1] = n(o[1]);
  }
  return e.coordinates.forEach(i), e;
}
function FN(e, t) {
  if (typeof document < "u") {
    const n = document.createElement("canvas");
    return n.setAttribute("width", e), n.setAttribute("height", t), n;
  }
  throw new Error("Can not create a canvas instance.");
}
function yit(e = 1) {
  const t = 255 * e | 0;
  return (n, i, r) => {
    for (let s = 0, o = 0; s < r; ++s)
      for (let a = 0; a < i; ++a, o += 4)
        n[o + 3] = t;
  };
}
function mit(e) {
  const { apply: t } = e;
  return (n, i, r, s) => {
    for (let o = 0, a = 0; o < r; ++o)
      for (let c = 0, l = (r - o - 1) * i; c < i; ++c, a += 4)
        n[a + 3] = 255 * t(s[c + l]) | 0;
  };
}
function git(e = {}) {
  const { r: t = 0, g: n = 0, b: i = 0, opacity: r = 1 } = typeof e == "string" ? Vn(e) : e, s = new Uint8ClampedArray([t, n, i, 255 * r | 0]);
  return (o, a, c) => {
    for (let l = 0, u = 0; l < c; ++l)
      for (let f = 0; f < a; ++f, u += 4)
        o[u + 0] = s[0], o[u + 1] = s[1], o[u + 2] = s[2], o[u + 3] = s[3];
  };
}
function bit(e) {
  const { domain: t, range: n } = e, i = /* @__PURE__ */ Object.create(null), r = new Uint8ClampedArray(4 * t.length), s = t.length - 1, o = n.length;
  for (let a = 0; a <= s; ++a) {
    const c = n[a % o], { r: l, g: u, b: f, opacity: h = 1 } = typeof c == "string" ? Vn(c) : c, d = a << 2;
    r[d + 0] = l, r[d + 1] = u, r[d + 2] = f, r[d + 3] = 255 * h | 0, i[t[a]] = d;
  }
  return (a, c, l, u) => {
    if (u.map)
      for (let f = 0, h = 0; f < l; ++f)
        for (let d = 0, p = (l - f - 1) * c; d < c; ++d, h += 4) {
          const y = i[u[d + p]];
          a[h + 0] = r[y + 0], a[h + 1] = r[y + 1], a[h + 2] = r[y + 2], a[h + 3] = r[y + 3];
        }
    else {
      const f = i[u];
      for (let h = 0, d = 0; h < l; ++h)
        for (let p = 0; p < c; ++p, d += 4)
          a[d + 0] = r[f + 0], a[d + 1] = r[f + 1], a[d + 2] = r[f + 2], a[d + 3] = r[f + 3];
    }
  };
}
function wit(e, t, n) {
  const { interpolate: i } = t, r = new Uint8ClampedArray(4 * e), s = e - 1;
  for (let o = 0; o <= s; ++o) {
    const a = i(o / s), { r: c, g: l, b: u, opacity: f = 1 } = typeof a == "string" ? Vn(a) : a, h = o << 2;
    r[h + 0] = c, r[h + 1] = l, r[h + 2] = u, r[h + 3] = 255 * f | 0;
  }
  return (o, a, c, l) => {
    for (let u = 0, f = 0; u < c; ++u)
      for (let h = 0, d = (c - u - 1) * a; h < a; ++h, f += 4) {
        const p = s * n(l[h + d]) << 2;
        o[f + 0] = r[p + 0], o[f + 1] = r[p + 1], o[f + 2] = r[p + 2], o[f + 3] = r[p + 3];
      }
  };
}
class Pv extends Y0 {
  constructor(t, n) {
    super("image", t, n), this.image = null;
  }
  setPlot(t, n) {
    const i = () => {
      this.hasFieldInfo() && this.rasterize();
    };
    t.addAttributeListener("schemeColor", i), super.setPlot(t, n);
  }
  convolve() {
    return super.convolve().rasterize();
  }
  rasterize() {
    const { bins: t, grids: n } = this, [i, r] = t, { numRows: s, columns: o } = n, { canvas: a, ctx: c, img: l } = Iit(this, i, r), { alpha: u, alphaProp: f, color: h, colorProp: d } = EN(this), p = o[f] ?? [], y = o[d] ?? [];
    return this.data = {
      numRows: s,
      columns: {
        src: Array.from({ length: s }, (m, g) => (h == null || h(l.data, i, r, y[g]), u == null || u(l.data, i, r, p[g]), c.putImageData(l, 0, 0), a.toDataURL()))
      }
    }, this;
  }
  plotSpecs() {
    var o;
    const { type: t, plot: n, data: { numRows: i, columns: r } } = this, s = {
      src: r.src,
      width: n.innerWidth(),
      height: n.innerHeight(),
      preserveAspectRatio: "none",
      imageRendering: (o = this.channel("imageRendering")) == null ? void 0 : o.value,
      frameAnchor: "middle"
    };
    return [{ type: t, data: { length: i }, options: s }];
  }
}
class vit extends Pv {
  constructor(t, n) {
    super(t, {
      bandwidth: 20,
      interpolate: "linear",
      pixelSize: 2,
      ...n
    });
  }
}
function EN(e) {
  const { aggr: t, densityMap: n, groupby: i, plot: r } = e, s = t.includes(Es), o = t.includes("fillOpacity"), a = e.channel("fill"), c = e.channel("fillOpacity");
  if (t.length > 2 || s && o)
    throw new Error("Invalid raster encodings. Try dropping an aggregate?");
  if (i.includes(c == null ? void 0 : c.as))
    throw new Error("Raster fillOpacity must be an aggregate or constant.");
  const l = n.fill || t.includes("fill") ? "grid" : i.includes(a == null ? void 0 : a.as) ? "group" : IN(a == null ? void 0 : a.value) ? a.value : s && r.getAttribute("colorScheme") ? "grid" : void 0, u = n.fillOpacity || t.includes("fillOpacity") ? "grid" : typeof (c == null ? void 0 : c.value) == "number" ? c.value : s && l !== "grid" ? "grid" : void 0;
  if (l !== "grid" && u !== "grid")
    throw new Error("Raster mark missing density values.");
  const f = (a == null ? void 0 : a.as) ?? (l === "grid" ? Es : null), h = (c == null ? void 0 : c.as) ?? (u === "grid" ? Es : null), d = l !== "grid" && l !== "group" ? git(l) : Sit(e, f), p = u !== "grid" ? yit(u) : _it(e, h);
  return { alphaProp: h, colorProp: f, alpha: p, color: d };
}
function _it(e, t) {
  const { plot: n, grids: i } = e, r = n.getAttribute("opacityDomain"), s = r === mf, o = r == null ? void 0 : r[$i], a = !s && !o && r || zv(i.columns[t]);
  (s || o || !r) && (s || (a[$i] = !0), n.setAttribute("opacityDomain", a));
  const c = Xu({
    opacity: {
      type: n.getAttribute("opacityScale"),
      domain: a,
      clamp: n.getAttribute("opacityClamp"),
      nice: n.getAttribute("opacityNice"),
      reverse: n.getAttribute("opacityReverse"),
      zero: n.getAttribute("opacityZero"),
      base: n.getAttribute("opacityBase"),
      exponent: n.getAttribute("opacityExponent"),
      constant: n.getAttribute("opacityConstant")
    }
  });
  return mit(c);
}
function Sit(e, t) {
  var h;
  const { plot: n, grids: i } = e, r = i.columns[t], s = !((h = r[0]) != null && h.map), o = s || Array.isArray(r[0]), a = n.getAttribute("colorDomain"), c = a === mf, l = a == null ? void 0 : a[$i], u = !c && !l && a || (s ? r.sort(me) : o ? sit(r) : zv(r));
  (c || l || !a) && (c || (u[$i] = !0), n.setAttribute("colorDomain", u));
  const f = Xu({
    color: {
      type: n.getAttribute("colorScale"),
      domain: u,
      range: n.getAttribute("colorRange"),
      clamp: n.getAttribute("colorClamp"),
      n: n.getAttribute("colorN"),
      nice: n.getAttribute("colorNice"),
      reverse: n.getAttribute("colorReverse"),
      scheme: n.getAttribute("colorScheme"),
      interpolate: n.getAttribute("colorInterpolate"),
      pivot: n.getAttribute("colorPivot"),
      symmetric: n.getAttribute("colorSymmetric"),
      zero: n.getAttribute("colorZero"),
      base: n.getAttribute("colorBase"),
      exponent: n.getAttribute("colorExponent"),
      constant: n.getAttribute("colorConstant")
    }
  });
  if (o)
    return bit(f);
  {
    const d = Xu({
      x: {
        type: xit(f.type),
        domain: f.domain,
        reverse: f.reverse,
        range: [0, 1],
        clamp: f.clamp,
        base: f.base,
        exponent: f.exponent,
        constant: f.constant
      }
    });
    return wit(1024, f, d.apply);
  }
}
function xit(e) {
  return e.endsWith("symlog") ? "symlog" : e.endsWith("log") ? "log" : e.endsWith("pow") ? "pow" : e.endsWith("sqrt") ? "sqrt" : e === "diverging" ? "linear" : e;
}
function Iit(e, t, n) {
  if (!e.image || e.image.w !== t || e.image.h !== n) {
    const i = FN(t, n), r = i.getContext("2d", { willReadFrequently: !0 }), s = r.getImageData(0, 0, t, n);
    e.image = { canvas: i, ctx: r, img: s, w: t, h: n };
  }
  return e.image;
}
class Ait extends Pv {
  constructor(t, n) {
    const { normalize: i = !0, ...r } = n;
    super(t, r), this.normalize = Rn(i, (s) => (this.normalize = s, this.requestUpdate()));
  }
  query(t = []) {
    const { channels: n, normalize: i, source: r, pad: s } = this, [o, a] = this.bins = this.binDimensions(), [c] = Qs(this, "x", o, Wf(this, t), s), [l] = Qs(this, "y", a, Gf(this, t), s), u = Lt.from(r.table).where(Mit(this, t));
    this.aggr = ["density"];
    const f = this.groupby = [], h = [];
    for (const d of n)
      if (Object.hasOwn(d, "field")) {
        const { channel: p, field: y } = d;
        p === "z" ? (u.select({ [p]: y }), h.push("z")) : p !== "x" && p !== "y" && (u.select({ [p]: y }), f.push(p));
      }
    return $it(u, c, l, h, o, a, f, i);
  }
}
function Mit(e, t) {
  if (Array.isArray(t) && !t.length)
    return t;
  const { column: n } = e.channelField("x"), { column: i } = e.channelField("y"), r = (o) => {
    const a = `${o.field}`;
    return o.op !== "BETWEEN" || a !== n && a !== i;
  }, s = (o) => o.op === "AND" ? qs(o.children.filter((a) => r(a))) : o;
  return Array.isArray(t) ? t.filter((o) => r(o)).map((o) => s(o)) : s(t);
}
function $it(e, t, n, i, r, s, o = [], a = !0) {
  e.select({
    x: q`FLOOR(${t})::INTEGER`,
    y: q`FLOOR(${n})::INTEGER`
  });
  const c = o.concat(i), l = c.length ? `PARTITION BY ${c.join(", ")} ` : "", u = Lt.from(e).select(c, {
    x0: "x",
    y0: "y",
    dx: q`(lead(x) OVER sw - x)`,
    dy: q`(lead(y) OVER sw - y)`
  }).window({ sw: q`${l}ORDER BY x ASC` }).qualify(qs(
    q`(x0 < ${r} OR x0 + dx < ${r})`,
    q`(y0 < ${s} OR y0 + dy < ${s})`,
    q`(x0 > 0 OR x0 + dx > 0)`,
    q`(y0 > 0 OR y0 + dy > 0)`
  )), f = Lt.select({ x: q`GREATEST(MAX(ABS(dx)), MAX(ABS(dy)))` }).from("pairs"), h = Lt.select({ i: q`UNNEST(range((${f})))::INTEGER` }), d = Lt.unionAll(
    Lt.select(c, {
      x: q`x0 + i`,
      y: q`y0 + ROUND(i * dy / dx::FLOAT)::INTEGER`
    }).from("pairs", "indices").where(q`ABS(dy) <= ABS(dx) AND i < ABS(dx)`),
    Lt.select(c, {
      x: q`x0 + ROUND(SIGN(dy) * i * dx / dy::FLOAT)::INTEGER`,
      y: q`y0 + SIGN(dy) * i`
    }).from("pairs", "indices").where(q`ABS(dy) > ABS(dx) AND i < ABS(dy)`),
    Lt.select(c, { x: "x0", y: "y0" }).from("pairs").where(Eb("dx"))
  ), p = ["x"].concat(c).join(", "), y = Lt.from("raster").select(
    c,
    "x",
    "y",
    a ? { w: q`1.0 / COUNT(*) OVER (PARTITION BY ${p})` } : null
  ).where(qs(Tn("x", [0, r], !0), Tn("y", [0, s], !0)));
  return Lt.with({ pairs: u, indices: h, raster: d, points: y }).from("points").select(o, {
    index: q`x + y * ${r}::INTEGER`,
    density: a ? oa("w") : Uo()
  }).groupby("index", o);
}
class LN extends ha {
  constructor(t, n, i) {
    const { bins: r = 1024, bandwidth: s = 20, ...o } = i, a = t.endsWith("X") ? "y" : "x";
    super(t, n, o, a === "x" ? $N : TN), this.dim = a, this.bins = Rn(r, (c) => (this.bins = c, this.requestUpdate())), this.bandwidth = Rn(s, (c) => (this.bandwidth = c, this.grid ? this.convolve().update() : null));
  }
  get filterIndexable() {
    const t = this.dim === "x" ? "xDomain" : "yDomain", n = this.plot.getAttribute(t);
    return n && !n[$i];
  }
  query(t = []) {
    if (this.hasOwnData())
      throw new Error("Density1DMark requires a data source");
    const { bins: n, channels: i, dim: r, source: { table: s } } = this, o = this.extent = (r === "x" ? Wf : Gf)(this, t), [a, c] = Qs(this, r, n, o), l = MN(i, s, [r]).where(t.concat(Tn(c, o))), u = this.channelField("weight") ? "weight" : null;
    return Tit(l, a, u);
  }
  queryResult(t) {
    const { columns: { index: n, density: i } } = Zu(t);
    return this.grid = iit(this.bins, n, i), this.convolve();
  }
  convolve() {
    const { bins: t, bandwidth: n, dim: i, grid: r, plot: s, extent: [o, a] } = this, c = r.some((w) => w < 0), l = i === "x" ? s.innerWidth() : s.innerHeight(), u = H1(n * (t - 1) / l, c), f = J1(u, r, t), h = i === "x" ? "y" : "x", d = this.channelField(i).as, p = +o, y = (a - p) / (t - 1), m = 1 / y, g = new Float64Array(t), b = new Float64Array(t);
    for (let w = 0; w < t; ++w)
      g[w] = p + w * y, b[w] = f[w] * m;
    return this.data = { numRows: t, columns: { [d]: g, [h]: b } }, this;
  }
  plotSpecs() {
    const { type: t, data: { numRows: n, columns: i }, channels: r, dim: s } = this, o = s === "x" ? { y: i.y } : { x: i.x };
    for (const a of r)
      o[a.channel] = Kn(a, i);
    return [{ type: t, data: { length: n }, options: o }];
  }
}
function Tit(e, t, n) {
  const i = n ? `* ${n}` : "", r = e.clone().select({
    p: t,
    i: q`FLOOR(p)::INTEGER`,
    w: q`(FLOOR(p) + 1 - p)${i}`
  }), s = e.clone().select({
    p: t,
    i: q`FLOOR(p)::INTEGER + 1`,
    w: q`(p - FLOOR(p))${i}`
  });
  return Lt.from(Lt.unionAll(r, s)).select({ index: "i", density: oa("w") }).groupby("index").having(q3("density", 0));
}
class Dit extends Y0 {
  constructor(t, n) {
    const { type: i = "dot", ...r } = n;
    super(i, t, {
      bandwidth: 20,
      interpolate: "linear",
      pad: 0,
      pixelSize: 2,
      ...r
    });
  }
  convolve() {
    super.convolve();
    const { bins: t, pad: n, extentX: i, extentY: r } = this, [s, o] = t, a = ey(this, "x"), c = ey(this, "y"), [l, u] = i.map((m) => a.apply(m)), [f, h] = r.map((m) => c.apply(m)), d = (u - l) / (s - n), p = (h - f) / (o - n), y = n ? 0 : 0.5;
    return this.data = Nit(
      this.grids,
      t,
      l,
      f,
      d,
      p,
      a.invert,
      c.invert,
      y
    ), this;
  }
  plotSpecs() {
    const { type: t, channels: n, densityMap: i, data: { numRows: r, columns: s } } = this, o = {};
    for (const a of n) {
      const { channel: c } = a;
      o[c] = c === "x" || c === "y" ? s[c] : Kn(a, s);
    }
    for (const a in i)
      i[a] && (o[a] = s.density);
    return [{ type: t, data: { length: r }, options: o }];
  }
}
function Nit(e, t, n, i, r, s, o, a, c) {
  const l = 1 / (r * s), [u, f] = t, h = u * f, d = h * e.numRows, p = new Float64Array(d), y = new Float64Array(d), m = new Float64Array(d), g = { x: p, y, density: m }, { density: b, ...w } = e.columns;
  for (const S in w)
    g[S] = new w[S].constructor(d);
  let v = 0;
  for (let S = 0; S < e.numRows; ++S) {
    for (const I in w)
      g[I].fill(w[I][S], v, v + h);
    const _ = b[S];
    for (let I = 0, T = 0; T < f; ++T)
      for (let M = 0; M < u; ++M, ++v, ++I)
        p[v] = o(n + (M + c) * r), y[v] = a(i + (T + c) * s), m[v] = _[I] * l;
  }
  return { numRows: d, columns: g };
}
const Bit = "geom";
class Oit extends ha {
  constructor(t, n = {}, i) {
    !X1(t) && !(n != null && n.geometry) && (n.geometry = G3(Bit)), super("geo", t, n, i);
  }
  queryResult(t) {
    var i;
    super.queryResult(t);
    const n = (i = this.channelField("geometry")) == null ? void 0 : i.as;
    if (n) {
      const { columns: r } = this.data;
      typeof r[n][0] == "string" && (r[n] = r[n].map((s) => JSON.parse(s)));
    }
    return this;
  }
}
class Fit extends ha {
  constructor(t, n) {
    const { type: i = "hexagon", binWidth: r = 20, ...s } = n;
    super(i, t, { r: r / 2, clip: !0, ...s }, DN), this.binWidth = Rn(r, (o) => (this.binWidth = o, this.requestUpdate()));
  }
  get filterIndexable() {
    const t = this.plot.getAttribute("xDomain"), n = this.plot.getAttribute("yDomain");
    return t && n && !t[$i] && !n[$i];
  }
  query(t = []) {
    if (this.hasOwnData())
      return null;
    const { plot: n, binWidth: i, channels: r, source: s } = this, [o, a] = Wf(this, t), [c, l] = Gf(this, t), u = 0.5 - n.getAttribute("marginLeft"), f = 0 - n.getAttribute("marginTop"), h = `${i}::DOUBLE`, d = `${i * (1.5 / Math.sqrt(3))}::DOUBLE`, p = `${n.innerWidth() / (a - o)}::DOUBLE`, y = `${n.innerHeight() / (l - c)}::DOUBLE`;
    let m, g;
    const b = /* @__PURE__ */ new Set(), w = {};
    let v;
    for (const M of r)
      M.channel === "orderby" ? v = M.value : M.channel === "x" ? m = M : M.channel === "y" ? g = M : Object.hasOwn(M, "field") && (w[M.as] = M.field, M.field.aggregate && M.field.columns.forEach((N) => b.add(N)));
    const S = Lt.select({
      [m.as]: q`${o}::DOUBLE + ((x + 0.5 * (y & 1)) * ${h} + ${u})::DOUBLE / ${p}`,
      [g.as]: q`${l}::DOUBLE - (y * ${d} + ${f})::DOUBLE / ${y}`,
      ...w
    }).groupby("x", "y");
    v && S.orderby(v);
    const _ = `${p} * (${m.field} - ${o}::DOUBLE)`, I = `${y} * (${l}::DOUBLE - ${g.field})`, T = Lt.select({
      py: q`(${I} - ${f}) / ${d}`,
      pj: q`ROUND(py)::INTEGER`,
      px: q`(${_} - ${u}) / ${h} - 0.5 * (pj & 1)`,
      pi: q`ROUND(px)::INTEGER`,
      tt: q`ABS(py-pj) * 3 > 1 AND (px-pi)**2 + (py-pj)**2 > (px - pi - 0.5 * CASE WHEN px < pi THEN -1 ELSE 1 END)**2 + (py - pj - CASE WHEN py < pj THEN -1 ELSE 1 END)**2`,
      x: q`CASE WHEN tt THEN (pi + (CASE WHEN px < pi THEN -0.5 ELSE 0.5 END) + (CASE WHEN pj & 1 <> 0 THEN 0.5 ELSE -0.5 END))::INTEGER ELSE pi END`,
      y: q`CASE WHEN tt THEN (pj + CASE WHEN py < pj THEN -1 ELSE 1 END)::INTEGER ELSE pj END`
    }).select(Array.from(b)).from(s.table).where(Mu(m.field), Mu(g.field), t);
    return S.from(T);
  }
}
class Eit extends Y0 {
  constructor(t, n) {
    const { origin: i = [0, 0], dim: r = "xy", ...s } = n;
    super("image", t, s), this.image = null, this.origin = i, this.tileX = r.toLowerCase().includes("x"), this.tileY = r.toLowerCase().includes("y");
  }
  setPlot(t, n) {
    const i = () => {
      this.hasFieldInfo() && this.rasterize();
    };
    t.addAttributeListener("schemeColor", i), super.setPlot(t, n);
  }
  requestQuery() {
    return this.requestTiles();
  }
  query(t = []) {
    return this._filter = t, null;
  }
  tileQuery(t) {
    const { interpolate: n, pad: i, channels: r, densityMap: s, source: o } = this, [[a, c], [l, u]] = t, [f, h] = this.bins, [d, p] = Qs(this, "x", f, [a, c], i), [y, m] = Qs(this, "y", h, [l, u], i), g = i ? [Tn(p, [+a, +c]), Tn(m, [+l, +u])] : [Tu(+a, p), $u(p, +c), Tu(+l, m), $u(m, +u)], b = Lt.from(o.table).where(g), w = this.groupby = [], v = {};
    for (const _ of r)
      if (Object.hasOwn(_, "field")) {
        const { as: I, channel: T, field: M } = _;
        M.aggregate ? (v[T] = M, s[T] = !0) : T === "weight" ? v.density = oa(M) : T !== "x" && T !== "y" && (b.select({ [I]: M }), w.push(I));
      }
    const S = this.aggr = Object.keys(v);
    if (v.density && S.length > 1)
      throw new Error("Weight option can not be used with custom aggregates.");
    if (S.length || (S.push("density"), v.density = Uo()), n === "linear") {
      if (S.length > 1)
        throw new Error("Linear binning not applicable to multiple aggregates.");
      if (!v.density)
        throw new Error("Linear binning not applicable to custom aggregates.");
      return Uit(b, d, y, v.density, f, w);
    } else
      return kit(b, d, y, v, f, w);
  }
  async requestTiles() {
    const t = Wr();
    this.prefetch && t.cancel(this.prefetch);
    const { pad: n, tileX: i, tileY: r, origin: [s, o] } = this, [a, c] = this.bins = this.binDimensions(), [l, u] = Wf(this, this._filter), [f, h] = Gf(this, this._filter), d = u - l, p = h - f, y = Math.floor((l - s) * (a - n) / d), m = Math.floor((f - o) * (c - n) / p), g = (A, B) => [
      [s + A * d, s + (A + 1) * d],
      [o + B * p, o + (B + 1) * p]
    ], b = Math.floor((l - s) / d), w = i ? Jx((u - s) / d) : b, v = Math.floor((f - o) / p), S = r ? Jx((h - o) / p) : v, _ = [];
    for (let A = b; A <= w; ++A)
      for (let B = v; B <= S; ++B)
        _.push([A, B]);
    const I = _.map(
      ([A, B]) => t.query(this.tileQuery(g(A, B)))
    ), T = [];
    if (i)
      for (let A = v; A <= S; ++A)
        T.push([w + 1, A]), T.push([b - 1, A]);
    if (r) {
      const A = i ? b - 1 : b, B = i ? w + 1 : w;
      for (let R = A; R <= B; ++R)
        T.push([R, S + 1]), T.push([R, v - 1]);
    }
    this.prefetch = T.map(
      ([A, B]) => t.prefetch(this.tileQuery(g(A, B)))
    );
    const M = await Promise.all(I), N = Lit(a, c, y, m, _, M);
    this.grids0 = {
      numRows: N.length,
      columns: { density: [N] }
    }, this.convolve().update();
  }
  convolve() {
    return super.convolve().rasterize();
  }
  rasterize() {
    const { bins: t, grids: n } = this, [i, r] = t, { numRows: s, columns: o } = n, { canvas: a, ctx: c, img: l } = Cit(this, i, r), { alpha: u, alphaProp: f, color: h, colorProp: d } = EN(this), p = o[f] ?? [], y = o[d] ?? [];
    return this.data = {
      numRows: s,
      columns: {
        src: Array.from({ length: s }, (m, g) => (h == null || h(l.data, i, r, y[g]), u == null || u(l.data, i, r, p[g]), c.putImageData(l, 0, 0), a.toDataURL()))
      }
    }, this;
  }
  plotSpecs() {
    var o;
    const { type: t, plot: n, data: { numRows: i, columns: r } } = this, s = {
      src: r.src,
      width: n.innerWidth(),
      height: n.innerHeight(),
      preserveAspectRatio: "none",
      imageRendering: (o = this.channel("imageRendering")) == null ? void 0 : o.value,
      frameAnchor: "middle"
    };
    return [{ type: t, data: { length: i }, options: s }];
  }
}
function Lit(e, t, n, i, r, s) {
  const o = new Float64Array(e * t);
  return s.forEach((a, c) => {
    const [l, u] = r[c], f = l * e - n, h = u * t - i;
    Rit(e, t, o, a, f, h);
  }), o;
}
function Rit(e, t, n, i, r, s) {
  const o = i.numRows;
  if (o === 0)
    return;
  const a = i.getChild("index").toArray(), c = i.getChild("density").toArray();
  for (let l = 0; l < o; ++l) {
    const u = a[l], f = r + u % e, h = s + Math.floor(u / e);
    0 <= f && f < e && 0 <= h && h < t && (n[f + h * e] = c[l]);
  }
}
function Cit(e, t, n) {
  if (!e.image || e.image.w !== t || e.image.h !== n) {
    const i = FN(t, n), r = i.getContext("2d", { willReadFrequently: !0 }), s = r.getImageData(0, 0, t, n);
    e.image = { canvas: i, ctx: r, img: s, w: t, h: n };
  }
  return e.image;
}
function kit(e, t, n, i, r, s) {
  return e.select({
    index: q`FLOOR(${t})::INTEGER + FLOOR(${n})::INTEGER * ${r}`,
    ...i
  }).groupby("index", s);
}
function Uit(e, t, n, i, r, s) {
  const o = i.column ? `* ${i.column}` : "", a = (h, d) => e.clone().select({ xp: t, yp: n, i: h, w: d }), c = a(
    q`FLOOR(xp)::INTEGER + FLOOR(yp)::INTEGER * ${r}`,
    q`(FLOOR(xp)::INTEGER + 1 - xp) * (FLOOR(yp)::INTEGER + 1 - yp)${o}`
  ), l = a(
    q`FLOOR(xp)::INTEGER + (FLOOR(yp)::INTEGER + 1) * ${r}`,
    q`(FLOOR(xp)::INTEGER + 1 - xp) * (yp - FLOOR(yp)::INTEGER)${o}`
  ), u = a(
    q`FLOOR(xp)::INTEGER + 1 + FLOOR(yp)::INTEGER * ${r}`,
    q`(xp - FLOOR(xp)::INTEGER) * (FLOOR(yp)::INTEGER + 1 - yp)${o}`
  ), f = a(
    q`FLOOR(xp)::INTEGER + 1 + (FLOOR(yp)::INTEGER + 1) * ${r}`,
    q`(xp - FLOOR(xp)::INTEGER) * (yp - FLOOR(yp)::INTEGER)${o}`
  );
  return Lt.from(Lt.unionAll(c, l, u, f)).select({ index: "i", density: oa("w") }, s).groupby("index", s).having(Lb("density", 0));
}
function Jx(e) {
  const t = Math.floor(e);
  return t === e ? t - 1 : t;
}
function zit(e, t, n) {
  var i = 1e-8, r = t - 1, s = n - 1, o = 0, a, c, l, u, f, h, d, p, y, m, g;
  if (e <= 0)
    return 0;
  if (e >= 1)
    return 1;
  for (t >= 1 && n >= 1 ? (l = e < 0.5 ? e : 1 - e, u = Math.sqrt(-2 * Math.log(l)), d = (2.30753 + u * 0.27061) / (1 + u * (0.99229 + u * 0.04481)) - u, e < 0.5 && (d = -d), p = (d * d - 3) / 6, y = 2 / (1 / (2 * t - 1) + 1 / (2 * n - 1)), m = d * Math.sqrt(p + y) / y - (1 / (2 * n - 1) - 1 / (2 * t - 1)) * (p + 5 / 6 - 2 / (3 * y)), d = t / (t + n * Math.exp(2 * m))) : (a = Math.log(t / (t + n)), c = Math.log(n / (t + n)), u = Math.exp(t * a) / t, f = Math.exp(n * c) / n, m = u + f, e < u / m ? d = Math.pow(t * m * e, 1 / t) : d = 1 - Math.pow(n * m * (1 - e), 1 / n)), g = -gc(t) - gc(n) + gc(t + n); o < 10; o++) {
    if (d === 0 || d === 1)
      return d;
    if (h = Pit(d, t, n) - e, u = Math.exp(r * Math.log(d) + s * Math.log(1 - d) + g), f = h / u, d -= u = f / (1 - 0.5 * Math.min(1, f * (r / d - s / (1 - d)))), d <= 0 && (d = 0.5 * (d + u)), d >= 1 && (d = 0.5 * (d + u + 1)), Math.abs(u) < i * d && o > 0)
      break;
  }
  return d;
}
function Pit(e, t, n) {
  var i = e === 0 || e === 1 ? 0 : Math.exp(gc(t + n) - gc(t) - gc(n) + t * Math.log(e) + n * Math.log(1 - e));
  return e < 0 || e > 1 ? 0 : e < (t + 1) / (t + n + 2) ? i * Kx(e, t, n) / t : 1 - i * Kx(1 - e, n, t) / n;
}
function Kx(e, t, n) {
  var i = 1e-30, r = 1, s = t + n, o = t + 1, a = t - 1, c = 1, l = 1 - s * e / o, u, f, h, d;
  for (Math.abs(l) < i && (l = i), l = 1 / l, d = l; r <= 100 && (u = 2 * r, f = r * (n - r) * e / ((a + u) * (t + u)), l = 1 + f * l, Math.abs(l) < i && (l = i), c = 1 + f / c, Math.abs(c) < i && (c = i), l = 1 / l, d *= l * c, f = -(t + r) * (s + r) * e / ((t + u) * (o + u)), l = 1 + f * l, Math.abs(l) < i && (l = i), c = 1 + f / c, Math.abs(c) < i && (c = i), l = 1 / l, h = l * c, d *= h, !(Math.abs(h - 1) < 3e-7)); r++)
    ;
  return d;
}
function gc(e) {
  var t = 0, n = [
    76.18009172947146,
    -86.5053203294167,
    24.01409824083091,
    -1.231739572450155,
    0.001208650973866179,
    -5395239384953e-18
  ], i = 1.000000000190015, r, s, o;
  for (o = (s = r = e) + 5.5, o -= (r + 0.5) * Math.log(o); t < 6; t++)
    i += n[t] / ++s;
  return Math.log(2.506628274631 * i / r) - o;
}
function Vit(e, t) {
  var n = zit(2 * Math.min(e, 1 - e), 0.5 * t, 0.5);
  return n = Math.sqrt(t * (1 - n) / n), e > 0.5 ? n : -n;
}
class jit extends ha {
  constructor(t, n) {
    const { ci: i = 0.95, precision: r = 4, ...s } = n;
    super("line", t, s);
    const o = () => this.modelFit ? this.confidenceBand().update() : null;
    this.ci = Rn(i, (a) => (this.ci = a, o())), this.precision = Rn(r, (a) => (this.precision = a, o()));
  }
  query(t = []) {
    const n = this.channelField("x").as, i = this.channelField("y").as, r = Array.from(new Set(
      ["stroke", "z", "fx", "fy"].flatMap((s) => {
        var o;
        return ((o = this.channelField(s)) == null ? void 0 : o.as) || [];
      })
    ));
    return Lt.from(super.query(t)).select({
      intercept: tU(i, n),
      slope: eU(i, n),
      n: nU(i, n),
      ssy: iU(i, n),
      ssx: rU(i, n),
      xm: sU(i, n),
      x0: Og(Tc(n).where(Mu(i))),
      x1: Og($c(n).where(Mu(i)))
    }).select(r).groupby(r);
  }
  queryResult(t) {
    return this.modelFit = Zu(t), this.lineData = qit(this.modelFit), this.confidenceBand();
  }
  confidenceBand() {
    const { ci: t, modelFit: n, precision: i, plot: r } = this, s = r.innerWidth();
    return this.areaData = t ? Yit(n, t, i, s) : null, this;
  }
  plotSpecs() {
    const { lineData: t, areaData: n, channels: i, ci: r } = this, s = t.columns, o = r ? n.columns : {}, a = { x: s.x, y: s.y }, c = { x: o.x, y1: o.y1, y2: o.y2, fillOpacity: 0.1 };
    for (const l of i)
      switch (l.channel) {
        case "x":
        case "y":
        case "fill":
          break;
        case "tip":
          c.tip = Kn(l, o);
          break;
        case "stroke":
          a.stroke = Kn(l, s), c.fill = Kn(l, o);
          break;
        case "strokeOpacity":
          a.strokeOpacity = Kn(l, s);
          break;
        case "fillOpacity":
          c.fillOpacity = Kn(l, o);
          break;
        default:
          a[l.channel] = Kn(l, s), c[l.channel] = Kn(l, o);
          break;
      }
    return [
      ...r ? [{ type: "areaY", data: { length: n.numRows }, options: c }] : [],
      { type: "line", data: { length: t.numRows }, options: a }
    ];
  }
}
function rg(e, t) {
  if (e.concat)
    return e.concat(t);
  const n = new e.constructor(e.length + t.length);
  return n.set(e, 0), n.set(t, e.length), n;
}
function qit(e) {
  const { x0: t, x1: n, xm: i, intercept: r, slope: s, n: o, ssx: a, ssy: c, ...l } = e.columns, u = (d, p) => r[p] + d * s[p], f = rg(t, n), h = rg(t.map(u), n.map(u));
  for (const d in l)
    l[d] = rg(l[d], l[d]);
  return { numRows: f.length, columns: { x: f, y: h, ...l } };
}
function Yit(e, t, n, i) {
  const r = e.numRows, { x0: s, x1: o, xm: a, intercept: c, slope: l, n: u, ssx: f, ssy: h, ...d } = e.columns, p = Object.keys(d), y = { x: [], y1: [], y2: [] };
  p.forEach((m) => y[m] = []);
  for (let m = 0; m < r; ++m) {
    const g = n * (o[m] - s[m]) / i, b = Vit((1 - t) / 2, u[m] - 2) * Math.sqrt(h[m] / (u[m] - 2));
    kn(s[m], o[m] - g / 2, g).concat(o[m]).forEach((w) => {
      const v = c[m] + w * l[m], S = b * Math.sqrt(1 / u[m] + (w - a[m]) ** 2 / f[m]);
      y.x.push(w), y.y1.push(v - S), y.y2.push(v + S), p.forEach((_) => y[_].push(d[_][m]));
    });
  }
  return { numRows: y.x.length, columns: y };
}
function Wit(e) {
  const t = e.toLowerCase(), n = e.length;
  let i = "";
  for (let r = 0; r < n; ++r)
    i += (e[r] !== t[r] ? "-" : "") + t[r];
  return i;
}
function Vv(e) {
  const t = {};
  for (const n in e)
    t[Wit(n)] = e[n];
  return t;
}
function Git(e) {
  const { channels: t } = e, n = /* @__PURE__ */ new Set();
  let i = !1, r = !1;
  for (const s of t) {
    const { channel: o, field: a, as: c } = s;
    if (o === "orderby")
      i = !0;
    else if (a)
      if (a.aggregate)
        r = !0;
      else {
        if (n.has(c))
          continue;
        n.add(c);
      }
  }
  return !i && r && n.size && e.channels.push({ channel: "orderby", value: Array.from(n) }), e;
}
class Xit {
  constructor(t, {
    selection: n,
    channels: i = {}
  }) {
    this.mark = Git(t), this.selection = n;
    const r = Object.entries(Vv(i));
    this.channels = r.length ? r : [["opacity", 0.2]], this.selection.addEventListener("value", FI(() => this.update()));
  }
  init(t) {
    this.svg = t;
    const n = this.values = [], i = this.mark.index, r = this.nodes = t.querySelectorAll(`[data-index="${i}"] > *`), { channels: s } = this;
    for (let o = 0; o < r.length; ++o) {
      const a = r[o];
      n.push(s.map((c) => a.getAttribute(c[0])));
    }
    return this.update();
  }
  async update() {
    const { svg: t, nodes: n, channels: i, values: r, mark: s, selection: o } = this;
    if (!t)
      return;
    const a = await Hit(s, o);
    for (let c = 0; c < n.length; ++c) {
      const l = n[c], u = r[c], f = a(l.__data__);
      for (let h = 0; h < i.length; ++h) {
        const [d, p] = i[h];
        l.setAttribute(d, f ? u[h] : p);
      }
    }
  }
}
async function Hit(e, t) {
  var l, u;
  const n = t == null ? void 0 : t.predicate(e);
  if (!n || n.length === 0)
    return () => !0;
  const i = (l = e.filterBy) == null ? void 0 : l.predicate(e, !0), r = { __: qs(n) }, s = e.query(i), o = s.groupby().length ? s.select(r) : s.$select(r), a = await e.coordinator.query(o), c = (u = a.getChild) == null ? void 0 : u.call(a, "__");
  return a.numRows || a.length ? c ? (f) => c.get(f) : (f) => a[f].__ : () => !1;
}
function jv(e) {
  const t = e.on;
  let n = !0;
  function i(r) {
    n = !1, r(), n = !0;
  }
  return e.reset = (...r) => {
    i(() => e.clear(...r));
  }, e.moveSilent = (...r) => {
    i(() => e.move(...r));
  }, e.on = (...r) => {
    if (r.length > 1 && r[1]) {
      const s = r[1];
      r[1] = (...o) => n && s(...o);
    }
    return t(...r);
  }, e;
}
function Jit() {
  return jv(jq());
}
function Kit() {
  return jv(Pq());
}
function Zit() {
  return jv(Vq());
}
const Zx = 1e-12;
function K1(e, t) {
  return e === t || e && t && Math.abs(e[0] - t[0]) < Zx && Math.abs(e[1] - t[1]) < Zx || !1;
}
function Wc(e, t) {
  var i;
  const n = (i = e.channelField(t)) == null ? void 0 : i.field;
  return (n == null ? void 0 : n.basis) || n;
}
function Z1(e, t, n = 1) {
  return t.invert(n * Math.floor(e / n));
}
function RN() {
  const e = this, t = e.getScreenCTM;
  let n;
  e.getScreenCTM = () => e.isConnected ? n = t.call(e) : n;
}
class qv {
  constructor(t, {
    channel: n,
    selection: i,
    field: r = void 0,
    pixelSize: s = 1,
    peers: o = !0,
    brush: a
  }) {
    this.mark = t, this.channel = n, this.pixelSize = s || 1, this.selection = i, this.peers = o, this.field = r || Wc(t, n), this.style = a && Vv(a), this.brush = n === "y" ? Zit() : Kit(), this.brush.on("brush end", ({ selection: c }) => this.publish(c));
  }
  reset() {
    this.value = void 0, this.g && this.brush.reset(this.g);
  }
  activate() {
    this.selection.activate(this.clause(this.value || [0, 1]));
  }
  publish(t) {
    let n;
    t && (n = t.map((i) => Z1(i, this.scale, this.pixelSize)).sort((i, r) => i - r)), K1(n, this.value) || (this.value = n, this.g.call(this.brush.moveSilent, t), this.selection.update(this.clause(n)));
  }
  clause(t) {
    const { mark: n, pixelSize: i, field: r, scale: s } = this;
    return {
      source: this,
      schema: { type: "interval", pixelSize: i, scales: [s] },
      clients: this.peers ? n.plot.markSet : (/* @__PURE__ */ new Set()).add(n),
      value: t,
      predicate: t ? Tn(r, t) : null
    };
  }
  init(t, n) {
    var l;
    const { brush: i, channel: r, style: s } = this;
    this.scale = t.scale(r);
    const o = t.scale("x").range, a = t.scale("y").range;
    i.extent([[Ye(o), Ye(a)], [De(o), De(a)]]);
    const c = ce(t).selectAll('g[aria-label="facet"]');
    if (n = c.size() ? c : ce(n ?? t), this.g = n.append("g").attr("class", `interval-${r}`).each(RN).call(i).call(i.moveSilent, (l = this.value) == null ? void 0 : l.map(this.scale.apply)), s) {
      const u = this.g.selectAll("rect.selection");
      for (const f in s)
        u.attr(f, s[f]);
    }
    t.addEventListener("pointerenter", (u) => {
      u.buttons || this.activate();
    });
  }
}
const Fh = (e, t) => e - t;
class Qit {
  constructor(t, {
    selection: n,
    xfield: i,
    yfield: r,
    pixelSize: s = 1,
    peers: o = !0,
    brush: a
  }) {
    this.mark = t, this.pixelSize = s || 1, this.selection = n, this.peers = o, this.xfield = i || Wc(t, "x"), this.yfield = r || Wc(t, "y"), this.style = a && Vv(a), this.brush = Jit(), this.brush.on("brush end", ({ selection: c }) => this.publish(c));
  }
  reset() {
    this.value = void 0, this.g && this.brush.reset(this.g);
  }
  activate() {
    this.selection.activate(this.clause(this.value || [[0, 1], [0, 1]]));
  }
  publish(t) {
    const { value: n, pixelSize: i, xscale: r, yscale: s } = this;
    let o, a;
    if (t) {
      const [c, l] = t;
      o = [c[0], l[0]].map((u) => Z1(u, r, i)).sort(Fh), a = [c[1], l[1]].map((u) => Z1(u, s, i)).sort(Fh);
    }
    (!K1(o, n == null ? void 0 : n[0]) || !K1(a, n == null ? void 0 : n[1])) && (this.value = t ? [o, a] : void 0, this.g.call(this.brush.moveSilent, t), this.selection.update(this.clause(this.value)));
  }
  clause(t) {
    const { mark: n, pixelSize: i, xfield: r, yfield: s, xscale: o, yscale: a } = this;
    return {
      source: this,
      schema: { type: "interval", pixelSize: i, scales: [o, a] },
      clients: this.peers ? n.plot.markSet : (/* @__PURE__ */ new Set()).add(n),
      value: t,
      predicate: t ? qs(Tn(r, t[0]), Tn(s, t[1])) : null
    };
  }
  init(t) {
    const { brush: n, style: i } = this, r = this.xscale = t.scale("x"), s = this.yscale = t.scale("y"), o = r.range, a = s.range;
    n.extent([[Ye(o), Ye(a)], [De(o), De(a)]]);
    const c = ce(t).selectAll('g[aria-label="facet"]'), l = c.size() ? c : ce(t);
    if (this.g = l.append("g").attr("class", "interval-xy").each(RN).call(n), i) {
      const u = this.g.selectAll("rect.selection");
      for (const f in i)
        u.attr(f, i[f]);
    }
    if (this.value) {
      const [u, f] = this.value[0].map(r.apply).sort(Fh), [h, d] = this.value[1].map(s.apply).sort(Fh);
      this.g.call(n.moveSilent, [[u, h], [f, d]]);
    }
    t.addEventListener("pointerenter", (u) => {
      u.buttons || this.activate();
    });
  }
}
class CN {
  constructor(t, {
    selection: n,
    channel: i,
    field: r
  }) {
    this.mark = t, this.selection = n, this.clients = (/* @__PURE__ */ new Set()).add(t), this.channel = i, this.field = r || Wc(t, [i]);
  }
  clause(t) {
    const { clients: n, field: i } = this, r = t ? Vy(i, tl(t)) : null;
    return {
      source: this,
      schema: { type: "point" },
      clients: n,
      value: t,
      predicate: r
    };
  }
  init(t) {
    const n = this, { mark: i, channel: r, selection: s } = this, { data: o } = i, a = i.channelField(r).as, c = ce(t).selectAll('g[aria-label="facet"]'), l = c.size() ? c : ce(t), u = t.scale(r), f = !rs(s);
    l.on("pointerdown pointermove", function(h) {
      const [d, p] = mi(h, this), y = trt(o.columns[a], u.invert(r === "x" ? d : p));
      s.update(f ? y : n.clause(y));
    }), !f && t.addEventListener("pointerenter", (h) => {
      h.buttons || this.selection.activate(this.clause(0));
    });
  }
}
function trt(e, t) {
  let n = 1 / 0, i;
  for (let r = 0; r < e.length; ++r) {
    const s = Math.abs(e[r] - t);
    s < n && (n = s, i = e[r]);
  }
  return i;
}
const Qx = (e, t) => e - t;
class ert {
  constructor(t, {
    x: n = new Xd(),
    y: i = new Xd(),
    xfield: r,
    yfield: s,
    zoom: o = !0,
    panx: a = !0,
    pany: c = !0
  }) {
    this.mark = t, this.xsel = n, this.ysel = i, this.xfield = r || Wc(t, "x"), this.yfield = s || Wc(t, "y"), this.zoom = sg(o, [0, 1 / 0], [1, 1]), this.panx = this.xsel && a, this.pany = this.ysel && c;
    const { plot: l } = t;
    a && this.xsel.addEventListener("value", (u) => {
      l.setAttribute("xDomain", u) && l.update();
    }), c && this.ysel.addEventListener("value", (u) => {
      l.setAttribute("yDomain", u) && l.update();
    });
  }
  publish(t) {
    if (this.panx) {
      const n = nrt(t, this.xscale);
      this.xsel.update(this.clause(n, this.xfield, this.xscale));
    }
    if (this.pany) {
      const n = irt(t, this.yscale);
      this.ysel.update(this.clause(n, this.yfield, this.yscale));
    }
  }
  clause(t, n, i) {
    return {
      source: this,
      schema: { type: "interval", scales: [i] },
      clients: this.mark.plot.markSet,
      value: t,
      predicate: t ? Tn(n, t) : null
    };
  }
  init(t) {
    if (this.svg = t, this.initialized)
      return;
    this.initialized = !0;
    const { panx: n, pany: i, mark: { plot: { element: r } }, xsel: s, ysel: o } = this;
    this.xscale = t.scale("x"), this.yscale = t.scale("y");
    const a = this.xscale.range.slice().sort(Qx), c = this.yscale.range.slice().sort(Qx), l = sg(n, [-1 / 0, 1 / 0], a), u = sg(i, [-1 / 0, 1 / 0], c), f = EH().extent([[a[0], c[0]], [a[1], c[1]]]).scaleExtent(this.zoom).translateExtent([[l[0], u[0]], [l[1], u[1]]]).on("start", () => {
      this.xscale = this.svg.scale("x"), this.yscale = this.svg.scale("y");
    }).on("end", () => r.__zoom = new ir(1, 0, 0)).on("zoom", ({ transform: h }) => this.publish(h));
    if (ce(r).call(f), n || i) {
      let h = !1;
      r.addEventListener("pointerenter", (d) => {
        if (!h && (h = !0, !d.buttons)) {
          if (n) {
            const { xscale: p, xfield: y } = this;
            s.activate(this.clause(p.domain, y, p));
          }
          if (i) {
            const { yscale: p, yfield: y } = this;
            o.activate(this.clause(p.domain, y, p));
          }
        }
      }), r.addEventListener("pointerleave", () => h = !1);
    }
  }
}
function sg(e, t, n) {
  return e ? Array.isArray(e) ? e : t : n;
}
function nrt(e, t) {
  return t.range.map(e.invertX, e).map(t.invert, t);
}
function irt(e, t) {
  return t.range.map(e.invertY, e).map(t.invert, t);
}
class kN {
  /**
   * @param {*} mark The mark to interact with.
   * @param {*} options The interactor options.
   */
  constructor(t, {
    selection: n,
    channels: i,
    peers: r = !0
  }) {
    this.value = null, this.mark = t, this.selection = n, this.peers = r, this.channels = i.map((s) => {
      var a;
      const o = s === "color" ? ["color", "fill", "stroke"] : s === "x" ? ["x", "x1", "x2"] : s === "y" ? ["y", "y1", "y2"] : [s];
      for (let c = 0; c < o.length; ++c) {
        const l = t.channelField(o[c], { exact: !0 });
        if (l)
          return {
            field: ((a = l.field) == null ? void 0 : a.basis) || l.field,
            as: l.as
          };
      }
      throw new Error(`Missing channel: ${s}`);
    });
  }
  clause(t) {
    const { channels: n, mark: i } = this;
    let r = null;
    if (t) {
      const s = t.map((o) => {
        const a = o.map((c, l) => Y3(n[l].field, tl(c)));
        return a.length > 1 ? qs(a) : a[0];
      });
      r = s.length > 1 ? Fb(s) : s[0];
    }
    return {
      source: this,
      schema: { type: "point" },
      clients: this.peers ? i.plot.markSet : (/* @__PURE__ */ new Set()).add(i),
      value: t,
      predicate: r
    };
  }
  init(t, n, i) {
    const { mark: r, channels: s, selection: o } = this, { data: { columns: a = {} } = {} } = r;
    i ?? (i = (l) => s.map((u) => a[u.as][l.__data__])), n ?? (n = `[data-index="${r.index}"]`);
    const c = new Set(t.querySelectorAll(n));
    t.addEventListener("pointerdown", (l) => {
      const u = o.single ? o.value : this.value, f = l.target;
      let h = null;
      if (rrt(c, f)) {
        const d = i(f);
        (l.shiftKey || l.metaKey) && (u != null && u.length) ? (h = u.filter((p) => Q1(p, d)), h.length === u.length && h.push(d)) : (u == null ? void 0 : u.length) === 1 && !Q1(u[0], d) ? h = null : h = [d];
      }
      this.value = h, srt(u, h) && o.update(this.clause(h));
    }), t.addEventListener("pointerenter", (l) => {
      l.buttons || this.selection.activate(this.clause([this.channels.map(() => 0)]));
    });
  }
}
function rrt(e, t) {
  var n;
  return e.has(t) || e.has(t.parentNode) || e.has((n = t.parentNode) == null ? void 0 : n.parentNode);
}
function srt(e, t) {
  return e == null || t == null ? e != null || t != null : e.length !== t.length || e.some((n, i) => Q1(n, t[i]));
}
function Q1(e, t) {
  const n = e.length;
  if (t.length !== n)
    return !0;
  for (let i = 0; i < n; ++i)
    if (e[i] !== t[i])
      return !0;
  return !1;
}
const UN = ":scope > div, :scope > span", ad = "swatch", tI = "ramp";
class eI {
  constructor(t, n) {
    const { as: i, field: r, ...s } = n;
    this.channel = t, this.options = { label: null, ...s }, this.type = null, this.handler = null, this.selection = i, this.field = r, this.legend = null, this.element = document.createElement("div"), this.element.setAttribute("class", "legend"), Object.assign(this.element, { value: this });
  }
  setPlot(t) {
    this.plot = t;
  }
  init(t) {
    const n = ort(this, t);
    return this.element.replaceChildren(n), this.element;
  }
  update() {
    if (!this.legend)
      return;
    const { value: t } = this.selection, n = t && t.length ? new Set(t.map((r) => r[0])) : null, i = this.legend.querySelectorAll(UN);
    for (const r of i) {
      const s = n ? n.has(r.__data__) : !0;
      r.style.opacity = s ? 1 : 0.2;
    }
  }
}
function ort(e, t) {
  const { channel: n, options: i, selection: r } = e, s = t.scale(n), o = s.type === "ordinal" ? ad : tI, a = o === ad ? i : i.label ? { tickSize: 2, ...i } : { tickSize: 2, marginTop: 1, height: 29, ...i }, c = t.legend(n, a);
  e.legend = c;
  let l = !!r;
  if (l && o === tI) {
    const u = a.width ?? 240, f = urt(s, u);
    f ? c.scale = function(h) {
      return h === "x" ? { range: [0, u] } : h === "y" ? { range: [-10, 0] } : h === n ? f : void 0;
    } : l = !1;
  }
  if (l) {
    const u = art(e, o);
    o === ad ? (u.init(c, UN, (f) => [f.__data__]), e.update()) : u.init(c, c.querySelector("g:last-of-type"));
  }
  return c;
}
function art(e, t) {
  const { channel: n, handler: i, selection: r } = e;
  if (i)
    return i;
  const s = crt(e);
  if (t === ad)
    e.handler = new kN(s, { selection: r, channels: [n] }), r.addEventListener("value", () => e.update());
  else {
    const o = { fill: "none", stroke: "currentColor" };
    e.handler = new qv(s, { selection: r, channel: n, brush: o });
  }
  return e.handler;
}
function crt(e) {
  const { channel: t, plot: n } = e, i = e.field ?? lrt(n.marks, t) ?? "value";
  if (i) {
    const r = { field: i };
    return { plot: n, channelField: (s) => t === s ? r : void 0 };
  }
}
function lrt(e, t) {
  const n = t === "color" ? ["fill", "stroke"] : t === "opacity" ? ["opacity", "fillOpacity", "strokeOpacity"] : null;
  if (n == null)
    return null;
  for (let i = e.length - 1; i > -1; --i)
    for (const r of n) {
      const s = e[i].channelField(r, { exact: !0 });
      if (s)
        return s.field;
    }
  return null;
}
function urt(e, t) {
  const { apply: n, invert: i, interpolate: r, ...s } = e;
  let o = e.type;
  o.startsWith("diverging-") && (o = o.slice(11));
  let a;
  switch (o) {
    case "log":
    case "pow":
    case "sqrt":
    case "symlog":
      a = o;
      break;
    case "threshold":
    case "quantize":
    case "quantile":
      return console.warn(`Legends do not yet support ${o} scales.`), null;
    default:
      a = "linear";
  }
  return Xu({ x: { ...s, type: a, range: [0, t] } });
}
const frt = /* @__PURE__ */ new Set(["rectY-x", "rectX-y", "rect-x", "rect-y"]);
function hrt(e, t = { steps: 25 }) {
  const n = (i, r) => frt.has(`${i.type}-${r}`) ? {
    [`${r}1`]: og(i, r, e, t),
    [`${r}2`]: og(i, r, e, { ...t, offset: 1 })
  } : {
    [r]: og(i, r, e, t)
  };
  return n[eM] = !0, n;
}
function og(e, t, n, i) {
  return {
    column: n,
    label: n,
    get stats() {
      return { column: n, stats: ["min", "max"] };
    },
    get columns() {
      return [n];
    },
    get basis() {
      return n;
    },
    toString() {
      const { apply: r, sqlApply: s, sqlInvert: o } = ey(e, t), { min: a, max: c } = e.channelField(t), l = drt(r(a), r(c), i), u = s(n), f = l.min === 0 ? u : `(${u} - ${l.min})`, h = `${(l.max - l.min) / l.steps}::DOUBLE`, d = i.offset ? `${i.offset} + ` : "", p = `${l.min} + ${h} * (${d}FLOOR(${f} / ${h}))`;
      return `${o(p)}`;
    }
  };
}
function drt(e, t, n) {
  let { steps: i = 25, minstep: r = 0, nice: s = !0 } = n;
  if (s !== !1) {
    const o = t - e, a = i, c = Math.LN10, l = Math.ceil(Math.log(a) / c);
    let u = Math.max(
      r,
      Math.pow(10, Math.round(Math.log(o) / c) - l)
    );
    for (; Math.ceil(o / u) > a; )
      u *= 10;
    const f = [5, 2];
    let h;
    for (let y = 0, m = f.length; y < m; ++y)
      h = u / f[y], h >= r && o / h <= a && (u = h);
    h = Math.log(u);
    const d = h >= 0 ? 0 : ~~(-h / c) + 1, p = Math.pow(10, -d - 1);
    h = Math.floor(e / u + p) * u, e = e < h ? h - u : h, t = Math.ceil(t / u) * u, i = Math.round((t - e) / u);
  }
  return { min: e, max: t, steps: i };
}
const prt = (e) => e && typeof e == "object" && !Array.isArray(e);
class yrt extends af {
  /**
   * Create a new Menu instance.
   * @param {object} options Options object
   */
  constructor({
    element: t,
    filterBy: n,
    from: i,
    column: r,
    label: s = r,
    format: o = (u) => u,
    // TODO
    options: a,
    value: c,
    as: l
  } = {}) {
    var f, h, d, p;
    super(n), this.from = i, this.column = r, this.selection = l, this.format = o, this.element = t ?? document.createElement("div"), this.element.setAttribute("class", "input"), this.element.value = this;
    const u = document.createElement("label");
    u.innerText = s || r, this.element.appendChild(u), this.select = document.createElement("select"), a && (this.data = a.map((y) => prt(y) ? y : { value: y }), this.update()), c = c ?? ((f = this.selection) == null ? void 0 : f.value) ?? ((d = (h = this.data) == null ? void 0 : h[0]) == null ? void 0 : d.value), ((p = this.selection) == null ? void 0 : p.value) === void 0 && this.publish(c), this.element.appendChild(this.select), this.selection && (this.select.addEventListener("input", () => {
      this.publish(this.selectedValue() ?? null);
    }), rs(this.selection) || this.selection.addEventListener("value", (y) => {
      y !== this.select.value && this.selectedValue(y);
    }));
  }
  selectedValue(t) {
    var n;
    if (arguments.length === 0) {
      const i = this.select.selectedIndex;
      return this.data[i].value;
    } else {
      const i = (n = this.data) == null ? void 0 : n.findIndex((r) => r.value === t);
      i >= 0 ? this.select.selectedIndex = i : this.select.value = String(t);
    }
  }
  reset() {
    this.select.selectedIndex = this.from ? 0 : -1;
  }
  publish(t) {
    const { selection: n, column: i } = this;
    rs(n) ? n.update({
      source: this,
      schema: { type: "point" },
      value: t,
      predicate: t !== "" && t !== void 0 ? Vy(i, tl(t)) : null
    }) : Us(n) && n.update(t);
  }
  query(t = []) {
    const { from: n, column: i } = this;
    return n ? Lt.from(n).select({ value: i }).distinct().where(t).orderby(i) : null;
  }
  queryResult(t) {
    return this.data = [{ value: "", label: "All" }, ...t], this;
  }
  update() {
    var r;
    const { data: t, format: n, select: i } = this;
    i.replaceChildren();
    for (const { value: s, label: o } of t) {
      const a = document.createElement("option");
      a.setAttribute("value", s), a.innerText = o ?? n(s), this.select.appendChild(a);
    }
    return this.selection && this.selectedValue(((r = this.selection) == null ? void 0 : r.value) ?? ""), this;
  }
}
const mrt = { contains: S9, prefix: x9, suffix: I9, regexp: _9 };
let grt = 0;
class brt extends af {
  /**
   * Create a new Search instance.
   * @param {object} options Options object
   */
  constructor({
    element: t,
    filterBy: n,
    from: i,
    column: r,
    label: s,
    type: o = "contains",
    as: a
  } = {}) {
    if (super(n), this.id = "search_" + ++grt, this.type = o, this.from = i, this.column = r, this.selection = a, this.element = t ?? document.createElement("div"), this.element.setAttribute("class", "input"), this.element.value = this, s) {
      const c = document.createElement("label");
      c.setAttribute("for", this.id), c.innerText = s, this.element.appendChild(c);
    }
    this.searchbox = document.createElement("input"), this.searchbox.setAttribute("id", this.id), this.searchbox.setAttribute("type", "text"), this.searchbox.setAttribute("placeholder", "Query"), this.element.appendChild(this.searchbox), this.selection && (this.searchbox.addEventListener("input", () => {
      this.publish(this.searchbox.value || null);
    }), rs(this.selection) || this.selection.addEventListener("value", (c) => {
      c !== this.searchbox.value && (this.searchbox.value = c);
    }));
  }
  reset() {
    this.searchbox.value = "";
  }
  publish(t) {
    const { selection: n, column: i, type: r } = this;
    rs(n) ? n.update({
      source: this,
      schema: { type: r },
      value: t,
      predicate: t ? mrt[r](i, tl(t)) : null
    }) : Us(n) && n.update(t);
  }
  query(t = []) {
    const { from: n, column: i } = this;
    return n ? Lt.from(n).select({ list: i }).distinct().where(t) : null;
  }
  queryResult(t) {
    return this.data = t, this;
  }
  update() {
    const t = document.createElement("datalist"), n = `${this.id}_list`;
    t.setAttribute("id", n);
    for (const i of this.data) {
      const r = document.createElement("option");
      r.setAttribute("value", i.list), t.append(r);
    }
    return this.datalist && this.datalist.remove(), this.element.appendChild(this.datalist = t), this.searchbox.setAttribute("list", n), this;
  }
}
let wrt = 0;
class vrt extends af {
  /**
   * Create a new Slider instance.
   * @param {object} options Options object
   */
  constructor({
    element: t,
    filterBy: n,
    as: i,
    min: r,
    max: s,
    step: o,
    from: a,
    column: c,
    label: l = c,
    value: u = i == null ? void 0 : i.value,
    width: f
  } = {}) {
    var h;
    if (super(n), this.id = "slider_" + ++wrt, this.from = a, this.column = c || "value", this.selection = i, this.min = r, this.max = s, this.step = o, this.element = t || document.createElement("div"), this.element.setAttribute("class", "input"), this.element.value = this, l) {
      const d = document.createElement("label");
      d.setAttribute("for", this.id), d.innerText = l, this.element.appendChild(d);
    }
    this.slider = document.createElement("input"), this.slider.setAttribute("id", this.id), this.slider.setAttribute("type", "range"), f != null && (this.slider.style.width = `${+f}px`), r != null && this.slider.setAttribute("min", r), s != null && this.slider.setAttribute("max", s), o != null && this.slider.setAttribute("step", o), u != null && (this.slider.setAttribute("value", u), ((h = this.selection) == null ? void 0 : h.value) === void 0 && this.publish(u)), this.element.appendChild(this.slider), this.selection && (this.slider.addEventListener("input", () => {
      this.publish(+this.slider.value);
    }), rs(this.selection) || this.selection.addEventListener("value", (d) => {
      d !== +this.slider.value && (this.slider.value = d);
    }));
  }
  query(t = []) {
    const { from: n, column: i } = this;
    return !n || this.min != null && this.max != null ? null : Lt.select({ min: Tc(i), max: $c(i) }).from(n).where(t);
  }
  queryResult(t) {
    const { min: n, max: i } = Array.from(t)[0];
    return this.min == null && this.slider.setAttribute("min", n), this.max == null && this.slider.setAttribute("max", i), this.step == null && this.slider.setAttribute("step", String((i - n) / 500)), this;
  }
  publish(t) {
    const { selection: n, column: i } = this;
    rs(n) ? n.update({
      source: this,
      schema: { type: "point" },
      value: t,
      predicate: Vy(i, tl(t))
    }) : Us(this.selection) && n.update(t);
  }
}
const zN = VN((e) => {
  const t = Yv(e);
  return (n) => n == null ? "" : typeof n == "number" ? t(n) : n instanceof Date ? PN(n) : `${n}`;
}), Yv = VN((e) => (t) => t === 0 ? "0" : t.toLocaleString(e));
zN();
Yv();
function PN(e) {
  return iD(e, "Invalid Date");
}
function VN(e) {
  let t = null, n;
  return (i = "en") => i === t ? n : n = e(t = i);
}
let _rt = -1, Srt = class extends af {
  /**
   * Create a new Table instance.
   * @param {object} options Options object
   */
  constructor({
    element: t,
    filterBy: n,
    from: i,
    columns: r = ["*"],
    align: s = {},
    format: o,
    width: a,
    maxWidth: c,
    height: l = 500,
    rowBatch: u = 100
  } = {}) {
    super(n), this.id = `table-${++_rt}`, this.from = i, this.columns = r, this.format = o, this.align = s, this.widths = typeof a == "object" ? a : {}, this.offset = 0, this.limit = +u, this.pending = !1, this.sortHeader = null, this.sortColumn = null, this.sortDesc = !1, this.element = t || document.createElement("div"), this.element.setAttribute("id", this.id), this.element.value = this, typeof a == "number" && (this.element.style.width = `${a}px`), c && (this.element.style.maxWidth = `${c}px`), this.element.style.maxHeight = `${l}px`, this.element.style.overflow = "auto";
    let f = -1;
    this.element.addEventListener("scroll", (h) => {
      const { pending: d, loaded: p } = this, { scrollHeight: y, scrollTop: m, clientHeight: g } = h.target, b = m < f;
      f = m, !(b || d || p) && y - m < 2 * g && (this.pending = !0, this.requestData(this.offset + this.limit));
    }), this.tbl = document.createElement("table"), this.element.appendChild(this.tbl), this.head = document.createElement("thead"), this.tbl.appendChild(this.head), this.body = document.createElement("tbody"), this.tbl.appendChild(this.body), this.style = document.createElement("style"), this.element.appendChild(this.style);
  }
  requestData(t = 0) {
    var i;
    this.offset = t;
    const n = this.query((i = this.filterBy) == null ? void 0 : i.predicate(this));
    this.requestQuery(n), Wr().prefetch(n.clone().offset(t + this.limit));
  }
  fields() {
    return this.columns.map((t) => zy(this.from, t));
  }
  fieldInfo(t) {
    this.schema = t;
    const n = this.head;
    n.innerHTML = "";
    const i = document.createElement("tr");
    for (const { column: r } of t) {
      const s = document.createElement("th");
      s.addEventListener("click", (o) => this.sort(o, r)), s.appendChild(document.createElement("span")), s.appendChild(document.createTextNode(r)), i.appendChild(s);
    }
    return n.appendChild(i), this.formats = xrt(this.format, t), this.style.innerText = Mrt(
      this.id,
      Irt(this.align, t),
      Art(this.widths, t)
    ), this;
  }
  query(t = []) {
    const { from: n, limit: i, offset: r, schema: s, sortColumn: o, sortDesc: a } = this;
    return Lt.from(n).select(s.map((c) => c.column)).where(t).orderby(o ? a ? y9(o) : o : []).limit(i).offset(r);
  }
  queryResult(t) {
    return this.pending || (this.loaded = !1, this.body.replaceChildren()), this.data = t, this;
  }
  update() {
    const { body: t, formats: n, data: i, schema: r, limit: s } = this, o = r.length;
    let a = 0;
    for (const c of i) {
      ++a;
      const l = document.createElement("tr");
      for (let u = 0; u < o; ++u) {
        const f = c[r[u].column], h = document.createElement("td");
        h.innerText = f == null ? "" : n[u](f), l.appendChild(h);
      }
      t.appendChild(l);
    }
    return a < s && (this.loaded = !0), this.pending = !1, this;
  }
  sort(t, n) {
    n === this.sortColumn ? this.sortDesc = !this.sortDesc : (this.sortColumn = n, this.sortDesc = !1);
    const i = t.currentTarget, r = this.sortHeader;
    r === i && t.metaKey ? (r.firstChild.textContent = "", this.sortHeader = null, this.sortColumn = null) : (r && (r.firstChild.textContent = ""), this.sortHeader = i, i.firstChild.textContent = this.sortDesc ? "" : ""), this.requestData();
  }
};
function xrt(e = {}, t, n) {
  return t.map(({ column: i, type: r }) => {
    if (i in e)
      return e[i];
    switch (r) {
      case "number":
        return Yv(n);
      case "date":
        return PN;
      default:
        return zN(n);
    }
  });
}
function Irt(e = {}, t) {
  return t.map(({ column: n, type: i }) => n in e ? e[n] : i === "number" ? "right" : "left");
}
function Art(e = {}, t) {
  return t.map(({ column: n }) => e[n]);
}
function Mrt(e, t, n) {
  const i = [];
  return t.forEach((r, s) => {
    const o = +n[s];
    if (r !== "left" || o) {
      const a = r !== "left" ? `text-align:${r};` : "", c = o ? `width:${o}px;max-width:${o}px;` : "";
      i.push(`#${e} tr>:nth-child(${s + 1}) {${a}${c}}`);
    }
  }), i.join(" ");
}
function jN(e, ...t) {
  var i;
  const n = ((i = e == null ? void 0 : e.context) == null ? void 0 : i.coordinator) ?? Wr();
  for (const r of t)
    n.connect(r);
}
function W0(e, t, n) {
  const i = new t(n);
  return jN(e, i), i.element;
}
function $rt(e) {
  return W0(this, yrt, e);
}
function Trt(e) {
  return W0(this, brt, e);
}
function Drt(e) {
  return W0(this, vrt, e);
}
function Nrt(e) {
  return W0(this, Srt, e);
}
function qN({ direction: e = "vertical", wrap: t = !1 }, n) {
  const i = document.createElement("div");
  return i.style.display = "flex", i.style.flexDirection = e === "vertical" ? "column" : "row", i.style.flexWrap = t ? t === !0 ? "wrap" : t : "nowrap", i.style.justifyContent = "flex-start", i.style.alignItems = "flex-start", n.forEach((r) => i.appendChild(r)), Object.assign(i, { value: { element: i } }), i;
}
function Brt(...e) {
  return qN({ direction: "vertical" }, e.flat());
}
function Ort(...e) {
  return qN({ direction: "horizontal" }, e.flat());
}
function YN({ dim: e = "width", size: t = 10 }) {
  const n = document.createElement("span");
  return n.style.display = "inline-block", n.style[e] = Number.isNaN(+t) ? t : `${t}px`, Object.assign(n, { value: { element: n } });
}
function Frt(e) {
  return YN({ dim: "height", size: e });
}
function Ert(e) {
  return YN({ dim: "width", size: e });
}
class WN extends Map {
  request(t, n) {
    if (this.has(t))
      n(this.get(t));
    else {
      const i = this.waiting || (this.waiting = /* @__PURE__ */ new Map()), r = i.get(t) || [];
      i.set(t, r.concat(n));
    }
  }
  set(t, n) {
    this.has(t) && console.warn(`Overwriting named plot "${t}".`);
    const { waiting: i } = this;
    return i != null && i.has(t) && (i.get(t).forEach((r) => r(n)), i.delete(t)), super.set(t, n);
  }
  clear() {
    var t;
    return (t = this.waiting) == null || t.clear(), super.clear();
  }
}
const Wv = new WN();
function Lrt(e, t, n) {
  var r;
  (((r = e == null ? void 0 : e.context) == null ? void 0 : r.namedPlots) ?? Wv).request(t, n);
}
function Rrt(e, t, n) {
  var r;
  (((r = e == null ? void 0 : e.context) == null ? void 0 : r.namedPlots) ?? Wv).set(t, n);
}
function GN(e) {
  return (t) => Rrt(this, e, t);
}
function XN(e, t, n) {
  Us(n) ? (n.addEventListener("value", (i) => {
    e.setAttribute(t, i), e.update();
  }), n.value !== void 0 && e.setAttribute(t, n.value)) : e.setAttribute(t, n);
}
function Crt(e, t) {
  return (n) => {
    XN(n, e, t);
  };
}
function Gv(e) {
  return (t) => {
    for (const [n, i] of Object.entries(e))
      XN(t, n, i);
  };
}
function HN(e) {
  const { top: t, bottom: n, left: i, right: r } = e, s = {};
  return t !== void 0 && (s.marginTop = t), n !== void 0 && (s.marginBottom = n), i !== void 0 && (s.marginLeft = i), r !== void 0 && (s.marginRight = r), Gv(s);
}
function JN(e) {
  return Gv({
    marginTop: e,
    marginBottom: e,
    marginLeft: e,
    marginRight: e
  });
}
function KN(e) {
  return Gv({ xDomain: e, yDomain: e });
}
const O = (e) => (t) => Crt(e, t), ZN = O("style"), QN = O("width"), tB = O("height"), eB = O("marginLeft"), nB = O("marginRight"), iB = O("marginTop"), rB = O("marginBottom"), sB = O("align"), oB = O("aspectRatio"), aB = O("axis"), cB = O("inset"), lB = O("grid"), uB = O("label"), fB = O("padding"), hB = O("xScale"), dB = O("xDomain"), pB = O("xRange"), yB = O("xNice"), mB = O("xInset"), gB = O("xInsetLeft"), bB = O("xInsetRight"), wB = O("xClamp"), vB = O("xRound"), _B = O("xAlign"), SB = O("xPadding"), xB = O("xPaddingInner"), IB = O("xPaddingOuter"), AB = O("xAxis"), MB = O("xTicks"), $B = O("xTickSize"), TB = O("xTickSpacing"), DB = O("xTickPadding"), NB = O("xTickFormat"), BB = O("xTickRotate"), OB = O("xGrid"), FB = O("xLine"), EB = O("xLabel"), LB = O("xLabelAnchor"), RB = O("xLabelOffset"), CB = O("xFontVariant"), kB = O("xAriaLabel"), UB = O("xAriaDescription"), zB = O("xReverse"), PB = O("xZero"), VB = O("xBase"), jB = O("xExponent"), qB = O("xConstant"), YB = O("yScale"), WB = O("yDomain"), GB = O("yRange"), XB = O("yNice"), HB = O("yInset"), JB = O("yInsetTop"), KB = O("yInsetBottom"), ZB = O("yClamp"), QB = O("yRound"), tO = O("yAlign"), eO = O("yPadding"), nO = O("yPaddingInner"), iO = O("yPaddingOuter"), rO = O("yAxis"), sO = O("yTicks"), oO = O("yTickSize"), aO = O("yTickSpacing"), cO = O("yTickPadding"), lO = O("yTickFormat"), uO = O("yTickRotate"), fO = O("yGrid"), hO = O("yLine"), dO = O("yLabel"), pO = O("yLabelAnchor"), yO = O("yLabelOffset"), mO = O("yFontVariant"), gO = O("yAriaLabel"), bO = O("yAriaDescription"), wO = O("yReverse"), vO = O("yZero"), _O = O("yBase"), SO = O("yExponent"), xO = O("yConstant"), IO = O("facetMargin"), AO = O("facetMarginTop"), MO = O("facetMarginBottom"), $O = O("facetMarginLeft"), TO = O("facetMarginRight"), DO = O("facetGrid"), NO = O("facetLabel"), BO = O("fxDomain"), OO = O("fxRange"), FO = O("fxNice"), EO = O("fxInset"), LO = O("fxInsetLeft"), RO = O("fxInsetRight"), CO = O("fxRound"), kO = O("fxAlign"), UO = O("fxPadding"), zO = O("fxPaddingInner"), PO = O("fxPaddingOuter"), VO = O("fxAxis"), jO = O("fxTicks"), qO = O("fxTickSize"), YO = O("fxTickSpacing"), WO = O("fxTickPadding"), GO = O("fxTickFormat"), XO = O("fxTickRotate"), HO = O("fxGrid"), JO = O("fxLine"), KO = O("fxLabel"), ZO = O("fxLabelAnchor"), QO = O("fxLabelOffset"), tF = O("fxFontVariant"), eF = O("fxAriaLabel"), nF = O("fxAriaDescription"), iF = O("fxReverse"), rF = O("fyDomain"), sF = O("fyRange"), oF = O("fyNice"), aF = O("fyInset"), cF = O("fyInsetTop"), lF = O("fyInsetBottom"), uF = O("fyRound"), fF = O("fyAlign"), hF = O("fyPadding"), dF = O("fyPaddingInner"), pF = O("fyPaddingOuter"), yF = O("fyAxis"), mF = O("fyTicks"), gF = O("fyTickSize"), bF = O("fyTickSpacing"), wF = O("fyTickPadding"), vF = O("fyTickFormat"), _F = O("fyTickRotate"), SF = O("fyGrid"), xF = O("fyLine"), IF = O("fyLabel"), AF = O("fyLabelAnchor"), MF = O("fyLabelOffset"), $F = O("fyFontVariant"), TF = O("fyAriaLabel"), DF = O("fyAriaDescription"), NF = O("fyReverse"), BF = O("colorScale"), OF = O("colorDomain"), FF = O("colorRange"), EF = O("colorClamp"), LF = O("colorN"), RF = O("colorNice"), CF = O("colorScheme"), kF = O("colorInterpolate"), UF = O("colorPivot"), zF = O("colorSymmetric"), PF = O("colorLabel"), VF = O("colorReverse"), jF = O("colorZero"), qF = O("colorTickFormat"), YF = O("colorBase"), WF = O("colorExponent"), GF = O("colorConstant"), XF = O("opacityScale"), HF = O("opacityDomain"), JF = O("opacityRange"), KF = O("opacityClamp"), ZF = O("opacityNice"), QF = O("opacityLabel"), tE = O("opacityReverse"), eE = O("opacityZero"), nE = O("opacityTickFormat"), iE = O("opacityBase"), rE = O("opacityExponent"), sE = O("opacityConstant"), oE = O("symbolScale"), aE = O("symbolDomain"), cE = O("symbolRange"), lE = O("rScale"), uE = O("rDomain"), fE = O("rRange"), hE = O("rClamp"), dE = O("rNice"), pE = O("rZero"), yE = O("rBase"), mE = O("rExponent"), gE = O("rConstant"), bE = O("lengthScale"), wE = O("lengthDomain"), vE = O("lengthRange"), _E = O("lengthClamp"), SE = O("lengthNice"), xE = O("lengthZero"), IE = O("lengthBase"), AE = O("lengthExponent"), ME = O("lengthConstant"), $E = O("projectionType"), TE = O("projectionParallels"), DE = O("projectionPrecision"), NE = O("projectionRotate"), BE = O("projectionDomain"), OE = O("projectionInset"), FE = O("projectionInsetLeft"), EE = O("projectionInsetRight"), LE = O("projectionInsetTop"), RE = O("projectionInsetBottom"), CE = O("projectionClip"), krt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  align: sB,
  aspectRatio: oB,
  axis: aB,
  colorBase: YF,
  colorClamp: EF,
  colorConstant: GF,
  colorDomain: OF,
  colorExponent: WF,
  colorInterpolate: kF,
  colorLabel: PF,
  colorN: LF,
  colorNice: RF,
  colorPivot: UF,
  colorRange: FF,
  colorReverse: VF,
  colorScale: BF,
  colorScheme: CF,
  colorSymmetric: zF,
  colorTickFormat: qF,
  colorZero: jF,
  facetGrid: DO,
  facetLabel: NO,
  facetMargin: IO,
  facetMarginBottom: MO,
  facetMarginLeft: $O,
  facetMarginRight: TO,
  facetMarginTop: AO,
  fxAlign: kO,
  fxAriaDescription: nF,
  fxAriaLabel: eF,
  fxAxis: VO,
  fxDomain: BO,
  fxFontVariant: tF,
  fxGrid: HO,
  fxInset: EO,
  fxInsetLeft: LO,
  fxInsetRight: RO,
  fxLabel: KO,
  fxLabelAnchor: ZO,
  fxLabelOffset: QO,
  fxLine: JO,
  fxNice: FO,
  fxPadding: UO,
  fxPaddingInner: zO,
  fxPaddingOuter: PO,
  fxRange: OO,
  fxReverse: iF,
  fxRound: CO,
  fxTickFormat: GO,
  fxTickPadding: WO,
  fxTickRotate: XO,
  fxTickSize: qO,
  fxTickSpacing: YO,
  fxTicks: jO,
  fyAlign: fF,
  fyAriaDescription: DF,
  fyAriaLabel: TF,
  fyAxis: yF,
  fyDomain: rF,
  fyFontVariant: $F,
  fyGrid: SF,
  fyInset: aF,
  fyInsetBottom: lF,
  fyInsetTop: cF,
  fyLabel: IF,
  fyLabelAnchor: AF,
  fyLabelOffset: MF,
  fyLine: xF,
  fyNice: oF,
  fyPadding: hF,
  fyPaddingInner: dF,
  fyPaddingOuter: pF,
  fyRange: sF,
  fyReverse: NF,
  fyRound: uF,
  fyTickFormat: vF,
  fyTickPadding: wF,
  fyTickRotate: _F,
  fyTickSize: gF,
  fyTickSpacing: bF,
  fyTicks: mF,
  grid: lB,
  height: tB,
  inset: cB,
  label: uB,
  lengthBase: IE,
  lengthClamp: _E,
  lengthConstant: ME,
  lengthDomain: wE,
  lengthExponent: AE,
  lengthNice: SE,
  lengthRange: vE,
  lengthScale: bE,
  lengthZero: xE,
  margin: JN,
  marginBottom: rB,
  marginLeft: eB,
  marginRight: nB,
  marginTop: iB,
  margins: HN,
  name: GN,
  opacityBase: iE,
  opacityClamp: KF,
  opacityConstant: sE,
  opacityDomain: HF,
  opacityExponent: rE,
  opacityLabel: QF,
  opacityNice: ZF,
  opacityRange: JF,
  opacityReverse: tE,
  opacityScale: XF,
  opacityTickFormat: nE,
  opacityZero: eE,
  padding: fB,
  projectionClip: CE,
  projectionDomain: BE,
  projectionInset: OE,
  projectionInsetBottom: RE,
  projectionInsetLeft: FE,
  projectionInsetRight: EE,
  projectionInsetTop: LE,
  projectionParallels: TE,
  projectionPrecision: DE,
  projectionRotate: NE,
  projectionType: $E,
  rBase: yE,
  rClamp: hE,
  rConstant: gE,
  rDomain: uE,
  rExponent: mE,
  rNice: dE,
  rRange: fE,
  rScale: lE,
  rZero: pE,
  style: ZN,
  symbolDomain: aE,
  symbolRange: cE,
  symbolScale: oE,
  width: QN,
  xAlign: _B,
  xAriaDescription: UB,
  xAriaLabel: kB,
  xAxis: AB,
  xBase: VB,
  xClamp: wB,
  xConstant: qB,
  xDomain: dB,
  xExponent: jB,
  xFontVariant: CB,
  xGrid: OB,
  xInset: mB,
  xInsetLeft: gB,
  xInsetRight: bB,
  xLabel: EB,
  xLabelAnchor: LB,
  xLabelOffset: RB,
  xLine: FB,
  xNice: yB,
  xPadding: SB,
  xPaddingInner: xB,
  xPaddingOuter: IB,
  xRange: pB,
  xReverse: zB,
  xRound: vB,
  xScale: hB,
  xTickFormat: NB,
  xTickPadding: DB,
  xTickRotate: BB,
  xTickSize: $B,
  xTickSpacing: TB,
  xTicks: MB,
  xZero: PB,
  xyDomain: KN,
  yAlign: tO,
  yAriaDescription: bO,
  yAriaLabel: gO,
  yAxis: rO,
  yBase: _O,
  yClamp: ZB,
  yConstant: xO,
  yDomain: WB,
  yExponent: SO,
  yFontVariant: mO,
  yGrid: fO,
  yInset: HB,
  yInsetBottom: KB,
  yInsetTop: JB,
  yLabel: dO,
  yLabelAnchor: pO,
  yLabelOffset: yO,
  yLine: hO,
  yNice: XB,
  yPadding: eO,
  yPaddingInner: nO,
  yPaddingOuter: iO,
  yRange: GB,
  yReverse: wO,
  yRound: QB,
  yScale: YB,
  yTickFormat: lO,
  yTickPadding: cO,
  yTickRotate: uO,
  yTickSize: oO,
  yTickSpacing: aO,
  yTicks: sO,
  yZero: vO
}, Symbol.toStringTag, { value: "Module" }));
function Urt(e, t) {
  return { table: e, options: t };
}
const zrt = /* @__PURE__ */ new Set([
  "frame",
  "axisX",
  "axisY",
  "axisFx",
  "axisFy",
  "gridX",
  "gridY",
  "gridFx",
  "gridFy",
  "hexgrid",
  "graticule",
  "sphere"
]);
function xt(e, t, n = {}) {
  arguments.length === 2 && !Array.isArray(t) && (n = t, t = zrt.has(e) ? null : [{}]);
  const i = e.startsWith("area") || e.startsWith("line") ? eit : ha;
  return Xv(i, e, t, n);
}
function Xv(e, t, n, i) {
  return (r) => {
    r.addMark(new e(t, n, i));
  };
}
function ys(e, t, n) {
  return (i) => {
    i.addMark(new e(t, n));
  };
}
const kE = (...e) => xt("area", ...e), UE = (...e) => xt("areaX", ...e), zE = (...e) => xt("areaY", ...e), PE = (...e) => xt("line", ...e), VE = (...e) => xt("lineX", ...e), jE = (...e) => xt("lineY", ...e), qE = (...e) => xt("barX", ...e), YE = (...e) => xt("barY", ...e), WE = (...e) => xt("cell", ...e), GE = (...e) => xt("cellX", ...e), XE = (...e) => xt("cellY", ...e), HE = (...e) => xt("rect", ...e), JE = (...e) => xt("rectX", ...e), KE = (...e) => xt("rectY", ...e), ZE = (...e) => xt("dot", ...e), QE = (...e) => xt("dotX", ...e), t5 = (...e) => xt("dotY", ...e), e5 = (...e) => xt("circle", ...e), n5 = (...e) => xt("hexagon", ...e), i5 = (...e) => xt("text", ...e), r5 = (...e) => xt("textX", ...e), s5 = (...e) => xt("textY", ...e), o5 = (...e) => xt("ruleX", ...e), a5 = (...e) => xt("ruleY", ...e), c5 = (...e) => xt("tickX", ...e), l5 = (...e) => xt("tickY", ...e), u5 = (...e) => xt("vector", ...e), f5 = (...e) => xt("vectoX", ...e), h5 = (...e) => xt("vectorY", ...e), d5 = (...e) => xt("spike", ...e), p5 = (...e) => xt("image", ...e), y5 = (...e) => Xv(LN, "areaX", ...e), m5 = (...e) => Xv(LN, "areaY", ...e), g5 = (...e) => ys(Dit, ...e), b5 = (...e) => ys(Ait, ...e), w5 = (...e) => ys(dit, ...e), v5 = (...e) => ys(vit, ...e), _5 = (...e) => ys(Pv, ...e), S5 = (...e) => ys(Eit, ...e), x5 = (...e) => ys(Fit, ...e), I5 = (...e) => xt("hexgrid", ...e), A5 = (...e) => ys(jit, ...e), M5 = (...e) => xt("voronoi", ...e), $5 = (...e) => xt("voronoiMesh", ...e), T5 = (...e) => xt("delaunayLink", ...e), D5 = (...e) => xt("delaunayMesh", ...e), N5 = (...e) => xt("hull", ...e), B5 = (...e) => xt("arrow", ...e), O5 = (...e) => xt("link", ...e), F5 = (...e) => xt("frame", ...e), E5 = (...e) => xt("axisX", ...e), L5 = (...e) => xt("axisY", ...e), R5 = (...e) => xt("axisFx", ...e), C5 = (...e) => xt("axisFy", ...e), k5 = (...e) => xt("gridX", ...e), U5 = (...e) => xt("gridY", ...e), z5 = (...e) => xt("gridFx", ...e), P5 = (...e) => xt("gridFy", ...e), V5 = (...e) => ys(Oit, ...e), j5 = (...e) => xt("sphere", ...e), q5 = (...e) => xt("graticule", ...e), Prt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  area: kE,
  areaX: UE,
  areaY: zE,
  arrow: B5,
  axisFx: R5,
  axisFy: C5,
  axisX: E5,
  axisY: L5,
  barX: qE,
  barY: YE,
  cell: WE,
  cellX: GE,
  cellY: XE,
  circle: e5,
  contour: w5,
  delaunayLink: T5,
  delaunayMesh: D5,
  denseLine: b5,
  density: g5,
  densityX: y5,
  densityY: m5,
  dot: ZE,
  dotX: QE,
  dotY: t5,
  frame: F5,
  geo: V5,
  graticule: q5,
  gridFx: z5,
  gridFy: P5,
  gridX: k5,
  gridY: U5,
  heatmap: v5,
  hexagon: n5,
  hexbin: x5,
  hexgrid: I5,
  hull: N5,
  image: p5,
  line: PE,
  lineX: VE,
  lineY: jE,
  link: O5,
  raster: _5,
  rasterTile: S5,
  rect: HE,
  rectX: JE,
  rectY: KE,
  regressionY: A5,
  ruleX: o5,
  ruleY: a5,
  sphere: j5,
  spike: d5,
  text: i5,
  textX: r5,
  textY: s5,
  tickX: c5,
  tickY: l5,
  vector: u5,
  vectorX: f5,
  vectorY: h5,
  voronoi: M5,
  voronoiMesh: $5
}, Symbol.toStringTag, { value: "Module" }));
function po(e, t) {
  return (n) => {
    const i = n.marks[n.marks.length - 1];
    n.addInteractor(new e(i, t));
  };
}
function Y5({ by: e, ...t }) {
  return po(Xit, { selection: e, channels: t });
}
function Xf({ as: e, ...t }) {
  return po(kN, { ...t, selection: e });
}
function W5(e) {
  return Xf({ ...e, channels: ["x"] });
}
function G5(e) {
  return Xf({ ...e, channels: ["y"] });
}
function X5(e) {
  return Xf({ ...e, channels: ["color"] });
}
function H5({ as: e, ...t }) {
  return po(CN, { ...t, selection: e, channel: "x" });
}
function J5({ as: e, ...t }) {
  return po(CN, { ...t, selection: e, channel: "y" });
}
function K5({ as: e, ...t }) {
  return po(qv, { ...t, selection: e, channel: "x" });
}
function Z5({ as: e, ...t }) {
  return po(qv, { ...t, selection: e, channel: "y" });
}
function Q5({ as: e, ...t }) {
  return po(Qit, { ...t, selection: e });
}
function yl(e) {
  return po(ert, e);
}
function tL(e = {}) {
  return yl({ ...e, zoom: !1 });
}
function eL(e = {}) {
  return yl({ ...e, zoom: !1, pany: !1 });
}
function nL(e = {}) {
  return yl({ ...e, zoom: !1, panx: !1 });
}
function iL(e = {}) {
  return yl(e);
}
function rL(e = {}) {
  return yl({ ...e, pany: !1 });
}
function sL(e = {}) {
  return yl({ ...e, panx: !1 });
}
const Vrt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  highlight: Y5,
  intervalX: K5,
  intervalXY: Q5,
  intervalY: Z5,
  nearestX: H5,
  nearestY: J5,
  pan: tL,
  panX: eL,
  panY: nL,
  panZoom: iL,
  panZoomX: rL,
  panZoomY: sL,
  toggle: Xf,
  toggleColor: X5,
  toggleX: W5,
  toggleY: G5
}, Symbol.toStringTag, { value: "Module" }));
function Hv(e, t = {}) {
  if (t.for) {
    const { for: n, ...i } = t, r = new eI(e, i), s = typeof n, o = (a) => a.addLegend(r, !1);
    return s === "string" ? Lrt(this, n, o) : n.value && o(n.value), r.element;
  } else
    return (n) => n.addLegend(new eI(e, t));
}
function oL(e) {
  return Hv.call(this, "color", e);
}
function aL(e) {
  return Hv.call(this, "opacity", e);
}
function cL(e) {
  return Hv.call(this, "symbol", e);
}
const jrt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  colorLegend: oL,
  opacityLegend: aL,
  symbolLegend: cL
}, Symbol.toStringTag, { value: "Module" }));
function qrt(...e) {
  const t = new Ynt();
  return e.flat().forEach((n) => n(t)), jN(this, ...t.marks), t.update(), t.element;
}
const Yrt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Fixed: mf,
  Param: zo,
  Query: Lt,
  Selection: Xd,
  agg: R9,
  align: sB,
  and: qs,
  area: kE,
  areaX: UE,
  areaY: zE,
  argmax: Bg,
  argmin: Ng,
  arrayAgg: lU,
  arrow: B5,
  aspectRatio: oB,
  avg: U9,
  axis: aB,
  axisFx: R5,
  axisFy: C5,
  axisX: E5,
  axisY: L5,
  barX: qE,
  barY: YE,
  bin: hrt,
  cast: Rb,
  castDouble: Og,
  castInteger: uU,
  cell: WE,
  cellX: GE,
  cellY: XE,
  centroid: Cb,
  centroidX: gU,
  centroidY: bU,
  circle: e5,
  colorBase: YF,
  colorClamp: EF,
  colorConstant: GF,
  colorDomain: OF,
  colorExponent: WF,
  colorInterpolate: kF,
  colorLabel: PF,
  colorLegend: oL,
  colorN: LF,
  colorNice: RF,
  colorPivot: UF,
  colorRange: FF,
  colorReverse: VF,
  colorScale: BF,
  colorScheme: CF,
  colorSymmetric: zF,
  colorTickFormat: qF,
  colorZero: jF,
  column: zy,
  contour: w5,
  coordinator: Wr,
  corr: Z9,
  count: Uo,
  covarPop: Q9,
  create: yf,
  cume_dist: D9,
  dateDay: pU,
  dateMonth: hU,
  dateMonthDay: dU,
  delaunayLink: T5,
  delaunayMesh: D5,
  denseLine: b5,
  dense_rank: $9,
  density: g5,
  densityX: y5,
  densityY: m5,
  dot: ZE,
  dotX: QE,
  dotY: t5,
  entropy: H9,
  eq: Vy,
  facetGrid: DO,
  facetLabel: NO,
  facetMargin: IO,
  facetMarginBottom: MO,
  facetMarginLeft: $O,
  facetMarginRight: TO,
  facetMarginTop: AO,
  first: oU,
  first_value: F9,
  frame: F5,
  from: Urt,
  fxAlign: kO,
  fxAriaDescription: nF,
  fxAriaLabel: eF,
  fxAxis: VO,
  fxDomain: BO,
  fxFontVariant: tF,
  fxGrid: HO,
  fxInset: EO,
  fxInsetLeft: LO,
  fxInsetRight: RO,
  fxLabel: KO,
  fxLabelAnchor: ZO,
  fxLabelOffset: QO,
  fxLine: JO,
  fxNice: FO,
  fxPadding: UO,
  fxPaddingInner: zO,
  fxPaddingOuter: PO,
  fxRange: OO,
  fxReverse: iF,
  fxRound: CO,
  fxTickFormat: GO,
  fxTickPadding: WO,
  fxTickRotate: XO,
  fxTickSize: qO,
  fxTickSpacing: YO,
  fxTicks: jO,
  fyAlign: fF,
  fyAriaDescription: DF,
  fyAriaLabel: TF,
  fyAxis: yF,
  fyDomain: rF,
  fyFontVariant: $F,
  fyGrid: SF,
  fyInset: aF,
  fyInsetBottom: lF,
  fyInsetTop: cF,
  fyLabel: IF,
  fyLabelAnchor: AF,
  fyLabelOffset: MF,
  fyLine: xF,
  fyNice: oF,
  fyPadding: hF,
  fyPaddingInner: dF,
  fyPaddingOuter: pF,
  fyRange: sF,
  fyReverse: NF,
  fyRound: uF,
  fyTickFormat: vF,
  fyTickPadding: wF,
  fyTickRotate: _F,
  fyTickSize: gF,
  fyTickSpacing: bF,
  fyTicks: mF,
  geo: V5,
  geojson: G3,
  graticule: q5,
  grid: lB,
  gridFx: z5,
  gridFy: P5,
  gridX: k5,
  gridY: U5,
  gt: q3,
  gte: b9,
  hconcat: Ort,
  heatmap: v5,
  height: tB,
  hexagon: n5,
  hexbin: x5,
  hexgrid: I5,
  highlight: Y5,
  hspace: Ert,
  hull: N5,
  image: p5,
  inset: cB,
  intervalX: K5,
  intervalXY: Q5,
  intervalY: Z5,
  isBetween: Tn,
  isDistinct: w9,
  isNotBetween: v9,
  isNotDistinct: Y3,
  isNotNull: Mu,
  isNull: Eb,
  kurtosis: X9,
  label: uB,
  lag: B9,
  last: aU,
  last_value: E9,
  lead: O9,
  lengthBase: IE,
  lengthClamp: _E,
  lengthConstant: ME,
  lengthDomain: wE,
  lengthExponent: AE,
  lengthNice: SE,
  lengthRange: vE,
  lengthScale: bE,
  lengthZero: xE,
  line: PE,
  lineX: VE,
  lineY: jE,
  link: O5,
  literal: tl,
  loadCSV: TU,
  loadExtension: H3,
  loadJSON: DU,
  loadObjects: OU,
  loadParquet: NU,
  loadSpatial: BU,
  lt: $u,
  lte: Tu,
  mad: z9,
  margin: JN,
  marginBottom: rB,
  marginLeft: eB,
  marginRight: nB,
  marginTop: iB,
  margins: HN,
  max: $c,
  median: V9,
  menu: $rt,
  min: Tc,
  mode: q9,
  name: GN,
  nearestX: H5,
  nearestY: J5,
  neq: Lb,
  not: g9,
  nth_value: L9,
  ntile: N9,
  opacityBase: iE,
  opacityClamp: KF,
  opacityConstant: sE,
  opacityDomain: HF,
  opacityExponent: rE,
  opacityLabel: QF,
  opacityLegend: aL,
  opacityNice: ZF,
  opacityRange: JF,
  opacityReverse: tE,
  opacityScale: XF,
  opacityTickFormat: nE,
  opacityZero: eE,
  or: Fb,
  padding: fB,
  pan: tL,
  panX: eL,
  panY: nL,
  panZoom: iL,
  panZoomX: rL,
  panZoomY: sL,
  percent_rank: T9,
  plot: qrt,
  product: P9,
  projectionClip: CE,
  projectionDomain: BE,
  projectionInset: OE,
  projectionInsetBottom: RE,
  projectionInsetLeft: FE,
  projectionInsetRight: EE,
  projectionInsetTop: LE,
  projectionParallels: TE,
  projectionPrecision: DE,
  projectionRotate: NE,
  projectionType: $E,
  quantile: j9,
  rBase: yE,
  rClamp: hE,
  rConstant: gE,
  rDomain: uE,
  rExponent: mE,
  rNice: dE,
  rRange: fE,
  rScale: lE,
  rZero: pE,
  rank: M9,
  raster: _5,
  rasterTile: S5,
  rect: HE,
  rectX: JE,
  rectY: KE,
  regressionY: A5,
  row_number: A9,
  ruleX: o5,
  ruleY: a5,
  search: Trt,
  skewness: G9,
  slider: Drt,
  sphere: j5,
  spike: d5,
  sql: q,
  stddev: W9,
  stddevPop: K9,
  stringAgg: cU,
  style: ZN,
  sum: oa,
  symbolDomain: aE,
  symbolLegend: cL,
  symbolRange: cE,
  symbolScale: oE,
  table: Nrt,
  text: i5,
  textX: r5,
  textY: s5,
  tickX: c5,
  tickY: l5,
  toggle: Xf,
  toggleColor: X5,
  toggleX: W5,
  toggleY: G5,
  varPop: J9,
  variance: Y9,
  vconcat: Brt,
  vector: u5,
  vectorX: f5,
  vectorY: h5,
  voronoi: M5,
  voronoiMesh: $5,
  vspace: Frt,
  width: QN,
  xAlign: _B,
  xAriaDescription: UB,
  xAriaLabel: kB,
  xAxis: AB,
  xBase: VB,
  xClamp: wB,
  xConstant: qB,
  xDomain: dB,
  xExponent: jB,
  xFontVariant: CB,
  xGrid: OB,
  xInset: mB,
  xInsetLeft: gB,
  xInsetRight: bB,
  xLabel: EB,
  xLabelAnchor: LB,
  xLabelOffset: RB,
  xLine: FB,
  xNice: yB,
  xPadding: SB,
  xPaddingInner: xB,
  xPaddingOuter: IB,
  xRange: pB,
  xReverse: zB,
  xRound: vB,
  xScale: hB,
  xTickFormat: NB,
  xTickPadding: DB,
  xTickRotate: BB,
  xTickSize: $B,
  xTickSpacing: TB,
  xTicks: MB,
  xZero: PB,
  xyDomain: KN,
  yAlign: tO,
  yAriaDescription: bO,
  yAriaLabel: gO,
  yAxis: rO,
  yBase: _O,
  yClamp: ZB,
  yConstant: xO,
  yDomain: WB,
  yExponent: SO,
  yFontVariant: mO,
  yGrid: fO,
  yInset: HB,
  yInsetBottom: KB,
  yInsetTop: JB,
  yLabel: dO,
  yLabelAnchor: pO,
  yLabelOffset: yO,
  yLine: hO,
  yNice: XB,
  yPadding: eO,
  yPaddingInner: nO,
  yPaddingOuter: iO,
  yRange: GB,
  yReverse: wO,
  yRound: QB,
  yScale: YB,
  yTickFormat: lO,
  yTickPadding: cO,
  yTickRotate: uO,
  yTickSize: oO,
  yTickSpacing: aO,
  yTicks: sO,
  yZero: vO
}, Symbol.toStringTag, { value: "Module" }));
function Wrt({
  coordinator: e = Wr(),
  namedPlots: t = new WN(),
  extensions: n = null,
  ...i
} = {}) {
  return {
    ...Yrt,
    ...n,
    context: {
      coordinator: e,
      namedPlots: t,
      ...i
    }
  };
}
const Grt = "spec", lL = "literal", Xrt = "options", Hrt = "selection", Jrt = "paramref", Krt = "param", uL = "select", tb = "value", Zrt = "crossfilter", fL = "intersect", Qrt = "union", tst = "single", est = "data", nst = "expression", bc = "sql", Go = "agg", Jv = "input", ny = "hconcat", iy = "vconcat", ry = "hspace", sy = "vspace", hL = "mark", nI = "from", oy = "plot", Kv = "legend", ist = "attribute", rst = "transform", sst = "interactor", cd = "Fixed";
class Oe {
  constructor(t, n = null) {
    this.type = t, this.children = n;
  }
  /**
   * Instantiate this AST node to use in a live web application.
   * @param {import('../ast-to-dom.js').InstantiateContext} ctx The instantiation context.
   * @returns {*} The instantiated value of this node.
   */
  instantiate(t) {
    throw Error("instantiate not implemented");
  }
  /**
   * Generate ESM code for this AST node.
   * @param {import('../ast-to-esm.js').CodegenContext} ctx The code generator context.
   * @returns {string|void} The generated ESM code for the node.
   */
  codegen(t) {
    return Error("codegen not implemented");
  }
  /**
   * @returns {*} This AST node in JSON specification format.
   */
  toJSON() {
    return Error("toJSON not implemented");
  }
}
class ost extends Oe {
  constructor(t, n, i, r, s, o) {
    super(Grt, [t]), this.root = t, this.meta = n, this.config = i, this.data = r, this.params = s, this.plotDefaults = o;
  }
  toJSON() {
    const { root: t, meta: n, config: i, plotDefaults: r } = this, s = new Map(Object.entries(this.data)), o = new Map(Object.entries(this.params)), a = {};
    if (n && (a.meta = { ...n }), i && (a.config = { ...i }), s != null && s.size) {
      const c = a.data = {};
      for (const [l, u] of s)
        c[l] = u.toJSON();
    }
    if (o != null && o.size) {
      const c = a.params = {};
      for (const [l, u] of o)
        c[l] = u.toJSON();
    }
    if (r != null && r.length) {
      const c = a.plotDefaults = {};
      for (const l of r)
        Object.assign(c, l.toJSON());
    }
    return Object.assign(a, t.toJSON());
  }
}
function ast(e) {
  const t = typeof e;
  return t === "object" ? e == null ? void 0 : e.param : t === "string" ? cst(e) : null;
}
function cst(e) {
  return (e == null ? void 0 : e[0]) === "$" ? e.slice(1) : null;
}
function iI(e) {
  return `$${e}`;
}
function lst(e) {
  return [e].flat();
}
function Xo(e) {
  return Array.isArray(e);
}
function dL(e) {
  return e !== null && typeof e == "object" && !Xo(e);
}
function ld(e) {
  return typeof e == "string";
}
function pL(e, t) {
  throw Object.assign(Error(e), { data: t });
}
const ust = /^(?:[-+]\d{2})?\d{4}(?:-\d{2}(?:-\d{2})?)?(?:T\d{2}:\d{2}(?::\d{2}(?:\.\d{3})?)?(?:Z|[-+]\d{2}:?\d{2})?)?$/;
function fst(e, t) {
  return ust.test(e += "") ? new Date(e) : t;
}
function ms(e, t) {
  const n = {};
  for (const i in e)
    n[i] = t.maybeSelection(e[i]);
  return new G0(n);
}
class G0 extends Oe {
  constructor(t) {
    super(Xrt), this.options = t;
  }
  filter(t) {
    const n = Object.fromEntries(
      Object.entries(this.options).filter(([i, r]) => t(i, r))
    );
    return new G0(n);
  }
  instantiate(t) {
    const { options: n } = this, i = {};
    for (const r in n)
      i[r] = n[r].instantiate(t);
    return i;
  }
  codegen(t) {
    const { options: n } = this, i = [];
    for (const r in n)
      i.push(`${r}: ${n[r].codegen(t)}`);
    return i.length ? `{${t.maybeLineWrap(i)}}` : "";
  }
  toJSON() {
    const { options: t } = this, n = {};
    for (const i in t)
      n[i] = t[i].toJSON();
    return n;
  }
}
const yL = "table", mL = "parquet", gL = "csv", Zv = "json", Qv = "spatial", rI = /* @__PURE__ */ new Map([
  [yL, mst],
  [mL, gst],
  [gL, bst],
  [Zv, wst],
  [Qv, vst]
]);
function hst(e, t, n) {
  const i = dst(t);
  if (rI.has(i.type))
    return rI.get(i.type)(e, i, n);
  n.error("Unrecognized data format type.", t);
}
function dst(e) {
  return Xo(e) && (e = { type: "json", data: e }), ld(e) && (e = { type: "table", query: e }), { ...e, type: pst(e) };
}
function pst(e) {
  return e.type || yst(e.file) || "table";
}
function yst(e) {
  const t = e == null ? void 0 : e.lastIndexOf(".");
  return t > 0 ? e.slice(t + 1) : null;
}
function mst(e, t, n) {
  const { query: i, type: r, ...s } = t;
  return new xst(e, i, ms(s, n));
}
function gst(e, t, n) {
  const { file: i, type: r, ...s } = t;
  return new Ast(e, i, ms(s, n));
}
function bst(e, t, n) {
  const { file: i, type: r, ...s } = t;
  return new Mst(e, i, ms(s, n));
}
function wst(e, t, n) {
  const { data: i, file: r, type: s, ...o } = t, a = ms(o, n);
  return i ? new Tst(e, i, a) : new $st(e, r, a);
}
function vst(e, t, n) {
  const { file: i, type: r, ...s } = t;
  return new Ist(e, i, ms(s, n));
}
function sI(e, t) {
  return t ? new URL(e, t).toString() : e;
}
function _st(e, t) {
  const n = e == null ? void 0 : e.codegen(t);
  return n ? `, ${n}` : "";
}
class Sst extends Oe {
  constructor(t, n) {
    super(est), this.name = t, this.format = n;
  }
}
class t_ extends Sst {
  constructor(t, n) {
    super(t, n);
  }
  /**
   * Instantiate a table creation query.
   * @param {import('../ast-to-dom.js').InstantiateContext} ctx The instantiation context.
   * @returns {string|void} The instantiated query.
   */
  instantiateQuery(t) {
    t.error("instantiateQuery not implemented");
  }
  /**
   * Code generate a table creation query.
   * @param {import('../ast-to-esm.js').CodegenContext} ctx The code generator context.
   * @returns {string|void} The generated query code.
   */
  codegenQuery(t) {
    t.error("codegenQuery not implemented");
  }
  /**
   * Instantiate this AST node to use in a live web application.
   * @param {import('../ast-to-dom.js').InstantiateContext} ctx The instantiation context.
   * @returns {*} The instantiated value of this node.
   */
  instantiate(t) {
    const n = this.instantiateQuery(t);
    if (n)
      return n;
  }
  /**
   * Generate ESM code for this AST node.
   * @param {import('../ast-to-esm.js').CodegenContext} ctx The code generator context.
   * @returns {string|void} The generated ESM code for the node.
   */
  codegen(t) {
    const n = this.codegenQuery(t);
    if (n)
      return n;
  }
}
class xst extends t_ {
  constructor(t, n, i) {
    super(t, yL), this.query = n == null ? void 0 : n.trim(), this.options = i;
  }
  /**
   * Instantiate a table creation query.
   * @param {import('../ast-to-dom.js').InstantiateContext} ctx The instantiation context.
   * @returns {string|void} The instantiated query.
   */
  instantiateQuery(t) {
    const { name: n, query: i, options: r } = this;
    if (i)
      return t.api.create(n, i, r.instantiate(t));
  }
  /**
   * Code generate a table creation query.
   * @param {import('../ast-to-esm.js').CodegenContext} ctx The code generator context.
   * @returns {string|void} The generated query code.
   */
  codegenQuery(t) {
    const { name: n, query: i, options: r } = this;
    if (i)
      return `\`${yf(n, i, r.instantiate(t))}\``;
  }
  toJSON() {
    const { format: t, query: n, options: i } = this;
    return { type: t, query: n, ...i.toJSON() };
  }
}
class X0 extends t_ {
  constructor(t, n, i, r, s) {
    super(t, n), this.file = r, this.method = i, this.options = s;
  }
  /**
   * Instantiate a table creation query.
   * @param {import('../ast-to-dom.js').InstantiateContext} ctx The instantiation context.
   * @returns {string|void} The instantiated query.
   */
  instantiateQuery(t) {
    const { name: n, method: i, file: r, options: s } = this, o = sI(r, t.baseURL), a = s == null ? void 0 : s.instantiate(t);
    return t.api[i](n, o, a);
  }
  /**
   * Code generate a table creation query.
   * @param {import('../ast-to-esm.js').CodegenContext} ctx The code generator context.
   * @returns {string|void} The generated query code.
   */
  codegenQuery(t) {
    const { name: n, method: i, file: r, options: s } = this, o = sI(r, t.baseURL), a = _st(s, t);
    return `${t.ns()}${i}("${n}", "${o}"${a})`;
  }
  toJSON() {
    const { format: t, file: n, options: i } = this;
    return { type: t, file: n, ...i.toJSON() };
  }
}
class Ist extends X0 {
  constructor(t, n, i) {
    super(t, Qv, "loadSpatial", n, i);
  }
}
class Ast extends X0 {
  constructor(t, n, i) {
    super(t, mL, "loadParquet", n, i);
  }
}
class Mst extends X0 {
  constructor(t, n, i) {
    super(t, gL, "loadCSV", n, i);
  }
}
class $st extends X0 {
  constructor(t, n, i) {
    super(t, Zv, "loadJSON", n, i);
  }
}
class Tst extends t_ {
  constructor(t, n, i) {
    super(t, Zv), this.data = n, this.options = i;
  }
  /**
   * Instantiate a table creation query.
   * @param {import('../ast-to-dom.js').InstantiateContext} ctx The instantiation context.
   * @returns {string|void} The instantiated query.
   */
  instantiateQuery(t) {
    const { name: n, data: i, options: r } = this;
    return t.api.loadObjects(n, i, r.instantiate(t));
  }
  /**
   * Code generate a table creation query.
   * @param {import('../ast-to-esm.js').CodegenContext} ctx The code generator context.
   * @returns {string|void} The generated query code.
   */
  codegenQuery(t) {
    const { name: n, data: i, options: r } = this, s = r ? "," + r.codegen(t) : "", o = `[
    ` + i.map((a) => JSON.stringify(a)).join(`,
    `) + `
  ]`;
    return `${t.ns()}loadObjects("${n}", ${o}${s})`;
  }
  toJSON() {
    const { format: t, data: n, options: i } = this;
    return { type: t, data: n, ...i.toJSON() };
  }
}
function Dst(e) {
  var i;
  const t = (i = e.config) == null ? void 0 : i.extensions, n = new Set(t ? lst(t) : []);
  for (const r of Object.values(e.data))
    r.format === Qv && n.add("spatial");
  return n;
}
async function Nst(e, t) {
  const { data: n, params: i, plotDefaults: r } = e, s = new Bst({ plotDefaults: r, ...t }), o = [], a = Dst(e);
  o.push(...Array.from(a).map((c) => H3(c)));
  for (const c of Object.values(n)) {
    const l = c.instantiate(s);
    l && o.push(l);
  }
  o.length > 0 && await s.coordinator.exec(o);
  for (const [c, l] of Object.entries(i))
    if (!s.activeParams.has(c)) {
      const u = l.instantiate(s);
      s.activeParams.set(c, u);
    }
  return {
    element: e.root.instantiate(s),
    params: s.activeParams
  };
}
class Bst {
  constructor({
    api: t = Wrt(),
    plotDefaults: n = [],
    params: i = /* @__PURE__ */ new Map(),
    baseURL: r = null
  } = {}) {
    this.api = t, this.plotDefaults = n, this.activeParams = i, this.baseURL = r, this.coordinator = t.context.coordinator;
  }
  error(t, n) {
    pL(t, n);
  }
}
class bL extends Oe {
  constructor(t) {
    super(lL), this.value = t;
  }
  instantiate() {
    return this.value;
  }
  codegen(t) {
    return t.stringify(this.value);
  }
  toJSON() {
    return this.value;
  }
}
class wL extends Oe {
  constructor(t = fL, n) {
    super(Hrt), this.select = t, this.cross = n;
  }
  instantiate(t) {
    const { select: n, cross: i } = this;
    return t.api.Selection[n]({ cross: i });
  }
  codegen(t) {
    const { select: n, cross: i } = this, r = i != null ? `{ cross: ${i} }` : "";
    return `${t.ns()}Selection.${n}(${r})`;
  }
  toJSON() {
    const { select: t, cross: n } = this;
    return { select: t, cross: n };
  }
}
const Ost = /* @__PURE__ */ new Set([tb, tst, Zrt, fL, Qrt]);
function Fst(e, t) {
  const n = dL(e) ? e : { value: e }, { select: i = tb, cross: r, date: s, value: o } = n;
  return Ost.has(i) || t.error(`Unrecognized param type: ${i}`, n), i !== tb ? new wL(i, r) : Xo(o) ? new eb(o.map((a) => t.maybeParam(a))) : new eb(o, s);
}
class eb extends Oe {
  constructor(t, n) {
    super(Krt), this.value = t, this.date = n;
  }
  instantiate(t) {
    const { date: n, value: i } = this, { Param: r } = t.api;
    return Xo(i) ? r.array(i.map((s) => s.instantiate(t))) : r.value(fst(n, i));
  }
  codegen(t) {
    const { value: n, date: i } = this, r = `${t.ns()}Param.`;
    return Xo(n) ? `${r}array([${n.map((s) => s.codegen(t)).join(", ")}])` : i ? `${r}value(new Date(${JSON.stringify(i)}))` : `${r}value(${JSON.stringify(n)})`;
  }
  toJSON() {
    const { date: t, value: n } = this;
    return Xo(n) ? n.map((i) => i.toJSON()) : t ? { date: t } : n;
  }
}
class Est extends Oe {
  constructor(t) {
    super(Jrt), this.name = t;
  }
  instantiate(t) {
    var n;
    return (n = t.activeParams) == null ? void 0 : n.get(this.name);
  }
  codegen() {
    return iI(this.name);
  }
  toJSON() {
    return iI(this.name);
  }
}
function vL(e, t, n) {
  var i, r;
  return (r = (i = n.plot) == null ? void 0 : i.attributes) != null && r.has(e) || n.error(`Unrecognized attribute: ${e}`), new Lst(
    e,
    t === cd ? new Rst() : n.maybeParam(t)
  );
}
class Lst extends Oe {
  constructor(t, n) {
    super(ist), this.name = t, this.value = n;
  }
  instantiate(t) {
    const { name: n, value: i } = this;
    return t.api[n](i.instantiate(t));
  }
  codegen(t) {
    const { name: n, value: i } = this;
    return `${t.tab()}${t.ns()}${n}(${i.codegen(t)})`;
  }
  toJSON() {
    const { name: t, value: n } = this;
    return { [t]: n.toJSON() };
  }
}
class Rst extends Oe {
  constructor() {
    super(lL), this.value = cd;
  }
  instantiate(t) {
    return t.api[cd];
  }
  codegen(t) {
    return `${t.ns()}${cd}`;
  }
  toJSON() {
    return this.value;
  }
}
function Cst(e, t) {
  const n = e[ny].map((i) => t.parseComponent(i));
  return new kst(n);
}
class kst extends Oe {
  constructor(t) {
    super(ny, t);
  }
  instantiate(t) {
    return t.api[ny](this.children.map((n) => n.instantiate(t)));
  }
  codegen(t) {
    t.indent();
    const n = this.children.map((i) => i.codegen(t));
    return t.undent(), `${t.tab()}${t.ns()}${this.type}(
${n.join(`,
`)}
${t.tab()})`;
  }
  toJSON() {
    return { [this.type]: this.children.map((t) => t.toJSON()) };
  }
}
function Ust(e) {
  return new zst(e[ry]);
}
class zst extends Oe {
  constructor(t) {
    super(ry), this.value = t;
  }
  instantiate(t) {
    return t.api[ry](this.value);
  }
  codegen(t) {
    return `${t.tab()}${t.ns()}${this.type}(${t.stringify(this.value)})`;
  }
  toJSON() {
    return { [this.type]: this.value };
  }
}
function Pst(e, t) {
  var r;
  const { [Jv]: n, ...i } = e;
  return (r = t.inputs) != null && r.has(n) || t.error(`Unrecognized input type: ${n}`, e), new Vst(n, ms(i, t));
}
class Vst extends Oe {
  constructor(t, n) {
    super(Jv), this.name = t, this.options = n;
  }
  instantiate(t) {
    return t.api[this.name](this.options.instantiate(t));
  }
  codegen(t) {
    const n = this.options.codegen(t);
    return `${t.tab()}${t.ns()}${this.name}(${n})`;
  }
  toJSON() {
    const { type: t, name: n, options: i } = this;
    return { [t]: n, ...i.toJSON() };
  }
}
function _L(e, t) {
  var s, o;
  const { [Kv]: n, ...i } = e, r = `${n}Legend`;
  return (o = (s = t.plot) == null ? void 0 : s.legends) != null && o.has(r) || t.error(`Unrecognized legend type: ${n}`, e), new jst(r, n, ms(i, t));
}
class jst extends Oe {
  constructor(t, n, i) {
    super(Kv), this.key = t, this.name = n, this.options = i;
  }
  instantiate(t) {
    return t.api[this.key](this.options.instantiate(t));
  }
  codegen(t) {
    const n = this.options.codegen(t);
    return `${t.tab()}${t.ns()}${this.key}(${n})`;
  }
  toJSON() {
    const { type: t, name: n, options: i } = this;
    return { [t]: n, ...i.toJSON() };
  }
}
function qst(e, t) {
  var r, s;
  const { [uL]: n, ...i } = e;
  return (s = (r = t.plot) == null ? void 0 : r.interactors) != null && s.has(n) || t.error(`Unrecognized interactor type: ${n}`, e), new Yst(n, ms(i, t));
}
class Yst extends Oe {
  constructor(t, n) {
    super(sst), this.name = t, this.options = n;
  }
  instantiate(t) {
    return t.api[this.name](this.options.instantiate(t));
  }
  codegen(t) {
    const n = this.options.codegen(t);
    return `${t.tab()}${t.ns()}${this.name}(${n})`;
  }
  toJSON() {
    const { name: t, options: n } = this;
    return { [uL]: t, ...n.toJSON() };
  }
}
function Wst(e, t) {
  const { label: n } = e, i = e[bc] ? bc : e[Go] ? Go : t.error("Unrecognized expression type", e), r = e[i], s = r.split(/(\\'|\\"|"(?:\\"|[^"])*"|'(?:\\'|[^'])*'|\$\w+)/g), o = [""], a = [];
  for (let c = 0, l = 0; c < s.length; ++c) {
    const u = s[c];
    u.startsWith("$") ? (a[l] = t.maybeParam(u), o[++l] = "") : o[l] += u;
  }
  return new Gst(r, o, a, n, i === Go);
}
class Gst extends Oe {
  constructor(t, n, i, r, s) {
    super(nst), this.value = t, this.spans = n, this.params = i, this.label = r, this.aggregate = s;
  }
  instantiate(t) {
    const { spans: n, params: i, label: r, aggregate: s } = this, o = t.api[s ? Go : bc], a = i.map((c) => c.instantiate(t));
    return o(n, ...a).annotate({ label: r });
  }
  codegen(t) {
    const { spans: n, params: i, label: r, aggregate: s } = this, o = s ? Go : bc;
    let a = "";
    const c = i.length;
    for (let l = 0; l < c; ++l)
      a += n[l] + "${" + i[l].codegen(t) + "}";
    return a += n[c], `${t.ns()}${o}\`${a}\`` + (r ? `.annotate({ label: ${JSON.stringify(r)} })` : "");
  }
  toJSON() {
    return { [this.aggregate ? Go : bc]: this.value };
  }
}
function Xst(e, t) {
  if (!e)
    return null;
  if (Xo(e))
    return new bL(e);
  const { from: n, ...i } = e;
  return new Hst(n, ms(i, t));
}
class Hst extends Oe {
  constructor(t, n) {
    super(nI), this.table = t, this.options = n;
  }
  instantiate(t) {
    const { table: n, options: i } = this;
    return t.api[nI](n, i.instantiate(t));
  }
  codegen(t) {
    const { type: n, table: i, options: r } = this, s = r.codegen(t);
    return `${t.ns()}${n}("${i}"${s ? ", " + s : ""})`;
  }
  toJSON() {
    const { type: t, table: n, options: i } = this;
    return { [t]: n, ...i.toJSON() };
  }
}
function ag(e) {
  return e == null ? [] : [e].flat();
}
function Jst(e, t) {
  let n;
  for (const s in e)
    t.transforms.has(s) && (n = s);
  if (!n)
    return;
  const i = n === "count" || n == null ? [] : ag(e[n]), r = {
    distinct: e.distinct,
    orderby: ag(e.orderby).map((s) => t.maybeParam(s)),
    partitionby: ag(e.partitionby).map((s) => t.maybeParam(s)),
    rows: e.rows ? t.maybeParam(e.rows) : null,
    range: e.range ? t.maybeParam(e.range) : null
  };
  return new Kst(n, i, r);
}
class Kst extends Oe {
  constructor(t, n, i) {
    super(rst), this.name = t, this.args = n, this.options = i;
  }
  instantiate(t) {
    const { name: n, args: i, options: r } = this, { distinct: s, orderby: o, partitionby: a, rows: c, range: l } = r;
    let u = t.api[n](...i);
    return s && (u = u.distinct()), o.length && (u = u.orderby(o.map((f) => f.instantiate(t)))), a.length && (u = u.partitionby(a.map((f) => f.instantiate(t)))), c != null ? u = u.rows(c.instantiate(t)) : l != null && (u = u.range(l.instantiate(t))), u;
  }
  codegen(t) {
    const { name: n, args: i, options: r } = this, { distinct: s, orderby: o, partitionby: a, rows: c, range: l } = r;
    let u = `${t.ns()}${n}(` + i.map((f) => JSON.stringify(f)).join(", ") + ")";
    if (s && (u += ".distinct()"), o.length) {
      const f = o.map((h) => h.codegen(t));
      u += `.orderby(${f.join(", ")})`;
    }
    if (a.length) {
      const f = a.map((h) => h.codegen(t));
      u += `.partitionby(${f.join(", ")})`;
    }
    return c ? u += `.rows(${c.codegen(t)})` : l && (u += `.range(${l.codegen(t)})`), u;
  }
  toJSON() {
    const { name: t, args: n, options: i } = this, { distinct: r, orderby: s, partitionby: o, rows: a, range: c } = i, l = { [t]: cg(n) };
    return r && (l.distinct = !0), s.length && (l.orderby = cg(s.map((u) => u.toJSON()))), o.length && (l.partitionby = cg(o.map((u) => u.toJSON()))), a ? l.rows = a.toJSON() : c && (l.range = c.toJSON()), l;
  }
}
function cg(e) {
  return e.length === 0 ? "" : e.length === 1 ? e[0] : e;
}
function Zst(e, t) {
  if (dL(e))
    return e[bc] || e[Go] ? Wst(e, t) : Jst(e, t);
}
function Qst(e, t) {
  var a, c;
  const { mark: n, data: i, ...r } = e;
  (c = (a = t.plot) == null ? void 0 : a.marks) != null && c.has(n) || t.error(`Unrecognized mark type: ${n}`, e);
  const s = Xst(i, t), o = {};
  for (const l in r) {
    const u = r[l];
    o[l] = Zst(u, t) || t.maybeParam(u);
  }
  return new tot(n, s, new G0(o));
}
class tot extends Oe {
  constructor(t, n, i) {
    super(hL), this.name = t, this.data = n, this.options = i;
  }
  instantiate(t) {
    const { name: n, data: i, options: r } = this, s = r.instantiate(t);
    return i ? t.api[n](i.instantiate(t), s) : t.api[n](s);
  }
  codegen(t) {
    const { name: n, data: i, options: r } = this, s = i ? i.codegen(t) : "", o = r.codegen(t);
    let a;
    if (s && o) {
      t.indent();
      const c = r.codegen(t);
      a = `
${t.tab()}${s},
${t.tab()}${c}
`, t.undent(), a += t.tab();
    } else
      a = `${s}${o}`;
    return `${t.tab()}${t.ns()}${n}(${a})`;
  }
  toJSON() {
    const { type: t, name: n, data: i, options: r } = this;
    return {
      [t]: n,
      ...i ? { data: i.toJSON() } : {},
      ...r.toJSON()
    };
  }
}
function eot(e, t) {
  return SL({ plot: [e] }, t);
}
function SL(e, t) {
  const { [oy]: n, ...i } = e, r = Object.entries(i).map(([o, a]) => vL(o, a, t)), s = n.map((o) => ld(o.mark) ? Qst(o, t) : ld(o.legend) ? _L(o, t) : ld(o.select) ? qst(o, t) : t.error("Invalid plot entry.", o));
  return new not(s, r);
}
class not extends Oe {
  constructor(t, n) {
    super(oy, t), this.attributes = n;
  }
  instantiate(t) {
    const n = [
      ...t.plotDefaults || [],
      ...this.attributes || []
    ];
    return t.api[oy](
      this.children.map((i) => i.instantiate(t)),
      n.map((i) => i.instantiate(t))
    );
  }
  codegen(t) {
    var o;
    const { type: n, children: i, attributes: r } = this;
    t.indent();
    const s = [
      ...i.map((a) => a.codegen(t)),
      ...(o = t.plotDefaults) != null && o.length ? [`${t.tab()}...defaultAttributes`] : [],
      ...r.map((a) => a.codegen(t))
    ].join(`,
`);
    return t.undent(), `${t.tab()}${t.ns()}${n}(
${s}
${t.tab()})`;
  }
  toJSON() {
    const { type: t, children: n, attributes: i } = this, r = { [t]: n.map((s) => s.toJSON()) };
    for (const s of i)
      Object.assign(r, s.toJSON());
    return r;
  }
}
function iot(e, t) {
  const n = e[iy].map((i) => t.parseComponent(i));
  return new rot(n);
}
class rot extends Oe {
  constructor(t) {
    super(iy, t);
  }
  instantiate(t) {
    return t.api[iy](this.children.map((n) => n.instantiate(t)));
  }
  codegen(t) {
    t.indent();
    const n = this.children.map((i) => i.codegen(t));
    return t.undent(), `${t.tab()}${t.ns()}${this.type}(
${n.join(`,
`)}
${t.tab()})`;
  }
  toJSON() {
    return { [this.type]: this.children.map((t) => t.toJSON()) };
  }
}
function sot(e) {
  return new oot(e[sy]);
}
class oot extends Oe {
  constructor(t) {
    super(sy), this.value = t;
  }
  instantiate(t) {
    return t.api[sy](this.value);
  }
  codegen(t) {
    return `${t.tab()}${t.ns()}${this.type}(${t.stringify(this.value)})`;
  }
  toJSON() {
    return { [this.type]: this.value };
  }
}
function aot(e = []) {
  return new Map([
    [oy, SL],
    [hL, eot],
    [Kv, _L],
    [Jv, Pst],
    [ny, Cst],
    [iy, iot],
    [ry, Ust],
    [sy, sot],
    ...e
  ]);
}
function cot(e = []) {
  return /* @__PURE__ */ new Set([
    "menu",
    "search",
    "slider",
    "table",
    ...e
  ]);
}
function lot({
  attributes: e = uot(),
  interactors: t = fot(),
  legends: n = hot(),
  marks: i = dot()
} = {}) {
  return { attributes: e, interactors: t, legends: n, marks: i };
}
function uot(e = []) {
  return /* @__PURE__ */ new Set([
    ...Object.keys(krt),
    ...e
  ]);
}
function fot(e = []) {
  return /* @__PURE__ */ new Set([
    ...Object.keys(Vrt),
    ...e
  ]);
}
function hot(e = []) {
  return /* @__PURE__ */ new Set([
    ...Object.keys(jrt),
    ...e
  ]);
}
function dot(e = []) {
  return /* @__PURE__ */ new Set([
    ...Object.keys(Prt),
    ...e
  ]);
}
function pot(e = []) {
  return /* @__PURE__ */ new Set([
    "argmin",
    "argmax",
    "avg",
    "bin",
    "centroid",
    "centroidX",
    "centroidY",
    "count",
    "dateMonth",
    "dateMonthDay",
    "dateDay",
    "first",
    "geojson",
    "last",
    "max",
    "median",
    "min",
    "mode",
    "product",
    "quantile",
    "sum",
    "row_number",
    "rank",
    "dense_rank",
    "percent_rank",
    "cume_dist",
    "ntile",
    "lag",
    "lead",
    "first_value",
    "last_value",
    "nth_value",
    ...e
  ]);
}
function yot(e, t) {
  return new mot(t).parse(e);
}
class mot {
  /**
   * Create a new parser context.
   * @param {object} [options]
   * @param {Map<string, Function>} [options.components] Map of component names to parse functions.
   * @param {Set<string>} [options.transforms] The names of allowed transform functions.
   * @param {Set<string>} [options.inputs] The names of supported input widgets.
   * @param {PlotNames} [options.plot] The names of supported plot elements.
   * @param {any[]} [options.params] An array of [name, node] pairs of pre-parsed
   *  Param or Selection AST nodes.
   * @param {any[]} [options.datasets] An array of [name, node] pairs of pre-parsed
   *  dataset definition AST nodes.
   */
  constructor({
    components: t = aot(),
    transforms: n = pot(),
    inputs: i = cot(),
    plot: r = lot(),
    params: s = [],
    datasets: o = []
  } = {}) {
    this.components = t, this.transforms = n, this.inputs = i, this.plot = r, this.params = new Map(s), this.datasets = new Map(o);
  }
  parse(t) {
    const {
      meta: n,
      config: i,
      data: r = {},
      params: s,
      plotDefaults: o = {},
      ...a
    } = t;
    for (const c in r)
      this.datasets.set(c, hst(c, r[c], this));
    this.plotDefaults = Object.entries(o).map(([c, l]) => vL(c, l, this));
    for (const c in s)
      this.params.set(c, Fst(s[c], this));
    return new ost(
      this.parseComponent(a),
      n ? { ...n } : void 0,
      i ? { ...i } : void 0,
      Object.fromEntries(this.datasets),
      Object.fromEntries(this.params),
      this.plotDefaults
    );
  }
  parseComponent(t) {
    for (const [n, i] of this.components)
      if (t[n] != null)
        return i(t, this);
    this.error("Invalid specification.", t);
  }
  /**
   * Test if a value is param reference, if so, generate a paramter definition
   * as needed and return a new ParamRefNode. Otherwise, return a LiteralNode.
   * @param {*} value The value to test.
   * @param {() => ParamNode | SelectionNode} [makeNode] A Param of Selection AST
   *  node constructor.
   * @returns {ParamRefNode|LiteralNode} An AST node for the input value.
   */
  maybeParam(t, n = () => new eb()) {
    const { params: i } = this, r = ast(t);
    if (r) {
      if (!i.has(r)) {
        const s = n();
        i.set(r, s);
      }
      return new Est(r);
    }
    return new bL(t);
  }
  maybeSelection(t) {
    return this.maybeParam(t, () => new wL());
  }
  error(t, n) {
    pL(t, n);
  }
}
const got = new TextDecoder("utf-8"), nb = (e) => got.decode(e), bot = new TextEncoder(), e_ = (e) => bot.encode(e), wot = (e) => typeof e == "number", vot = (e) => typeof e == "boolean", an = (e) => typeof e == "function", Oi = (e) => e != null && Object(e) === e, Qu = (e) => Oi(e) && an(e.then), H0 = (e) => Oi(e) && an(e[Symbol.iterator]), n_ = (e) => Oi(e) && an(e[Symbol.asyncIterator]), ib = (e) => Oi(e) && Oi(e.schema), xL = (e) => Oi(e) && "done" in e && "value" in e, IL = (e) => Oi(e) && an(e.stat) && wot(e.fd), AL = (e) => Oi(e) && i_(e.body), ML = (e) => "_getDOMStream" in e && "_getNodeStream" in e, i_ = (e) => Oi(e) && an(e.cancel) && an(e.getReader) && !ML(e), $L = (e) => Oi(e) && an(e.read) && an(e.pipe) && vot(e.readable) && !ML(e), _ot = (e) => Oi(e) && an(e.clear) && an(e.bytes) && an(e.position) && an(e.setPosition) && an(e.capacity) && an(e.getBufferIdentifier) && an(e.createLong), r_ = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : ArrayBuffer;
function Sot(e) {
  const t = e[0] ? [e[0]] : [];
  let n, i, r, s;
  for (let o, a, c = 0, l = 0, u = e.length; ++c < u; ) {
    if (o = t[l], a = e[c], !o || !a || o.buffer !== a.buffer || a.byteOffset < o.byteOffset) {
      a && (t[++l] = a);
      continue;
    }
    if ({ byteOffset: n, byteLength: r } = o, { byteOffset: i, byteLength: s } = a, n + r < i || i + s < n) {
      a && (t[++l] = a);
      continue;
    }
    t[l] = new Uint8Array(o.buffer, n, i - n + s);
  }
  return t;
}
function oI(e, t, n = 0, i = t.byteLength) {
  const r = e.byteLength, s = new Uint8Array(e.buffer, e.byteOffset, r), o = new Uint8Array(t.buffer, t.byteOffset, Math.min(i, r));
  return s.set(o, n), e;
}
function yr(e, t) {
  const n = Sot(e), i = n.reduce((u, f) => u + f.byteLength, 0);
  let r, s, o, a = 0, c = -1;
  const l = Math.min(t || Number.POSITIVE_INFINITY, i);
  for (const u = n.length; ++c < u; ) {
    if (r = n[c], s = r.subarray(0, Math.min(r.length, l - a)), l <= a + s.length) {
      s.length < r.length ? n[c] = r.subarray(s.length) : s.length === r.length && c++, o ? oI(o, s, a) : o = s;
      break;
    }
    oI(o || (o = new Uint8Array(l)), s, a), a += s.length;
  }
  return [o || new Uint8Array(0), n.slice(c), i - (o ? o.byteLength : 0)];
}
function se(e, t) {
  let n = xL(t) ? t.value : t;
  return n instanceof e ? e === Uint8Array ? new e(n.buffer, n.byteOffset, n.byteLength) : n : n ? (typeof n == "string" && (n = e_(n)), n instanceof ArrayBuffer ? new e(n) : n instanceof r_ ? new e(n) : _ot(n) ? se(e, n.bytes()) : ArrayBuffer.isView(n) ? n.byteLength <= 0 ? new e(0) : new e(n.buffer, n.byteOffset, n.byteLength / e.BYTES_PER_ELEMENT) : e.from(n)) : new e(0);
}
const Ol = (e) => se(Int32Array, e), aI = (e) => se(BigInt64Array, e), Wt = (e) => se(Uint8Array, e), rb = (e) => (e.next(), e);
function* xot(e, t) {
  const n = function* (r) {
    yield r;
  }, i = typeof t == "string" || ArrayBuffer.isView(t) || t instanceof ArrayBuffer || t instanceof r_ ? n(t) : H0(t) ? t : n(t);
  return yield* rb(function* (r) {
    let s = null;
    do
      s = r.next(yield se(e, s));
    while (!s.done);
  }(i[Symbol.iterator]())), new e();
}
const Iot = (e) => xot(Uint8Array, e);
function TL(e, t) {
  return Re(this, arguments, function* () {
    if (Qu(t))
      return yield H(yield H(yield* ks(ci(TL(e, yield H(t))))));
    const i = function(o) {
      return Re(this, arguments, function* () {
        yield yield H(yield H(o));
      });
    }, r = function(o) {
      return Re(this, arguments, function* () {
        yield H(yield* ks(ci(rb(function* (a) {
          let c = null;
          do
            c = a.next(yield c == null ? void 0 : c.value);
          while (!c.done);
        }(o[Symbol.iterator]())))));
      });
    }, s = typeof t == "string" || ArrayBuffer.isView(t) || t instanceof ArrayBuffer || t instanceof r_ ? i(t) : H0(t) ? r(t) : n_(t) ? t : i(t);
    return yield H(
      // otherwise if AsyncIterable, use it
      yield* ks(ci(rb(function(o) {
        return Re(this, arguments, function* () {
          let a = null;
          do
            a = yield H(o.next(yield yield H(se(e, a))));
          while (!a.done);
        });
      }(s[Symbol.asyncIterator]()))))
    ), yield H(new e());
  });
}
const Aot = (e) => TL(Uint8Array, e);
function Mot(e, t) {
  let n = 0;
  const i = e.length;
  if (i !== t.length)
    return !1;
  if (i > 0)
    do
      if (e[n] !== t[n])
        return !1;
    while (++n < i);
  return !0;
}
const Zn = {
  fromIterable(e) {
    return Eh($ot(e));
  },
  fromAsyncIterable(e) {
    return Eh(Tot(e));
  },
  fromDOMStream(e) {
    return Eh(Dot(e));
  },
  fromNodeStream(e) {
    return Eh(Bot(e));
  },
  // @ts-ignore
  toDOMStream(e, t) {
    throw new Error('"toDOMStream" not available in this environment');
  },
  // @ts-ignore
  toNodeStream(e, t) {
    throw new Error('"toNodeStream" not available in this environment');
  }
}, Eh = (e) => (e.next(), e);
function* $ot(e) {
  let t, n = !1, i = [], r, s, o, a = 0;
  function c() {
    return s === "peek" ? yr(i, o)[0] : ([r, i, a] = yr(i, o), r);
  }
  ({ cmd: s, size: o } = (yield null) || { cmd: "read", size: 0 });
  const l = Iot(e)[Symbol.iterator]();
  try {
    do
      if ({ done: t, value: r } = Number.isNaN(o - a) ? l.next() : l.next(o - a), !t && r.byteLength > 0 && (i.push(r), a += r.byteLength), t || o <= a)
        do
          ({ cmd: s, size: o } = yield c());
        while (o < a);
    while (!t);
  } catch (u) {
    (n = !0) && typeof l.throw == "function" && l.throw(u);
  } finally {
    n === !1 && typeof l.return == "function" && l.return(null);
  }
  return null;
}
function Tot(e) {
  return Re(this, arguments, function* () {
    let n, i = !1, r = [], s, o, a, c = 0;
    function l() {
      return o === "peek" ? yr(r, a)[0] : ([s, r, c] = yr(r, a), s);
    }
    ({ cmd: o, size: a } = (yield yield H(null)) || { cmd: "read", size: 0 });
    const u = Aot(e)[Symbol.asyncIterator]();
    try {
      do
        if ({ done: n, value: s } = Number.isNaN(a - c) ? yield H(u.next()) : yield H(u.next(a - c)), !n && s.byteLength > 0 && (r.push(s), c += s.byteLength), n || a <= c)
          do
            ({ cmd: o, size: a } = yield yield H(l()));
          while (a < c);
      while (!n);
    } catch (f) {
      (i = !0) && typeof u.throw == "function" && (yield H(u.throw(f)));
    } finally {
      i === !1 && typeof u.return == "function" && (yield H(u.return(new Uint8Array(0))));
    }
    return yield H(null);
  });
}
function Dot(e) {
  return Re(this, arguments, function* () {
    let n = !1, i = !1, r = [], s, o, a, c = 0;
    function l() {
      return o === "peek" ? yr(r, a)[0] : ([s, r, c] = yr(r, a), s);
    }
    ({ cmd: o, size: a } = (yield yield H(null)) || { cmd: "read", size: 0 });
    const u = new Not(e);
    try {
      do
        if ({ done: n, value: s } = Number.isNaN(a - c) ? yield H(u.read()) : yield H(u.read(a - c)), !n && s.byteLength > 0 && (r.push(Wt(s)), c += s.byteLength), n || a <= c)
          do
            ({ cmd: o, size: a } = yield yield H(l()));
          while (a < c);
      while (!n);
    } catch (f) {
      (i = !0) && (yield H(u.cancel(f)));
    } finally {
      i === !1 ? yield H(u.cancel()) : e.locked && u.releaseLock();
    }
    return yield H(null);
  });
}
class Not {
  constructor(t) {
    this.source = t, this.reader = null, this.reader = this.source.getReader(), this.reader.closed.catch(() => {
    });
  }
  get closed() {
    return this.reader ? this.reader.closed.catch(() => {
    }) : Promise.resolve();
  }
  releaseLock() {
    this.reader && this.reader.releaseLock(), this.reader = null;
  }
  cancel(t) {
    return W(this, void 0, void 0, function* () {
      const { reader: n, source: i } = this;
      n && (yield n.cancel(t).catch(() => {
      })), i && i.locked && this.releaseLock();
    });
  }
  read(t) {
    return W(this, void 0, void 0, function* () {
      if (t === 0)
        return { done: this.reader == null, value: new Uint8Array(0) };
      const n = yield this.reader.read();
      return !n.done && (n.value = Wt(n)), n;
    });
  }
}
const lg = (e, t) => {
  const n = (r) => i([t, r]);
  let i;
  return [t, n, new Promise((r) => (i = r) && e.once(t, n))];
};
function Bot(e) {
  return Re(this, arguments, function* () {
    const n = [];
    let i = "error", r = !1, s = null, o, a, c = 0, l = [], u;
    function f() {
      return o === "peek" ? yr(l, a)[0] : ([u, l, c] = yr(l, a), u);
    }
    if ({ cmd: o, size: a } = (yield yield H(null)) || { cmd: "read", size: 0 }, e.isTTY)
      return yield yield H(new Uint8Array(0)), yield H(null);
    try {
      n[0] = lg(e, "end"), n[1] = lg(e, "error");
      do {
        if (n[2] = lg(e, "readable"), [i, s] = yield H(Promise.race(n.map((d) => d[2]))), i === "error")
          break;
        if ((r = i === "end") || (Number.isFinite(a - c) ? (u = Wt(e.read(a - c)), u.byteLength < a - c && (u = Wt(e.read()))) : u = Wt(e.read()), u.byteLength > 0 && (l.push(u), c += u.byteLength)), r || a <= c)
          do
            ({ cmd: o, size: a } = yield yield H(f()));
          while (a < c);
      } while (!r);
    } finally {
      yield H(h(n, i === "error" ? s : null));
    }
    return yield H(null);
    function h(d, p) {
      return u = l = null, new Promise((y, m) => {
        for (const [g, b] of d)
          e.off(g, b);
        try {
          const g = e.destroy;
          g && g.call(e, p), p = void 0;
        } catch (g) {
          p = g || p;
        } finally {
          p != null ? m(p) : y();
        }
      });
    }
  });
}
var Le;
(function(e) {
  e[e.V1 = 0] = "V1", e[e.V2 = 1] = "V2", e[e.V3 = 2] = "V3", e[e.V4 = 3] = "V4", e[e.V5 = 4] = "V5";
})(Le || (Le = {}));
var On;
(function(e) {
  e[e.Sparse = 0] = "Sparse", e[e.Dense = 1] = "Dense";
})(On || (On = {}));
var rn;
(function(e) {
  e[e.HALF = 0] = "HALF", e[e.SINGLE = 1] = "SINGLE", e[e.DOUBLE = 2] = "DOUBLE";
})(rn || (rn = {}));
var Fi;
(function(e) {
  e[e.DAY = 0] = "DAY", e[e.MILLISECOND = 1] = "MILLISECOND";
})(Fi || (Fi = {}));
var bt;
(function(e) {
  e[e.SECOND = 0] = "SECOND", e[e.MILLISECOND = 1] = "MILLISECOND", e[e.MICROSECOND = 2] = "MICROSECOND", e[e.NANOSECOND = 3] = "NANOSECOND";
})(bt || (bt = {}));
var mr;
(function(e) {
  e[e.YEAR_MONTH = 0] = "YEAR_MONTH", e[e.DAY_TIME = 1] = "DAY_TIME", e[e.MONTH_DAY_NANO = 2] = "MONTH_DAY_NANO";
})(mr || (mr = {}));
var ay;
(function(e) {
  e[e.BUFFER = 0] = "BUFFER";
})(ay || (ay = {}));
var cy;
(function(e) {
  e[e.LZ4_FRAME = 0] = "LZ4_FRAME", e[e.ZSTD = 1] = "ZSTD";
})(cy || (cy = {}));
class Ds {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsBodyCompression(t, n) {
    return (n || new Ds()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsBodyCompression(t, n) {
    return t.setPosition(t.position() + nt), (n || new Ds()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  /**
   * Compressor library.
   * For LZ4_FRAME, each compressed buffer must consist of a single frame.
   */
  codec() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt8(this.bb_pos + t) : cy.LZ4_FRAME;
  }
  /**
   * Indicates the way the record batch body was compressed
   */
  method() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.readInt8(this.bb_pos + t) : ay.BUFFER;
  }
  static startBodyCompression(t) {
    t.startObject(2);
  }
  static addCodec(t, n) {
    t.addFieldInt8(0, n, cy.LZ4_FRAME);
  }
  static addMethod(t, n) {
    t.addFieldInt8(1, n, ay.BUFFER);
  }
  static endBodyCompression(t) {
    return t.endObject();
  }
  static createBodyCompression(t, n, i) {
    return Ds.startBodyCompression(t), Ds.addCodec(t, n), Ds.addMethod(t, i), Ds.endBodyCompression(t);
  }
}
class DL {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  /**
   * The relative offset into the shared memory page where the bytes for this
   * buffer starts
   */
  offset() {
    return this.bb.readInt64(this.bb_pos);
  }
  /**
   * The absolute length (in bytes) of the memory buffer. The memory is found
   * from offset (inclusive) to offset + length (non-inclusive). When building
   * messages using the encapsulated IPC message, padding bytes may be written
   * after a buffer, but such padding bytes do not need to be accounted for in
   * the size here.
   */
  length() {
    return this.bb.readInt64(this.bb_pos + 8);
  }
  static sizeOf() {
    return 16;
  }
  static createBuffer(t, n, i) {
    return t.prep(8, 16), t.writeInt64(BigInt(i ?? 0)), t.writeInt64(BigInt(n ?? 0)), t.offset();
  }
}
let NL = class {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  /**
   * The number of value slots in the Arrow array at this level of a nested
   * tree
   */
  length() {
    return this.bb.readInt64(this.bb_pos);
  }
  /**
   * The number of observed nulls. Fields with null_count == 0 may choose not
   * to write their physical validity bitmap out as a materialized buffer,
   * instead setting the length of the bitmap buffer to 0.
   */
  nullCount() {
    return this.bb.readInt64(this.bb_pos + 8);
  }
  static sizeOf() {
    return 16;
  }
  static createFieldNode(t, n, i) {
    return t.prep(8, 16), t.writeInt64(BigInt(i ?? 0)), t.writeInt64(BigInt(n ?? 0)), t.offset();
  }
}, kr = class sb {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsRecordBatch(t, n) {
    return (n || new sb()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsRecordBatch(t, n) {
    return t.setPosition(t.position() + nt), (n || new sb()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  /**
   * number of records / rows. The arrays in the batch should all have this
   * length
   */
  length() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt64(this.bb_pos + t) : BigInt("0");
  }
  /**
   * Nodes correspond to the pre-ordered flattened logical schema
   */
  nodes(t, n) {
    const i = this.bb.__offset(this.bb_pos, 6);
    return i ? (n || new NL()).__init(this.bb.__vector(this.bb_pos + i) + t * 16, this.bb) : null;
  }
  nodesLength() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  /**
   * Buffers correspond to the pre-ordered flattened buffer tree
   *
   * The number of buffers appended to this list depends on the schema. For
   * example, most primitive arrays will have 2 buffers, 1 for the validity
   * bitmap and 1 for the values. For struct arrays, there will only be a
   * single buffer for the validity (nulls) bitmap
   */
  buffers(t, n) {
    const i = this.bb.__offset(this.bb_pos, 8);
    return i ? (n || new DL()).__init(this.bb.__vector(this.bb_pos + i) + t * 16, this.bb) : null;
  }
  buffersLength() {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  /**
   * Optional compression of the message body
   */
  compression(t) {
    const n = this.bb.__offset(this.bb_pos, 10);
    return n ? (t || new Ds()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;
  }
  static startRecordBatch(t) {
    t.startObject(4);
  }
  static addLength(t, n) {
    t.addFieldInt64(0, n, BigInt("0"));
  }
  static addNodes(t, n) {
    t.addFieldOffset(1, n, 0);
  }
  static startNodesVector(t, n) {
    t.startVector(16, n, 8);
  }
  static addBuffers(t, n) {
    t.addFieldOffset(2, n, 0);
  }
  static startBuffersVector(t, n) {
    t.startVector(16, n, 8);
  }
  static addCompression(t, n) {
    t.addFieldOffset(3, n, 0);
  }
  static endRecordBatch(t) {
    return t.endObject();
  }
}, Va = class ob {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsDictionaryBatch(t, n) {
    return (n || new ob()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsDictionaryBatch(t, n) {
    return t.setPosition(t.position() + nt), (n || new ob()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  id() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt64(this.bb_pos + t) : BigInt("0");
  }
  data(t) {
    const n = this.bb.__offset(this.bb_pos, 6);
    return n ? (t || new kr()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;
  }
  /**
   * If isDelta is true the values in the dictionary are to be appended to a
   * dictionary with the indicated id. If isDelta is false this dictionary
   * should replace the existing dictionary.
   */
  isDelta() {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? !!this.bb.readInt8(this.bb_pos + t) : !1;
  }
  static startDictionaryBatch(t) {
    t.startObject(3);
  }
  static addId(t, n) {
    t.addFieldInt64(0, n, BigInt("0"));
  }
  static addData(t, n) {
    t.addFieldOffset(1, n, 0);
  }
  static addIsDelta(t, n) {
    t.addFieldInt8(2, +n, 0);
  }
  static endDictionaryBatch(t) {
    return t.endObject();
  }
};
var Gc;
(function(e) {
  e[e.Little = 0] = "Little", e[e.Big = 1] = "Big";
})(Gc || (Gc = {}));
var ly;
(function(e) {
  e[e.DenseArray = 0] = "DenseArray";
})(ly || (ly = {}));
class Cn {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsInt(t, n) {
    return (n || new Cn()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsInt(t, n) {
    return t.setPosition(t.position() + nt), (n || new Cn()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  bitWidth() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt32(this.bb_pos + t) : 0;
  }
  isSigned() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? !!this.bb.readInt8(this.bb_pos + t) : !1;
  }
  static startInt(t) {
    t.startObject(2);
  }
  static addBitWidth(t, n) {
    t.addFieldInt32(0, n, 0);
  }
  static addIsSigned(t, n) {
    t.addFieldInt8(1, +n, 0);
  }
  static endInt(t) {
    return t.endObject();
  }
  static createInt(t, n, i) {
    return Cn.startInt(t), Cn.addBitWidth(t, n), Cn.addIsSigned(t, i), Cn.endInt(t);
  }
}
class qr {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsDictionaryEncoding(t, n) {
    return (n || new qr()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsDictionaryEncoding(t, n) {
    return t.setPosition(t.position() + nt), (n || new qr()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  /**
   * The known dictionary id in the application where this data is used. In
   * the file or streaming formats, the dictionary ids are found in the
   * DictionaryBatch messages
   */
  id() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt64(this.bb_pos + t) : BigInt("0");
  }
  /**
   * The dictionary indices are constrained to be non-negative integers. If
   * this field is null, the indices must be signed int32. To maximize
   * cross-language compatibility and performance, implementations are
   * recommended to prefer signed integer types over unsigned integer types
   * and to avoid uint64 indices unless they are required by an application.
   */
  indexType(t) {
    const n = this.bb.__offset(this.bb_pos, 6);
    return n ? (t || new Cn()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;
  }
  /**
   * By default, dictionaries are not ordered, or the order does not have
   * semantic meaning. In some statistical, applications, dictionary-encoding
   * is used to represent ordered categorical data, and we provide a way to
   * preserve that metadata here
   */
  isOrdered() {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? !!this.bb.readInt8(this.bb_pos + t) : !1;
  }
  dictionaryKind() {
    const t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.readInt16(this.bb_pos + t) : ly.DenseArray;
  }
  static startDictionaryEncoding(t) {
    t.startObject(4);
  }
  static addId(t, n) {
    t.addFieldInt64(0, n, BigInt("0"));
  }
  static addIndexType(t, n) {
    t.addFieldOffset(1, n, 0);
  }
  static addIsOrdered(t, n) {
    t.addFieldInt8(2, +n, 0);
  }
  static addDictionaryKind(t, n) {
    t.addFieldInt16(3, n, ly.DenseArray);
  }
  static endDictionaryEncoding(t) {
    return t.endObject();
  }
}
class Ce {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsKeyValue(t, n) {
    return (n || new Ce()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsKeyValue(t, n) {
    return t.setPosition(t.position() + nt), (n || new Ce()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  key(t) {
    const n = this.bb.__offset(this.bb_pos, 4);
    return n ? this.bb.__string(this.bb_pos + n, t) : null;
  }
  value(t) {
    const n = this.bb.__offset(this.bb_pos, 6);
    return n ? this.bb.__string(this.bb_pos + n, t) : null;
  }
  static startKeyValue(t) {
    t.startObject(2);
  }
  static addKey(t, n) {
    t.addFieldOffset(0, n, 0);
  }
  static addValue(t, n) {
    t.addFieldOffset(1, n, 0);
  }
  static endKeyValue(t) {
    return t.endObject();
  }
  static createKeyValue(t, n, i) {
    return Ce.startKeyValue(t), Ce.addKey(t, n), Ce.addValue(t, i), Ce.endKeyValue(t);
  }
}
let cI = class Ql {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsBinary(t, n) {
    return (n || new Ql()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsBinary(t, n) {
    return t.setPosition(t.position() + nt), (n || new Ql()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static startBinary(t) {
    t.startObject(0);
  }
  static endBinary(t) {
    return t.endObject();
  }
  static createBinary(t) {
    return Ql.startBinary(t), Ql.endBinary(t);
  }
}, lI = class tu {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsBool(t, n) {
    return (n || new tu()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsBool(t, n) {
    return t.setPosition(t.position() + nt), (n || new tu()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static startBool(t) {
    t.startObject(0);
  }
  static endBool(t) {
    return t.endObject();
  }
  static createBool(t) {
    return tu.startBool(t), tu.endBool(t);
  }
}, ud = class ja {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsDate(t, n) {
    return (n || new ja()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsDate(t, n) {
    return t.setPosition(t.position() + nt), (n || new ja()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  unit() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt16(this.bb_pos + t) : Fi.MILLISECOND;
  }
  static startDate(t) {
    t.startObject(1);
  }
  static addUnit(t, n) {
    t.addFieldInt16(0, n, Fi.MILLISECOND);
  }
  static endDate(t) {
    return t.endObject();
  }
  static createDate(t, n) {
    return ja.startDate(t), ja.addUnit(t, n), ja.endDate(t);
  }
}, qa = class As {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsDecimal(t, n) {
    return (n || new As()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsDecimal(t, n) {
    return t.setPosition(t.position() + nt), (n || new As()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  /**
   * Total number of decimal digits
   */
  precision() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt32(this.bb_pos + t) : 0;
  }
  /**
   * Number of digits after the decimal point "."
   */
  scale() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.readInt32(this.bb_pos + t) : 0;
  }
  /**
   * Number of bits per value. The only accepted widths are 128 and 256.
   * We use bitWidth for consistency with Int::bitWidth.
   */
  bitWidth() {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.readInt32(this.bb_pos + t) : 128;
  }
  static startDecimal(t) {
    t.startObject(3);
  }
  static addPrecision(t, n) {
    t.addFieldInt32(0, n, 0);
  }
  static addScale(t, n) {
    t.addFieldInt32(1, n, 0);
  }
  static addBitWidth(t, n) {
    t.addFieldInt32(2, n, 128);
  }
  static endDecimal(t) {
    return t.endObject();
  }
  static createDecimal(t, n, i, r) {
    return As.startDecimal(t), As.addPrecision(t, n), As.addScale(t, i), As.addBitWidth(t, r), As.endDecimal(t);
  }
}, fd = class Ya {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsDuration(t, n) {
    return (n || new Ya()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsDuration(t, n) {
    return t.setPosition(t.position() + nt), (n || new Ya()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  unit() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt16(this.bb_pos + t) : bt.MILLISECOND;
  }
  static startDuration(t) {
    t.startObject(1);
  }
  static addUnit(t, n) {
    t.addFieldInt16(0, n, bt.MILLISECOND);
  }
  static endDuration(t) {
    return t.endObject();
  }
  static createDuration(t, n) {
    return Ya.startDuration(t), Ya.addUnit(t, n), Ya.endDuration(t);
  }
}, hd = class Wa {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsFixedSizeBinary(t, n) {
    return (n || new Wa()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsFixedSizeBinary(t, n) {
    return t.setPosition(t.position() + nt), (n || new Wa()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  /**
   * Number of bytes per value
   */
  byteWidth() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt32(this.bb_pos + t) : 0;
  }
  static startFixedSizeBinary(t) {
    t.startObject(1);
  }
  static addByteWidth(t, n) {
    t.addFieldInt32(0, n, 0);
  }
  static endFixedSizeBinary(t) {
    return t.endObject();
  }
  static createFixedSizeBinary(t, n) {
    return Wa.startFixedSizeBinary(t), Wa.addByteWidth(t, n), Wa.endFixedSizeBinary(t);
  }
}, dd = class Ga {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsFixedSizeList(t, n) {
    return (n || new Ga()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsFixedSizeList(t, n) {
    return t.setPosition(t.position() + nt), (n || new Ga()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  /**
   * Number of list items per value
   */
  listSize() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt32(this.bb_pos + t) : 0;
  }
  static startFixedSizeList(t) {
    t.startObject(1);
  }
  static addListSize(t, n) {
    t.addFieldInt32(0, n, 0);
  }
  static endFixedSizeList(t) {
    return t.endObject();
  }
  static createFixedSizeList(t, n) {
    return Ga.startFixedSizeList(t), Ga.addListSize(t, n), Ga.endFixedSizeList(t);
  }
};
class tr {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsFloatingPoint(t, n) {
    return (n || new tr()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsFloatingPoint(t, n) {
    return t.setPosition(t.position() + nt), (n || new tr()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  precision() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt16(this.bb_pos + t) : rn.HALF;
  }
  static startFloatingPoint(t) {
    t.startObject(1);
  }
  static addPrecision(t, n) {
    t.addFieldInt16(0, n, rn.HALF);
  }
  static endFloatingPoint(t) {
    return t.endObject();
  }
  static createFloatingPoint(t, n) {
    return tr.startFloatingPoint(t), tr.addPrecision(t, n), tr.endFloatingPoint(t);
  }
}
class er {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsInterval(t, n) {
    return (n || new er()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsInterval(t, n) {
    return t.setPosition(t.position() + nt), (n || new er()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  unit() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt16(this.bb_pos + t) : mr.YEAR_MONTH;
  }
  static startInterval(t) {
    t.startObject(1);
  }
  static addUnit(t, n) {
    t.addFieldInt16(0, n, mr.YEAR_MONTH);
  }
  static endInterval(t) {
    return t.endObject();
  }
  static createInterval(t, n) {
    return er.startInterval(t), er.addUnit(t, n), er.endInterval(t);
  }
}
let uI = class eu {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsLargeBinary(t, n) {
    return (n || new eu()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsLargeBinary(t, n) {
    return t.setPosition(t.position() + nt), (n || new eu()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static startLargeBinary(t) {
    t.startObject(0);
  }
  static endLargeBinary(t) {
    return t.endObject();
  }
  static createLargeBinary(t) {
    return eu.startLargeBinary(t), eu.endLargeBinary(t);
  }
}, fI = class nu {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsLargeUtf8(t, n) {
    return (n || new nu()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsLargeUtf8(t, n) {
    return t.setPosition(t.position() + nt), (n || new nu()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static startLargeUtf8(t) {
    t.startObject(0);
  }
  static endLargeUtf8(t) {
    return t.endObject();
  }
  static createLargeUtf8(t) {
    return nu.startLargeUtf8(t), nu.endLargeUtf8(t);
  }
}, hI = class iu {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsList(t, n) {
    return (n || new iu()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsList(t, n) {
    return t.setPosition(t.position() + nt), (n || new iu()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static startList(t) {
    t.startObject(0);
  }
  static endList(t) {
    return t.endObject();
  }
  static createList(t) {
    return iu.startList(t), iu.endList(t);
  }
}, pd = class Xa {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsMap(t, n) {
    return (n || new Xa()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsMap(t, n) {
    return t.setPosition(t.position() + nt), (n || new Xa()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  /**
   * Set to true if the keys within each value are sorted
   */
  keysSorted() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? !!this.bb.readInt8(this.bb_pos + t) : !1;
  }
  static startMap(t) {
    t.startObject(1);
  }
  static addKeysSorted(t, n) {
    t.addFieldInt8(0, +n, 0);
  }
  static endMap(t) {
    return t.endObject();
  }
  static createMap(t, n) {
    return Xa.startMap(t), Xa.addKeysSorted(t, n), Xa.endMap(t);
  }
}, dI = class ru {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsNull(t, n) {
    return (n || new ru()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsNull(t, n) {
    return t.setPosition(t.position() + nt), (n || new ru()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static startNull(t) {
    t.startObject(0);
  }
  static endNull(t) {
    return t.endObject();
  }
  static createNull(t) {
    return ru.startNull(t), ru.endNull(t);
  }
};
class ko {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsStruct_(t, n) {
    return (n || new ko()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsStruct_(t, n) {
    return t.setPosition(t.position() + nt), (n || new ko()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static startStruct_(t) {
    t.startObject(0);
  }
  static endStruct_(t) {
    return t.endObject();
  }
  static createStruct_(t) {
    return ko.startStruct_(t), ko.endStruct_(t);
  }
}
class Qn {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsTime(t, n) {
    return (n || new Qn()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsTime(t, n) {
    return t.setPosition(t.position() + nt), (n || new Qn()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  unit() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt16(this.bb_pos + t) : bt.MILLISECOND;
  }
  bitWidth() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.readInt32(this.bb_pos + t) : 32;
  }
  static startTime(t) {
    t.startObject(2);
  }
  static addUnit(t, n) {
    t.addFieldInt16(0, n, bt.MILLISECOND);
  }
  static addBitWidth(t, n) {
    t.addFieldInt32(1, n, 32);
  }
  static endTime(t) {
    return t.endObject();
  }
  static createTime(t, n, i) {
    return Qn.startTime(t), Qn.addUnit(t, n), Qn.addBitWidth(t, i), Qn.endTime(t);
  }
}
class ti {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsTimestamp(t, n) {
    return (n || new ti()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsTimestamp(t, n) {
    return t.setPosition(t.position() + nt), (n || new ti()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  unit() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt16(this.bb_pos + t) : bt.SECOND;
  }
  timezone(t) {
    const n = this.bb.__offset(this.bb_pos, 6);
    return n ? this.bb.__string(this.bb_pos + n, t) : null;
  }
  static startTimestamp(t) {
    t.startObject(2);
  }
  static addUnit(t, n) {
    t.addFieldInt16(0, n, bt.SECOND);
  }
  static addTimezone(t, n) {
    t.addFieldOffset(1, n, 0);
  }
  static endTimestamp(t) {
    return t.endObject();
  }
  static createTimestamp(t, n, i) {
    return ti.startTimestamp(t), ti.addUnit(t, n), ti.addTimezone(t, i), ti.endTimestamp(t);
  }
}
class In {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsUnion(t, n) {
    return (n || new In()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsUnion(t, n) {
    return t.setPosition(t.position() + nt), (n || new In()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  mode() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt16(this.bb_pos + t) : On.Sparse;
  }
  typeIds(t) {
    const n = this.bb.__offset(this.bb_pos, 6);
    return n ? this.bb.readInt32(this.bb.__vector(this.bb_pos + n) + t * 4) : 0;
  }
  typeIdsLength() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  typeIdsArray() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null;
  }
  static startUnion(t) {
    t.startObject(2);
  }
  static addMode(t, n) {
    t.addFieldInt16(0, n, On.Sparse);
  }
  static addTypeIds(t, n) {
    t.addFieldOffset(1, n, 0);
  }
  static createTypeIdsVector(t, n) {
    t.startVector(4, n.length, 4);
    for (let i = n.length - 1; i >= 0; i--)
      t.addInt32(n[i]);
    return t.endVector();
  }
  static startTypeIdsVector(t, n) {
    t.startVector(4, n, 4);
  }
  static endUnion(t) {
    return t.endObject();
  }
  static createUnion(t, n, i) {
    return In.startUnion(t), In.addMode(t, n), In.addTypeIds(t, i), In.endUnion(t);
  }
}
let pI = class su {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsUtf8(t, n) {
    return (n || new su()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsUtf8(t, n) {
    return t.setPosition(t.position() + nt), (n || new su()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static startUtf8(t) {
    t.startObject(0);
  }
  static endUtf8(t) {
    return t.endObject();
  }
  static createUtf8(t) {
    return su.startUtf8(t), su.endUtf8(t);
  }
};
var pe;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.Null = 1] = "Null", e[e.Int = 2] = "Int", e[e.FloatingPoint = 3] = "FloatingPoint", e[e.Binary = 4] = "Binary", e[e.Utf8 = 5] = "Utf8", e[e.Bool = 6] = "Bool", e[e.Decimal = 7] = "Decimal", e[e.Date = 8] = "Date", e[e.Time = 9] = "Time", e[e.Timestamp = 10] = "Timestamp", e[e.Interval = 11] = "Interval", e[e.List = 12] = "List", e[e.Struct_ = 13] = "Struct_", e[e.Union = 14] = "Union", e[e.FixedSizeBinary = 15] = "FixedSizeBinary", e[e.FixedSizeList = 16] = "FixedSizeList", e[e.Map = 17] = "Map", e[e.Duration = 18] = "Duration", e[e.LargeBinary = 19] = "LargeBinary", e[e.LargeUtf8 = 20] = "LargeUtf8", e[e.LargeList = 21] = "LargeList", e[e.RunEndEncoded = 22] = "RunEndEncoded";
})(pe || (pe = {}));
let Hn = class yd {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsField(t, n) {
    return (n || new yd()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsField(t, n) {
    return t.setPosition(t.position() + nt), (n || new yd()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  name(t) {
    const n = this.bb.__offset(this.bb_pos, 4);
    return n ? this.bb.__string(this.bb_pos + n, t) : null;
  }
  /**
   * Whether or not this field can contain nulls. Should be true in general.
   */
  nullable() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? !!this.bb.readInt8(this.bb_pos + t) : !1;
  }
  typeType() {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.readUint8(this.bb_pos + t) : pe.NONE;
  }
  /**
   * This is the type of the decoded value if the field is dictionary encoded.
   */
  type(t) {
    const n = this.bb.__offset(this.bb_pos, 10);
    return n ? this.bb.__union(t, this.bb_pos + n) : null;
  }
  /**
   * Present only if the field is dictionary encoded.
   */
  dictionary(t) {
    const n = this.bb.__offset(this.bb_pos, 12);
    return n ? (t || new qr()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;
  }
  /**
   * children apply only to nested data types like Struct, List and Union. For
   * primitive types children will have length 0.
   */
  children(t, n) {
    const i = this.bb.__offset(this.bb_pos, 14);
    return i ? (n || new yd()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + t * 4), this.bb) : null;
  }
  childrenLength() {
    const t = this.bb.__offset(this.bb_pos, 14);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  /**
   * User-defined metadata
   */
  customMetadata(t, n) {
    const i = this.bb.__offset(this.bb_pos, 16);
    return i ? (n || new Ce()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + t * 4), this.bb) : null;
  }
  customMetadataLength() {
    const t = this.bb.__offset(this.bb_pos, 16);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  static startField(t) {
    t.startObject(7);
  }
  static addName(t, n) {
    t.addFieldOffset(0, n, 0);
  }
  static addNullable(t, n) {
    t.addFieldInt8(1, +n, 0);
  }
  static addTypeType(t, n) {
    t.addFieldInt8(2, n, pe.NONE);
  }
  static addType(t, n) {
    t.addFieldOffset(3, n, 0);
  }
  static addDictionary(t, n) {
    t.addFieldOffset(4, n, 0);
  }
  static addChildren(t, n) {
    t.addFieldOffset(5, n, 0);
  }
  static createChildrenVector(t, n) {
    t.startVector(4, n.length, 4);
    for (let i = n.length - 1; i >= 0; i--)
      t.addOffset(n[i]);
    return t.endVector();
  }
  static startChildrenVector(t, n) {
    t.startVector(4, n, 4);
  }
  static addCustomMetadata(t, n) {
    t.addFieldOffset(6, n, 0);
  }
  static createCustomMetadataVector(t, n) {
    t.startVector(4, n.length, 4);
    for (let i = n.length - 1; i >= 0; i--)
      t.addOffset(n[i]);
    return t.endVector();
  }
  static startCustomMetadataVector(t, n) {
    t.startVector(4, n, 4);
  }
  static endField(t) {
    return t.endObject();
  }
}, Gi = class Er {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsSchema(t, n) {
    return (n || new Er()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsSchema(t, n) {
    return t.setPosition(t.position() + nt), (n || new Er()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  /**
   * endianness of the buffer
   * it is Little Endian by default
   * if endianness doesn't match the underlying system then the vectors need to be converted
   */
  endianness() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt16(this.bb_pos + t) : Gc.Little;
  }
  fields(t, n) {
    const i = this.bb.__offset(this.bb_pos, 6);
    return i ? (n || new Hn()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + t * 4), this.bb) : null;
  }
  fieldsLength() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  customMetadata(t, n) {
    const i = this.bb.__offset(this.bb_pos, 8);
    return i ? (n || new Ce()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + t * 4), this.bb) : null;
  }
  customMetadataLength() {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  /**
   * Features used in the stream/file.
   */
  features(t) {
    const n = this.bb.__offset(this.bb_pos, 10);
    return n ? this.bb.readInt64(this.bb.__vector(this.bb_pos + n) + t * 8) : BigInt(0);
  }
  featuresLength() {
    const t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  static startSchema(t) {
    t.startObject(4);
  }
  static addEndianness(t, n) {
    t.addFieldInt16(0, n, Gc.Little);
  }
  static addFields(t, n) {
    t.addFieldOffset(1, n, 0);
  }
  static createFieldsVector(t, n) {
    t.startVector(4, n.length, 4);
    for (let i = n.length - 1; i >= 0; i--)
      t.addOffset(n[i]);
    return t.endVector();
  }
  static startFieldsVector(t, n) {
    t.startVector(4, n, 4);
  }
  static addCustomMetadata(t, n) {
    t.addFieldOffset(2, n, 0);
  }
  static createCustomMetadataVector(t, n) {
    t.startVector(4, n.length, 4);
    for (let i = n.length - 1; i >= 0; i--)
      t.addOffset(n[i]);
    return t.endVector();
  }
  static startCustomMetadataVector(t, n) {
    t.startVector(4, n, 4);
  }
  static addFeatures(t, n) {
    t.addFieldOffset(3, n, 0);
  }
  static createFeaturesVector(t, n) {
    t.startVector(8, n.length, 8);
    for (let i = n.length - 1; i >= 0; i--)
      t.addInt64(n[i]);
    return t.endVector();
  }
  static startFeaturesVector(t, n) {
    t.startVector(8, n, 8);
  }
  static endSchema(t) {
    return t.endObject();
  }
  static finishSchemaBuffer(t, n) {
    t.finish(n);
  }
  static finishSizePrefixedSchemaBuffer(t, n) {
    t.finish(n, void 0, !0);
  }
  static createSchema(t, n, i, r, s) {
    return Er.startSchema(t), Er.addEndianness(t, n), Er.addFields(t, i), Er.addCustomMetadata(t, r), Er.addFeatures(t, s), Er.endSchema(t);
  }
};
var te;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.Schema = 1] = "Schema", e[e.DictionaryBatch = 2] = "DictionaryBatch", e[e.RecordBatch = 3] = "RecordBatch", e[e.Tensor = 4] = "Tensor", e[e.SparseTensor = 5] = "SparseTensor";
})(te || (te = {}));
var E;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.Null = 1] = "Null", e[e.Int = 2] = "Int", e[e.Float = 3] = "Float", e[e.Binary = 4] = "Binary", e[e.Utf8 = 5] = "Utf8", e[e.Bool = 6] = "Bool", e[e.Decimal = 7] = "Decimal", e[e.Date = 8] = "Date", e[e.Time = 9] = "Time", e[e.Timestamp = 10] = "Timestamp", e[e.Interval = 11] = "Interval", e[e.List = 12] = "List", e[e.Struct = 13] = "Struct", e[e.Union = 14] = "Union", e[e.FixedSizeBinary = 15] = "FixedSizeBinary", e[e.FixedSizeList = 16] = "FixedSizeList", e[e.Map = 17] = "Map", e[e.Duration = 18] = "Duration", e[e.LargeBinary = 19] = "LargeBinary", e[e.LargeUtf8 = 20] = "LargeUtf8", e[e.Dictionary = -1] = "Dictionary", e[e.Int8 = -2] = "Int8", e[e.Int16 = -3] = "Int16", e[e.Int32 = -4] = "Int32", e[e.Int64 = -5] = "Int64", e[e.Uint8 = -6] = "Uint8", e[e.Uint16 = -7] = "Uint16", e[e.Uint32 = -8] = "Uint32", e[e.Uint64 = -9] = "Uint64", e[e.Float16 = -10] = "Float16", e[e.Float32 = -11] = "Float32", e[e.Float64 = -12] = "Float64", e[e.DateDay = -13] = "DateDay", e[e.DateMillisecond = -14] = "DateMillisecond", e[e.TimestampSecond = -15] = "TimestampSecond", e[e.TimestampMillisecond = -16] = "TimestampMillisecond", e[e.TimestampMicrosecond = -17] = "TimestampMicrosecond", e[e.TimestampNanosecond = -18] = "TimestampNanosecond", e[e.TimeSecond = -19] = "TimeSecond", e[e.TimeMillisecond = -20] = "TimeMillisecond", e[e.TimeMicrosecond = -21] = "TimeMicrosecond", e[e.TimeNanosecond = -22] = "TimeNanosecond", e[e.DenseUnion = -23] = "DenseUnion", e[e.SparseUnion = -24] = "SparseUnion", e[e.IntervalDayTime = -25] = "IntervalDayTime", e[e.IntervalYearMonth = -26] = "IntervalYearMonth", e[e.DurationSecond = -27] = "DurationSecond", e[e.DurationMillisecond = -28] = "DurationMillisecond", e[e.DurationMicrosecond = -29] = "DurationMicrosecond", e[e.DurationNanosecond = -30] = "DurationNanosecond";
})(E || (E = {}));
var Ur;
(function(e) {
  e[e.OFFSET = 0] = "OFFSET", e[e.DATA = 1] = "DATA", e[e.VALIDITY = 2] = "VALIDITY", e[e.TYPE = 3] = "TYPE";
})(Ur || (Ur = {}));
const Oot = void 0;
function tf(e) {
  if (e === null)
    return "null";
  if (e === Oot)
    return "undefined";
  switch (typeof e) {
    case "number":
      return `${e}`;
    case "bigint":
      return `${e}`;
    case "string":
      return `"${e}"`;
  }
  return typeof e[Symbol.toPrimitive] == "function" ? e[Symbol.toPrimitive]("string") : ArrayBuffer.isView(e) ? e instanceof BigInt64Array || e instanceof BigUint64Array ? `[${[...e].map((t) => tf(t))}]` : `[${e}]` : ArrayBuffer.isView(e) ? `[${e}]` : JSON.stringify(e, (t, n) => typeof n == "bigint" ? `${n}` : n);
}
const Fot = Symbol.for("isArrowBigNum");
function Ui(e, ...t) {
  return t.length === 0 ? Object.setPrototypeOf(se(this.TypedArray, e), this.constructor.prototype) : Object.setPrototypeOf(new this.TypedArray(e, ...t), this.constructor.prototype);
}
Ui.prototype[Fot] = !0;
Ui.prototype.toJSON = function() {
  return `"${nf(this)}"`;
};
Ui.prototype.valueOf = function() {
  return BL(this);
};
Ui.prototype.toString = function() {
  return nf(this);
};
Ui.prototype[Symbol.toPrimitive] = function(e = "default") {
  switch (e) {
    case "number":
      return BL(this);
    case "string":
      return nf(this);
    case "default":
      return Eot(this);
  }
  return nf(this);
};
function wc(...e) {
  return Ui.apply(this, e);
}
function vc(...e) {
  return Ui.apply(this, e);
}
function ef(...e) {
  return Ui.apply(this, e);
}
Object.setPrototypeOf(wc.prototype, Object.create(Int32Array.prototype));
Object.setPrototypeOf(vc.prototype, Object.create(Uint32Array.prototype));
Object.setPrototypeOf(ef.prototype, Object.create(Uint32Array.prototype));
Object.assign(wc.prototype, Ui.prototype, { constructor: wc, signed: !0, TypedArray: Int32Array, BigIntArray: BigInt64Array });
Object.assign(vc.prototype, Ui.prototype, { constructor: vc, signed: !1, TypedArray: Uint32Array, BigIntArray: BigUint64Array });
Object.assign(ef.prototype, Ui.prototype, { constructor: ef, signed: !0, TypedArray: Uint32Array, BigIntArray: BigUint64Array });
function BL(e) {
  const { buffer: t, byteOffset: n, length: i, signed: r } = e, s = new BigUint64Array(t, n, i), o = r && s.at(-1) & BigInt(1) << BigInt(63);
  let a = BigInt(o ? 1 : 0), c = BigInt(0);
  if (o) {
    for (const l of s)
      a += ~l * (BigInt(1) << BigInt(32) * c++);
    a *= BigInt(-1);
  } else
    for (const l of s)
      a += l * (BigInt(1) << BigInt(32) * c++);
  return a;
}
const nf = (e) => {
  if (e.byteLength === 8)
    return `${new e.BigIntArray(e.buffer, e.byteOffset, 1)[0]}`;
  if (!e.signed)
    return ug(e);
  let t = new Uint16Array(e.buffer, e.byteOffset, e.byteLength / 2);
  if (new Int16Array([t.at(-1)])[0] >= 0)
    return ug(e);
  t = t.slice();
  let i = 1;
  for (let s = 0; s < t.length; s++) {
    const o = t[s], a = ~o + i;
    t[s] = a, i &= o === 0 ? 1 : 0;
  }
  return `-${ug(t)}`;
}, Eot = (e) => e.byteLength === 8 ? new e.BigIntArray(e.buffer, e.byteOffset, 1)[0] : nf(e);
function ug(e) {
  let t = "";
  const n = new Uint32Array(2);
  let i = new Uint16Array(e.buffer, e.byteOffset, e.byteLength / 2);
  const r = new Uint32Array((i = new Uint16Array(i).reverse()).buffer);
  let s = -1;
  const o = i.length - 1;
  do {
    for (n[0] = i[s = 0]; s < o; )
      i[s++] = n[1] = n[0] / 10, n[0] = (n[0] - n[1] * 10 << 16) + i[s];
    i[s] = n[1] = n[0] / 10, n[0] = n[0] - n[1] * 10, t = `${n[0]}${t}`;
  } while (r[0] || r[1] || r[2] || r[3]);
  return t ?? "0";
}
class s_ {
  /** @nocollapse */
  static new(t, n) {
    switch (n) {
      case !0:
        return new wc(t);
      case !1:
        return new vc(t);
    }
    switch (t.constructor) {
      case Int8Array:
      case Int16Array:
      case Int32Array:
      case BigInt64Array:
        return new wc(t);
    }
    return t.byteLength === 16 ? new ef(t) : new vc(t);
  }
  /** @nocollapse */
  static signed(t) {
    return new wc(t);
  }
  /** @nocollapse */
  static unsigned(t) {
    return new vc(t);
  }
  /** @nocollapse */
  static decimal(t) {
    return new ef(t);
  }
  constructor(t, n) {
    return s_.new(t, n);
  }
}
function bn(e) {
  if (typeof e == "bigint" && (e < Number.MIN_SAFE_INTEGER || e > Number.MAX_SAFE_INTEGER))
    throw new TypeError(`${e} is not safe to convert to a number.`);
  return Number(e);
}
var OL, FL, EL, LL, RL, CL, kL, UL, zL, PL, VL, jL, qL, YL, WL, GL, XL, HL, JL, KL, ZL, QL;
class ot {
  /** @nocollapse */
  static isNull(t) {
    return (t == null ? void 0 : t.typeId) === E.Null;
  }
  /** @nocollapse */
  static isInt(t) {
    return (t == null ? void 0 : t.typeId) === E.Int;
  }
  /** @nocollapse */
  static isFloat(t) {
    return (t == null ? void 0 : t.typeId) === E.Float;
  }
  /** @nocollapse */
  static isBinary(t) {
    return (t == null ? void 0 : t.typeId) === E.Binary;
  }
  /** @nocollapse */
  static isLargeBinary(t) {
    return (t == null ? void 0 : t.typeId) === E.LargeBinary;
  }
  /** @nocollapse */
  static isUtf8(t) {
    return (t == null ? void 0 : t.typeId) === E.Utf8;
  }
  /** @nocollapse */
  static isLargeUtf8(t) {
    return (t == null ? void 0 : t.typeId) === E.LargeUtf8;
  }
  /** @nocollapse */
  static isBool(t) {
    return (t == null ? void 0 : t.typeId) === E.Bool;
  }
  /** @nocollapse */
  static isDecimal(t) {
    return (t == null ? void 0 : t.typeId) === E.Decimal;
  }
  /** @nocollapse */
  static isDate(t) {
    return (t == null ? void 0 : t.typeId) === E.Date;
  }
  /** @nocollapse */
  static isTime(t) {
    return (t == null ? void 0 : t.typeId) === E.Time;
  }
  /** @nocollapse */
  static isTimestamp(t) {
    return (t == null ? void 0 : t.typeId) === E.Timestamp;
  }
  /** @nocollapse */
  static isInterval(t) {
    return (t == null ? void 0 : t.typeId) === E.Interval;
  }
  /** @nocollapse */
  static isDuration(t) {
    return (t == null ? void 0 : t.typeId) === E.Duration;
  }
  /** @nocollapse */
  static isList(t) {
    return (t == null ? void 0 : t.typeId) === E.List;
  }
  /** @nocollapse */
  static isStruct(t) {
    return (t == null ? void 0 : t.typeId) === E.Struct;
  }
  /** @nocollapse */
  static isUnion(t) {
    return (t == null ? void 0 : t.typeId) === E.Union;
  }
  /** @nocollapse */
  static isFixedSizeBinary(t) {
    return (t == null ? void 0 : t.typeId) === E.FixedSizeBinary;
  }
  /** @nocollapse */
  static isFixedSizeList(t) {
    return (t == null ? void 0 : t.typeId) === E.FixedSizeList;
  }
  /** @nocollapse */
  static isMap(t) {
    return (t == null ? void 0 : t.typeId) === E.Map;
  }
  /** @nocollapse */
  static isDictionary(t) {
    return (t == null ? void 0 : t.typeId) === E.Dictionary;
  }
  /** @nocollapse */
  static isDenseUnion(t) {
    return ot.isUnion(t) && t.mode === On.Dense;
  }
  /** @nocollapse */
  static isSparseUnion(t) {
    return ot.isUnion(t) && t.mode === On.Sparse;
  }
  constructor(t) {
    this.typeId = t;
  }
}
OL = Symbol.toStringTag;
ot[OL] = ((e) => (e.children = null, e.ArrayType = Array, e.OffsetArrayType = Int32Array, e[Symbol.toStringTag] = "DataType"))(ot.prototype);
class to extends ot {
  constructor() {
    super(E.Null);
  }
  toString() {
    return "Null";
  }
}
FL = Symbol.toStringTag;
to[FL] = ((e) => e[Symbol.toStringTag] = "Null")(to.prototype);
class eo extends ot {
  constructor(t, n) {
    super(E.Int), this.isSigned = t, this.bitWidth = n;
  }
  get ArrayType() {
    switch (this.bitWidth) {
      case 8:
        return this.isSigned ? Int8Array : Uint8Array;
      case 16:
        return this.isSigned ? Int16Array : Uint16Array;
      case 32:
        return this.isSigned ? Int32Array : Uint32Array;
      case 64:
        return this.isSigned ? BigInt64Array : BigUint64Array;
    }
    throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
  }
  toString() {
    return `${this.isSigned ? "I" : "Ui"}nt${this.bitWidth}`;
  }
}
EL = Symbol.toStringTag;
eo[EL] = ((e) => (e.isSigned = null, e.bitWidth = null, e[Symbol.toStringTag] = "Int"))(eo.prototype);
class rf extends eo {
  constructor() {
    super(!0, 32);
  }
  get ArrayType() {
    return Int32Array;
  }
}
Object.defineProperty(rf.prototype, "ArrayType", { value: Int32Array });
class sf extends ot {
  constructor(t) {
    super(E.Float), this.precision = t;
  }
  get ArrayType() {
    switch (this.precision) {
      case rn.HALF:
        return Uint16Array;
      case rn.SINGLE:
        return Float32Array;
      case rn.DOUBLE:
        return Float64Array;
    }
    throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
  }
  toString() {
    return `Float${this.precision << 5 || 16}`;
  }
}
LL = Symbol.toStringTag;
sf[LL] = ((e) => (e.precision = null, e[Symbol.toStringTag] = "Float"))(sf.prototype);
class uy extends ot {
  constructor() {
    super(E.Binary);
  }
  toString() {
    return "Binary";
  }
}
RL = Symbol.toStringTag;
uy[RL] = ((e) => (e.ArrayType = Uint8Array, e[Symbol.toStringTag] = "Binary"))(uy.prototype);
class fy extends ot {
  constructor() {
    super(E.LargeBinary);
  }
  toString() {
    return "LargeBinary";
  }
}
CL = Symbol.toStringTag;
fy[CL] = ((e) => (e.ArrayType = Uint8Array, e.OffsetArrayType = BigInt64Array, e[Symbol.toStringTag] = "LargeBinary"))(fy.prototype);
class hy extends ot {
  constructor() {
    super(E.Utf8);
  }
  toString() {
    return "Utf8";
  }
}
kL = Symbol.toStringTag;
hy[kL] = ((e) => (e.ArrayType = Uint8Array, e[Symbol.toStringTag] = "Utf8"))(hy.prototype);
class dy extends ot {
  constructor() {
    super(E.LargeUtf8);
  }
  toString() {
    return "LargeUtf8";
  }
}
UL = Symbol.toStringTag;
dy[UL] = ((e) => (e.ArrayType = Uint8Array, e.OffsetArrayType = BigInt64Array, e[Symbol.toStringTag] = "LargeUtf8"))(dy.prototype);
class py extends ot {
  constructor() {
    super(E.Bool);
  }
  toString() {
    return "Bool";
  }
}
zL = Symbol.toStringTag;
py[zL] = ((e) => (e.ArrayType = Uint8Array, e[Symbol.toStringTag] = "Bool"))(py.prototype);
class yy extends ot {
  constructor(t, n, i = 128) {
    super(E.Decimal), this.scale = t, this.precision = n, this.bitWidth = i;
  }
  toString() {
    return `Decimal[${this.precision}e${this.scale > 0 ? "+" : ""}${this.scale}]`;
  }
}
PL = Symbol.toStringTag;
yy[PL] = ((e) => (e.scale = null, e.precision = null, e.ArrayType = Uint32Array, e[Symbol.toStringTag] = "Decimal"))(yy.prototype);
class my extends ot {
  constructor(t) {
    super(E.Date), this.unit = t;
  }
  toString() {
    return `Date${(this.unit + 1) * 32}<${Fi[this.unit]}>`;
  }
}
VL = Symbol.toStringTag;
my[VL] = ((e) => (e.unit = null, e.ArrayType = Int32Array, e[Symbol.toStringTag] = "Date"))(my.prototype);
class of extends ot {
  constructor(t, n) {
    super(E.Time), this.unit = t, this.bitWidth = n;
  }
  toString() {
    return `Time${this.bitWidth}<${bt[this.unit]}>`;
  }
  get ArrayType() {
    switch (this.bitWidth) {
      case 32:
        return Int32Array;
      case 64:
        return BigInt64Array;
    }
    throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
  }
}
jL = Symbol.toStringTag;
of[jL] = ((e) => (e.unit = null, e.bitWidth = null, e[Symbol.toStringTag] = "Time"))(of.prototype);
class gy extends ot {
  constructor(t, n) {
    super(E.Timestamp), this.unit = t, this.timezone = n;
  }
  toString() {
    return `Timestamp<${bt[this.unit]}${this.timezone ? `, ${this.timezone}` : ""}>`;
  }
}
qL = Symbol.toStringTag;
gy[qL] = ((e) => (e.unit = null, e.timezone = null, e.ArrayType = Int32Array, e[Symbol.toStringTag] = "Timestamp"))(gy.prototype);
class by extends ot {
  constructor(t) {
    super(E.Interval), this.unit = t;
  }
  toString() {
    return `Interval<${mr[this.unit]}>`;
  }
}
YL = Symbol.toStringTag;
by[YL] = ((e) => (e.unit = null, e.ArrayType = Int32Array, e[Symbol.toStringTag] = "Interval"))(by.prototype);
class wy extends ot {
  constructor(t) {
    super(E.Duration), this.unit = t;
  }
  toString() {
    return `Duration<${bt[this.unit]}>`;
  }
}
WL = Symbol.toStringTag;
wy[WL] = ((e) => (e.unit = null, e.ArrayType = BigInt64Array, e[Symbol.toStringTag] = "Duration"))(wy.prototype);
class vy extends ot {
  constructor(t) {
    super(E.List), this.children = [t];
  }
  toString() {
    return `List<${this.valueType}>`;
  }
  get valueType() {
    return this.children[0].type;
  }
  get valueField() {
    return this.children[0];
  }
  get ArrayType() {
    return this.valueType.ArrayType;
  }
}
GL = Symbol.toStringTag;
vy[GL] = ((e) => (e.children = null, e[Symbol.toStringTag] = "List"))(vy.prototype);
class hn extends ot {
  constructor(t) {
    super(E.Struct), this.children = t;
  }
  toString() {
    return `Struct<{${this.children.map((t) => `${t.name}:${t.type}`).join(", ")}}>`;
  }
}
XL = Symbol.toStringTag;
hn[XL] = ((e) => (e.children = null, e[Symbol.toStringTag] = "Struct"))(hn.prototype);
class _y extends ot {
  constructor(t, n, i) {
    super(E.Union), this.mode = t, this.children = i, this.typeIds = n = Int32Array.from(n), this.typeIdToChildIndex = n.reduce((r, s, o) => (r[s] = o) && r || r, /* @__PURE__ */ Object.create(null));
  }
  toString() {
    return `${this[Symbol.toStringTag]}<${this.children.map((t) => `${t.type}`).join(" | ")}>`;
  }
}
HL = Symbol.toStringTag;
_y[HL] = ((e) => (e.mode = null, e.typeIds = null, e.children = null, e.typeIdToChildIndex = null, e.ArrayType = Int8Array, e[Symbol.toStringTag] = "Union"))(_y.prototype);
class Sy extends ot {
  constructor(t) {
    super(E.FixedSizeBinary), this.byteWidth = t;
  }
  toString() {
    return `FixedSizeBinary[${this.byteWidth}]`;
  }
}
JL = Symbol.toStringTag;
Sy[JL] = ((e) => (e.byteWidth = null, e.ArrayType = Uint8Array, e[Symbol.toStringTag] = "FixedSizeBinary"))(Sy.prototype);
class xy extends ot {
  constructor(t, n) {
    super(E.FixedSizeList), this.listSize = t, this.children = [n];
  }
  get valueType() {
    return this.children[0].type;
  }
  get valueField() {
    return this.children[0];
  }
  get ArrayType() {
    return this.valueType.ArrayType;
  }
  toString() {
    return `FixedSizeList[${this.listSize}]<${this.valueType}>`;
  }
}
KL = Symbol.toStringTag;
xy[KL] = ((e) => (e.children = null, e.listSize = null, e[Symbol.toStringTag] = "FixedSizeList"))(xy.prototype);
class Iy extends ot {
  constructor(t, n = !1) {
    var i, r, s;
    if (super(E.Map), this.children = [t], this.keysSorted = n, t && (t.name = "entries", !((i = t == null ? void 0 : t.type) === null || i === void 0) && i.children)) {
      const o = (r = t == null ? void 0 : t.type) === null || r === void 0 ? void 0 : r.children[0];
      o && (o.name = "key");
      const a = (s = t == null ? void 0 : t.type) === null || s === void 0 ? void 0 : s.children[1];
      a && (a.name = "value");
    }
  }
  get keyType() {
    return this.children[0].type.children[0].type;
  }
  get valueType() {
    return this.children[0].type.children[1].type;
  }
  get childType() {
    return this.children[0].type;
  }
  toString() {
    return `Map<{${this.children[0].type.children.map((t) => `${t.name}:${t.type}`).join(", ")}}>`;
  }
}
ZL = Symbol.toStringTag;
Iy[ZL] = ((e) => (e.children = null, e.keysSorted = null, e[Symbol.toStringTag] = "Map_"))(Iy.prototype);
const Lot = /* @__PURE__ */ ((e) => () => ++e)(-1);
class Xc extends ot {
  constructor(t, n, i, r) {
    super(E.Dictionary), this.indices = n, this.dictionary = t, this.isOrdered = r || !1, this.id = i == null ? Lot() : bn(i);
  }
  get children() {
    return this.dictionary.children;
  }
  get valueType() {
    return this.dictionary;
  }
  get ArrayType() {
    return this.dictionary.ArrayType;
  }
  toString() {
    return `Dictionary<${this.indices}, ${this.dictionary}>`;
  }
}
QL = Symbol.toStringTag;
Xc[QL] = ((e) => (e.id = null, e.indices = null, e.isOrdered = null, e.dictionary = null, e[Symbol.toStringTag] = "Dictionary"))(Xc.prototype);
function zr(e) {
  const t = e;
  switch (e.typeId) {
    case E.Decimal:
      return e.bitWidth / 32;
    case E.Timestamp:
      return 2;
    case E.Date:
      return 1 + t.unit;
    case E.Interval:
      return 1 + t.unit;
    case E.FixedSizeList:
      return t.listSize;
    case E.FixedSizeBinary:
      return t.byteWidth;
    default:
      return 1;
  }
}
class zt {
  visitMany(t, ...n) {
    return t.map((i, r) => this.visit(i, ...n.map((s) => s[r])));
  }
  visit(...t) {
    return this.getVisitFn(t[0], !1).apply(this, t);
  }
  getVisitFn(t, n = !0) {
    return Rot(this, t, n);
  }
  getVisitFnByTypeId(t, n = !0) {
    return Ha(this, t, n);
  }
  visitNull(t, ...n) {
    return null;
  }
  visitBool(t, ...n) {
    return null;
  }
  visitInt(t, ...n) {
    return null;
  }
  visitFloat(t, ...n) {
    return null;
  }
  visitUtf8(t, ...n) {
    return null;
  }
  visitLargeUtf8(t, ...n) {
    return null;
  }
  visitBinary(t, ...n) {
    return null;
  }
  visitLargeBinary(t, ...n) {
    return null;
  }
  visitFixedSizeBinary(t, ...n) {
    return null;
  }
  visitDate(t, ...n) {
    return null;
  }
  visitTimestamp(t, ...n) {
    return null;
  }
  visitTime(t, ...n) {
    return null;
  }
  visitDecimal(t, ...n) {
    return null;
  }
  visitList(t, ...n) {
    return null;
  }
  visitStruct(t, ...n) {
    return null;
  }
  visitUnion(t, ...n) {
    return null;
  }
  visitDictionary(t, ...n) {
    return null;
  }
  visitInterval(t, ...n) {
    return null;
  }
  visitDuration(t, ...n) {
    return null;
  }
  visitFixedSizeList(t, ...n) {
    return null;
  }
  visitMap(t, ...n) {
    return null;
  }
}
function Rot(e, t, n = !0) {
  return typeof t == "number" ? Ha(e, t, n) : typeof t == "string" && t in E ? Ha(e, E[t], n) : t && t instanceof ot ? Ha(e, yI(t), n) : t != null && t.type && t.type instanceof ot ? Ha(e, yI(t.type), n) : Ha(e, E.NONE, n);
}
function Ha(e, t, n = !0) {
  let i = null;
  switch (t) {
    case E.Null:
      i = e.visitNull;
      break;
    case E.Bool:
      i = e.visitBool;
      break;
    case E.Int:
      i = e.visitInt;
      break;
    case E.Int8:
      i = e.visitInt8 || e.visitInt;
      break;
    case E.Int16:
      i = e.visitInt16 || e.visitInt;
      break;
    case E.Int32:
      i = e.visitInt32 || e.visitInt;
      break;
    case E.Int64:
      i = e.visitInt64 || e.visitInt;
      break;
    case E.Uint8:
      i = e.visitUint8 || e.visitInt;
      break;
    case E.Uint16:
      i = e.visitUint16 || e.visitInt;
      break;
    case E.Uint32:
      i = e.visitUint32 || e.visitInt;
      break;
    case E.Uint64:
      i = e.visitUint64 || e.visitInt;
      break;
    case E.Float:
      i = e.visitFloat;
      break;
    case E.Float16:
      i = e.visitFloat16 || e.visitFloat;
      break;
    case E.Float32:
      i = e.visitFloat32 || e.visitFloat;
      break;
    case E.Float64:
      i = e.visitFloat64 || e.visitFloat;
      break;
    case E.Utf8:
      i = e.visitUtf8;
      break;
    case E.LargeUtf8:
      i = e.visitLargeUtf8;
      break;
    case E.Binary:
      i = e.visitBinary;
      break;
    case E.LargeBinary:
      i = e.visitLargeBinary;
      break;
    case E.FixedSizeBinary:
      i = e.visitFixedSizeBinary;
      break;
    case E.Date:
      i = e.visitDate;
      break;
    case E.DateDay:
      i = e.visitDateDay || e.visitDate;
      break;
    case E.DateMillisecond:
      i = e.visitDateMillisecond || e.visitDate;
      break;
    case E.Timestamp:
      i = e.visitTimestamp;
      break;
    case E.TimestampSecond:
      i = e.visitTimestampSecond || e.visitTimestamp;
      break;
    case E.TimestampMillisecond:
      i = e.visitTimestampMillisecond || e.visitTimestamp;
      break;
    case E.TimestampMicrosecond:
      i = e.visitTimestampMicrosecond || e.visitTimestamp;
      break;
    case E.TimestampNanosecond:
      i = e.visitTimestampNanosecond || e.visitTimestamp;
      break;
    case E.Time:
      i = e.visitTime;
      break;
    case E.TimeSecond:
      i = e.visitTimeSecond || e.visitTime;
      break;
    case E.TimeMillisecond:
      i = e.visitTimeMillisecond || e.visitTime;
      break;
    case E.TimeMicrosecond:
      i = e.visitTimeMicrosecond || e.visitTime;
      break;
    case E.TimeNanosecond:
      i = e.visitTimeNanosecond || e.visitTime;
      break;
    case E.Decimal:
      i = e.visitDecimal;
      break;
    case E.List:
      i = e.visitList;
      break;
    case E.Struct:
      i = e.visitStruct;
      break;
    case E.Union:
      i = e.visitUnion;
      break;
    case E.DenseUnion:
      i = e.visitDenseUnion || e.visitUnion;
      break;
    case E.SparseUnion:
      i = e.visitSparseUnion || e.visitUnion;
      break;
    case E.Dictionary:
      i = e.visitDictionary;
      break;
    case E.Interval:
      i = e.visitInterval;
      break;
    case E.IntervalDayTime:
      i = e.visitIntervalDayTime || e.visitInterval;
      break;
    case E.IntervalYearMonth:
      i = e.visitIntervalYearMonth || e.visitInterval;
      break;
    case E.Duration:
      i = e.visitDuration;
      break;
    case E.DurationSecond:
      i = e.visitDurationSecond || e.visitDuration;
      break;
    case E.DurationMillisecond:
      i = e.visitDurationMillisecond || e.visitDuration;
      break;
    case E.DurationMicrosecond:
      i = e.visitDurationMicrosecond || e.visitDuration;
      break;
    case E.DurationNanosecond:
      i = e.visitDurationNanosecond || e.visitDuration;
      break;
    case E.FixedSizeList:
      i = e.visitFixedSizeList;
      break;
    case E.Map:
      i = e.visitMap;
      break;
  }
  if (typeof i == "function")
    return i;
  if (!n)
    return () => null;
  throw new Error(`Unrecognized type '${E[t]}'`);
}
function yI(e) {
  switch (e.typeId) {
    case E.Null:
      return E.Null;
    case E.Int: {
      const { bitWidth: t, isSigned: n } = e;
      switch (t) {
        case 8:
          return n ? E.Int8 : E.Uint8;
        case 16:
          return n ? E.Int16 : E.Uint16;
        case 32:
          return n ? E.Int32 : E.Uint32;
        case 64:
          return n ? E.Int64 : E.Uint64;
      }
      return E.Int;
    }
    case E.Float:
      switch (e.precision) {
        case rn.HALF:
          return E.Float16;
        case rn.SINGLE:
          return E.Float32;
        case rn.DOUBLE:
          return E.Float64;
      }
      return E.Float;
    case E.Binary:
      return E.Binary;
    case E.LargeBinary:
      return E.LargeBinary;
    case E.Utf8:
      return E.Utf8;
    case E.LargeUtf8:
      return E.LargeUtf8;
    case E.Bool:
      return E.Bool;
    case E.Decimal:
      return E.Decimal;
    case E.Time:
      switch (e.unit) {
        case bt.SECOND:
          return E.TimeSecond;
        case bt.MILLISECOND:
          return E.TimeMillisecond;
        case bt.MICROSECOND:
          return E.TimeMicrosecond;
        case bt.NANOSECOND:
          return E.TimeNanosecond;
      }
      return E.Time;
    case E.Timestamp:
      switch (e.unit) {
        case bt.SECOND:
          return E.TimestampSecond;
        case bt.MILLISECOND:
          return E.TimestampMillisecond;
        case bt.MICROSECOND:
          return E.TimestampMicrosecond;
        case bt.NANOSECOND:
          return E.TimestampNanosecond;
      }
      return E.Timestamp;
    case E.Date:
      switch (e.unit) {
        case Fi.DAY:
          return E.DateDay;
        case Fi.MILLISECOND:
          return E.DateMillisecond;
      }
      return E.Date;
    case E.Interval:
      switch (e.unit) {
        case mr.DAY_TIME:
          return E.IntervalDayTime;
        case mr.YEAR_MONTH:
          return E.IntervalYearMonth;
      }
      return E.Interval;
    case E.Duration:
      switch (e.unit) {
        case bt.SECOND:
          return E.DurationSecond;
        case bt.MILLISECOND:
          return E.DurationMillisecond;
        case bt.MICROSECOND:
          return E.DurationMicrosecond;
        case bt.NANOSECOND:
          return E.DurationNanosecond;
      }
      return E.Duration;
    case E.Map:
      return E.Map;
    case E.List:
      return E.List;
    case E.Struct:
      return E.Struct;
    case E.Union:
      switch (e.mode) {
        case On.Dense:
          return E.DenseUnion;
        case On.Sparse:
          return E.SparseUnion;
      }
      return E.Union;
    case E.FixedSizeBinary:
      return E.FixedSizeBinary;
    case E.FixedSizeList:
      return E.FixedSizeList;
    case E.Dictionary:
      return E.Dictionary;
  }
  throw new Error(`Unrecognized type '${E[e.typeId]}'`);
}
zt.prototype.visitInt8 = null;
zt.prototype.visitInt16 = null;
zt.prototype.visitInt32 = null;
zt.prototype.visitInt64 = null;
zt.prototype.visitUint8 = null;
zt.prototype.visitUint16 = null;
zt.prototype.visitUint32 = null;
zt.prototype.visitUint64 = null;
zt.prototype.visitFloat16 = null;
zt.prototype.visitFloat32 = null;
zt.prototype.visitFloat64 = null;
zt.prototype.visitDateDay = null;
zt.prototype.visitDateMillisecond = null;
zt.prototype.visitTimestampSecond = null;
zt.prototype.visitTimestampMillisecond = null;
zt.prototype.visitTimestampMicrosecond = null;
zt.prototype.visitTimestampNanosecond = null;
zt.prototype.visitTimeSecond = null;
zt.prototype.visitTimeMillisecond = null;
zt.prototype.visitTimeMicrosecond = null;
zt.prototype.visitTimeNanosecond = null;
zt.prototype.visitDenseUnion = null;
zt.prototype.visitSparseUnion = null;
zt.prototype.visitIntervalDayTime = null;
zt.prototype.visitIntervalYearMonth = null;
zt.prototype.visitDuration = null;
zt.prototype.visitDurationSecond = null;
zt.prototype.visitDurationMillisecond = null;
zt.prototype.visitDurationMicrosecond = null;
zt.prototype.visitDurationNanosecond = null;
const tR = new Float64Array(1), Ta = new Uint32Array(tR.buffer);
function eR(e) {
  const t = (e & 31744) >> 10, n = (e & 1023) / 1024, i = Math.pow(-1, (e & 32768) >> 15);
  switch (t) {
    case 31:
      return i * (n ? Number.NaN : 1 / 0);
    case 0:
      return i * (n ? 6103515625e-14 * n : 0);
  }
  return i * Math.pow(2, t - 15) * (1 + n);
}
function Cot(e) {
  if (e !== e)
    return 32256;
  tR[0] = e;
  const t = (Ta[1] & 2147483648) >> 16 & 65535;
  let n = Ta[1] & 2146435072, i = 0;
  return n >= 1089470464 ? Ta[0] > 0 ? n = 31744 : (n = (n & 2080374784) >> 16, i = (Ta[1] & 1048575) >> 10) : n <= 1056964608 ? (i = 1048576 + (Ta[1] & 1048575), i = 1048576 + (i << (n >> 20) - 998) >> 21, n = 0) : (n = n - 1056964608 >> 10, i = (Ta[1] & 1048575) + 512 >> 10), t | n | i & 65535;
}
class It extends zt {
}
function Nt(e) {
  return (t, n, i) => {
    if (t.setValid(n, i != null))
      return e(t, n, i);
  };
}
const kot = (e, t, n) => {
  e[t] = Math.trunc(n / 864e5);
}, o_ = (e, t, n) => {
  e[t] = Math.trunc(n % 4294967296), e[t + 1] = Math.trunc(n / 4294967296);
}, Uot = (e, t, n) => {
  e[t] = Math.trunc(n * 1e3 % 4294967296), e[t + 1] = Math.trunc(n * 1e3 / 4294967296);
}, zot = (e, t, n) => {
  e[t] = Math.trunc(n * 1e6 % 4294967296), e[t + 1] = Math.trunc(n * 1e6 / 4294967296);
}, nR = (e, t, n, i) => {
  if (n + 1 < t.length) {
    const r = bn(t[n]), s = bn(t[n + 1]);
    e.set(i.subarray(0, s - r), r);
  }
}, Pot = ({ offset: e, values: t }, n, i) => {
  const r = e + n;
  i ? t[r >> 3] |= 1 << r % 8 : t[r >> 3] &= ~(1 << r % 8);
}, gs = ({ values: e }, t, n) => {
  e[t] = n;
}, a_ = ({ values: e }, t, n) => {
  e[t] = n;
}, iR = ({ values: e }, t, n) => {
  e[t] = Cot(n);
}, Vot = (e, t, n) => {
  switch (e.type.precision) {
    case rn.HALF:
      return iR(e, t, n);
    case rn.SINGLE:
    case rn.DOUBLE:
      return a_(e, t, n);
  }
}, rR = ({ values: e }, t, n) => {
  kot(e, t, n.valueOf());
}, sR = ({ values: e }, t, n) => {
  o_(e, t * 2, n.valueOf());
}, jot = ({ stride: e, values: t }, n, i) => {
  t.set(i.subarray(0, e), e * n);
}, oR = ({ values: e, valueOffsets: t }, n, i) => nR(e, t, n, i), aR = ({ values: e, valueOffsets: t }, n, i) => nR(e, t, n, e_(i)), qot = (e, t, n) => {
  e.type.unit === Fi.DAY ? rR(e, t, n) : sR(e, t, n);
}, cR = ({ values: e }, t, n) => o_(e, t * 2, n / 1e3), lR = ({ values: e }, t, n) => o_(e, t * 2, n), uR = ({ values: e }, t, n) => Uot(e, t * 2, n), fR = ({ values: e }, t, n) => zot(e, t * 2, n), Yot = (e, t, n) => {
  switch (e.type.unit) {
    case bt.SECOND:
      return cR(e, t, n);
    case bt.MILLISECOND:
      return lR(e, t, n);
    case bt.MICROSECOND:
      return uR(e, t, n);
    case bt.NANOSECOND:
      return fR(e, t, n);
  }
}, hR = ({ values: e }, t, n) => {
  e[t] = n;
}, dR = ({ values: e }, t, n) => {
  e[t] = n;
}, pR = ({ values: e }, t, n) => {
  e[t] = n;
}, yR = ({ values: e }, t, n) => {
  e[t] = n;
}, Wot = (e, t, n) => {
  switch (e.type.unit) {
    case bt.SECOND:
      return hR(e, t, n);
    case bt.MILLISECOND:
      return dR(e, t, n);
    case bt.MICROSECOND:
      return pR(e, t, n);
    case bt.NANOSECOND:
      return yR(e, t, n);
  }
}, Got = ({ values: e, stride: t }, n, i) => {
  e.set(i.subarray(0, t), t * n);
}, Xot = (e, t, n) => {
  const i = e.children[0], r = e.valueOffsets, s = hi.getVisitFn(i);
  if (Array.isArray(n))
    for (let o = -1, a = r[t], c = r[t + 1]; a < c; )
      s(i, a++, n[++o]);
  else
    for (let o = -1, a = r[t], c = r[t + 1]; a < c; )
      s(i, a++, n.get(++o));
}, Hot = (e, t, n) => {
  const i = e.children[0], { valueOffsets: r } = e, s = hi.getVisitFn(i);
  let { [t]: o, [t + 1]: a } = r;
  const c = n instanceof Map ? n.entries() : Object.entries(n);
  for (const l of c)
    if (s(i, o, l), ++o >= a)
      break;
}, Jot = (e, t) => (n, i, r, s) => i && n(i, e, t[s]), Kot = (e, t) => (n, i, r, s) => i && n(i, e, t.get(s)), Zot = (e, t) => (n, i, r, s) => i && n(i, e, t.get(r.name)), Qot = (e, t) => (n, i, r, s) => i && n(i, e, t[r.name]), tat = (e, t, n) => {
  const i = e.type.children.map((s) => hi.getVisitFn(s.type)), r = n instanceof Map ? Zot(t, n) : n instanceof ae ? Kot(t, n) : Array.isArray(n) ? Jot(t, n) : Qot(t, n);
  e.type.children.forEach((s, o) => r(i[o], e.children[o], s, o));
}, eat = (e, t, n) => {
  e.type.mode === On.Dense ? mR(e, t, n) : gR(e, t, n);
}, mR = (e, t, n) => {
  const i = e.type.typeIdToChildIndex[e.typeIds[t]], r = e.children[i];
  hi.visit(r, e.valueOffsets[t], n);
}, gR = (e, t, n) => {
  const i = e.type.typeIdToChildIndex[e.typeIds[t]], r = e.children[i];
  hi.visit(r, t, n);
}, nat = (e, t, n) => {
  var i;
  (i = e.dictionary) === null || i === void 0 || i.set(e.values[t], n);
}, iat = (e, t, n) => {
  e.type.unit === mr.DAY_TIME ? bR(e, t, n) : wR(e, t, n);
}, bR = ({ values: e }, t, n) => {
  e.set(n.subarray(0, 2), 2 * t);
}, wR = ({ values: e }, t, n) => {
  e[t] = n[0] * 12 + n[1] % 12;
}, vR = ({ values: e }, t, n) => {
  e[t] = n;
}, _R = ({ values: e }, t, n) => {
  e[t] = n;
}, SR = ({ values: e }, t, n) => {
  e[t] = n;
}, xR = ({ values: e }, t, n) => {
  e[t] = n;
}, rat = (e, t, n) => {
  switch (e.type.unit) {
    case bt.SECOND:
      return vR(e, t, n);
    case bt.MILLISECOND:
      return _R(e, t, n);
    case bt.MICROSECOND:
      return SR(e, t, n);
    case bt.NANOSECOND:
      return xR(e, t, n);
  }
}, sat = (e, t, n) => {
  const { stride: i } = e, r = e.children[0], s = hi.getVisitFn(r);
  if (Array.isArray(n))
    for (let o = -1, a = t * i; ++o < i; )
      s(r, a + o, n[o]);
  else
    for (let o = -1, a = t * i; ++o < i; )
      s(r, a + o, n.get(o));
};
It.prototype.visitBool = Nt(Pot);
It.prototype.visitInt = Nt(gs);
It.prototype.visitInt8 = Nt(gs);
It.prototype.visitInt16 = Nt(gs);
It.prototype.visitInt32 = Nt(gs);
It.prototype.visitInt64 = Nt(gs);
It.prototype.visitUint8 = Nt(gs);
It.prototype.visitUint16 = Nt(gs);
It.prototype.visitUint32 = Nt(gs);
It.prototype.visitUint64 = Nt(gs);
It.prototype.visitFloat = Nt(Vot);
It.prototype.visitFloat16 = Nt(iR);
It.prototype.visitFloat32 = Nt(a_);
It.prototype.visitFloat64 = Nt(a_);
It.prototype.visitUtf8 = Nt(aR);
It.prototype.visitLargeUtf8 = Nt(aR);
It.prototype.visitBinary = Nt(oR);
It.prototype.visitLargeBinary = Nt(oR);
It.prototype.visitFixedSizeBinary = Nt(jot);
It.prototype.visitDate = Nt(qot);
It.prototype.visitDateDay = Nt(rR);
It.prototype.visitDateMillisecond = Nt(sR);
It.prototype.visitTimestamp = Nt(Yot);
It.prototype.visitTimestampSecond = Nt(cR);
It.prototype.visitTimestampMillisecond = Nt(lR);
It.prototype.visitTimestampMicrosecond = Nt(uR);
It.prototype.visitTimestampNanosecond = Nt(fR);
It.prototype.visitTime = Nt(Wot);
It.prototype.visitTimeSecond = Nt(hR);
It.prototype.visitTimeMillisecond = Nt(dR);
It.prototype.visitTimeMicrosecond = Nt(pR);
It.prototype.visitTimeNanosecond = Nt(yR);
It.prototype.visitDecimal = Nt(Got);
It.prototype.visitList = Nt(Xot);
It.prototype.visitStruct = Nt(tat);
It.prototype.visitUnion = Nt(eat);
It.prototype.visitDenseUnion = Nt(mR);
It.prototype.visitSparseUnion = Nt(gR);
It.prototype.visitDictionary = Nt(nat);
It.prototype.visitInterval = Nt(iat);
It.prototype.visitIntervalDayTime = Nt(bR);
It.prototype.visitIntervalYearMonth = Nt(wR);
It.prototype.visitDuration = Nt(rat);
It.prototype.visitDurationSecond = Nt(vR);
It.prototype.visitDurationMillisecond = Nt(_R);
It.prototype.visitDurationMicrosecond = Nt(SR);
It.prototype.visitDurationNanosecond = Nt(xR);
It.prototype.visitFixedSizeList = Nt(sat);
It.prototype.visitMap = Nt(Hot);
const hi = new It(), gi = Symbol.for("parent"), _c = Symbol.for("rowIndex");
class c_ {
  constructor(t, n) {
    return this[gi] = t, this[_c] = n, new Proxy(this, new aat());
  }
  toArray() {
    return Object.values(this.toJSON());
  }
  toJSON() {
    const t = this[_c], n = this[gi], i = n.type.children, r = {};
    for (let s = -1, o = i.length; ++s < o; )
      r[i[s].name] = Fn.visit(n.children[s], t);
    return r;
  }
  toString() {
    return `{${[...this].map(([t, n]) => `${tf(t)}: ${tf(n)}`).join(", ")}}`;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.toString();
  }
  [Symbol.iterator]() {
    return new oat(this[gi], this[_c]);
  }
}
class oat {
  constructor(t, n) {
    this.childIndex = 0, this.children = t.children, this.rowIndex = n, this.childFields = t.type.children, this.numChildren = this.childFields.length;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const t = this.childIndex;
    return t < this.numChildren ? (this.childIndex = t + 1, {
      done: !1,
      value: [
        this.childFields[t].name,
        Fn.visit(this.children[t], this.rowIndex)
      ]
    }) : { done: !0, value: null };
  }
}
Object.defineProperties(c_.prototype, {
  [Symbol.toStringTag]: { enumerable: !1, configurable: !1, value: "Row" },
  [gi]: { writable: !0, enumerable: !1, configurable: !1, value: null },
  [_c]: { writable: !0, enumerable: !1, configurable: !1, value: -1 }
});
class aat {
  isExtensible() {
    return !1;
  }
  deleteProperty() {
    return !1;
  }
  preventExtensions() {
    return !0;
  }
  ownKeys(t) {
    return t[gi].type.children.map((n) => n.name);
  }
  has(t, n) {
    return t[gi].type.children.findIndex((i) => i.name === n) !== -1;
  }
  getOwnPropertyDescriptor(t, n) {
    if (t[gi].type.children.findIndex((i) => i.name === n) !== -1)
      return { writable: !0, enumerable: !0, configurable: !0 };
  }
  get(t, n) {
    if (Reflect.has(t, n))
      return t[n];
    const i = t[gi].type.children.findIndex((r) => r.name === n);
    if (i !== -1) {
      const r = Fn.visit(t[gi].children[i], t[_c]);
      return Reflect.set(t, n, r), r;
    }
  }
  set(t, n, i) {
    const r = t[gi].type.children.findIndex((s) => s.name === n);
    return r !== -1 ? (hi.visit(t[gi].children[r], t[_c], i), Reflect.set(t, n, i)) : Reflect.has(t, n) || typeof n == "symbol" ? Reflect.set(t, n, i) : !1;
  }
}
class ht extends zt {
}
function At(e) {
  return (t, n) => t.getValid(n) ? e(t, n) : null;
}
const cat = (e, t) => 864e5 * e[t], l_ = (e, t) => 4294967296 * e[t + 1] + (e[t] >>> 0), lat = (e, t) => 4294967296 * (e[t + 1] / 1e3) + (e[t] >>> 0) / 1e3, uat = (e, t) => 4294967296 * (e[t + 1] / 1e6) + (e[t] >>> 0) / 1e6, IR = (e) => new Date(e), fat = (e, t) => IR(cat(e, t)), hat = (e, t) => IR(l_(e, t)), dat = (e, t) => null, AR = (e, t, n) => {
  if (n + 1 >= t.length)
    return null;
  const i = bn(t[n]), r = bn(t[n + 1]);
  return e.subarray(i, r);
}, pat = ({ offset: e, values: t }, n) => {
  const i = e + n;
  return (t[i >> 3] & 1 << i % 8) !== 0;
}, MR = ({ values: e }, t) => fat(e, t), $R = ({ values: e }, t) => hat(e, t * 2), yo = ({ stride: e, values: t }, n) => t[e * n], yat = ({ stride: e, values: t }, n) => eR(t[e * n]), TR = ({ values: e }, t) => e[t], mat = ({ stride: e, values: t }, n) => t.subarray(e * n, e * (n + 1)), DR = ({ values: e, valueOffsets: t }, n) => AR(e, t, n), NR = ({ values: e, valueOffsets: t }, n) => {
  const i = AR(e, t, n);
  return i !== null ? nb(i) : null;
}, gat = ({ values: e }, t) => e[t], bat = ({ type: e, values: t }, n) => e.precision !== rn.HALF ? t[n] : eR(t[n]), wat = (e, t) => e.type.unit === Fi.DAY ? MR(e, t) : $R(e, t), BR = ({ values: e }, t) => 1e3 * l_(e, t * 2), OR = ({ values: e }, t) => l_(e, t * 2), FR = ({ values: e }, t) => lat(e, t * 2), ER = ({ values: e }, t) => uat(e, t * 2), vat = (e, t) => {
  switch (e.type.unit) {
    case bt.SECOND:
      return BR(e, t);
    case bt.MILLISECOND:
      return OR(e, t);
    case bt.MICROSECOND:
      return FR(e, t);
    case bt.NANOSECOND:
      return ER(e, t);
  }
}, LR = ({ values: e }, t) => e[t], RR = ({ values: e }, t) => e[t], CR = ({ values: e }, t) => e[t], kR = ({ values: e }, t) => e[t], _at = (e, t) => {
  switch (e.type.unit) {
    case bt.SECOND:
      return LR(e, t);
    case bt.MILLISECOND:
      return RR(e, t);
    case bt.MICROSECOND:
      return CR(e, t);
    case bt.NANOSECOND:
      return kR(e, t);
  }
}, Sat = ({ values: e, stride: t }, n) => s_.decimal(e.subarray(t * n, t * (n + 1))), xat = (e, t) => {
  const { valueOffsets: n, stride: i, children: r } = e, { [t * i]: s, [t * i + 1]: o } = n, c = r[0].slice(s, o - s);
  return new ae([c]);
}, Iat = (e, t) => {
  const { valueOffsets: n, children: i } = e, { [t]: r, [t + 1]: s } = n, o = i[0];
  return new u_(o.slice(r, s - r));
}, Aat = (e, t) => new c_(e, t), Mat = (e, t) => e.type.mode === On.Dense ? UR(e, t) : zR(e, t), UR = (e, t) => {
  const n = e.type.typeIdToChildIndex[e.typeIds[t]], i = e.children[n];
  return Fn.visit(i, e.valueOffsets[t]);
}, zR = (e, t) => {
  const n = e.type.typeIdToChildIndex[e.typeIds[t]], i = e.children[n];
  return Fn.visit(i, t);
}, $at = (e, t) => {
  var n;
  return (n = e.dictionary) === null || n === void 0 ? void 0 : n.get(e.values[t]);
}, Tat = (e, t) => e.type.unit === mr.DAY_TIME ? PR(e, t) : VR(e, t), PR = ({ values: e }, t) => e.subarray(2 * t, 2 * (t + 1)), VR = ({ values: e }, t) => {
  const n = e[t], i = new Int32Array(2);
  return i[0] = Math.trunc(n / 12), i[1] = Math.trunc(n % 12), i;
}, jR = ({ values: e }, t) => e[t], qR = ({ values: e }, t) => e[t], YR = ({ values: e }, t) => e[t], WR = ({ values: e }, t) => e[t], Dat = (e, t) => {
  switch (e.type.unit) {
    case bt.SECOND:
      return jR(e, t);
    case bt.MILLISECOND:
      return qR(e, t);
    case bt.MICROSECOND:
      return YR(e, t);
    case bt.NANOSECOND:
      return WR(e, t);
  }
}, Nat = (e, t) => {
  const { stride: n, children: i } = e, s = i[0].slice(t * n, n);
  return new ae([s]);
};
ht.prototype.visitNull = At(dat);
ht.prototype.visitBool = At(pat);
ht.prototype.visitInt = At(gat);
ht.prototype.visitInt8 = At(yo);
ht.prototype.visitInt16 = At(yo);
ht.prototype.visitInt32 = At(yo);
ht.prototype.visitInt64 = At(TR);
ht.prototype.visitUint8 = At(yo);
ht.prototype.visitUint16 = At(yo);
ht.prototype.visitUint32 = At(yo);
ht.prototype.visitUint64 = At(TR);
ht.prototype.visitFloat = At(bat);
ht.prototype.visitFloat16 = At(yat);
ht.prototype.visitFloat32 = At(yo);
ht.prototype.visitFloat64 = At(yo);
ht.prototype.visitUtf8 = At(NR);
ht.prototype.visitLargeUtf8 = At(NR);
ht.prototype.visitBinary = At(DR);
ht.prototype.visitLargeBinary = At(DR);
ht.prototype.visitFixedSizeBinary = At(mat);
ht.prototype.visitDate = At(wat);
ht.prototype.visitDateDay = At(MR);
ht.prototype.visitDateMillisecond = At($R);
ht.prototype.visitTimestamp = At(vat);
ht.prototype.visitTimestampSecond = At(BR);
ht.prototype.visitTimestampMillisecond = At(OR);
ht.prototype.visitTimestampMicrosecond = At(FR);
ht.prototype.visitTimestampNanosecond = At(ER);
ht.prototype.visitTime = At(_at);
ht.prototype.visitTimeSecond = At(LR);
ht.prototype.visitTimeMillisecond = At(RR);
ht.prototype.visitTimeMicrosecond = At(CR);
ht.prototype.visitTimeNanosecond = At(kR);
ht.prototype.visitDecimal = At(Sat);
ht.prototype.visitList = At(xat);
ht.prototype.visitStruct = At(Aat);
ht.prototype.visitUnion = At(Mat);
ht.prototype.visitDenseUnion = At(UR);
ht.prototype.visitSparseUnion = At(zR);
ht.prototype.visitDictionary = At($at);
ht.prototype.visitInterval = At(Tat);
ht.prototype.visitIntervalDayTime = At(PR);
ht.prototype.visitIntervalYearMonth = At(VR);
ht.prototype.visitDuration = At(Dat);
ht.prototype.visitDurationSecond = At(jR);
ht.prototype.visitDurationMillisecond = At(qR);
ht.prototype.visitDurationMicrosecond = At(YR);
ht.prototype.visitDurationNanosecond = At(WR);
ht.prototype.visitFixedSizeList = At(Nat);
ht.prototype.visitMap = At(Iat);
const Fn = new ht(), nr = Symbol.for("keys"), Sc = Symbol.for("vals");
class u_ {
  constructor(t) {
    return this[nr] = new ae([t.children[0]]).memoize(), this[Sc] = t.children[1], new Proxy(this, new Oat());
  }
  [Symbol.iterator]() {
    return new Bat(this[nr], this[Sc]);
  }
  get size() {
    return this[nr].length;
  }
  toArray() {
    return Object.values(this.toJSON());
  }
  toJSON() {
    const t = this[nr], n = this[Sc], i = {};
    for (let r = -1, s = t.length; ++r < s; )
      i[t.get(r)] = Fn.visit(n, r);
    return i;
  }
  toString() {
    return `{${[...this].map(([t, n]) => `${tf(t)}: ${tf(n)}`).join(", ")}}`;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.toString();
  }
}
class Bat {
  constructor(t, n) {
    this.keys = t, this.vals = n, this.keyIndex = 0, this.numKeys = t.length;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const t = this.keyIndex;
    return t === this.numKeys ? { done: !0, value: null } : (this.keyIndex++, {
      done: !1,
      value: [
        this.keys.get(t),
        Fn.visit(this.vals, t)
      ]
    });
  }
}
class Oat {
  isExtensible() {
    return !1;
  }
  deleteProperty() {
    return !1;
  }
  preventExtensions() {
    return !0;
  }
  ownKeys(t) {
    return t[nr].toArray().map(String);
  }
  has(t, n) {
    return t[nr].includes(n);
  }
  getOwnPropertyDescriptor(t, n) {
    if (t[nr].indexOf(n) !== -1)
      return { writable: !0, enumerable: !0, configurable: !0 };
  }
  get(t, n) {
    if (Reflect.has(t, n))
      return t[n];
    const i = t[nr].indexOf(n);
    if (i !== -1) {
      const r = Fn.visit(Reflect.get(t, Sc), i);
      return Reflect.set(t, n, r), r;
    }
  }
  set(t, n, i) {
    const r = t[nr].indexOf(n);
    return r !== -1 ? (hi.visit(Reflect.get(t, Sc), r, i), Reflect.set(t, n, i)) : Reflect.has(t, n) ? Reflect.set(t, n, i) : !1;
  }
}
Object.defineProperties(u_.prototype, {
  [Symbol.toStringTag]: { enumerable: !1, configurable: !1, value: "Row" },
  [nr]: { writable: !0, enumerable: !1, configurable: !1, value: null },
  [Sc]: { writable: !0, enumerable: !1, configurable: !1, value: null }
});
let mI;
function GR(e, t, n, i) {
  const { length: r = 0 } = e;
  let s = typeof t != "number" ? 0 : t, o = typeof n != "number" ? r : n;
  return s < 0 && (s = (s % r + r) % r), o < 0 && (o = (o % r + r) % r), o < s && (mI = s, s = o, o = mI), o > r && (o = r), i ? i(e, s, o) : [s, o];
}
const gI = (e) => e !== e;
function ml(e) {
  if (typeof e !== "object" || e === null)
    return gI(e) ? gI : (n) => n === e;
  if (e instanceof Date) {
    const n = e.valueOf();
    return (i) => i instanceof Date ? i.valueOf() === n : !1;
  }
  return ArrayBuffer.isView(e) ? (n) => n ? Mot(e, n) : !1 : e instanceof Map ? Eat(e) : Array.isArray(e) ? Fat(e) : e instanceof ae ? Lat(e) : Rat(e, !0);
}
function Fat(e) {
  const t = [];
  for (let n = -1, i = e.length; ++n < i; )
    t[n] = ml(e[n]);
  return J0(t);
}
function Eat(e) {
  let t = -1;
  const n = [];
  for (const i of e.values())
    n[++t] = ml(i);
  return J0(n);
}
function Lat(e) {
  const t = [];
  for (let n = -1, i = e.length; ++n < i; )
    t[n] = ml(e.get(n));
  return J0(t);
}
function Rat(e, t = !1) {
  const n = Object.keys(e);
  if (!t && n.length === 0)
    return () => !1;
  const i = [];
  for (let r = -1, s = n.length; ++r < s; )
    i[r] = ml(e[n[r]]);
  return J0(i, n);
}
function J0(e, t) {
  return (n) => {
    if (!n || typeof n != "object")
      return !1;
    switch (n.constructor) {
      case Array:
        return Cat(e, n);
      case Map:
        return bI(e, n, n.keys());
      case u_:
      case c_:
      case Object:
      case void 0:
        return bI(e, n, t || Object.keys(n));
    }
    return n instanceof ae ? kat(e, n) : !1;
  };
}
function Cat(e, t) {
  const n = e.length;
  if (t.length !== n)
    return !1;
  for (let i = -1; ++i < n; )
    if (!e[i](t[i]))
      return !1;
  return !0;
}
function kat(e, t) {
  const n = e.length;
  if (t.length !== n)
    return !1;
  for (let i = -1; ++i < n; )
    if (!e[i](t.get(i)))
      return !1;
  return !0;
}
function bI(e, t, n) {
  const i = n[Symbol.iterator](), r = t instanceof Map ? t.keys() : Object.keys(t)[Symbol.iterator](), s = t instanceof Map ? t.values() : Object.values(t)[Symbol.iterator]();
  let o = 0;
  const a = e.length;
  let c = s.next(), l = i.next(), u = r.next();
  for (; o < a && !l.done && !u.done && !c.done && !(l.value !== u.value || !e[o](c.value)); ++o, l = i.next(), u = r.next(), c = s.next())
    ;
  return o === a && l.done && u.done && c.done ? !0 : (i.return && i.return(), r.return && r.return(), s.return && s.return(), !1);
}
function XR(e, t, n, i) {
  return (n & 1 << i) !== 0;
}
function Uat(e, t, n, i) {
  return (n & 1 << i) >> i;
}
function wI(e, t, n) {
  const i = n.byteLength + 7 & -8;
  if (e > 0 || n.byteLength < i) {
    const r = new Uint8Array(i);
    return r.set(e % 8 === 0 ? n.subarray(e >> 3) : (
      // Otherwise iterate each bit from the offset and return a new one
      ab(new f_(n, e, t, null, XR)).subarray(0, i)
    )), r;
  }
  return n;
}
function ab(e) {
  const t = [];
  let n = 0, i = 0, r = 0;
  for (const o of e)
    o && (r |= 1 << i), ++i === 8 && (t[n++] = r, r = i = 0);
  (n === 0 || i > 0) && (t[n++] = r);
  const s = new Uint8Array(t.length + 7 & -8);
  return s.set(t), s;
}
class f_ {
  constructor(t, n, i, r, s) {
    this.bytes = t, this.length = i, this.context = r, this.get = s, this.bit = n % 8, this.byteIndex = n >> 3, this.byte = t[this.byteIndex++], this.index = 0;
  }
  next() {
    return this.index < this.length ? (this.bit === 8 && (this.bit = 0, this.byte = this.bytes[this.byteIndex++]), {
      value: this.get(this.context, this.index++, this.byte, this.bit++)
    }) : { done: !0, value: null };
  }
  [Symbol.iterator]() {
    return this;
  }
}
function cb(e, t, n) {
  if (n - t <= 0)
    return 0;
  if (n - t < 8) {
    let s = 0;
    for (const o of new f_(e, t, n - t, e, Uat))
      s += o;
    return s;
  }
  const i = n >> 3 << 3, r = t + (t % 8 === 0 ? 0 : 8 - t % 8);
  return (
    // Get the popcnt of bits between the left hand side, and the next highest multiple of 8
    cb(e, t, r) + // Get the popcnt of bits between the right hand side, and the next lowest multiple of 8
    cb(e, i, n) + // Get the popcnt of all bits between the left and right hand sides' multiples of 8
    zat(e, r >> 3, i - r >> 3)
  );
}
function zat(e, t, n) {
  let i = 0, r = Math.trunc(t);
  const s = new DataView(e.buffer, e.byteOffset, e.byteLength), o = n === void 0 ? e.byteLength : r + n;
  for (; o - r >= 4; )
    i += fg(s.getUint32(r)), r += 4;
  for (; o - r >= 2; )
    i += fg(s.getUint16(r)), r += 2;
  for (; o - r >= 1; )
    i += fg(s.getUint8(r)), r += 1;
  return i;
}
function fg(e) {
  let t = Math.trunc(e);
  return t = t - (t >>> 1 & 1431655765), t = (t & 858993459) + (t >>> 2 & 858993459), (t + (t >>> 4) & 252645135) * 16843009 >>> 24;
}
const Pat = -1;
class ne {
  get typeId() {
    return this.type.typeId;
  }
  get ArrayType() {
    return this.type.ArrayType;
  }
  get buffers() {
    return [this.valueOffsets, this.values, this.nullBitmap, this.typeIds];
  }
  get nullable() {
    if (this._nullCount !== 0) {
      const { type: t } = this;
      return ot.isSparseUnion(t) ? this.children.some((n) => n.nullable) : ot.isDenseUnion(t) ? this.children.some((n) => n.nullable) : this.nullBitmap && this.nullBitmap.byteLength > 0;
    }
    return !0;
  }
  get byteLength() {
    let t = 0;
    const { valueOffsets: n, values: i, nullBitmap: r, typeIds: s } = this;
    return n && (t += n.byteLength), i && (t += i.byteLength), r && (t += r.byteLength), s && (t += s.byteLength), this.children.reduce((o, a) => o + a.byteLength, t);
  }
  get nullCount() {
    if (ot.isUnion(this.type))
      return this.children.reduce((i, r) => i + r.nullCount, 0);
    let t = this._nullCount, n;
    return t <= Pat && (n = this.nullBitmap) && (this._nullCount = t = this.length - cb(n, this.offset, this.offset + this.length)), t;
  }
  constructor(t, n, i, r, s, o = [], a) {
    this.type = t, this.children = o, this.dictionary = a, this.offset = Math.floor(Math.max(n || 0, 0)), this.length = Math.floor(Math.max(i || 0, 0)), this._nullCount = Math.floor(Math.max(r || 0, -1));
    let c;
    s instanceof ne ? (this.stride = s.stride, this.values = s.values, this.typeIds = s.typeIds, this.nullBitmap = s.nullBitmap, this.valueOffsets = s.valueOffsets) : (this.stride = zr(t), s && ((c = s[0]) && (this.valueOffsets = c), (c = s[1]) && (this.values = c), (c = s[2]) && (this.nullBitmap = c), (c = s[3]) && (this.typeIds = c)));
  }
  getValid(t) {
    const { type: n } = this;
    if (ot.isUnion(n)) {
      const i = n, r = this.children[i.typeIdToChildIndex[this.typeIds[t]]], s = i.mode === On.Dense ? this.valueOffsets[t] : t;
      return r.getValid(s);
    }
    if (this.nullable && this.nullCount > 0) {
      const i = this.offset + t;
      return (this.nullBitmap[i >> 3] & 1 << i % 8) !== 0;
    }
    return !0;
  }
  setValid(t, n) {
    let i;
    const { type: r } = this;
    if (ot.isUnion(r)) {
      const s = r, o = this.children[s.typeIdToChildIndex[this.typeIds[t]]], a = s.mode === On.Dense ? this.valueOffsets[t] : t;
      i = o.getValid(a), o.setValid(a, n);
    } else {
      let { nullBitmap: s } = this;
      const { offset: o, length: a } = this, c = o + t, l = 1 << c % 8, u = c >> 3;
      (!s || s.byteLength <= u) && (s = new Uint8Array((o + a + 63 & -64) >> 3).fill(255), this.nullCount > 0 && s.set(wI(o, a, this.nullBitmap), 0), Object.assign(this, { nullBitmap: s, _nullCount: -1 }));
      const f = s[u];
      i = (f & l) !== 0, n ? s[u] = f | l : s[u] = f & ~l;
    }
    return i !== !!n && (this._nullCount = this.nullCount + (n ? -1 : 1)), n;
  }
  clone(t = this.type, n = this.offset, i = this.length, r = this._nullCount, s = this, o = this.children) {
    return new ne(t, n, i, r, s, o, this.dictionary);
  }
  slice(t, n) {
    const { stride: i, typeId: r, children: s } = this, o = +(this._nullCount === 0) - 1, a = r === 16 ? i : 1, c = this._sliceBuffers(t, n, i, r);
    return this.clone(
      this.type,
      this.offset + t,
      n,
      o,
      c,
      // Don't slice children if we have value offsets (the variable-width types)
      s.length === 0 || this.valueOffsets ? s : this._sliceChildren(s, a * t, a * n)
    );
  }
  _changeLengthAndBackfillNullBitmap(t) {
    if (this.typeId === E.Null)
      return this.clone(this.type, 0, t, 0);
    const { length: n, nullCount: i } = this, r = new Uint8Array((t + 63 & -64) >> 3).fill(255, 0, n >> 3);
    r[n >> 3] = (1 << n - (n & -8)) - 1, i > 0 && r.set(wI(this.offset, n, this.nullBitmap), 0);
    const s = this.buffers;
    return s[Ur.VALIDITY] = r, this.clone(this.type, 0, t, i + (t - n), s);
  }
  _sliceBuffers(t, n, i, r) {
    let s;
    const { buffers: o } = this;
    return (s = o[Ur.TYPE]) && (o[Ur.TYPE] = s.subarray(t, t + n)), (s = o[Ur.OFFSET]) && (o[Ur.OFFSET] = s.subarray(t, t + n + 1)) || // Otherwise if no offsets, slice the data buffer. Don't slice the data vector for Booleans, since the offset goes by bits not bytes
    (s = o[Ur.DATA]) && (o[Ur.DATA] = r === 6 ? s : s.subarray(i * t, i * (t + n))), o;
  }
  _sliceChildren(t, n, i) {
    return t.map((r) => r.slice(n, i));
  }
}
ne.prototype.children = Object.freeze([]);
class gu extends zt {
  visit(t) {
    return this.getVisitFn(t.type).call(this, t);
  }
  visitNull(t) {
    const { ["type"]: n, ["offset"]: i = 0, ["length"]: r = 0 } = t;
    return new ne(n, i, r, r);
  }
  visitBool(t) {
    const { ["type"]: n, ["offset"]: i = 0 } = t, r = Wt(t.nullBitmap), s = se(n.ArrayType, t.data), { ["length"]: o = s.length >> 3, ["nullCount"]: a = t.nullBitmap ? -1 : 0 } = t;
    return new ne(n, i, o, a, [void 0, s, r]);
  }
  visitInt(t) {
    const { ["type"]: n, ["offset"]: i = 0 } = t, r = Wt(t.nullBitmap), s = se(n.ArrayType, t.data), { ["length"]: o = s.length, ["nullCount"]: a = t.nullBitmap ? -1 : 0 } = t;
    return new ne(n, i, o, a, [void 0, s, r]);
  }
  visitFloat(t) {
    const { ["type"]: n, ["offset"]: i = 0 } = t, r = Wt(t.nullBitmap), s = se(n.ArrayType, t.data), { ["length"]: o = s.length, ["nullCount"]: a = t.nullBitmap ? -1 : 0 } = t;
    return new ne(n, i, o, a, [void 0, s, r]);
  }
  visitUtf8(t) {
    const { ["type"]: n, ["offset"]: i = 0 } = t, r = Wt(t.data), s = Wt(t.nullBitmap), o = Ol(t.valueOffsets), { ["length"]: a = o.length - 1, ["nullCount"]: c = t.nullBitmap ? -1 : 0 } = t;
    return new ne(n, i, a, c, [o, r, s]);
  }
  visitLargeUtf8(t) {
    const { ["type"]: n, ["offset"]: i = 0 } = t, r = Wt(t.data), s = Wt(t.nullBitmap), o = aI(t.valueOffsets), { ["length"]: a = o.length - 1, ["nullCount"]: c = t.nullBitmap ? -1 : 0 } = t;
    return new ne(n, i, a, c, [o, r, s]);
  }
  visitBinary(t) {
    const { ["type"]: n, ["offset"]: i = 0 } = t, r = Wt(t.data), s = Wt(t.nullBitmap), o = Ol(t.valueOffsets), { ["length"]: a = o.length - 1, ["nullCount"]: c = t.nullBitmap ? -1 : 0 } = t;
    return new ne(n, i, a, c, [o, r, s]);
  }
  visitLargeBinary(t) {
    const { ["type"]: n, ["offset"]: i = 0 } = t, r = Wt(t.data), s = Wt(t.nullBitmap), o = aI(t.valueOffsets), { ["length"]: a = o.length - 1, ["nullCount"]: c = t.nullBitmap ? -1 : 0 } = t;
    return new ne(n, i, a, c, [o, r, s]);
  }
  visitFixedSizeBinary(t) {
    const { ["type"]: n, ["offset"]: i = 0 } = t, r = Wt(t.nullBitmap), s = se(n.ArrayType, t.data), { ["length"]: o = s.length / zr(n), ["nullCount"]: a = t.nullBitmap ? -1 : 0 } = t;
    return new ne(n, i, o, a, [void 0, s, r]);
  }
  visitDate(t) {
    const { ["type"]: n, ["offset"]: i = 0 } = t, r = Wt(t.nullBitmap), s = se(n.ArrayType, t.data), { ["length"]: o = s.length / zr(n), ["nullCount"]: a = t.nullBitmap ? -1 : 0 } = t;
    return new ne(n, i, o, a, [void 0, s, r]);
  }
  visitTimestamp(t) {
    const { ["type"]: n, ["offset"]: i = 0 } = t, r = Wt(t.nullBitmap), s = se(n.ArrayType, t.data), { ["length"]: o = s.length / zr(n), ["nullCount"]: a = t.nullBitmap ? -1 : 0 } = t;
    return new ne(n, i, o, a, [void 0, s, r]);
  }
  visitTime(t) {
    const { ["type"]: n, ["offset"]: i = 0 } = t, r = Wt(t.nullBitmap), s = se(n.ArrayType, t.data), { ["length"]: o = s.length / zr(n), ["nullCount"]: a = t.nullBitmap ? -1 : 0 } = t;
    return new ne(n, i, o, a, [void 0, s, r]);
  }
  visitDecimal(t) {
    const { ["type"]: n, ["offset"]: i = 0 } = t, r = Wt(t.nullBitmap), s = se(n.ArrayType, t.data), { ["length"]: o = s.length / zr(n), ["nullCount"]: a = t.nullBitmap ? -1 : 0 } = t;
    return new ne(n, i, o, a, [void 0, s, r]);
  }
  visitList(t) {
    const { ["type"]: n, ["offset"]: i = 0, ["child"]: r } = t, s = Wt(t.nullBitmap), o = Ol(t.valueOffsets), { ["length"]: a = o.length - 1, ["nullCount"]: c = t.nullBitmap ? -1 : 0 } = t;
    return new ne(n, i, a, c, [o, void 0, s], [r]);
  }
  visitStruct(t) {
    const { ["type"]: n, ["offset"]: i = 0, ["children"]: r = [] } = t, s = Wt(t.nullBitmap), { length: o = r.reduce((c, { length: l }) => Math.max(c, l), 0), nullCount: a = t.nullBitmap ? -1 : 0 } = t;
    return new ne(n, i, o, a, [void 0, void 0, s], r);
  }
  visitUnion(t) {
    const { ["type"]: n, ["offset"]: i = 0, ["children"]: r = [] } = t, s = se(n.ArrayType, t.typeIds), { ["length"]: o = s.length, ["nullCount"]: a = -1 } = t;
    if (ot.isSparseUnion(n))
      return new ne(n, i, o, a, [void 0, void 0, void 0, s], r);
    const c = Ol(t.valueOffsets);
    return new ne(n, i, o, a, [c, void 0, void 0, s], r);
  }
  visitDictionary(t) {
    const { ["type"]: n, ["offset"]: i = 0 } = t, r = Wt(t.nullBitmap), s = se(n.indices.ArrayType, t.data), { ["dictionary"]: o = new ae([new gu().visit({ type: n.dictionary })]) } = t, { ["length"]: a = s.length, ["nullCount"]: c = t.nullBitmap ? -1 : 0 } = t;
    return new ne(n, i, a, c, [void 0, s, r], [], o);
  }
  visitInterval(t) {
    const { ["type"]: n, ["offset"]: i = 0 } = t, r = Wt(t.nullBitmap), s = se(n.ArrayType, t.data), { ["length"]: o = s.length / zr(n), ["nullCount"]: a = t.nullBitmap ? -1 : 0 } = t;
    return new ne(n, i, o, a, [void 0, s, r]);
  }
  visitDuration(t) {
    const { ["type"]: n, ["offset"]: i = 0 } = t, r = Wt(t.nullBitmap), s = se(n.ArrayType, t.data), { ["length"]: o = s.length, ["nullCount"]: a = t.nullBitmap ? -1 : 0 } = t;
    return new ne(n, i, o, a, [void 0, s, r]);
  }
  visitFixedSizeList(t) {
    const { ["type"]: n, ["offset"]: i = 0, ["child"]: r = new gu().visit({ type: n.valueType }) } = t, s = Wt(t.nullBitmap), { ["length"]: o = r.length / zr(n), ["nullCount"]: a = t.nullBitmap ? -1 : 0 } = t;
    return new ne(n, i, o, a, [void 0, void 0, s], [r]);
  }
  visitMap(t) {
    const { ["type"]: n, ["offset"]: i = 0, ["child"]: r = new gu().visit({ type: n.childType }) } = t, s = Wt(t.nullBitmap), o = Ol(t.valueOffsets), { ["length"]: a = o.length - 1, ["nullCount"]: c = t.nullBitmap ? -1 : 0 } = t;
    return new ne(n, i, a, c, [o, void 0, s], [r]);
  }
}
const Vat = new gu();
function Ct(e) {
  return Vat.visit(e);
}
class vI {
  constructor(t = 0, n) {
    this.numChunks = t, this.getChunkIterator = n, this.chunkIndex = 0, this.chunkIterator = this.getChunkIterator(0);
  }
  next() {
    for (; this.chunkIndex < this.numChunks; ) {
      const t = this.chunkIterator.next();
      if (!t.done)
        return t;
      ++this.chunkIndex < this.numChunks && (this.chunkIterator = this.getChunkIterator(this.chunkIndex));
    }
    return { done: !0, value: null };
  }
  [Symbol.iterator]() {
    return this;
  }
}
function jat(e) {
  return e.some((t) => t.nullable);
}
function HR(e) {
  return e.reduce((t, n) => t + n.nullCount, 0);
}
function JR(e) {
  return e.reduce((t, n, i) => (t[i + 1] = t[i] + n.length, t), new Uint32Array(e.length + 1));
}
function KR(e, t, n, i) {
  const r = [];
  for (let s = -1, o = e.length; ++s < o; ) {
    const a = e[s], c = t[s], { length: l } = a;
    if (c >= i)
      break;
    if (n >= c + l)
      continue;
    if (c >= n && c + l <= i) {
      r.push(a);
      continue;
    }
    const u = Math.max(0, n - c), f = Math.min(i - c, l);
    r.push(a.slice(u, f - u));
  }
  return r.length === 0 && r.push(e[0].slice(0, 0)), r;
}
function h_(e, t, n, i) {
  let r = 0, s = 0, o = t.length - 1;
  do {
    if (r >= o - 1)
      return n < t[o] ? i(e, r, n - t[r]) : null;
    s = r + Math.trunc((o - r) * 0.5), n < t[s] ? o = s : r = s;
  } while (r < o);
}
function d_(e, t) {
  return e.getValid(t);
}
function Ay(e) {
  function t(n, i, r) {
    return e(n[i], r);
  }
  return function(n) {
    const i = this.data;
    return h_(i, this._offsets, n, t);
  };
}
function ZR(e) {
  let t;
  function n(i, r, s) {
    return e(i[r], s, t);
  }
  return function(i, r) {
    const s = this.data;
    t = r;
    const o = h_(s, this._offsets, i, n);
    return t = void 0, o;
  };
}
function QR(e) {
  let t;
  function n(i, r, s) {
    let o = s, a = 0, c = 0;
    for (let l = r - 1, u = i.length; ++l < u; ) {
      const f = i[l];
      if (~(a = e(f, t, o)))
        return c + a;
      o = 0, c += f.length;
    }
    return -1;
  }
  return function(i, r) {
    t = i;
    const s = this.data, o = typeof r != "number" ? n(s, 0, 0) : h_(s, this._offsets, r, n);
    return t = void 0, o;
  };
}
class dt extends zt {
}
function qat(e, t) {
  return t === null && e.length > 0 ? 0 : -1;
}
function Yat(e, t) {
  const { nullBitmap: n } = e;
  if (!n || e.nullCount <= 0)
    return -1;
  let i = 0;
  for (const r of new f_(n, e.offset + (t || 0), e.length, n, XR)) {
    if (!r)
      return i;
    ++i;
  }
  return -1;
}
function Ot(e, t, n) {
  if (t === void 0)
    return -1;
  if (t === null)
    switch (e.typeId) {
      case E.Union:
        break;
      case E.Dictionary:
        break;
      default:
        return Yat(e, n);
    }
  const i = Fn.getVisitFn(e), r = ml(t);
  for (let s = (n || 0) - 1, o = e.length; ++s < o; )
    if (r(i(e, s)))
      return s;
  return -1;
}
function tC(e, t, n) {
  const i = Fn.getVisitFn(e), r = ml(t);
  for (let s = (n || 0) - 1, o = e.length; ++s < o; )
    if (r(i(e, s)))
      return s;
  return -1;
}
dt.prototype.visitNull = qat;
dt.prototype.visitBool = Ot;
dt.prototype.visitInt = Ot;
dt.prototype.visitInt8 = Ot;
dt.prototype.visitInt16 = Ot;
dt.prototype.visitInt32 = Ot;
dt.prototype.visitInt64 = Ot;
dt.prototype.visitUint8 = Ot;
dt.prototype.visitUint16 = Ot;
dt.prototype.visitUint32 = Ot;
dt.prototype.visitUint64 = Ot;
dt.prototype.visitFloat = Ot;
dt.prototype.visitFloat16 = Ot;
dt.prototype.visitFloat32 = Ot;
dt.prototype.visitFloat64 = Ot;
dt.prototype.visitUtf8 = Ot;
dt.prototype.visitLargeUtf8 = Ot;
dt.prototype.visitBinary = Ot;
dt.prototype.visitLargeBinary = Ot;
dt.prototype.visitFixedSizeBinary = Ot;
dt.prototype.visitDate = Ot;
dt.prototype.visitDateDay = Ot;
dt.prototype.visitDateMillisecond = Ot;
dt.prototype.visitTimestamp = Ot;
dt.prototype.visitTimestampSecond = Ot;
dt.prototype.visitTimestampMillisecond = Ot;
dt.prototype.visitTimestampMicrosecond = Ot;
dt.prototype.visitTimestampNanosecond = Ot;
dt.prototype.visitTime = Ot;
dt.prototype.visitTimeSecond = Ot;
dt.prototype.visitTimeMillisecond = Ot;
dt.prototype.visitTimeMicrosecond = Ot;
dt.prototype.visitTimeNanosecond = Ot;
dt.prototype.visitDecimal = Ot;
dt.prototype.visitList = Ot;
dt.prototype.visitStruct = Ot;
dt.prototype.visitUnion = Ot;
dt.prototype.visitDenseUnion = tC;
dt.prototype.visitSparseUnion = tC;
dt.prototype.visitDictionary = Ot;
dt.prototype.visitInterval = Ot;
dt.prototype.visitIntervalDayTime = Ot;
dt.prototype.visitIntervalYearMonth = Ot;
dt.prototype.visitDuration = Ot;
dt.prototype.visitDurationSecond = Ot;
dt.prototype.visitDurationMillisecond = Ot;
dt.prototype.visitDurationMicrosecond = Ot;
dt.prototype.visitDurationNanosecond = Ot;
dt.prototype.visitFixedSizeList = Ot;
dt.prototype.visitMap = Ot;
const My = new dt();
class pt extends zt {
}
function Mt(e) {
  const { type: t } = e;
  if (e.nullCount === 0 && e.stride === 1 && (t.typeId === E.Timestamp || t instanceof eo && t.bitWidth !== 64 || t instanceof of && t.bitWidth !== 64 || t instanceof sf && t.precision !== rn.HALF))
    return new vI(e.data.length, (i) => {
      const r = e.data[i];
      return r.values.subarray(0, r.length)[Symbol.iterator]();
    });
  let n = 0;
  return new vI(e.data.length, (i) => {
    const s = e.data[i].length, o = e.slice(n, n + s);
    return n += s, new Wat(o);
  });
}
class Wat {
  constructor(t) {
    this.vector = t, this.index = 0;
  }
  next() {
    return this.index < this.vector.length ? {
      value: this.vector.get(this.index++)
    } : { done: !0, value: null };
  }
  [Symbol.iterator]() {
    return this;
  }
}
pt.prototype.visitNull = Mt;
pt.prototype.visitBool = Mt;
pt.prototype.visitInt = Mt;
pt.prototype.visitInt8 = Mt;
pt.prototype.visitInt16 = Mt;
pt.prototype.visitInt32 = Mt;
pt.prototype.visitInt64 = Mt;
pt.prototype.visitUint8 = Mt;
pt.prototype.visitUint16 = Mt;
pt.prototype.visitUint32 = Mt;
pt.prototype.visitUint64 = Mt;
pt.prototype.visitFloat = Mt;
pt.prototype.visitFloat16 = Mt;
pt.prototype.visitFloat32 = Mt;
pt.prototype.visitFloat64 = Mt;
pt.prototype.visitUtf8 = Mt;
pt.prototype.visitLargeUtf8 = Mt;
pt.prototype.visitBinary = Mt;
pt.prototype.visitLargeBinary = Mt;
pt.prototype.visitFixedSizeBinary = Mt;
pt.prototype.visitDate = Mt;
pt.prototype.visitDateDay = Mt;
pt.prototype.visitDateMillisecond = Mt;
pt.prototype.visitTimestamp = Mt;
pt.prototype.visitTimestampSecond = Mt;
pt.prototype.visitTimestampMillisecond = Mt;
pt.prototype.visitTimestampMicrosecond = Mt;
pt.prototype.visitTimestampNanosecond = Mt;
pt.prototype.visitTime = Mt;
pt.prototype.visitTimeSecond = Mt;
pt.prototype.visitTimeMillisecond = Mt;
pt.prototype.visitTimeMicrosecond = Mt;
pt.prototype.visitTimeNanosecond = Mt;
pt.prototype.visitDecimal = Mt;
pt.prototype.visitList = Mt;
pt.prototype.visitStruct = Mt;
pt.prototype.visitUnion = Mt;
pt.prototype.visitDenseUnion = Mt;
pt.prototype.visitSparseUnion = Mt;
pt.prototype.visitDictionary = Mt;
pt.prototype.visitInterval = Mt;
pt.prototype.visitIntervalDayTime = Mt;
pt.prototype.visitIntervalYearMonth = Mt;
pt.prototype.visitDuration = Mt;
pt.prototype.visitDurationSecond = Mt;
pt.prototype.visitDurationMillisecond = Mt;
pt.prototype.visitDurationMicrosecond = Mt;
pt.prototype.visitDurationNanosecond = Mt;
pt.prototype.visitFixedSizeList = Mt;
pt.prototype.visitMap = Mt;
const p_ = new pt();
var eC;
const nC = {}, iC = {};
class ae {
  constructor(t) {
    var n, i, r;
    const s = t[0] instanceof ae ? t.flatMap((a) => a.data) : t;
    if (s.length === 0 || s.some((a) => !(a instanceof ne)))
      throw new TypeError("Vector constructor expects an Array of Data instances.");
    const o = (n = s[0]) === null || n === void 0 ? void 0 : n.type;
    switch (s.length) {
      case 0:
        this._offsets = [0];
        break;
      case 1: {
        const { get: a, set: c, indexOf: l } = nC[o.typeId], u = s[0];
        this.isValid = (f) => d_(u, f), this.get = (f) => a(u, f), this.set = (f, h) => c(u, f, h), this.indexOf = (f) => l(u, f), this._offsets = [0, u.length];
        break;
      }
      default:
        Object.setPrototypeOf(this, iC[o.typeId]), this._offsets = JR(s);
        break;
    }
    this.data = s, this.type = o, this.stride = zr(o), this.numChildren = (r = (i = o.children) === null || i === void 0 ? void 0 : i.length) !== null && r !== void 0 ? r : 0, this.length = this._offsets.at(-1);
  }
  /**
   * The aggregate size (in bytes) of this Vector's buffers and/or child Vectors.
   */
  get byteLength() {
    return this.data.reduce((t, n) => t + n.byteLength, 0);
  }
  /**
   * Whether this Vector's elements can contain null values.
   */
  get nullable() {
    return jat(this.data);
  }
  /**
   * The number of null elements in this Vector.
   */
  get nullCount() {
    return HR(this.data);
  }
  /**
   * The Array or TypedArray constructor used for the JS representation
   *  of the element's values in {@link Vector.prototype.toArray `toArray()`}.
   */
  get ArrayType() {
    return this.type.ArrayType;
  }
  /**
   * The name that should be printed when the Vector is logged in a message.
   */
  get [Symbol.toStringTag]() {
    return `${this.VectorName}<${this.type[Symbol.toStringTag]}>`;
  }
  /**
   * The name of this Vector.
   */
  get VectorName() {
    return `${E[this.type.typeId]}Vector`;
  }
  /**
   * Check whether an element is null.
   * @param index The index at which to read the validity bitmap.
   */
  // @ts-ignore
  isValid(t) {
    return !1;
  }
  /**
   * Get an element value by position.
   * @param index The index of the element to read.
   */
  // @ts-ignore
  get(t) {
    return null;
  }
  /**
   * Set an element value by position.
   * @param index The index of the element to write.
   * @param value The value to set.
   */
  // @ts-ignore
  set(t, n) {
  }
  /**
   * Retrieve the index of the first occurrence of a value in an Vector.
   * @param element The value to locate in the Vector.
   * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
   */
  // @ts-ignore
  indexOf(t, n) {
    return -1;
  }
  includes(t, n) {
    return this.indexOf(t, n) > -1;
  }
  /**
   * Iterator for the Vector's elements.
   */
  [Symbol.iterator]() {
    return p_.visit(this);
  }
  /**
   * Combines two or more Vectors of the same type.
   * @param others Additional Vectors to add to the end of this Vector.
   */
  concat(...t) {
    return new ae(this.data.concat(t.flatMap((n) => n.data).flat(Number.POSITIVE_INFINITY)));
  }
  /**
   * Return a zero-copy sub-section of this Vector.
   * @param start The beginning of the specified portion of the Vector.
   * @param end The end of the specified portion of the Vector. This is exclusive of the element at the index 'end'.
   */
  slice(t, n) {
    return new ae(GR(this, t, n, ({ data: i, _offsets: r }, s, o) => KR(i, r, s, o)));
  }
  toJSON() {
    return [...this];
  }
  /**
   * Return a JavaScript Array or TypedArray of the Vector's elements.
   *
   * @note If this Vector contains a single Data chunk and the Vector's type is a
   *  primitive numeric type corresponding to one of the JavaScript TypedArrays, this
   *  method returns a zero-copy slice of the underlying TypedArray values. If there's
   *  more than one chunk, the resulting TypedArray will be a copy of the data from each
   *  chunk's underlying TypedArray values.
   *
   * @returns An Array or TypedArray of the Vector's elements, based on the Vector's DataType.
   */
  toArray() {
    const { type: t, data: n, length: i, stride: r, ArrayType: s } = this;
    switch (t.typeId) {
      case E.Int:
      case E.Float:
      case E.Decimal:
      case E.Time:
      case E.Timestamp:
        switch (n.length) {
          case 0:
            return new s();
          case 1:
            return n[0].values.subarray(0, i * r);
          default:
            return n.reduce((o, { values: a, length: c }) => (o.array.set(a.subarray(0, c * r), o.offset), o.offset += c * r, o), { array: new s(i * r), offset: 0 }).array;
        }
    }
    return [...this];
  }
  /**
   * Returns a string representation of the Vector.
   *
   * @returns A string representation of the Vector.
   */
  toString() {
    return `[${[...this].join(",")}]`;
  }
  /**
   * Returns a child Vector by name, or null if this Vector has no child with the given name.
   * @param name The name of the child to retrieve.
   */
  getChild(t) {
    var n;
    return this.getChildAt((n = this.type.children) === null || n === void 0 ? void 0 : n.findIndex((i) => i.name === t));
  }
  /**
   * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
   * @param index The index of the child to retrieve.
   */
  getChildAt(t) {
    return t > -1 && t < this.numChildren ? new ae(this.data.map(({ children: n }) => n[t])) : null;
  }
  get isMemoized() {
    return ot.isDictionary(this.type) ? this.data[0].dictionary.isMemoized : !1;
  }
  /**
   * Adds memoization to the Vector's {@link get} method. For dictionary
   * vectors, this method return a vector that memoizes only the dictionary
   * values.
   *
   * Memoization is very useful when decoding a value is expensive such as
   * Utf8. The memoization creates a cache of the size of the Vector and
   * therefore increases memory usage.
   *
   * @returns A new vector that memoizes calls to {@link get}.
   */
  memoize() {
    if (ot.isDictionary(this.type)) {
      const t = new $y(this.data[0].dictionary), n = this.data.map((i) => {
        const r = i.clone();
        return r.dictionary = t, r;
      });
      return new ae(n);
    }
    return new $y(this);
  }
  /**
   * Returns a vector without memoization of the {@link get} method. If this
   * vector is not memoized, this method returns this vector.
   *
   * @returns A new vector without memoization.
   */
  unmemoize() {
    if (ot.isDictionary(this.type) && this.isMemoized) {
      const t = this.data[0].dictionary.unmemoize(), n = this.data.map((i) => {
        const r = i.clone();
        return r.dictionary = t, r;
      });
      return new ae(n);
    }
    return this;
  }
}
eC = Symbol.toStringTag;
ae[eC] = ((e) => {
  e.type = ot.prototype, e.data = [], e.length = 0, e.stride = 1, e.numChildren = 0, e._offsets = new Uint32Array([0]), e[Symbol.isConcatSpreadable] = !0;
  const t = Object.keys(E).map((n) => E[n]).filter((n) => typeof n == "number" && n !== E.NONE);
  for (const n of t) {
    const i = Fn.getVisitFnByTypeId(n), r = hi.getVisitFnByTypeId(n), s = My.getVisitFnByTypeId(n);
    nC[n] = { get: i, set: r, indexOf: s }, iC[n] = Object.create(e, {
      isValid: { value: Ay(d_) },
      get: { value: Ay(Fn.getVisitFnByTypeId(n)) },
      set: { value: ZR(hi.getVisitFnByTypeId(n)) },
      indexOf: { value: QR(My.getVisitFnByTypeId(n)) }
    });
  }
  return "Vector";
})(ae.prototype);
class $y extends ae {
  constructor(t) {
    super(t.data);
    const n = this.get, i = this.set, r = this.slice, s = new Array(this.length);
    Object.defineProperty(this, "get", {
      value(o) {
        const a = s[o];
        if (a !== void 0)
          return a;
        const c = n.call(this, o);
        return s[o] = c, c;
      }
    }), Object.defineProperty(this, "set", {
      value(o, a) {
        i.call(this, o, a), s[o] = a;
      }
    }), Object.defineProperty(this, "slice", {
      value: (o, a) => new $y(r.call(this, o, a))
    }), Object.defineProperty(this, "isMemoized", { value: !0 }), Object.defineProperty(this, "unmemoize", {
      value: () => new ae(this.data)
    }), Object.defineProperty(this, "memoize", {
      value: () => this
    });
  }
}
class lb {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  /**
   * Index to the start of the RecordBlock (note this is past the Message header)
   */
  offset() {
    return this.bb.readInt64(this.bb_pos);
  }
  /**
   * Length of the metadata
   */
  metaDataLength() {
    return this.bb.readInt32(this.bb_pos + 8);
  }
  /**
   * Length of the data (this is aligned so there can be a gap between this and
   * the metadata).
   */
  bodyLength() {
    return this.bb.readInt64(this.bb_pos + 16);
  }
  static sizeOf() {
    return 24;
  }
  static createBlock(t, n, i, r) {
    return t.prep(8, 24), t.writeInt64(BigInt(r ?? 0)), t.pad(4), t.writeInt32(i), t.writeInt64(BigInt(n ?? 0)), t.offset();
  }
}
class Ln {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsFooter(t, n) {
    return (n || new Ln()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsFooter(t, n) {
    return t.setPosition(t.position() + nt), (n || new Ln()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  version() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt16(this.bb_pos + t) : Le.V1;
  }
  schema(t) {
    const n = this.bb.__offset(this.bb_pos, 6);
    return n ? (t || new Gi()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;
  }
  dictionaries(t, n) {
    const i = this.bb.__offset(this.bb_pos, 8);
    return i ? (n || new lb()).__init(this.bb.__vector(this.bb_pos + i) + t * 24, this.bb) : null;
  }
  dictionariesLength() {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  recordBatches(t, n) {
    const i = this.bb.__offset(this.bb_pos, 10);
    return i ? (n || new lb()).__init(this.bb.__vector(this.bb_pos + i) + t * 24, this.bb) : null;
  }
  recordBatchesLength() {
    const t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  /**
   * User-defined metadata
   */
  customMetadata(t, n) {
    const i = this.bb.__offset(this.bb_pos, 12);
    return i ? (n || new Ce()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + t * 4), this.bb) : null;
  }
  customMetadataLength() {
    const t = this.bb.__offset(this.bb_pos, 12);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  static startFooter(t) {
    t.startObject(5);
  }
  static addVersion(t, n) {
    t.addFieldInt16(0, n, Le.V1);
  }
  static addSchema(t, n) {
    t.addFieldOffset(1, n, 0);
  }
  static addDictionaries(t, n) {
    t.addFieldOffset(2, n, 0);
  }
  static startDictionariesVector(t, n) {
    t.startVector(24, n, 8);
  }
  static addRecordBatches(t, n) {
    t.addFieldOffset(3, n, 0);
  }
  static startRecordBatchesVector(t, n) {
    t.startVector(24, n, 8);
  }
  static addCustomMetadata(t, n) {
    t.addFieldOffset(4, n, 0);
  }
  static createCustomMetadataVector(t, n) {
    t.startVector(4, n.length, 4);
    for (let i = n.length - 1; i >= 0; i--)
      t.addOffset(n[i]);
    return t.endVector();
  }
  static startCustomMetadataVector(t, n) {
    t.startVector(4, n, 4);
  }
  static endFooter(t) {
    return t.endObject();
  }
  static finishFooterBuffer(t, n) {
    t.finish(n);
  }
  static finishSizePrefixedFooterBuffer(t, n) {
    t.finish(n, void 0, !0);
  }
}
class ee {
  constructor(t = [], n, i, r = Le.V5) {
    this.fields = t || [], this.metadata = n || /* @__PURE__ */ new Map(), i || (i = ub(t)), this.dictionaries = i, this.metadataVersion = r;
  }
  get [Symbol.toStringTag]() {
    return "Schema";
  }
  get names() {
    return this.fields.map((t) => t.name);
  }
  toString() {
    return `Schema<{ ${this.fields.map((t, n) => `${n}: ${t}`).join(", ")} }>`;
  }
  /**
   * Construct a new Schema containing only specified fields.
   *
   * @param fieldNames Names of fields to keep.
   * @returns A new Schema of fields matching the specified names.
   */
  select(t) {
    const n = new Set(t), i = this.fields.filter((r) => n.has(r.name));
    return new ee(i, this.metadata);
  }
  /**
   * Construct a new Schema containing only fields at the specified indices.
   *
   * @param fieldIndices Indices of fields to keep.
   * @returns A new Schema of fields at the specified indices.
   */
  selectAt(t) {
    const n = t.map((i) => this.fields[i]).filter(Boolean);
    return new ee(n, this.metadata);
  }
  assign(...t) {
    const n = t[0] instanceof ee ? t[0] : Array.isArray(t[0]) ? new ee(t[0]) : new ee(t), i = [...this.fields], r = Lh(Lh(/* @__PURE__ */ new Map(), this.metadata), n.metadata), s = n.fields.filter((a) => {
      const c = i.findIndex((l) => l.name === a.name);
      return ~c ? (i[c] = a.clone({
        metadata: Lh(Lh(/* @__PURE__ */ new Map(), i[c].metadata), a.metadata)
      })) && !1 : !0;
    }), o = ub(s, /* @__PURE__ */ new Map());
    return new ee([...i, ...s], r, new Map([...this.dictionaries, ...o]));
  }
}
ee.prototype.fields = null;
ee.prototype.metadata = null;
ee.prototype.dictionaries = null;
class ge {
  /** @nocollapse */
  static new(...t) {
    let [n, i, r, s] = t;
    return t[0] && typeof t[0] == "object" && ({ name: n } = t[0], i === void 0 && (i = t[0].type), r === void 0 && (r = t[0].nullable), s === void 0 && (s = t[0].metadata)), new ge(`${n}`, i, r, s);
  }
  constructor(t, n, i = !1, r) {
    this.name = t, this.type = n, this.nullable = i, this.metadata = r || /* @__PURE__ */ new Map();
  }
  get typeId() {
    return this.type.typeId;
  }
  get [Symbol.toStringTag]() {
    return "Field";
  }
  toString() {
    return `${this.name}: ${this.type}`;
  }
  clone(...t) {
    let [n, i, r, s] = t;
    return !t[0] || typeof t[0] != "object" ? [n = this.name, i = this.type, r = this.nullable, s = this.metadata] = t : { name: n = this.name, type: i = this.type, nullable: r = this.nullable, metadata: s = this.metadata } = t[0], ge.new(n, i, r, s);
  }
}
ge.prototype.type = null;
ge.prototype.name = null;
ge.prototype.nullable = null;
ge.prototype.metadata = null;
function Lh(e, t) {
  return new Map([...e || /* @__PURE__ */ new Map(), ...t || /* @__PURE__ */ new Map()]);
}
function ub(e, t = /* @__PURE__ */ new Map()) {
  for (let n = -1, i = e.length; ++n < i; ) {
    const s = e[n].type;
    if (ot.isDictionary(s)) {
      if (!t.has(s.id))
        t.set(s.id, s.dictionary);
      else if (t.get(s.id) !== s.dictionary)
        throw new Error("Cannot create Schema containing two different dictionaries with the same Id");
    }
    s.children && s.children.length > 0 && ub(s.children, t);
  }
  return t;
}
var Gat = Ry, Xat = ur;
class y_ {
  /** @nocollapse */
  static decode(t) {
    t = new Xat(Wt(t));
    const n = Ln.getRootAsFooter(t), i = ee.decode(n.schema(), /* @__PURE__ */ new Map(), n.version());
    return new Hat(i, n);
  }
  /** @nocollapse */
  static encode(t) {
    const n = new Gat(), i = ee.encode(n, t.schema);
    Ln.startRecordBatchesVector(n, t.numRecordBatches);
    for (const o of [...t.recordBatches()].slice().reverse())
      Hc.encode(n, o);
    const r = n.endVector();
    Ln.startDictionariesVector(n, t.numDictionaries);
    for (const o of [...t.dictionaryBatches()].slice().reverse())
      Hc.encode(n, o);
    const s = n.endVector();
    return Ln.startFooter(n), Ln.addSchema(n, i), Ln.addVersion(n, Le.V5), Ln.addRecordBatches(n, r), Ln.addDictionaries(n, s), Ln.finishFooterBuffer(n, Ln.endFooter(n)), n.asUint8Array();
  }
  get numRecordBatches() {
    return this._recordBatches.length;
  }
  get numDictionaries() {
    return this._dictionaryBatches.length;
  }
  constructor(t, n = Le.V5, i, r) {
    this.schema = t, this.version = n, i && (this._recordBatches = i), r && (this._dictionaryBatches = r);
  }
  *recordBatches() {
    for (let t, n = -1, i = this.numRecordBatches; ++n < i; )
      (t = this.getRecordBatch(n)) && (yield t);
  }
  *dictionaryBatches() {
    for (let t, n = -1, i = this.numDictionaries; ++n < i; )
      (t = this.getDictionaryBatch(n)) && (yield t);
  }
  getRecordBatch(t) {
    return t >= 0 && t < this.numRecordBatches && this._recordBatches[t] || null;
  }
  getDictionaryBatch(t) {
    return t >= 0 && t < this.numDictionaries && this._dictionaryBatches[t] || null;
  }
}
class Hat extends y_ {
  get numRecordBatches() {
    return this._footer.recordBatchesLength();
  }
  get numDictionaries() {
    return this._footer.dictionariesLength();
  }
  constructor(t, n) {
    super(t, n.version()), this._footer = n;
  }
  getRecordBatch(t) {
    if (t >= 0 && t < this.numRecordBatches) {
      const n = this._footer.recordBatches(t);
      if (n)
        return Hc.decode(n);
    }
    return null;
  }
  getDictionaryBatch(t) {
    if (t >= 0 && t < this.numDictionaries) {
      const n = this._footer.dictionaries(t);
      if (n)
        return Hc.decode(n);
    }
    return null;
  }
}
class Hc {
  /** @nocollapse */
  static decode(t) {
    return new Hc(t.metaDataLength(), t.bodyLength(), t.offset());
  }
  /** @nocollapse */
  static encode(t, n) {
    const { metaDataLength: i } = n, r = BigInt(n.offset), s = BigInt(n.bodyLength);
    return lb.createBlock(t, r, i, s);
  }
  constructor(t, n, i) {
    this.metaDataLength = t, this.offset = bn(i), this.bodyLength = bn(n);
  }
}
const Ie = Object.freeze({ done: !0, value: void 0 });
class _I {
  constructor(t) {
    this._json = t;
  }
  get schema() {
    return this._json.schema;
  }
  get batches() {
    return this._json.batches || [];
  }
  get dictionaries() {
    return this._json.dictionaries || [];
  }
}
class rC {
  tee() {
    return this._getDOMStream().tee();
  }
  pipe(t, n) {
    return this._getNodeStream().pipe(t, n);
  }
  pipeTo(t, n) {
    return this._getDOMStream().pipeTo(t, n);
  }
  pipeThrough(t, n) {
    return this._getDOMStream().pipeThrough(t, n);
  }
  _getDOMStream() {
    return this._DOMStream || (this._DOMStream = this.toDOMStream());
  }
  _getNodeStream() {
    return this._nodeStream || (this._nodeStream = this.toNodeStream());
  }
}
class Jat extends rC {
  constructor() {
    super(), this._values = [], this.resolvers = [], this._closedPromise = new Promise((t) => this._closedPromiseResolve = t);
  }
  get closed() {
    return this._closedPromise;
  }
  cancel(t) {
    return W(this, void 0, void 0, function* () {
      yield this.return(t);
    });
  }
  write(t) {
    this._ensureOpen() && (this.resolvers.length <= 0 ? this._values.push(t) : this.resolvers.shift().resolve({ done: !1, value: t }));
  }
  abort(t) {
    this._closedPromiseResolve && (this.resolvers.length <= 0 ? this._error = { error: t } : this.resolvers.shift().reject({ done: !0, value: t }));
  }
  close() {
    if (this._closedPromiseResolve) {
      const { resolvers: t } = this;
      for (; t.length > 0; )
        t.shift().resolve(Ie);
      this._closedPromiseResolve(), this._closedPromiseResolve = void 0;
    }
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  toDOMStream(t) {
    return Zn.toDOMStream(this._closedPromiseResolve || this._error ? this : this._values, t);
  }
  toNodeStream(t) {
    return Zn.toNodeStream(this._closedPromiseResolve || this._error ? this : this._values, t);
  }
  throw(t) {
    return W(this, void 0, void 0, function* () {
      return yield this.abort(t), Ie;
    });
  }
  return(t) {
    return W(this, void 0, void 0, function* () {
      return yield this.close(), Ie;
    });
  }
  read(t) {
    return W(this, void 0, void 0, function* () {
      return (yield this.next(t, "read")).value;
    });
  }
  peek(t) {
    return W(this, void 0, void 0, function* () {
      return (yield this.next(t, "peek")).value;
    });
  }
  next(...t) {
    return this._values.length > 0 ? Promise.resolve({ done: !1, value: this._values.shift() }) : this._error ? Promise.reject({ done: !0, value: this._error.error }) : this._closedPromiseResolve ? new Promise((n, i) => {
      this.resolvers.push({ resolve: n, reject: i });
    }) : Promise.resolve(Ie);
  }
  _ensureOpen() {
    if (this._closedPromiseResolve)
      return !0;
    throw new Error("AsyncQueue is closed");
  }
}
class Kat extends Jat {
  write(t) {
    if ((t = Wt(t)).byteLength > 0)
      return super.write(t);
  }
  toString(t = !1) {
    return t ? nb(this.toUint8Array(!0)) : this.toUint8Array(!1).then(nb);
  }
  toUint8Array(t = !1) {
    return t ? yr(this._values)[0] : W(this, void 0, void 0, function* () {
      var n, i, r, s;
      const o = [];
      let a = 0;
      try {
        for (var c = !0, l = ci(this), u; u = yield l.next(), n = u.done, !n; c = !0) {
          s = u.value, c = !1;
          const f = s;
          o.push(f), a += f.byteLength;
        }
      } catch (f) {
        i = { error: f };
      } finally {
        try {
          !c && !n && (r = l.return) && (yield r.call(l));
        } finally {
          if (i)
            throw i.error;
        }
      }
      return yr(o, a)[0];
    });
  }
}
class Ty {
  constructor(t) {
    t && (this.source = new Zat(Zn.fromIterable(t)));
  }
  [Symbol.iterator]() {
    return this;
  }
  next(t) {
    return this.source.next(t);
  }
  throw(t) {
    return this.source.throw(t);
  }
  return(t) {
    return this.source.return(t);
  }
  peek(t) {
    return this.source.peek(t);
  }
  read(t) {
    return this.source.read(t);
  }
}
class Jc {
  constructor(t) {
    t instanceof Jc ? this.source = t.source : t instanceof Kat ? this.source = new bo(Zn.fromAsyncIterable(t)) : $L(t) ? this.source = new bo(Zn.fromNodeStream(t)) : i_(t) ? this.source = new bo(Zn.fromDOMStream(t)) : AL(t) ? this.source = new bo(Zn.fromDOMStream(t.body)) : H0(t) ? this.source = new bo(Zn.fromIterable(t)) : Qu(t) ? this.source = new bo(Zn.fromAsyncIterable(t)) : n_(t) && (this.source = new bo(Zn.fromAsyncIterable(t)));
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  next(t) {
    return this.source.next(t);
  }
  throw(t) {
    return this.source.throw(t);
  }
  return(t) {
    return this.source.return(t);
  }
  get closed() {
    return this.source.closed;
  }
  cancel(t) {
    return this.source.cancel(t);
  }
  peek(t) {
    return this.source.peek(t);
  }
  read(t) {
    return this.source.read(t);
  }
}
class Zat {
  constructor(t) {
    this.source = t;
  }
  cancel(t) {
    this.return(t);
  }
  peek(t) {
    return this.next(t, "peek").value;
  }
  read(t) {
    return this.next(t, "read").value;
  }
  next(t, n = "read") {
    return this.source.next({ cmd: n, size: t });
  }
  throw(t) {
    return Object.create(this.source.throw && this.source.throw(t) || Ie);
  }
  return(t) {
    return Object.create(this.source.return && this.source.return(t) || Ie);
  }
}
class bo {
  constructor(t) {
    this.source = t, this._closedPromise = new Promise((n) => this._closedPromiseResolve = n);
  }
  cancel(t) {
    return W(this, void 0, void 0, function* () {
      yield this.return(t);
    });
  }
  get closed() {
    return this._closedPromise;
  }
  read(t) {
    return W(this, void 0, void 0, function* () {
      return (yield this.next(t, "read")).value;
    });
  }
  peek(t) {
    return W(this, void 0, void 0, function* () {
      return (yield this.next(t, "peek")).value;
    });
  }
  next(t, n = "read") {
    return W(this, void 0, void 0, function* () {
      return yield this.source.next({ cmd: n, size: t });
    });
  }
  throw(t) {
    return W(this, void 0, void 0, function* () {
      const n = this.source.throw && (yield this.source.throw(t)) || Ie;
      return this._closedPromiseResolve && this._closedPromiseResolve(), this._closedPromiseResolve = void 0, Object.create(n);
    });
  }
  return(t) {
    return W(this, void 0, void 0, function* () {
      const n = this.source.return && (yield this.source.return(t)) || Ie;
      return this._closedPromiseResolve && this._closedPromiseResolve(), this._closedPromiseResolve = void 0, Object.create(n);
    });
  }
}
class SI extends Ty {
  constructor(t, n) {
    super(), this.position = 0, this.buffer = Wt(t), this.size = n === void 0 ? this.buffer.byteLength : n;
  }
  readInt32(t) {
    const { buffer: n, byteOffset: i } = this.readAt(t, 4);
    return new DataView(n, i).getInt32(0, !0);
  }
  seek(t) {
    return this.position = Math.min(t, this.size), t < this.size;
  }
  read(t) {
    const { buffer: n, size: i, position: r } = this;
    return n && r < i ? (typeof t != "number" && (t = Number.POSITIVE_INFINITY), this.position = Math.min(i, r + Math.min(i - r, t)), n.subarray(r, this.position)) : null;
  }
  readAt(t, n) {
    const i = this.buffer, r = Math.min(this.size, t + n);
    return i ? i.subarray(t, r) : new Uint8Array(n);
  }
  close() {
    this.buffer && (this.buffer = null);
  }
  throw(t) {
    return this.close(), { done: !0, value: t };
  }
  return(t) {
    return this.close(), { done: !0, value: t };
  }
}
class Dy extends Jc {
  constructor(t, n) {
    super(), this.position = 0, this._handle = t, typeof n == "number" ? this.size = n : this._pending = W(this, void 0, void 0, function* () {
      this.size = (yield t.stat()).size, delete this._pending;
    });
  }
  readInt32(t) {
    return W(this, void 0, void 0, function* () {
      const { buffer: n, byteOffset: i } = yield this.readAt(t, 4);
      return new DataView(n, i).getInt32(0, !0);
    });
  }
  seek(t) {
    return W(this, void 0, void 0, function* () {
      return this._pending && (yield this._pending), this.position = Math.min(t, this.size), t < this.size;
    });
  }
  read(t) {
    return W(this, void 0, void 0, function* () {
      this._pending && (yield this._pending);
      const { _handle: n, size: i, position: r } = this;
      if (n && r < i) {
        typeof t != "number" && (t = Number.POSITIVE_INFINITY);
        let s = r, o = 0, a = 0;
        const c = Math.min(i, s + Math.min(i - s, t)), l = new Uint8Array(Math.max(0, (this.position = c) - s));
        for (; (s += a) < c && (o += a) < l.byteLength; )
          ({ bytesRead: a } = yield n.read(l, o, l.byteLength - o, s));
        return l;
      }
      return null;
    });
  }
  readAt(t, n) {
    return W(this, void 0, void 0, function* () {
      this._pending && (yield this._pending);
      const { _handle: i, size: r } = this;
      if (i && t + n < r) {
        const s = Math.min(r, t + n), o = new Uint8Array(s - t);
        return (yield i.read(o, 0, n, t)).buffer;
      }
      return new Uint8Array(n);
    });
  }
  close() {
    return W(this, void 0, void 0, function* () {
      const t = this._handle;
      this._handle = null, t && (yield t.close());
    });
  }
  throw(t) {
    return W(this, void 0, void 0, function* () {
      return yield this.close(), { done: !0, value: t };
    });
  }
  return(t) {
    return W(this, void 0, void 0, function* () {
      return yield this.close(), { done: !0, value: t };
    });
  }
}
const Qat = 65536;
function sc(e) {
  return e < 0 && (e = 4294967295 + e + 1), `0x${e.toString(16)}`;
}
const Kc = 8, m_ = [
  1,
  10,
  100,
  1e3,
  1e4,
  1e5,
  1e6,
  1e7,
  1e8
];
class sC {
  constructor(t) {
    this.buffer = t;
  }
  high() {
    return this.buffer[1];
  }
  low() {
    return this.buffer[0];
  }
  _times(t) {
    const n = new Uint32Array([
      this.buffer[1] >>> 16,
      this.buffer[1] & 65535,
      this.buffer[0] >>> 16,
      this.buffer[0] & 65535
    ]), i = new Uint32Array([
      t.buffer[1] >>> 16,
      t.buffer[1] & 65535,
      t.buffer[0] >>> 16,
      t.buffer[0] & 65535
    ]);
    let r = n[3] * i[3];
    this.buffer[0] = r & 65535;
    let s = r >>> 16;
    return r = n[2] * i[3], s += r, r = n[3] * i[2] >>> 0, s += r, this.buffer[0] += s << 16, this.buffer[1] = s >>> 0 < r ? Qat : 0, this.buffer[1] += s >>> 16, this.buffer[1] += n[1] * i[3] + n[2] * i[2] + n[3] * i[1], this.buffer[1] += n[0] * i[3] + n[1] * i[2] + n[2] * i[1] + n[3] * i[0] << 16, this;
  }
  _plus(t) {
    const n = this.buffer[0] + t.buffer[0] >>> 0;
    this.buffer[1] += t.buffer[1], n < this.buffer[0] >>> 0 && ++this.buffer[1], this.buffer[0] = n;
  }
  lessThan(t) {
    return this.buffer[1] < t.buffer[1] || this.buffer[1] === t.buffer[1] && this.buffer[0] < t.buffer[0];
  }
  equals(t) {
    return this.buffer[1] === t.buffer[1] && this.buffer[0] == t.buffer[0];
  }
  greaterThan(t) {
    return t.lessThan(this);
  }
  hex() {
    return `${sc(this.buffer[1])} ${sc(this.buffer[0])}`;
  }
}
class ie extends sC {
  times(t) {
    return this._times(t), this;
  }
  plus(t) {
    return this._plus(t), this;
  }
  /** @nocollapse */
  static from(t, n = new Uint32Array(2)) {
    return ie.fromString(typeof t == "string" ? t : t.toString(), n);
  }
  /** @nocollapse */
  static fromNumber(t, n = new Uint32Array(2)) {
    return ie.fromString(t.toString(), n);
  }
  /** @nocollapse */
  static fromString(t, n = new Uint32Array(2)) {
    const i = t.length, r = new ie(n);
    for (let s = 0; s < i; ) {
      const o = Kc < i - s ? Kc : i - s, a = new ie(new Uint32Array([Number.parseInt(t.slice(s, s + o), 10), 0])), c = new ie(new Uint32Array([m_[o], 0]));
      r.times(c), r.plus(a), s += o;
    }
    return r;
  }
  /** @nocollapse */
  static convertArray(t) {
    const n = new Uint32Array(t.length * 2);
    for (let i = -1, r = t.length; ++i < r; )
      ie.from(t[i], new Uint32Array(n.buffer, n.byteOffset + 2 * i * 4, 2));
    return n;
  }
  /** @nocollapse */
  static multiply(t, n) {
    return new ie(new Uint32Array(t.buffer)).times(n);
  }
  /** @nocollapse */
  static add(t, n) {
    return new ie(new Uint32Array(t.buffer)).plus(n);
  }
}
class xn extends sC {
  negate() {
    return this.buffer[0] = ~this.buffer[0] + 1, this.buffer[1] = ~this.buffer[1], this.buffer[0] == 0 && ++this.buffer[1], this;
  }
  times(t) {
    return this._times(t), this;
  }
  plus(t) {
    return this._plus(t), this;
  }
  lessThan(t) {
    const n = this.buffer[1] << 0, i = t.buffer[1] << 0;
    return n < i || n === i && this.buffer[0] < t.buffer[0];
  }
  /** @nocollapse */
  static from(t, n = new Uint32Array(2)) {
    return xn.fromString(typeof t == "string" ? t : t.toString(), n);
  }
  /** @nocollapse */
  static fromNumber(t, n = new Uint32Array(2)) {
    return xn.fromString(t.toString(), n);
  }
  /** @nocollapse */
  static fromString(t, n = new Uint32Array(2)) {
    const i = t.startsWith("-"), r = t.length, s = new xn(n);
    for (let o = i ? 1 : 0; o < r; ) {
      const a = Kc < r - o ? Kc : r - o, c = new xn(new Uint32Array([Number.parseInt(t.slice(o, o + a), 10), 0])), l = new xn(new Uint32Array([m_[a], 0]));
      s.times(l), s.plus(c), o += a;
    }
    return i ? s.negate() : s;
  }
  /** @nocollapse */
  static convertArray(t) {
    const n = new Uint32Array(t.length * 2);
    for (let i = -1, r = t.length; ++i < r; )
      xn.from(t[i], new Uint32Array(n.buffer, n.byteOffset + 2 * i * 4, 2));
    return n;
  }
  /** @nocollapse */
  static multiply(t, n) {
    return new xn(new Uint32Array(t.buffer)).times(n);
  }
  /** @nocollapse */
  static add(t, n) {
    return new xn(new Uint32Array(t.buffer)).plus(n);
  }
}
class Xi {
  constructor(t) {
    this.buffer = t;
  }
  high() {
    return new xn(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));
  }
  low() {
    return new xn(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset, 2));
  }
  negate() {
    return this.buffer[0] = ~this.buffer[0] + 1, this.buffer[1] = ~this.buffer[1], this.buffer[2] = ~this.buffer[2], this.buffer[3] = ~this.buffer[3], this.buffer[0] == 0 && ++this.buffer[1], this.buffer[1] == 0 && ++this.buffer[2], this.buffer[2] == 0 && ++this.buffer[3], this;
  }
  times(t) {
    const n = new ie(new Uint32Array([this.buffer[3], 0])), i = new ie(new Uint32Array([this.buffer[2], 0])), r = new ie(new Uint32Array([this.buffer[1], 0])), s = new ie(new Uint32Array([this.buffer[0], 0])), o = new ie(new Uint32Array([t.buffer[3], 0])), a = new ie(new Uint32Array([t.buffer[2], 0])), c = new ie(new Uint32Array([t.buffer[1], 0])), l = new ie(new Uint32Array([t.buffer[0], 0]));
    let u = ie.multiply(s, l);
    this.buffer[0] = u.low();
    const f = new ie(new Uint32Array([u.high(), 0]));
    return u = ie.multiply(r, l), f.plus(u), u = ie.multiply(s, c), f.plus(u), this.buffer[1] = f.low(), this.buffer[3] = f.lessThan(u) ? 1 : 0, this.buffer[2] = f.high(), new ie(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2)).plus(ie.multiply(i, l)).plus(ie.multiply(r, c)).plus(ie.multiply(s, a)), this.buffer[3] += ie.multiply(n, l).plus(ie.multiply(i, c)).plus(ie.multiply(r, a)).plus(ie.multiply(s, o)).low(), this;
  }
  plus(t) {
    const n = new Uint32Array(4);
    return n[3] = this.buffer[3] + t.buffer[3] >>> 0, n[2] = this.buffer[2] + t.buffer[2] >>> 0, n[1] = this.buffer[1] + t.buffer[1] >>> 0, n[0] = this.buffer[0] + t.buffer[0] >>> 0, n[0] < this.buffer[0] >>> 0 && ++n[1], n[1] < this.buffer[1] >>> 0 && ++n[2], n[2] < this.buffer[2] >>> 0 && ++n[3], this.buffer[3] = n[3], this.buffer[2] = n[2], this.buffer[1] = n[1], this.buffer[0] = n[0], this;
  }
  hex() {
    return `${sc(this.buffer[3])} ${sc(this.buffer[2])} ${sc(this.buffer[1])} ${sc(this.buffer[0])}`;
  }
  /** @nocollapse */
  static multiply(t, n) {
    return new Xi(new Uint32Array(t.buffer)).times(n);
  }
  /** @nocollapse */
  static add(t, n) {
    return new Xi(new Uint32Array(t.buffer)).plus(n);
  }
  /** @nocollapse */
  static from(t, n = new Uint32Array(4)) {
    return Xi.fromString(typeof t == "string" ? t : t.toString(), n);
  }
  /** @nocollapse */
  static fromNumber(t, n = new Uint32Array(4)) {
    return Xi.fromString(t.toString(), n);
  }
  /** @nocollapse */
  static fromString(t, n = new Uint32Array(4)) {
    const i = t.startsWith("-"), r = t.length, s = new Xi(n);
    for (let o = i ? 1 : 0; o < r; ) {
      const a = Kc < r - o ? Kc : r - o, c = new Xi(new Uint32Array([Number.parseInt(t.slice(o, o + a), 10), 0, 0, 0])), l = new Xi(new Uint32Array([m_[a], 0, 0, 0]));
      s.times(l), s.plus(c), o += a;
    }
    return i ? s.negate() : s;
  }
  /** @nocollapse */
  static convertArray(t) {
    const n = new Uint32Array(t.length * 4);
    for (let i = -1, r = t.length; ++i < r; )
      Xi.from(t[i], new Uint32Array(n.buffer, n.byteOffset + 4 * 4 * i, 4));
    return n;
  }
}
class oC extends zt {
  constructor(t, n, i, r, s = Le.V5) {
    super(), this.nodesIndex = -1, this.buffersIndex = -1, this.bytes = t, this.nodes = n, this.buffers = i, this.dictionaries = r, this.metadataVersion = s;
  }
  visit(t) {
    return super.visit(t instanceof ge ? t.type : t);
  }
  visitNull(t, { length: n } = this.nextFieldNode()) {
    return Ct({ type: t, length: n });
  }
  visitBool(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return Ct({ type: t, length: n, nullCount: i, nullBitmap: this.readNullBitmap(t, i), data: this.readData(t) });
  }
  visitInt(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return Ct({ type: t, length: n, nullCount: i, nullBitmap: this.readNullBitmap(t, i), data: this.readData(t) });
  }
  visitFloat(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return Ct({ type: t, length: n, nullCount: i, nullBitmap: this.readNullBitmap(t, i), data: this.readData(t) });
  }
  visitUtf8(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return Ct({ type: t, length: n, nullCount: i, nullBitmap: this.readNullBitmap(t, i), valueOffsets: this.readOffsets(t), data: this.readData(t) });
  }
  visitLargeUtf8(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return Ct({ type: t, length: n, nullCount: i, nullBitmap: this.readNullBitmap(t, i), valueOffsets: this.readOffsets(t), data: this.readData(t) });
  }
  visitBinary(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return Ct({ type: t, length: n, nullCount: i, nullBitmap: this.readNullBitmap(t, i), valueOffsets: this.readOffsets(t), data: this.readData(t) });
  }
  visitLargeBinary(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return Ct({ type: t, length: n, nullCount: i, nullBitmap: this.readNullBitmap(t, i), valueOffsets: this.readOffsets(t), data: this.readData(t) });
  }
  visitFixedSizeBinary(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return Ct({ type: t, length: n, nullCount: i, nullBitmap: this.readNullBitmap(t, i), data: this.readData(t) });
  }
  visitDate(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return Ct({ type: t, length: n, nullCount: i, nullBitmap: this.readNullBitmap(t, i), data: this.readData(t) });
  }
  visitTimestamp(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return Ct({ type: t, length: n, nullCount: i, nullBitmap: this.readNullBitmap(t, i), data: this.readData(t) });
  }
  visitTime(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return Ct({ type: t, length: n, nullCount: i, nullBitmap: this.readNullBitmap(t, i), data: this.readData(t) });
  }
  visitDecimal(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return Ct({ type: t, length: n, nullCount: i, nullBitmap: this.readNullBitmap(t, i), data: this.readData(t) });
  }
  visitList(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return Ct({ type: t, length: n, nullCount: i, nullBitmap: this.readNullBitmap(t, i), valueOffsets: this.readOffsets(t), child: this.visit(t.children[0]) });
  }
  visitStruct(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return Ct({ type: t, length: n, nullCount: i, nullBitmap: this.readNullBitmap(t, i), children: this.visitMany(t.children) });
  }
  visitUnion(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return this.metadataVersion < Le.V5 && this.readNullBitmap(t, i), t.mode === On.Sparse ? this.visitSparseUnion(t, { length: n, nullCount: i }) : this.visitDenseUnion(t, { length: n, nullCount: i });
  }
  visitDenseUnion(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return Ct({ type: t, length: n, nullCount: i, typeIds: this.readTypeIds(t), valueOffsets: this.readOffsets(t), children: this.visitMany(t.children) });
  }
  visitSparseUnion(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return Ct({ type: t, length: n, nullCount: i, typeIds: this.readTypeIds(t), children: this.visitMany(t.children) });
  }
  visitDictionary(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return Ct({ type: t, length: n, nullCount: i, nullBitmap: this.readNullBitmap(t, i), data: this.readData(t.indices), dictionary: this.readDictionary(t) });
  }
  visitInterval(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return Ct({ type: t, length: n, nullCount: i, nullBitmap: this.readNullBitmap(t, i), data: this.readData(t) });
  }
  visitDuration(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return Ct({ type: t, length: n, nullCount: i, nullBitmap: this.readNullBitmap(t, i), data: this.readData(t) });
  }
  visitFixedSizeList(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return Ct({ type: t, length: n, nullCount: i, nullBitmap: this.readNullBitmap(t, i), child: this.visit(t.children[0]) });
  }
  visitMap(t, { length: n, nullCount: i } = this.nextFieldNode()) {
    return Ct({ type: t, length: n, nullCount: i, nullBitmap: this.readNullBitmap(t, i), valueOffsets: this.readOffsets(t), child: this.visit(t.children[0]) });
  }
  nextFieldNode() {
    return this.nodes[++this.nodesIndex];
  }
  nextBufferRange() {
    return this.buffers[++this.buffersIndex];
  }
  readNullBitmap(t, n, i = this.nextBufferRange()) {
    return n > 0 && this.readData(t, i) || new Uint8Array(0);
  }
  readOffsets(t, n) {
    return this.readData(t, n);
  }
  readTypeIds(t, n) {
    return this.readData(t, n);
  }
  readData(t, { length: n, offset: i } = this.nextBufferRange()) {
    return this.bytes.subarray(i, i + n);
  }
  readDictionary(t) {
    return this.dictionaries.get(t.id);
  }
}
class tct extends oC {
  constructor(t, n, i, r, s) {
    super(new Uint8Array(0), n, i, r, s), this.sources = t;
  }
  readNullBitmap(t, n, { offset: i } = this.nextBufferRange()) {
    return n <= 0 ? new Uint8Array(0) : ab(this.sources[i]);
  }
  readOffsets(t, { offset: n } = this.nextBufferRange()) {
    return se(Uint8Array, se(t.OffsetArrayType, this.sources[n]));
  }
  readTypeIds(t, { offset: n } = this.nextBufferRange()) {
    return se(Uint8Array, se(t.ArrayType, this.sources[n]));
  }
  readData(t, { offset: n } = this.nextBufferRange()) {
    const { sources: i } = this;
    return ot.isTimestamp(t) || (ot.isInt(t) || ot.isTime(t)) && t.bitWidth === 64 || ot.isDuration(t) || ot.isDate(t) && t.unit === Fi.MILLISECOND ? se(Uint8Array, xn.convertArray(i[n])) : ot.isDecimal(t) ? se(Uint8Array, Xi.convertArray(i[n])) : ot.isBinary(t) || ot.isLargeBinary(t) || ot.isFixedSizeBinary(t) ? ect(i[n]) : ot.isBool(t) ? ab(i[n]) : ot.isUtf8(t) || ot.isLargeUtf8(t) ? e_(i[n].join("")) : se(Uint8Array, se(t.ArrayType, i[n].map((r) => +r)));
  }
}
function ect(e) {
  const t = e.join(""), n = new Uint8Array(t.length / 2);
  for (let i = 0; i < t.length; i += 2)
    n[i >> 1] = Number.parseInt(t.slice(i, i + 2), 16);
  return n;
}
class yt extends zt {
  compareSchemas(t, n) {
    return t === n || n instanceof t.constructor && this.compareManyFields(t.fields, n.fields);
  }
  compareManyFields(t, n) {
    return t === n || Array.isArray(t) && Array.isArray(n) && t.length === n.length && t.every((i, r) => this.compareFields(i, n[r]));
  }
  compareFields(t, n) {
    return t === n || n instanceof t.constructor && t.name === n.name && t.nullable === n.nullable && this.visit(t.type, n.type);
  }
}
function _n(e, t) {
  return t instanceof e.constructor;
}
function da(e, t) {
  return e === t || _n(e, t);
}
function bs(e, t) {
  return e === t || _n(e, t) && e.bitWidth === t.bitWidth && e.isSigned === t.isSigned;
}
function K0(e, t) {
  return e === t || _n(e, t) && e.precision === t.precision;
}
function nct(e, t) {
  return e === t || _n(e, t) && e.byteWidth === t.byteWidth;
}
function g_(e, t) {
  return e === t || _n(e, t) && e.unit === t.unit;
}
function Hf(e, t) {
  return e === t || _n(e, t) && e.unit === t.unit && e.timezone === t.timezone;
}
function Jf(e, t) {
  return e === t || _n(e, t) && e.unit === t.unit && e.bitWidth === t.bitWidth;
}
function ict(e, t) {
  return e === t || _n(e, t) && e.children.length === t.children.length && no.compareManyFields(e.children, t.children);
}
function rct(e, t) {
  return e === t || _n(e, t) && e.children.length === t.children.length && no.compareManyFields(e.children, t.children);
}
function b_(e, t) {
  return e === t || _n(e, t) && e.mode === t.mode && e.typeIds.every((n, i) => n === t.typeIds[i]) && no.compareManyFields(e.children, t.children);
}
function sct(e, t) {
  return e === t || _n(e, t) && e.id === t.id && e.isOrdered === t.isOrdered && no.visit(e.indices, t.indices) && no.visit(e.dictionary, t.dictionary);
}
function w_(e, t) {
  return e === t || _n(e, t) && e.unit === t.unit;
}
function Kf(e, t) {
  return e === t || _n(e, t) && e.unit === t.unit;
}
function oct(e, t) {
  return e === t || _n(e, t) && e.listSize === t.listSize && e.children.length === t.children.length && no.compareManyFields(e.children, t.children);
}
function act(e, t) {
  return e === t || _n(e, t) && e.keysSorted === t.keysSorted && e.children.length === t.children.length && no.compareManyFields(e.children, t.children);
}
yt.prototype.visitNull = da;
yt.prototype.visitBool = da;
yt.prototype.visitInt = bs;
yt.prototype.visitInt8 = bs;
yt.prototype.visitInt16 = bs;
yt.prototype.visitInt32 = bs;
yt.prototype.visitInt64 = bs;
yt.prototype.visitUint8 = bs;
yt.prototype.visitUint16 = bs;
yt.prototype.visitUint32 = bs;
yt.prototype.visitUint64 = bs;
yt.prototype.visitFloat = K0;
yt.prototype.visitFloat16 = K0;
yt.prototype.visitFloat32 = K0;
yt.prototype.visitFloat64 = K0;
yt.prototype.visitUtf8 = da;
yt.prototype.visitLargeUtf8 = da;
yt.prototype.visitBinary = da;
yt.prototype.visitLargeBinary = da;
yt.prototype.visitFixedSizeBinary = nct;
yt.prototype.visitDate = g_;
yt.prototype.visitDateDay = g_;
yt.prototype.visitDateMillisecond = g_;
yt.prototype.visitTimestamp = Hf;
yt.prototype.visitTimestampSecond = Hf;
yt.prototype.visitTimestampMillisecond = Hf;
yt.prototype.visitTimestampMicrosecond = Hf;
yt.prototype.visitTimestampNanosecond = Hf;
yt.prototype.visitTime = Jf;
yt.prototype.visitTimeSecond = Jf;
yt.prototype.visitTimeMillisecond = Jf;
yt.prototype.visitTimeMicrosecond = Jf;
yt.prototype.visitTimeNanosecond = Jf;
yt.prototype.visitDecimal = da;
yt.prototype.visitList = ict;
yt.prototype.visitStruct = rct;
yt.prototype.visitUnion = b_;
yt.prototype.visitDenseUnion = b_;
yt.prototype.visitSparseUnion = b_;
yt.prototype.visitDictionary = sct;
yt.prototype.visitInterval = w_;
yt.prototype.visitIntervalDayTime = w_;
yt.prototype.visitIntervalYearMonth = w_;
yt.prototype.visitDuration = Kf;
yt.prototype.visitDurationSecond = Kf;
yt.prototype.visitDurationMillisecond = Kf;
yt.prototype.visitDurationMicrosecond = Kf;
yt.prototype.visitDurationNanosecond = Kf;
yt.prototype.visitFixedSizeList = oct;
yt.prototype.visitMap = act;
const no = new yt();
function cct(e, t) {
  return no.compareSchemas(e, t);
}
function hg(e, t) {
  return lct(e, t.map((n) => n.data.concat()));
}
function lct(e, t) {
  const n = [...e.fields], i = [], r = { numBatches: t.reduce((f, h) => Math.max(f, h.length), 0) };
  let s = 0, o = 0, a = -1;
  const c = t.length;
  let l, u = [];
  for (; r.numBatches-- > 0; ) {
    for (o = Number.POSITIVE_INFINITY, a = -1; ++a < c; )
      u[a] = l = t[a].shift(), o = Math.min(o, l ? l.length : o);
    Number.isFinite(o) && (u = uct(n, o, u, t, r), o > 0 && (i[s++] = Ct({
      type: new hn(n),
      length: o,
      nullCount: 0,
      children: u.slice()
    })));
  }
  return [
    e = e.assign(n),
    i.map((f) => new wi(e, f))
  ];
}
function uct(e, t, n, i, r) {
  var s;
  const o = (t + 63 & -64) >> 3;
  for (let a = -1, c = i.length; ++a < c; ) {
    const l = n[a], u = l == null ? void 0 : l.length;
    if (u >= t)
      u === t ? n[a] = l : (n[a] = l.slice(0, t), r.numBatches = Math.max(r.numBatches, i[a].unshift(l.slice(t, u - t))));
    else {
      const f = e[a];
      e[a] = f.clone({ nullable: !0 }), n[a] = (s = l == null ? void 0 : l._changeLengthAndBackfillNullBitmap(t)) !== null && s !== void 0 ? s : Ct({
        type: f.type,
        length: t,
        nullCount: t,
        nullBitmap: new Uint8Array(o)
      });
    }
  }
  return n;
}
var aC;
class ei {
  constructor(...t) {
    var n, i;
    if (t.length === 0)
      return this.batches = [], this.schema = new ee([]), this._offsets = [0], this;
    let r, s;
    t[0] instanceof ee && (r = t.shift()), t.at(-1) instanceof Uint32Array && (s = t.pop());
    const o = (c) => {
      if (c) {
        if (c instanceof wi)
          return [c];
        if (c instanceof ei)
          return c.batches;
        if (c instanceof ne) {
          if (c.type instanceof hn)
            return [new wi(new ee(c.type.children), c)];
        } else {
          if (Array.isArray(c))
            return c.flatMap((l) => o(l));
          if (typeof c[Symbol.iterator] == "function")
            return [...c].flatMap((l) => o(l));
          if (typeof c == "object") {
            const l = Object.keys(c), u = l.map((d) => new ae([c[d]])), f = r ?? new ee(l.map((d, p) => new ge(String(d), u[p].type, u[p].nullable))), [, h] = hg(f, u);
            return h.length === 0 ? [new wi(c)] : h;
          }
        }
      }
      return [];
    }, a = t.flatMap((c) => o(c));
    if (r = (i = r ?? ((n = a[0]) === null || n === void 0 ? void 0 : n.schema)) !== null && i !== void 0 ? i : new ee([]), !(r instanceof ee))
      throw new TypeError("Table constructor expects a [Schema, RecordBatch[]] pair.");
    for (const c of a) {
      if (!(c instanceof wi))
        throw new TypeError("Table constructor expects a [Schema, RecordBatch[]] pair.");
      if (!cct(r, c.schema))
        throw new TypeError("Table and inner RecordBatch schemas must be equivalent.");
    }
    this.schema = r, this.batches = a, this._offsets = s ?? JR(this.data);
  }
  /**
   * The contiguous {@link RecordBatch `RecordBatch`} chunks of the Table rows.
   */
  get data() {
    return this.batches.map(({ data: t }) => t);
  }
  /**
   * The number of columns in this Table.
   */
  get numCols() {
    return this.schema.fields.length;
  }
  /**
   * The number of rows in this Table.
   */
  get numRows() {
    return this.data.reduce((t, n) => t + n.length, 0);
  }
  /**
   * The number of null rows in this Table.
   */
  get nullCount() {
    return this._nullCount === -1 && (this._nullCount = HR(this.data)), this._nullCount;
  }
  /**
   * Check whether an element is null.
   *
   * @param index The index at which to read the validity bitmap.
   */
  // @ts-ignore
  isValid(t) {
    return !1;
  }
  /**
   * Get an element value by position.
   *
   * @param index The index of the element to read.
   */
  // @ts-ignore
  get(t) {
    return null;
  }
  /**
   * Set an element value by position.
   *
   * @param index The index of the element to write.
   * @param value The value to set.
   */
  // @ts-ignore
  set(t, n) {
  }
  /**
   * Retrieve the index of the first occurrence of a value in an Vector.
   *
   * @param element The value to locate in the Vector.
   * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
   */
  // @ts-ignore
  indexOf(t, n) {
    return -1;
  }
  /**
   * Iterator for rows in this Table.
   */
  [Symbol.iterator]() {
    return this.batches.length > 0 ? p_.visit(new ae(this.data)) : new Array(0)[Symbol.iterator]();
  }
  /**
   * Return a JavaScript Array of the Table rows.
   *
   * @returns An Array of Table rows.
   */
  toArray() {
    return [...this];
  }
  /**
   * Returns a string representation of the Table rows.
   *
   * @returns A string representation of the Table rows.
   */
  toString() {
    return `[
  ${this.toArray().join(`,
  `)}
]`;
  }
  /**
   * Combines two or more Tables of the same schema.
   *
   * @param others Additional Tables to add to the end of this Tables.
   */
  concat(...t) {
    const n = this.schema, i = this.data.concat(t.flatMap(({ data: r }) => r));
    return new ei(n, i.map((r) => new wi(n, r)));
  }
  /**
   * Return a zero-copy sub-section of this Table.
   *
   * @param begin The beginning of the specified portion of the Table.
   * @param end The end of the specified portion of the Table. This is exclusive of the element at the index 'end'.
   */
  slice(t, n) {
    const i = this.schema;
    [t, n] = GR({ length: this.numRows }, t, n);
    const r = KR(this.data, this._offsets, t, n);
    return new ei(i, r.map((s) => new wi(i, s)));
  }
  /**
   * Returns a child Vector by name, or null if this Vector has no child with the given name.
   *
   * @param name The name of the child to retrieve.
   */
  getChild(t) {
    return this.getChildAt(this.schema.fields.findIndex((n) => n.name === t));
  }
  /**
   * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
   *
   * @param index The index of the child to retrieve.
   */
  getChildAt(t) {
    if (t > -1 && t < this.schema.fields.length) {
      const n = this.data.map((i) => i.children[t]);
      if (n.length === 0) {
        const { type: i } = this.schema.fields[t], r = Ct({ type: i, length: 0, nullCount: 0 });
        n.push(r._changeLengthAndBackfillNullBitmap(this.numRows));
      }
      return new ae(n);
    }
    return null;
  }
  /**
   * Sets a child Vector by name.
   *
   * @param name The name of the child to overwrite.
   * @returns A new Table with the supplied child for the specified name.
   */
  setChild(t, n) {
    var i;
    return this.setChildAt((i = this.schema.fields) === null || i === void 0 ? void 0 : i.findIndex((r) => r.name === t), n);
  }
  setChildAt(t, n) {
    let i = this.schema, r = [...this.batches];
    if (t > -1 && t < this.numCols) {
      n || (n = new ae([Ct({ type: new to(), length: this.numRows })]));
      const s = i.fields.slice(), o = s[t].clone({ type: n.type }), a = this.schema.fields.map((c, l) => this.getChildAt(l));
      [s[t], a[t]] = [o, n], [i, r] = hg(i, a);
    }
    return new ei(i, r);
  }
  /**
   * Construct a new Table containing only specified columns.
   *
   * @param columnNames Names of columns to keep.
   * @returns A new Table of columns matching the specified names.
   */
  select(t) {
    const n = this.schema.fields.reduce((i, r, s) => i.set(r.name, s), /* @__PURE__ */ new Map());
    return this.selectAt(t.map((i) => n.get(i)).filter((i) => i > -1));
  }
  /**
   * Construct a new Table containing only columns at the specified indices.
   *
   * @param columnIndices Indices of columns to keep.
   * @returns A new Table of columns at the specified indices.
   */
  selectAt(t) {
    const n = this.schema.selectAt(t), i = this.batches.map((r) => r.selectAt(t));
    return new ei(n, i);
  }
  assign(t) {
    const n = this.schema.fields, [i, r] = t.schema.fields.reduce((a, c, l) => {
      const [u, f] = a, h = n.findIndex((d) => d.name === c.name);
      return ~h ? f[h] = l : u.push(l), a;
    }, [[], []]), s = this.schema.assign(t.schema), o = [
      ...n.map((a, c) => [c, r[c]]).map(([a, c]) => c === void 0 ? this.getChildAt(a) : t.getChildAt(c)),
      ...i.map((a) => t.getChildAt(a))
    ].filter(Boolean);
    return new ei(...hg(s, o));
  }
}
aC = Symbol.toStringTag;
ei[aC] = ((e) => (e.schema = null, e.batches = [], e._offsets = new Uint32Array([0]), e._nullCount = -1, e[Symbol.isConcatSpreadable] = !0, e.isValid = Ay(d_), e.get = Ay(Fn.getVisitFn(E.Struct)), e.set = ZR(hi.getVisitFn(E.Struct)), e.indexOf = QR(My.getVisitFn(E.Struct)), "Table"))(ei.prototype);
var cC;
let wi = class ou {
  constructor(...t) {
    switch (t.length) {
      case 2: {
        if ([this.schema] = t, !(this.schema instanceof ee))
          throw new TypeError("RecordBatch constructor expects a [Schema, Data] pair.");
        if ([
          ,
          this.data = Ct({
            nullCount: 0,
            type: new hn(this.schema.fields),
            children: this.schema.fields.map((n) => Ct({ type: n.type, nullCount: 0 }))
          })
        ] = t, !(this.data instanceof ne))
          throw new TypeError("RecordBatch constructor expects a [Schema, Data] pair.");
        [this.schema, this.data] = xI(this.schema, this.data.children);
        break;
      }
      case 1: {
        const [n] = t, { fields: i, children: r, length: s } = Object.keys(n).reduce((c, l, u) => (c.children[u] = n[l], c.length = Math.max(c.length, n[l].length), c.fields[u] = ge.new({ name: l, type: n[l].type, nullable: !0 }), c), {
          length: 0,
          fields: new Array(),
          children: new Array()
        }), o = new ee(i), a = Ct({ type: new hn(i), length: s, children: r, nullCount: 0 });
        [this.schema, this.data] = xI(o, a.children, s);
        break;
      }
      default:
        throw new TypeError("RecordBatch constructor expects an Object mapping names to child Data, or a [Schema, Data] pair.");
    }
  }
  get dictionaries() {
    return this._dictionaries || (this._dictionaries = lC(this.schema.fields, this.data.children));
  }
  /**
   * The number of columns in this RecordBatch.
   */
  get numCols() {
    return this.schema.fields.length;
  }
  /**
   * The number of rows in this RecordBatch.
   */
  get numRows() {
    return this.data.length;
  }
  /**
   * The number of null rows in this RecordBatch.
   */
  get nullCount() {
    return this.data.nullCount;
  }
  /**
   * Check whether an element is null.
   * @param index The index at which to read the validity bitmap.
   */
  isValid(t) {
    return this.data.getValid(t);
  }
  /**
   * Get a row by position.
   * @param index The index of the element to read.
   */
  get(t) {
    return Fn.visit(this.data, t);
  }
  /**
   * Set a row by position.
   * @param index The index of the element to write.
   * @param value The value to set.
   */
  set(t, n) {
    return hi.visit(this.data, t, n);
  }
  /**
   * Retrieve the index of the first occurrence of a row in an RecordBatch.
   * @param element The row to locate in the RecordBatch.
   * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
   */
  indexOf(t, n) {
    return My.visit(this.data, t, n);
  }
  /**
   * Iterator for rows in this RecordBatch.
   */
  [Symbol.iterator]() {
    return p_.visit(new ae([this.data]));
  }
  /**
   * Return a JavaScript Array of the RecordBatch rows.
   * @returns An Array of RecordBatch rows.
   */
  toArray() {
    return [...this];
  }
  /**
   * Combines two or more RecordBatch of the same schema.
   * @param others Additional RecordBatch to add to the end of this RecordBatch.
   */
  concat(...t) {
    return new ei(this.schema, [this, ...t]);
  }
  /**
   * Return a zero-copy sub-section of this RecordBatch.
   * @param start The beginning of the specified portion of the RecordBatch.
   * @param end The end of the specified portion of the RecordBatch. This is exclusive of the element at the index 'end'.
   */
  slice(t, n) {
    const [i] = new ae([this.data]).slice(t, n).data;
    return new ou(this.schema, i);
  }
  /**
   * Returns a child Vector by name, or null if this Vector has no child with the given name.
   * @param name The name of the child to retrieve.
   */
  getChild(t) {
    var n;
    return this.getChildAt((n = this.schema.fields) === null || n === void 0 ? void 0 : n.findIndex((i) => i.name === t));
  }
  /**
   * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
   * @param index The index of the child to retrieve.
   */
  getChildAt(t) {
    return t > -1 && t < this.schema.fields.length ? new ae([this.data.children[t]]) : null;
  }
  /**
   * Sets a child Vector by name.
   * @param name The name of the child to overwrite.
   * @returns A new RecordBatch with the new child for the specified name.
   */
  setChild(t, n) {
    var i;
    return this.setChildAt((i = this.schema.fields) === null || i === void 0 ? void 0 : i.findIndex((r) => r.name === t), n);
  }
  setChildAt(t, n) {
    let i = this.schema, r = this.data;
    if (t > -1 && t < this.numCols) {
      n || (n = new ae([Ct({ type: new to(), length: this.numRows })]));
      const s = i.fields.slice(), o = r.children.slice(), a = s[t].clone({ type: n.type });
      [s[t], o[t]] = [a, n.data[0]], i = new ee(s, new Map(this.schema.metadata)), r = Ct({ type: new hn(s), children: o });
    }
    return new ou(i, r);
  }
  /**
   * Construct a new RecordBatch containing only specified columns.
   *
   * @param columnNames Names of columns to keep.
   * @returns A new RecordBatch of columns matching the specified names.
   */
  select(t) {
    const n = this.schema.select(t), i = new hn(n.fields), r = [];
    for (const s of t) {
      const o = this.schema.fields.findIndex((a) => a.name === s);
      ~o && (r[o] = this.data.children[o]);
    }
    return new ou(n, Ct({ type: i, length: this.numRows, children: r }));
  }
  /**
   * Construct a new RecordBatch containing only columns at the specified indices.
   *
   * @param columnIndices Indices of columns to keep.
   * @returns A new RecordBatch of columns matching at the specified indices.
   */
  selectAt(t) {
    const n = this.schema.selectAt(t), i = t.map((s) => this.data.children[s]).filter(Boolean), r = Ct({ type: new hn(n.fields), length: this.numRows, children: i });
    return new ou(n, r);
  }
};
cC = Symbol.toStringTag;
wi[cC] = ((e) => (e._nullCount = -1, e[Symbol.isConcatSpreadable] = !0, "RecordBatch"))(wi.prototype);
function xI(e, t, n = t.reduce((i, r) => Math.max(i, r.length), 0)) {
  var i;
  const r = [...e.fields], s = [...t], o = (n + 63 & -64) >> 3;
  for (const [a, c] of e.fields.entries()) {
    const l = t[a];
    (!l || l.length !== n) && (r[a] = c.clone({ nullable: !0 }), s[a] = (i = l == null ? void 0 : l._changeLengthAndBackfillNullBitmap(n)) !== null && i !== void 0 ? i : Ct({
      type: c.type,
      length: n,
      nullCount: n,
      nullBitmap: new Uint8Array(o)
    }));
  }
  return [
    e.assign(r),
    Ct({ type: new hn(r), length: n, children: s })
  ];
}
function lC(e, t, n = /* @__PURE__ */ new Map()) {
  var i, r;
  if (((i = e == null ? void 0 : e.length) !== null && i !== void 0 ? i : 0) > 0 && (e == null ? void 0 : e.length) === (t == null ? void 0 : t.length))
    for (let s = -1, o = e.length; ++s < o; ) {
      const { type: a } = e[s], c = t[s];
      for (const l of [c, ...((r = c == null ? void 0 : c.dictionary) === null || r === void 0 ? void 0 : r.data) || []])
        lC(a.children, l == null ? void 0 : l.children, n);
      if (ot.isDictionary(a)) {
        const { id: l } = a;
        if (!n.has(l))
          c != null && c.dictionary && n.set(l, c.dictionary);
        else if (n.get(l) !== c.dictionary)
          throw new Error("Cannot create Schema containing two different dictionaries with the same Id");
      }
    }
  return n;
}
class uC extends wi {
  constructor(t) {
    const n = t.fields.map((r) => Ct({ type: r.type })), i = Ct({ type: new hn(t.fields), nullCount: 0, children: n });
    super(t, i);
  }
}
let _s = class qi {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, n) {
    return this.bb_pos = t, this.bb = n, this;
  }
  static getRootAsMessage(t, n) {
    return (n || new qi()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsMessage(t, n) {
    return t.setPosition(t.position() + nt), (n || new qi()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  version() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt16(this.bb_pos + t) : Le.V1;
  }
  headerType() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.readUint8(this.bb_pos + t) : te.NONE;
  }
  header(t) {
    const n = this.bb.__offset(this.bb_pos, 8);
    return n ? this.bb.__union(t, this.bb_pos + n) : null;
  }
  bodyLength() {
    const t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.readInt64(this.bb_pos + t) : BigInt("0");
  }
  customMetadata(t, n) {
    const i = this.bb.__offset(this.bb_pos, 12);
    return i ? (n || new Ce()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + t * 4), this.bb) : null;
  }
  customMetadataLength() {
    const t = this.bb.__offset(this.bb_pos, 12);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  static startMessage(t) {
    t.startObject(5);
  }
  static addVersion(t, n) {
    t.addFieldInt16(0, n, Le.V1);
  }
  static addHeaderType(t, n) {
    t.addFieldInt8(1, n, te.NONE);
  }
  static addHeader(t, n) {
    t.addFieldOffset(2, n, 0);
  }
  static addBodyLength(t, n) {
    t.addFieldInt64(3, n, BigInt("0"));
  }
  static addCustomMetadata(t, n) {
    t.addFieldOffset(4, n, 0);
  }
  static createCustomMetadataVector(t, n) {
    t.startVector(4, n.length, 4);
    for (let i = n.length - 1; i >= 0; i--)
      t.addOffset(n[i]);
    return t.endVector();
  }
  static startCustomMetadataVector(t, n) {
    t.startVector(4, n, 4);
  }
  static endMessage(t) {
    return t.endObject();
  }
  static finishMessageBuffer(t, n) {
    t.finish(n);
  }
  static finishSizePrefixedMessageBuffer(t, n) {
    t.finish(n, void 0, !0);
  }
  static createMessage(t, n, i, r, s, o) {
    return qi.startMessage(t), qi.addVersion(t, n), qi.addHeaderType(t, i), qi.addHeader(t, r), qi.addBodyLength(t, s), qi.addCustomMetadata(t, o), qi.endMessage(t);
  }
};
class fct extends zt {
  visit(t, n) {
    return t == null || n == null ? void 0 : super.visit(t, n);
  }
  visitNull(t, n) {
    return dI.startNull(n), dI.endNull(n);
  }
  visitInt(t, n) {
    return Cn.startInt(n), Cn.addBitWidth(n, t.bitWidth), Cn.addIsSigned(n, t.isSigned), Cn.endInt(n);
  }
  visitFloat(t, n) {
    return tr.startFloatingPoint(n), tr.addPrecision(n, t.precision), tr.endFloatingPoint(n);
  }
  visitBinary(t, n) {
    return cI.startBinary(n), cI.endBinary(n);
  }
  visitLargeBinary(t, n) {
    return uI.startLargeBinary(n), uI.endLargeBinary(n);
  }
  visitBool(t, n) {
    return lI.startBool(n), lI.endBool(n);
  }
  visitUtf8(t, n) {
    return pI.startUtf8(n), pI.endUtf8(n);
  }
  visitLargeUtf8(t, n) {
    return fI.startLargeUtf8(n), fI.endLargeUtf8(n);
  }
  visitDecimal(t, n) {
    return qa.startDecimal(n), qa.addScale(n, t.scale), qa.addPrecision(n, t.precision), qa.addBitWidth(n, t.bitWidth), qa.endDecimal(n);
  }
  visitDate(t, n) {
    return ud.startDate(n), ud.addUnit(n, t.unit), ud.endDate(n);
  }
  visitTime(t, n) {
    return Qn.startTime(n), Qn.addUnit(n, t.unit), Qn.addBitWidth(n, t.bitWidth), Qn.endTime(n);
  }
  visitTimestamp(t, n) {
    const i = t.timezone && n.createString(t.timezone) || void 0;
    return ti.startTimestamp(n), ti.addUnit(n, t.unit), i !== void 0 && ti.addTimezone(n, i), ti.endTimestamp(n);
  }
  visitInterval(t, n) {
    return er.startInterval(n), er.addUnit(n, t.unit), er.endInterval(n);
  }
  visitDuration(t, n) {
    return fd.startDuration(n), fd.addUnit(n, t.unit), fd.endDuration(n);
  }
  visitList(t, n) {
    return hI.startList(n), hI.endList(n);
  }
  visitStruct(t, n) {
    return ko.startStruct_(n), ko.endStruct_(n);
  }
  visitUnion(t, n) {
    In.startTypeIdsVector(n, t.typeIds.length);
    const i = In.createTypeIdsVector(n, t.typeIds);
    return In.startUnion(n), In.addMode(n, t.mode), In.addTypeIds(n, i), In.endUnion(n);
  }
  visitDictionary(t, n) {
    const i = this.visit(t.indices, n);
    return qr.startDictionaryEncoding(n), qr.addId(n, BigInt(t.id)), qr.addIsOrdered(n, t.isOrdered), i !== void 0 && qr.addIndexType(n, i), qr.endDictionaryEncoding(n);
  }
  visitFixedSizeBinary(t, n) {
    return hd.startFixedSizeBinary(n), hd.addByteWidth(n, t.byteWidth), hd.endFixedSizeBinary(n);
  }
  visitFixedSizeList(t, n) {
    return dd.startFixedSizeList(n), dd.addListSize(n, t.listSize), dd.endFixedSizeList(n);
  }
  visitMap(t, n) {
    return pd.startMap(n), pd.addKeysSorted(n, t.keysSorted), pd.endMap(n);
  }
}
const dg = new fct();
function hct(e, t = /* @__PURE__ */ new Map()) {
  return new ee(pct(e, t), md(e.metadata), t);
}
function fC(e) {
  return new Ei(e.count, hC(e.columns), dC(e.columns));
}
function dct(e) {
  return new as(fC(e.data), e.id, e.isDelta);
}
function pct(e, t) {
  return (e.fields || []).filter(Boolean).map((n) => ge.fromJSON(n, t));
}
function II(e, t) {
  return (e.children || []).filter(Boolean).map((n) => ge.fromJSON(n, t));
}
function hC(e) {
  return (e || []).reduce((t, n) => [
    ...t,
    new gl(n.count, yct(n.VALIDITY)),
    ...hC(n.children)
  ], []);
}
function dC(e, t = []) {
  for (let n = -1, i = (e || []).length; ++n < i; ) {
    const r = e[n];
    r.VALIDITY && t.push(new Kr(t.length, r.VALIDITY.length)), r.TYPE_ID && t.push(new Kr(t.length, r.TYPE_ID.length)), r.OFFSET && t.push(new Kr(t.length, r.OFFSET.length)), r.DATA && t.push(new Kr(t.length, r.DATA.length)), t = dC(r.children, t);
  }
  return t;
}
function yct(e) {
  return (e || []).reduce((t, n) => t + +(n === 0), 0);
}
function mct(e, t) {
  let n, i, r, s, o, a;
  return !t || !(s = e.dictionary) ? (o = MI(e, II(e, t)), r = new ge(e.name, o, e.nullable, md(e.metadata))) : t.has(n = s.id) ? (i = (i = s.indexType) ? AI(i) : new rf(), a = new Xc(t.get(n), i, n, s.isOrdered), r = new ge(e.name, a, e.nullable, md(e.metadata))) : (i = (i = s.indexType) ? AI(i) : new rf(), t.set(n, o = MI(e, II(e, t))), a = new Xc(o, i, n, s.isOrdered), r = new ge(e.name, a, e.nullable, md(e.metadata))), r || null;
}
function md(e = []) {
  return new Map(e.map(({ key: t, value: n }) => [t, n]));
}
function AI(e) {
  return new eo(e.isSigned, e.bitWidth);
}
function MI(e, t) {
  const n = e.type.name;
  switch (n) {
    case "NONE":
      return new to();
    case "null":
      return new to();
    case "binary":
      return new uy();
    case "largebinary":
      return new fy();
    case "utf8":
      return new hy();
    case "largeutf8":
      return new dy();
    case "bool":
      return new py();
    case "list":
      return new vy((t || [])[0]);
    case "struct":
      return new hn(t || []);
    case "struct_":
      return new hn(t || []);
  }
  switch (n) {
    case "int": {
      const i = e.type;
      return new eo(i.isSigned, i.bitWidth);
    }
    case "floatingpoint": {
      const i = e.type;
      return new sf(rn[i.precision]);
    }
    case "decimal": {
      const i = e.type;
      return new yy(i.scale, i.precision, i.bitWidth);
    }
    case "date": {
      const i = e.type;
      return new my(Fi[i.unit]);
    }
    case "time": {
      const i = e.type;
      return new of(bt[i.unit], i.bitWidth);
    }
    case "timestamp": {
      const i = e.type;
      return new gy(bt[i.unit], i.timezone);
    }
    case "interval": {
      const i = e.type;
      return new by(mr[i.unit]);
    }
    case "duration": {
      const i = e.type;
      return new wy(bt[i.unit]);
    }
    case "union": {
      const i = e.type, [r, ...s] = (i.mode + "").toLowerCase(), o = r.toUpperCase() + s.join("");
      return new _y(On[o], i.typeIds || [], t || []);
    }
    case "fixedsizebinary": {
      const i = e.type;
      return new Sy(i.byteWidth);
    }
    case "fixedsizelist": {
      const i = e.type;
      return new xy(i.listSize, (t || [])[0]);
    }
    case "map": {
      const i = e.type;
      return new Iy((t || [])[0], i.keysSorted);
    }
  }
  throw new Error(`Unrecognized type: "${n}"`);
}
var gct = Ry, bct = ur;
class _i {
  /** @nocollapse */
  static fromJSON(t, n) {
    const i = new _i(0, Le.V5, n);
    return i._createHeader = wct(t, n), i;
  }
  /** @nocollapse */
  static decode(t) {
    t = new bct(Wt(t));
    const n = _s.getRootAsMessage(t), i = n.bodyLength(), r = n.version(), s = n.headerType(), o = new _i(i, r, s);
    return o._createHeader = vct(n, s), o;
  }
  /** @nocollapse */
  static encode(t) {
    const n = new gct();
    let i = -1;
    return t.isSchema() ? i = ee.encode(n, t.header()) : t.isRecordBatch() ? i = Ei.encode(n, t.header()) : t.isDictionaryBatch() && (i = as.encode(n, t.header())), _s.startMessage(n), _s.addVersion(n, Le.V5), _s.addHeader(n, i), _s.addHeaderType(n, t.headerType), _s.addBodyLength(n, BigInt(t.bodyLength)), _s.finishMessageBuffer(n, _s.endMessage(n)), n.asUint8Array();
  }
  /** @nocollapse */
  static from(t, n = 0) {
    if (t instanceof ee)
      return new _i(0, Le.V5, te.Schema, t);
    if (t instanceof Ei)
      return new _i(n, Le.V5, te.RecordBatch, t);
    if (t instanceof as)
      return new _i(n, Le.V5, te.DictionaryBatch, t);
    throw new Error(`Unrecognized Message header: ${t}`);
  }
  get type() {
    return this.headerType;
  }
  get version() {
    return this._version;
  }
  get headerType() {
    return this._headerType;
  }
  get bodyLength() {
    return this._bodyLength;
  }
  header() {
    return this._createHeader();
  }
  isSchema() {
    return this.headerType === te.Schema;
  }
  isRecordBatch() {
    return this.headerType === te.RecordBatch;
  }
  isDictionaryBatch() {
    return this.headerType === te.DictionaryBatch;
  }
  constructor(t, n, i, r) {
    this._version = n, this._headerType = i, this.body = new Uint8Array(0), r && (this._createHeader = () => r), this._bodyLength = bn(t);
  }
}
class Ei {
  get nodes() {
    return this._nodes;
  }
  get length() {
    return this._length;
  }
  get buffers() {
    return this._buffers;
  }
  constructor(t, n, i) {
    this._nodes = n, this._buffers = i, this._length = bn(t);
  }
}
class as {
  get id() {
    return this._id;
  }
  get data() {
    return this._data;
  }
  get isDelta() {
    return this._isDelta;
  }
  get length() {
    return this.data.length;
  }
  get nodes() {
    return this.data.nodes;
  }
  get buffers() {
    return this.data.buffers;
  }
  constructor(t, n, i = !1) {
    this._data = t, this._isDelta = i, this._id = bn(n);
  }
}
class Kr {
  constructor(t, n) {
    this.offset = bn(t), this.length = bn(n);
  }
}
class gl {
  constructor(t, n) {
    this.length = bn(t), this.nullCount = bn(n);
  }
}
function wct(e, t) {
  return () => {
    switch (t) {
      case te.Schema:
        return ee.fromJSON(e);
      case te.RecordBatch:
        return Ei.fromJSON(e);
      case te.DictionaryBatch:
        return as.fromJSON(e);
    }
    throw new Error(`Unrecognized Message type: { name: ${te[t]}, type: ${t} }`);
  };
}
function vct(e, t) {
  return () => {
    switch (t) {
      case te.Schema:
        return ee.decode(e.header(new Gi()), /* @__PURE__ */ new Map(), e.version());
      case te.RecordBatch:
        return Ei.decode(e.header(new kr()), e.version());
      case te.DictionaryBatch:
        return as.decode(e.header(new Va()), e.version());
    }
    throw new Error(`Unrecognized Message type: { name: ${te[t]}, type: ${t} }`);
  };
}
ge.encode = Bct;
ge.decode = Dct;
ge.fromJSON = mct;
ee.encode = Nct;
ee.decode = _ct;
ee.fromJSON = hct;
Ei.encode = Oct;
Ei.decode = Sct;
Ei.fromJSON = fC;
as.encode = Fct;
as.decode = xct;
as.fromJSON = dct;
gl.encode = Ect;
gl.decode = Act;
Kr.encode = Lct;
Kr.decode = Ict;
function _ct(e, t = /* @__PURE__ */ new Map(), n = Le.V5) {
  const i = Tct(e, t);
  return new ee(i, gd(e), t, n);
}
function Sct(e, t = Le.V5) {
  if (e.compression() !== null)
    throw new Error("Record batch compression not implemented");
  return new Ei(e.length(), Mct(e), $ct(e, t));
}
function xct(e, t = Le.V5) {
  return new as(Ei.decode(e.data(), t), e.id(), e.isDelta());
}
function Ict(e) {
  return new Kr(e.offset(), e.length());
}
function Act(e) {
  return new gl(e.length(), e.nullCount());
}
function Mct(e) {
  const t = [];
  for (let n, i = -1, r = -1, s = e.nodesLength(); ++i < s; )
    (n = e.nodes(i)) && (t[++r] = gl.decode(n));
  return t;
}
function $ct(e, t) {
  const n = [];
  for (let i, r = -1, s = -1, o = e.buffersLength(); ++r < o; )
    (i = e.buffers(r)) && (t < Le.V4 && (i.bb_pos += 8 * (r + 1)), n[++s] = Kr.decode(i));
  return n;
}
function Tct(e, t) {
  const n = [];
  for (let i, r = -1, s = -1, o = e.fieldsLength(); ++r < o; )
    (i = e.fields(r)) && (n[++s] = ge.decode(i, t));
  return n;
}
function $I(e, t) {
  const n = [];
  for (let i, r = -1, s = -1, o = e.childrenLength(); ++r < o; )
    (i = e.children(r)) && (n[++s] = ge.decode(i, t));
  return n;
}
function Dct(e, t) {
  let n, i, r, s, o, a;
  return !t || !(a = e.dictionary()) ? (r = DI(e, $I(e, t)), i = new ge(e.name(), r, e.nullable(), gd(e))) : t.has(n = bn(a.id())) ? (s = (s = a.indexType()) ? TI(s) : new rf(), o = new Xc(t.get(n), s, n, a.isOrdered()), i = new ge(e.name(), o, e.nullable(), gd(e))) : (s = (s = a.indexType()) ? TI(s) : new rf(), t.set(n, r = DI(e, $I(e, t))), o = new Xc(r, s, n, a.isOrdered()), i = new ge(e.name(), o, e.nullable(), gd(e))), i || null;
}
function gd(e) {
  const t = /* @__PURE__ */ new Map();
  if (e)
    for (let n, i, r = -1, s = Math.trunc(e.customMetadataLength()); ++r < s; )
      (n = e.customMetadata(r)) && (i = n.key()) != null && t.set(i, n.value());
  return t;
}
function TI(e) {
  return new eo(e.isSigned(), e.bitWidth());
}
function DI(e, t) {
  const n = e.typeType();
  switch (n) {
    case pe.NONE:
      return new to();
    case pe.Null:
      return new to();
    case pe.Binary:
      return new uy();
    case pe.LargeBinary:
      return new fy();
    case pe.Utf8:
      return new hy();
    case pe.LargeUtf8:
      return new dy();
    case pe.Bool:
      return new py();
    case pe.List:
      return new vy((t || [])[0]);
    case pe.Struct_:
      return new hn(t || []);
  }
  switch (n) {
    case pe.Int: {
      const i = e.type(new Cn());
      return new eo(i.isSigned(), i.bitWidth());
    }
    case pe.FloatingPoint: {
      const i = e.type(new tr());
      return new sf(i.precision());
    }
    case pe.Decimal: {
      const i = e.type(new qa());
      return new yy(i.scale(), i.precision(), i.bitWidth());
    }
    case pe.Date: {
      const i = e.type(new ud());
      return new my(i.unit());
    }
    case pe.Time: {
      const i = e.type(new Qn());
      return new of(i.unit(), i.bitWidth());
    }
    case pe.Timestamp: {
      const i = e.type(new ti());
      return new gy(i.unit(), i.timezone());
    }
    case pe.Interval: {
      const i = e.type(new er());
      return new by(i.unit());
    }
    case pe.Duration: {
      const i = e.type(new fd());
      return new wy(i.unit());
    }
    case pe.Union: {
      const i = e.type(new In());
      return new _y(i.mode(), i.typeIdsArray() || [], t || []);
    }
    case pe.FixedSizeBinary: {
      const i = e.type(new hd());
      return new Sy(i.byteWidth());
    }
    case pe.FixedSizeList: {
      const i = e.type(new dd());
      return new xy(i.listSize(), (t || [])[0]);
    }
    case pe.Map: {
      const i = e.type(new pd());
      return new Iy((t || [])[0], i.keysSorted());
    }
  }
  throw new Error(`Unrecognized type: "${pe[n]}" (${n})`);
}
function Nct(e, t) {
  const n = t.fields.map((s) => ge.encode(e, s));
  Gi.startFieldsVector(e, n.length);
  const i = Gi.createFieldsVector(e, n), r = t.metadata && t.metadata.size > 0 ? Gi.createCustomMetadataVector(e, [...t.metadata].map(([s, o]) => {
    const a = e.createString(`${s}`), c = e.createString(`${o}`);
    return Ce.startKeyValue(e), Ce.addKey(e, a), Ce.addValue(e, c), Ce.endKeyValue(e);
  })) : -1;
  return Gi.startSchema(e), Gi.addFields(e, i), Gi.addEndianness(e, Rct ? Gc.Little : Gc.Big), r !== -1 && Gi.addCustomMetadata(e, r), Gi.endSchema(e);
}
function Bct(e, t) {
  let n = -1, i = -1, r = -1;
  const s = t.type;
  let o = t.typeId;
  ot.isDictionary(s) ? (o = s.dictionary.typeId, r = dg.visit(s, e), i = dg.visit(s.dictionary, e)) : i = dg.visit(s, e);
  const a = (s.children || []).map((u) => ge.encode(e, u)), c = Hn.createChildrenVector(e, a), l = t.metadata && t.metadata.size > 0 ? Hn.createCustomMetadataVector(e, [...t.metadata].map(([u, f]) => {
    const h = e.createString(`${u}`), d = e.createString(`${f}`);
    return Ce.startKeyValue(e), Ce.addKey(e, h), Ce.addValue(e, d), Ce.endKeyValue(e);
  })) : -1;
  return t.name && (n = e.createString(t.name)), Hn.startField(e), Hn.addType(e, i), Hn.addTypeType(e, o), Hn.addChildren(e, c), Hn.addNullable(e, !!t.nullable), n !== -1 && Hn.addName(e, n), r !== -1 && Hn.addDictionary(e, r), l !== -1 && Hn.addCustomMetadata(e, l), Hn.endField(e);
}
function Oct(e, t) {
  const n = t.nodes || [], i = t.buffers || [];
  kr.startNodesVector(e, n.length);
  for (const o of n.slice().reverse())
    gl.encode(e, o);
  const r = e.endVector();
  kr.startBuffersVector(e, i.length);
  for (const o of i.slice().reverse())
    Kr.encode(e, o);
  const s = e.endVector();
  return kr.startRecordBatch(e), kr.addLength(e, BigInt(t.length)), kr.addNodes(e, r), kr.addBuffers(e, s), kr.endRecordBatch(e);
}
function Fct(e, t) {
  const n = Ei.encode(e, t.data);
  return Va.startDictionaryBatch(e), Va.addId(e, BigInt(t.id)), Va.addIsDelta(e, t.isDelta), Va.addData(e, n), Va.endDictionaryBatch(e);
}
function Ect(e, t) {
  return NL.createFieldNode(e, BigInt(t.length), BigInt(t.nullCount));
}
function Lct(e, t) {
  return DL.createBuffer(e, BigInt(t.offset), BigInt(t.length));
}
const Rct = (() => {
  const e = new ArrayBuffer(2);
  return new DataView(e).setInt16(
    0,
    256,
    !0
    /* littleEndian */
  ), new Int16Array(e)[0] === 256;
})(), v_ = (e) => `Expected ${te[e]} Message in stream, but was null or length 0.`, __ = (e) => `Header pointer of flatbuffer-encoded ${te[e]} Message is null or length 0.`, pC = (e, t) => `Expected to read ${e} metadata bytes, but only read ${t}.`, yC = (e, t) => `Expected to read ${e} bytes for message body, but only read ${t}.`;
class mC {
  constructor(t) {
    this.source = t instanceof Ty ? t : new Ty(t);
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    let t;
    return (t = this.readMetadataLength()).done || t.value === -1 && (t = this.readMetadataLength()).done || (t = this.readMetadata(t.value)).done ? Ie : t;
  }
  throw(t) {
    return this.source.throw(t);
  }
  return(t) {
    return this.source.return(t);
  }
  readMessage(t) {
    let n;
    if ((n = this.next()).done)
      return null;
    if (t != null && n.value.headerType !== t)
      throw new Error(v_(t));
    return n.value;
  }
  readMessageBody(t) {
    if (t <= 0)
      return new Uint8Array(0);
    const n = Wt(this.source.read(t));
    if (n.byteLength < t)
      throw new Error(yC(t, n.byteLength));
    return (
      /* 1. */
      n.byteOffset % 8 === 0 && /* 2. */
      n.byteOffset + n.byteLength <= n.buffer.byteLength ? n : n.slice()
    );
  }
  readSchema(t = !1) {
    const n = te.Schema, i = this.readMessage(n), r = i == null ? void 0 : i.header();
    if (t && !r)
      throw new Error(__(n));
    return r;
  }
  readMetadataLength() {
    const t = this.source.read(Z0), n = t && new ur(t), i = (n == null ? void 0 : n.readInt32(0)) || 0;
    return { done: i === 0, value: i };
  }
  readMetadata(t) {
    const n = this.source.read(t);
    if (!n)
      return Ie;
    if (n.byteLength < t)
      throw new Error(pC(t, n.byteLength));
    return { done: !1, value: _i.decode(n) };
  }
}
class Cct {
  constructor(t, n) {
    this.source = t instanceof Jc ? t : IL(t) ? new Dy(t, n) : new Jc(t);
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  next() {
    return W(this, void 0, void 0, function* () {
      let t;
      return (t = yield this.readMetadataLength()).done || t.value === -1 && (t = yield this.readMetadataLength()).done || (t = yield this.readMetadata(t.value)).done ? Ie : t;
    });
  }
  throw(t) {
    return W(this, void 0, void 0, function* () {
      return yield this.source.throw(t);
    });
  }
  return(t) {
    return W(this, void 0, void 0, function* () {
      return yield this.source.return(t);
    });
  }
  readMessage(t) {
    return W(this, void 0, void 0, function* () {
      let n;
      if ((n = yield this.next()).done)
        return null;
      if (t != null && n.value.headerType !== t)
        throw new Error(v_(t));
      return n.value;
    });
  }
  readMessageBody(t) {
    return W(this, void 0, void 0, function* () {
      if (t <= 0)
        return new Uint8Array(0);
      const n = Wt(yield this.source.read(t));
      if (n.byteLength < t)
        throw new Error(yC(t, n.byteLength));
      return (
        /* 1. */
        n.byteOffset % 8 === 0 && /* 2. */
        n.byteOffset + n.byteLength <= n.buffer.byteLength ? n : n.slice()
      );
    });
  }
  readSchema(t = !1) {
    return W(this, void 0, void 0, function* () {
      const n = te.Schema, i = yield this.readMessage(n), r = i == null ? void 0 : i.header();
      if (t && !r)
        throw new Error(__(n));
      return r;
    });
  }
  readMetadataLength() {
    return W(this, void 0, void 0, function* () {
      const t = yield this.source.read(Z0), n = t && new ur(t), i = (n == null ? void 0 : n.readInt32(0)) || 0;
      return { done: i === 0, value: i };
    });
  }
  readMetadata(t) {
    return W(this, void 0, void 0, function* () {
      const n = yield this.source.read(t);
      if (!n)
        return Ie;
      if (n.byteLength < t)
        throw new Error(pC(t, n.byteLength));
      return { done: !1, value: _i.decode(n) };
    });
  }
}
class kct extends mC {
  constructor(t) {
    super(new Uint8Array(0)), this._schema = !1, this._body = [], this._batchIndex = 0, this._dictionaryIndex = 0, this._json = t instanceof _I ? t : new _I(t);
  }
  next() {
    const { _json: t } = this;
    if (!this._schema)
      return this._schema = !0, { done: !1, value: _i.fromJSON(t.schema, te.Schema) };
    if (this._dictionaryIndex < t.dictionaries.length) {
      const n = t.dictionaries[this._dictionaryIndex++];
      return this._body = n.data.columns, { done: !1, value: _i.fromJSON(n, te.DictionaryBatch) };
    }
    if (this._batchIndex < t.batches.length) {
      const n = t.batches[this._batchIndex++];
      return this._body = n.columns, { done: !1, value: _i.fromJSON(n, te.RecordBatch) };
    }
    return this._body = [], Ie;
  }
  readMessageBody(t) {
    return n(this._body);
    function n(i) {
      return (i || []).reduce((r, s) => [
        ...r,
        ...s.VALIDITY && [s.VALIDITY] || [],
        ...s.TYPE_ID && [s.TYPE_ID] || [],
        ...s.OFFSET && [s.OFFSET] || [],
        ...s.DATA && [s.DATA] || [],
        ...n(s.children)
      ], []);
    }
  }
  readMessage(t) {
    let n;
    if ((n = this.next()).done)
      return null;
    if (t != null && n.value.headerType !== t)
      throw new Error(v_(t));
    return n.value;
  }
  readSchema() {
    const t = te.Schema, n = this.readMessage(t), i = n == null ? void 0 : n.header();
    if (!n || !i)
      throw new Error(__(t));
    return i;
  }
}
const Z0 = 4, fb = "ARROW1", Ny = new Uint8Array(fb.length);
for (let e = 0; e < fb.length; e += 1)
  Ny[e] = fb.codePointAt(e);
function S_(e, t = 0) {
  for (let n = -1, i = Ny.length; ++n < i; )
    if (Ny[n] !== e[t + n])
      return !1;
  return !0;
}
const Zf = Ny.length, gC = Zf + Z0, Uct = Zf * 2 + Z0;
class ns extends rC {
  constructor(t) {
    super(), this._impl = t;
  }
  get closed() {
    return this._impl.closed;
  }
  get schema() {
    return this._impl.schema;
  }
  get autoDestroy() {
    return this._impl.autoDestroy;
  }
  get dictionaries() {
    return this._impl.dictionaries;
  }
  get numDictionaries() {
    return this._impl.numDictionaries;
  }
  get numRecordBatches() {
    return this._impl.numRecordBatches;
  }
  get footer() {
    return this._impl.isFile() ? this._impl.footer : null;
  }
  isSync() {
    return this._impl.isSync();
  }
  isAsync() {
    return this._impl.isAsync();
  }
  isFile() {
    return this._impl.isFile();
  }
  isStream() {
    return this._impl.isStream();
  }
  next() {
    return this._impl.next();
  }
  throw(t) {
    return this._impl.throw(t);
  }
  return(t) {
    return this._impl.return(t);
  }
  cancel() {
    return this._impl.cancel();
  }
  reset(t) {
    return this._impl.reset(t), this._DOMStream = void 0, this._nodeStream = void 0, this;
  }
  open(t) {
    const n = this._impl.open(t);
    return Qu(n) ? n.then(() => this) : this;
  }
  readRecordBatch(t) {
    return this._impl.isFile() ? this._impl.readRecordBatch(t) : null;
  }
  [Symbol.iterator]() {
    return this._impl[Symbol.iterator]();
  }
  [Symbol.asyncIterator]() {
    return this._impl[Symbol.asyncIterator]();
  }
  toDOMStream() {
    return Zn.toDOMStream(this.isSync() ? { [Symbol.iterator]: () => this } : { [Symbol.asyncIterator]: () => this });
  }
  toNodeStream() {
    return Zn.toNodeStream(this.isSync() ? { [Symbol.iterator]: () => this } : { [Symbol.asyncIterator]: () => this }, { objectMode: !0 });
  }
  /** @nocollapse */
  // @ts-ignore
  static throughNode(t) {
    throw new Error('"throughNode" not available in this environment');
  }
  /** @nocollapse */
  static throughDOM(t, n) {
    throw new Error('"throughDOM" not available in this environment');
  }
  /** @nocollapse */
  static from(t) {
    return t instanceof ns ? t : ib(t) ? jct(t) : IL(t) ? Wct(t) : Qu(t) ? W(this, void 0, void 0, function* () {
      return yield ns.from(yield t);
    }) : AL(t) || i_(t) || $L(t) || n_(t) ? Yct(new Jc(t)) : qct(new Ty(t));
  }
  /** @nocollapse */
  static readAll(t) {
    return t instanceof ns ? t.isSync() ? NI(t) : BI(t) : ib(t) || ArrayBuffer.isView(t) || H0(t) || xL(t) ? NI(t) : BI(t);
  }
}
class By extends ns {
  constructor(t) {
    super(t), this._impl = t;
  }
  readAll() {
    return [...this];
  }
  [Symbol.iterator]() {
    return this._impl[Symbol.iterator]();
  }
  [Symbol.asyncIterator]() {
    return Re(this, arguments, function* () {
      yield H(yield* ks(ci(this[Symbol.iterator]())));
    });
  }
}
class Oy extends ns {
  constructor(t) {
    super(t), this._impl = t;
  }
  readAll() {
    var t, n, i, r;
    return W(this, void 0, void 0, function* () {
      const s = new Array();
      try {
        for (var o = !0, a = ci(this), c; c = yield a.next(), t = c.done, !t; o = !0) {
          r = c.value, o = !1;
          const l = r;
          s.push(l);
        }
      } catch (l) {
        n = { error: l };
      } finally {
        try {
          !o && !t && (i = a.return) && (yield i.call(a));
        } finally {
          if (n)
            throw n.error;
        }
      }
      return s;
    });
  }
  [Symbol.iterator]() {
    throw new Error("AsyncRecordBatchStreamReader is not Iterable");
  }
  [Symbol.asyncIterator]() {
    return this._impl[Symbol.asyncIterator]();
  }
}
class bC extends By {
  constructor(t) {
    super(t), this._impl = t;
  }
}
class zct extends Oy {
  constructor(t) {
    super(t), this._impl = t;
  }
}
class wC {
  get numDictionaries() {
    return this._dictionaryIndex;
  }
  get numRecordBatches() {
    return this._recordBatchIndex;
  }
  constructor(t = /* @__PURE__ */ new Map()) {
    this.closed = !1, this.autoDestroy = !0, this._dictionaryIndex = 0, this._recordBatchIndex = 0, this.dictionaries = t;
  }
  isSync() {
    return !1;
  }
  isAsync() {
    return !1;
  }
  isFile() {
    return !1;
  }
  isStream() {
    return !1;
  }
  reset(t) {
    return this._dictionaryIndex = 0, this._recordBatchIndex = 0, this.schema = t, this.dictionaries = /* @__PURE__ */ new Map(), this;
  }
  _loadRecordBatch(t, n) {
    const i = this._loadVectors(t, n, this.schema.fields), r = Ct({ type: new hn(this.schema.fields), length: t.length, children: i });
    return new wi(this.schema, r);
  }
  _loadDictionaryBatch(t, n) {
    const { id: i, isDelta: r } = t, { dictionaries: s, schema: o } = this, a = s.get(i);
    if (r || !a) {
      const c = o.dictionaries.get(i), l = this._loadVectors(t.data, n, [c]);
      return (a && r ? a.concat(new ae(l)) : new ae(l)).memoize();
    }
    return a.memoize();
  }
  _loadVectors(t, n, i) {
    return new oC(n, t.nodes, t.buffers, this.dictionaries, this.schema.metadataVersion).visitMany(i);
  }
}
class Fy extends wC {
  constructor(t, n) {
    super(n), this._reader = ib(t) ? new kct(this._handle = t) : new mC(this._handle = t);
  }
  isSync() {
    return !0;
  }
  isStream() {
    return !0;
  }
  [Symbol.iterator]() {
    return this;
  }
  cancel() {
    !this.closed && (this.closed = !0) && (this.reset()._reader.return(), this._reader = null, this.dictionaries = null);
  }
  open(t) {
    return this.closed || (this.autoDestroy = _C(this, t), this.schema || (this.schema = this._reader.readSchema()) || this.cancel()), this;
  }
  throw(t) {
    return !this.closed && this.autoDestroy && (this.closed = !0) ? this.reset()._reader.throw(t) : Ie;
  }
  return(t) {
    return !this.closed && this.autoDestroy && (this.closed = !0) ? this.reset()._reader.return(t) : Ie;
  }
  next() {
    if (this.closed)
      return Ie;
    let t;
    const { _reader: n } = this;
    for (; t = this._readNextMessageAndValidate(); )
      if (t.isSchema())
        this.reset(t.header());
      else if (t.isRecordBatch()) {
        this._recordBatchIndex++;
        const i = t.header(), r = n.readMessageBody(t.bodyLength);
        return { done: !1, value: this._loadRecordBatch(i, r) };
      } else if (t.isDictionaryBatch()) {
        this._dictionaryIndex++;
        const i = t.header(), r = n.readMessageBody(t.bodyLength), s = this._loadDictionaryBatch(i, r);
        this.dictionaries.set(i.id, s);
      }
    return this.schema && this._recordBatchIndex === 0 ? (this._recordBatchIndex++, { done: !1, value: new uC(this.schema) }) : this.return();
  }
  _readNextMessageAndValidate(t) {
    return this._reader.readMessage(t);
  }
}
class Ey extends wC {
  constructor(t, n) {
    super(n), this._reader = new Cct(this._handle = t);
  }
  isAsync() {
    return !0;
  }
  isStream() {
    return !0;
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  cancel() {
    return W(this, void 0, void 0, function* () {
      !this.closed && (this.closed = !0) && (yield this.reset()._reader.return(), this._reader = null, this.dictionaries = null);
    });
  }
  open(t) {
    return W(this, void 0, void 0, function* () {
      return this.closed || (this.autoDestroy = _C(this, t), this.schema || (this.schema = yield this._reader.readSchema()) || (yield this.cancel())), this;
    });
  }
  throw(t) {
    return W(this, void 0, void 0, function* () {
      return !this.closed && this.autoDestroy && (this.closed = !0) ? yield this.reset()._reader.throw(t) : Ie;
    });
  }
  return(t) {
    return W(this, void 0, void 0, function* () {
      return !this.closed && this.autoDestroy && (this.closed = !0) ? yield this.reset()._reader.return(t) : Ie;
    });
  }
  next() {
    return W(this, void 0, void 0, function* () {
      if (this.closed)
        return Ie;
      let t;
      const { _reader: n } = this;
      for (; t = yield this._readNextMessageAndValidate(); )
        if (t.isSchema())
          yield this.reset(t.header());
        else if (t.isRecordBatch()) {
          this._recordBatchIndex++;
          const i = t.header(), r = yield n.readMessageBody(t.bodyLength);
          return { done: !1, value: this._loadRecordBatch(i, r) };
        } else if (t.isDictionaryBatch()) {
          this._dictionaryIndex++;
          const i = t.header(), r = yield n.readMessageBody(t.bodyLength), s = this._loadDictionaryBatch(i, r);
          this.dictionaries.set(i.id, s);
        }
      return this.schema && this._recordBatchIndex === 0 ? (this._recordBatchIndex++, { done: !1, value: new uC(this.schema) }) : yield this.return();
    });
  }
  _readNextMessageAndValidate(t) {
    return W(this, void 0, void 0, function* () {
      return yield this._reader.readMessage(t);
    });
  }
}
class vC extends Fy {
  get footer() {
    return this._footer;
  }
  get numDictionaries() {
    return this._footer ? this._footer.numDictionaries : 0;
  }
  get numRecordBatches() {
    return this._footer ? this._footer.numRecordBatches : 0;
  }
  constructor(t, n) {
    super(t instanceof SI ? t : new SI(t), n);
  }
  isSync() {
    return !0;
  }
  isFile() {
    return !0;
  }
  open(t) {
    if (!this.closed && !this._footer) {
      this.schema = (this._footer = this._readFooter()).schema;
      for (const n of this._footer.dictionaryBatches())
        n && this._readDictionaryBatch(this._dictionaryIndex++);
    }
    return super.open(t);
  }
  readRecordBatch(t) {
    var n;
    if (this.closed)
      return null;
    this._footer || this.open();
    const i = (n = this._footer) === null || n === void 0 ? void 0 : n.getRecordBatch(t);
    if (i && this._handle.seek(i.offset)) {
      const r = this._reader.readMessage(te.RecordBatch);
      if (r != null && r.isRecordBatch()) {
        const s = r.header(), o = this._reader.readMessageBody(r.bodyLength);
        return this._loadRecordBatch(s, o);
      }
    }
    return null;
  }
  _readDictionaryBatch(t) {
    var n;
    const i = (n = this._footer) === null || n === void 0 ? void 0 : n.getDictionaryBatch(t);
    if (i && this._handle.seek(i.offset)) {
      const r = this._reader.readMessage(te.DictionaryBatch);
      if (r != null && r.isDictionaryBatch()) {
        const s = r.header(), o = this._reader.readMessageBody(r.bodyLength), a = this._loadDictionaryBatch(s, o);
        this.dictionaries.set(s.id, a);
      }
    }
  }
  _readFooter() {
    const { _handle: t } = this, n = t.size - gC, i = t.readInt32(n), r = t.readAt(n - i, i);
    return y_.decode(r);
  }
  _readNextMessageAndValidate(t) {
    var n;
    if (this._footer || this.open(), this._footer && this._recordBatchIndex < this.numRecordBatches) {
      const i = (n = this._footer) === null || n === void 0 ? void 0 : n.getRecordBatch(this._recordBatchIndex);
      if (i && this._handle.seek(i.offset))
        return this._reader.readMessage(t);
    }
    return null;
  }
}
class Pct extends Ey {
  get footer() {
    return this._footer;
  }
  get numDictionaries() {
    return this._footer ? this._footer.numDictionaries : 0;
  }
  get numRecordBatches() {
    return this._footer ? this._footer.numRecordBatches : 0;
  }
  constructor(t, ...n) {
    const i = typeof n[0] != "number" ? n.shift() : void 0, r = n[0] instanceof Map ? n.shift() : void 0;
    super(t instanceof Dy ? t : new Dy(t, i), r);
  }
  isFile() {
    return !0;
  }
  isAsync() {
    return !0;
  }
  open(t) {
    const n = Object.create(null, {
      open: { get: () => super.open }
    });
    return W(this, void 0, void 0, function* () {
      if (!this.closed && !this._footer) {
        this.schema = (this._footer = yield this._readFooter()).schema;
        for (const i of this._footer.dictionaryBatches())
          i && (yield this._readDictionaryBatch(this._dictionaryIndex++));
      }
      return yield n.open.call(this, t);
    });
  }
  readRecordBatch(t) {
    var n;
    return W(this, void 0, void 0, function* () {
      if (this.closed)
        return null;
      this._footer || (yield this.open());
      const i = (n = this._footer) === null || n === void 0 ? void 0 : n.getRecordBatch(t);
      if (i && (yield this._handle.seek(i.offset))) {
        const r = yield this._reader.readMessage(te.RecordBatch);
        if (r != null && r.isRecordBatch()) {
          const s = r.header(), o = yield this._reader.readMessageBody(r.bodyLength);
          return this._loadRecordBatch(s, o);
        }
      }
      return null;
    });
  }
  _readDictionaryBatch(t) {
    var n;
    return W(this, void 0, void 0, function* () {
      const i = (n = this._footer) === null || n === void 0 ? void 0 : n.getDictionaryBatch(t);
      if (i && (yield this._handle.seek(i.offset))) {
        const r = yield this._reader.readMessage(te.DictionaryBatch);
        if (r != null && r.isDictionaryBatch()) {
          const s = r.header(), o = yield this._reader.readMessageBody(r.bodyLength), a = this._loadDictionaryBatch(s, o);
          this.dictionaries.set(s.id, a);
        }
      }
    });
  }
  _readFooter() {
    return W(this, void 0, void 0, function* () {
      const { _handle: t } = this;
      t._pending && (yield t._pending);
      const n = t.size - gC, i = yield t.readInt32(n), r = yield t.readAt(n - i, i);
      return y_.decode(r);
    });
  }
  _readNextMessageAndValidate(t) {
    return W(this, void 0, void 0, function* () {
      if (this._footer || (yield this.open()), this._footer && this._recordBatchIndex < this.numRecordBatches) {
        const n = this._footer.getRecordBatch(this._recordBatchIndex);
        if (n && (yield this._handle.seek(n.offset)))
          return yield this._reader.readMessage(t);
      }
      return null;
    });
  }
}
class Vct extends Fy {
  constructor(t, n) {
    super(t, n);
  }
  _loadVectors(t, n, i) {
    return new tct(n, t.nodes, t.buffers, this.dictionaries, this.schema.metadataVersion).visitMany(i);
  }
}
function _C(e, t) {
  return t && typeof t.autoDestroy == "boolean" ? t.autoDestroy : e.autoDestroy;
}
function* NI(e) {
  const t = ns.from(e);
  try {
    if (!t.open({ autoDestroy: !1 }).closed)
      do
        yield t;
      while (!t.reset().open().closed);
  } finally {
    t.cancel();
  }
}
function BI(e) {
  return Re(this, arguments, function* () {
    const n = yield H(ns.from(e));
    try {
      if (!(yield H(n.open({ autoDestroy: !1 }))).closed)
        do
          yield yield H(n);
        while (!(yield H(n.reset().open())).closed);
    } finally {
      yield H(n.cancel());
    }
  });
}
function jct(e) {
  return new By(new Vct(e));
}
function qct(e) {
  const t = e.peek(Zf + 7 & -8);
  return t && t.byteLength >= 4 ? S_(t) ? new bC(new vC(e.read())) : new By(new Fy(e)) : new By(new Fy(function* () {
  }()));
}
function Yct(e) {
  return W(this, void 0, void 0, function* () {
    const t = yield e.peek(Zf + 7 & -8);
    return t && t.byteLength >= 4 ? S_(t) ? new bC(new vC(yield e.read())) : new Oy(new Ey(e)) : new Oy(new Ey(function() {
      return Re(this, arguments, function* () {
      });
    }()));
  });
}
function Wct(e) {
  return W(this, void 0, void 0, function* () {
    const { size: t } = yield e.stat(), n = new Dy(e, t);
    return t >= Uct && S_(yield n.readAt(0, Zf + 7 & -8)) ? new zct(new Pct(n)) : new Oy(new Ey(n));
  });
}
function SC(e) {
  const t = ns.from(e);
  return Qu(t) ? t.then((n) => SC(n)) : t.isAsync() ? t.readAll().then((n) => new ei(n)) : new ei(t.readAll());
}
let Rh;
const Gct = new Uint8Array(16);
function Xct() {
  if (!Rh && (Rh = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !Rh))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return Rh(Gct);
}
const Ge = [];
for (let e = 0; e < 256; ++e)
  Ge.push((e + 256).toString(16).slice(1));
function Hct(e, t = 0) {
  return Ge[e[t + 0]] + Ge[e[t + 1]] + Ge[e[t + 2]] + Ge[e[t + 3]] + "-" + Ge[e[t + 4]] + Ge[e[t + 5]] + "-" + Ge[e[t + 6]] + Ge[e[t + 7]] + "-" + Ge[e[t + 8]] + Ge[e[t + 9]] + "-" + Ge[e[t + 10]] + Ge[e[t + 11]] + Ge[e[t + 12]] + Ge[e[t + 13]] + Ge[e[t + 14]] + Ge[e[t + 15]];
}
const Jct = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), OI = {
  randomUUID: Jct
};
function Kct(e, t, n) {
  if (OI.randomUUID && !t && !e)
    return OI.randomUUID();
  e = e || {};
  const i = e.random || (e.rng || Xct)();
  if (i[6] = i[6] & 15 | 64, i[8] = i[8] & 63 | 128, t) {
    n = n || 0;
    for (let r = 0; r < 16; ++r)
      t[n + r] = i[r];
    return t;
  }
  return Hct(i);
}
const Aut = {
  /** @type {import('anywidget/types').Initialize<Model>} */
  // eslint-disable-next-line no-unused-vars
  initialize(e) {
  },
  /** @type {import('anywidget/types').Render<Model>} */
  render(e) {
    e.el.classList.add("mosaic-widget");
    const t = () => e.model.get("spec"), n = () => e.model.get("temp_indexes"), i = Wr().logger(), r = /* @__PURE__ */ new Map();
    function s(u, f, h) {
      const d = Kct();
      r.set(d, {
        query: u,
        startTime: performance.now(),
        resolve: f,
        reject: h
      }), e.model.send({ ...u, uuid: d });
    }
    const o = {
      query(u) {
        return new Promise((f, h) => s(u, f, h));
      }
    };
    function a() {
      Wr().clear(), Wv.clear();
    }
    async function c() {
      const u = t();
      a(), i.log("Setting spec:", u);
      const f = await Zct(u);
      e.el.replaceChildren(f.element);
      const h = {};
      for (const [d, p] of f.params)
        h[d] = {
          value: p.value,
          ...rs(p) ? { predicate: String(p.predicate()) } : {}
        }, p.addEventListener("value", (y) => {
          h[d] = {
            value: y,
            ...rs(p) ? { predicate: String(p.predicate()) } : {}
          }, e.model.set("params", h), e.model.save_changes();
        });
      e.model.set("params", h), e.model.save_changes();
    }
    e.model.on("change:spec", () => c());
    function l() {
      const u = { temp: n() };
      Wr().configure({ indexes: u });
    }
    return e.model.on("change:temp_indexes", () => l()), e.model.on("msg:custom", (u, f) => {
      i.group(`query ${u.uuid}`), i.log("received message", u, f);
      const h = r.get(u.uuid);
      if (r.delete(u.uuid), i.log(h.query.sql, (performance.now() - h.startTime).toFixed(1)), u.error)
        h.reject(u.error), i.error(u.error);
      else
        switch (u.type) {
          case "arrow": {
            const d = SC(f[0].buffer);
            i.log("table", d), h.resolve(d);
            break;
          }
          case "json": {
            i.log("json", u.result), h.resolve(u.result);
            break;
          }
          default: {
            h.resolve({});
            break;
          }
        }
      i.groupEnd("query");
    }), Wr().databaseConnector(o), l(), c(), () => {
      a();
    };
  }
};
function Zct(e) {
  const t = yot(e);
  return Nst(t);
}
export {
  Aut as default
};
